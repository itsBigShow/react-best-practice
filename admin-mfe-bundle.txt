# CCaaS Admin MFE - Source Bundle
# Generated: 2026-02-13 22:53:42
# Total files: 395
# Categories: 228 TypeScript, 158 React (TSX), 1 CSS, 7 Config, 1 Docs
# Note: node_modules and dist NOT included - run 'npm install && npm run build' after extraction

===FILE: CLAUDE.md
# CLAUDE.md - ccaas-admin-mfe

## Overview
Admin panel micro frontend (MFE). Port **5185**. Loaded into agent-frontend via Vite Module Federation. Provides administrative functionality for managing Role Templates, AD Groups, Pending Approvals, and System Notices. React 19 + Vite + TypeScript + Radix UI + Zustand.

## Commands
```bash
npm run dev                              # Dev server (no remoteEntry.js)
npm run build && npm run preview -- --port 5185  # REQUIRED for Module Federation
npm run type-check                       # TypeScript validation
```

## CRITICAL
**Must use `npm run preview`** (not dev) to serve `remoteEntry.js`. The agent-frontend loads this MFE at `http://localhost:5185/assets/remoteEntry.js`.

## Module Federation
- **Remote Name:** `adminMfeRemote`
- **Exposed Modules:**
  - `./AdminMFE` - Main admin panel component

## Props Interface
```typescript
interface AdminMFEProps {
  authToken: string           // JWT token for API calls
  permissions?: AdminPermissions // User's admin permissions
  onNavigate?: (path: string) => void // Navigation callback to host
  onError?: (error: ErrorInfo) => void // Error reporting to host
}
```

## Communication
Props-based communication with host app (preferred over postMessage for Module Federation MFEs).

## Admin Views
1. **Role Templates** - View and preview role configurations
2. **AD Groups** - Configure AD group permissions and apps
3. **Pending Approvals** - Maker/Checker approval workflow
4. **System Notices** - Create and manage system notices

## Rules
- Keep MFE self-contained; minimize shared dependencies
- Test by loading in agent-frontend, not standalone
- Follow Maker/Checker workflow for all configuration changes
- Use `adm-` Tailwind prefix for all CSS classes
===ENDFILE

===FILE: index.html
<!DOCTYPE html>
<html lang="en" class="adm-h-full">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Admin MFE - CCaaS Platform</title>
  </head>
  <body class="adm-h-full adm-m-0">
    <div id="root" class="adm-h-full"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
===ENDFILE

===FILE: package-lock.json
{
  "name": "@ccaas/ccaas-admin-mfe",
  "version": "0.1.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "@ccaas/ccaas-admin-mfe",
      "version": "0.1.0",
      "dependencies": {
        "@radix-ui/react-accordion": "^1.2.12",
        "@radix-ui/react-alert-dialog": "^1.1.15",
        "@radix-ui/react-checkbox": "^1.3.3",
        "@radix-ui/react-collapsible": "^1.1.12",
        "@radix-ui/react-dialog": "^1.1.15",
        "@radix-ui/react-dropdown-menu": "^2.1.15",
        "@radix-ui/react-icons": "^1.3.2",
        "@radix-ui/react-label": "^2.1.7",
        "@radix-ui/react-popover": "^1.1.9",
        "@radix-ui/react-scroll-area": "^1.1.0",
        "@radix-ui/react-select": "^2.2.6",
        "@radix-ui/react-separator": "^1.1.7",
        "@radix-ui/react-slot": "^1.2.3",
        "@radix-ui/react-switch": "^1.2.5",
        "@radix-ui/react-tabs": "^1.1.12",
        "@radix-ui/react-toggle": "^1.1.10",
        "@radix-ui/react-toggle-group": "^1.1.11",
        "@radix-ui/react-tooltip": "^1.1.8",
        "@tanstack/react-query": "^5.66.7",
        "class-variance-authority": "^0.7.1",
        "clsx": "^2.1.1",
        "date-fns": "^4.1.0",
        "lucide-react": "^0.542.0",
        "tailwind-merge": "^3.3.1",
        "zustand": "^5.0.8"
      },
      "devDependencies": {
        "@originjs/vite-plugin-federation": "^1.4.1",
        "@testing-library/dom": "^10.4.1",
        "@testing-library/jest-dom": "^6.9.1",
        "@testing-library/react": "^16.3.2",
        "@testing-library/user-event": "^14.6.1",
        "@types/react": "^19.1.12",
        "@types/react-dom": "^19.1.9",
        "@typescript-eslint/parser": "^8.55.0",
        "@vitejs/plugin-react": "^4.6.0",
        "@vitest/coverage-istanbul": "^3.2.4",
        "@vitest/coverage-v8": "^3.2.4",
        "autoprefixer": "^10.4.14",
        "eslint-plugin-sonarjs": "^3.0.7",
        "jsdom": "^28.0.0",
        "postcss": "^8.4.24",
        "react": "19.2.0",
        "react-dom": "19.2.0",
        "tailwindcss": "^3.3.0",
        "tailwindcss-animate": "^1.0.7",
        "typescript": "^5.9.2",
        "vite": "^6.0.0",
        "vitest": "^3.2.4"
      },
      "optionalDependencies": {
        "@rollup/rollup-linux-x64-gnu": "^4.50.0"
      },
      "peerDependencies": {
        "react": "^19.2.0",
        "react-dom": "^19.2.0"
      }
    },
    "node_modules/@acemir/cssom": {
      "version": "0.9.31",
      "resolved": "https://registry.npmjs.org/@acemir/cssom/-/cssom-0.9.31.tgz",
      "integrity": "sha512-ZnR3GSaH+/vJ0YlHau21FjfLYjMpYVIzTD8M8vIEQvIGxeOXyXdzCI140rrCY862p/C/BbzWsjc1dgnM9mkoTA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@adobe/css-tools": {
      "version": "4.4.4",
      "resolved": "https://registry.npmjs.org/@adobe/css-tools/-/css-tools-4.4.4.tgz",
      "integrity": "sha512-Elp+iwUx5rN5+Y8xLt5/GRoG20WGoDCQ/1Fb+1LiGtvwbDavuSk0jhD/eZdckHAuzcDzccnkv+rEjyWfRx18gg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@alloc/quick-lru": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@alloc/quick-lru/-/quick-lru-5.2.0.tgz",
      "integrity": "sha512-UrcABB+4bUrFABwbluTIBErXwvbsU/V7TZWfmbgJfbkwiBuziS9gxdODUyuiecfdGQ85jglMW6juS3+z5TsKLw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@ampproject/remapping": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@asamuzakjp/css-color": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/@asamuzakjp/css-color/-/css-color-4.1.2.tgz",
      "integrity": "sha512-NfBUvBaYgKIuq6E/RBLY1m0IohzNHAYyaJGuTK79Z23uNwmz2jl1mPsC5ZxCCxylinKhT1Amn5oNTlx1wN8cQg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@csstools/css-calc": "^3.0.0",
        "@csstools/css-color-parser": "^4.0.1",
        "@csstools/css-parser-algorithms": "^4.0.0",
        "@csstools/css-tokenizer": "^4.0.0",
        "lru-cache": "^11.2.5"
      }
    },
    "node_modules/@asamuzakjp/css-color/node_modules/lru-cache": {
      "version": "11.2.5",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-11.2.5.tgz",
      "integrity": "sha512-vFrFJkWtJvJnD5hg+hJvVE8Lh/TcMzKnTgCWmtBipwI5yLX/iX+5UB2tfuyODF5E7k9xEzMdYgGqaSb1c0c5Yw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "engines": {
        "node": "20 || >=22"
      }
    },
    "node_modules/@asamuzakjp/dom-selector": {
      "version": "6.7.8",
      "resolved": "https://registry.npmjs.org/@asamuzakjp/dom-selector/-/dom-selector-6.7.8.tgz",
      "integrity": "sha512-stisC1nULNc9oH5lakAj8MH88ZxeGxzyWNDfbdCxvJSJIvDsHNZqYvscGTgy/ysgXWLJPt6K/4t0/GjvtKcFJQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@asamuzakjp/nwsapi": "^2.3.9",
        "bidi-js": "^1.0.3",
        "css-tree": "^3.1.0",
        "is-potential-custom-element-name": "^1.0.1",
        "lru-cache": "^11.2.5"
      }
    },
    "node_modules/@asamuzakjp/dom-selector/node_modules/lru-cache": {
      "version": "11.2.5",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-11.2.5.tgz",
      "integrity": "sha512-vFrFJkWtJvJnD5hg+hJvVE8Lh/TcMzKnTgCWmtBipwI5yLX/iX+5UB2tfuyODF5E7k9xEzMdYgGqaSb1c0c5Yw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "engines": {
        "node": "20 || >=22"
      }
    },
    "node_modules/@asamuzakjp/nwsapi": {
      "version": "2.3.9",
      "resolved": "https://registry.npmjs.org/@asamuzakjp/nwsapi/-/nwsapi-2.3.9.tgz",
      "integrity": "sha512-n8GuYSrI9bF7FFZ/SjhwevlHc8xaVlb/7HmHelnc/PZXBD2ZR49NnN9sMMuDdEGPeeRQ5d0hqlSlEpgCX3Wl0Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@babel/code-frame": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.29.0.tgz",
      "integrity": "sha512-9NhCeYjq9+3uxgdtp20LSiJXJvN0FeCtNGpJxuMFZ1Kv3cWUNb6DOhJwUvcVCzKGR66cw4njwM6hrJLqgOwbcw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.28.5",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.29.0.tgz",
      "integrity": "sha512-T1NCJqT/j9+cn8fvkt7jtwbLBfLC/1y1c7NtCeXFRgzGTsafi68MRv8yzkYSapBnFA6L3U2VSc02ciDzoAJhJg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.29.0.tgz",
      "integrity": "sha512-CGOfOJqWjg2qW/Mb6zNsDm+u5vFQ8DxXfbM09z69p5Z6+mE1ikP2jUXw+j42Pf1XTYED2Rni5f95npYeuwMDQA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.29.0",
        "@babel/generator": "^7.29.0",
        "@babel/helper-compilation-targets": "^7.28.6",
        "@babel/helper-module-transforms": "^7.28.6",
        "@babel/helpers": "^7.28.6",
        "@babel/parser": "^7.29.0",
        "@babel/template": "^7.28.6",
        "@babel/traverse": "^7.29.0",
        "@babel/types": "^7.29.0",
        "@jridgewell/remapping": "^2.3.5",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.29.0.tgz",
      "integrity": "sha512-vSH118/wwM/pLR38g/Sgk05sNtro6TlTJKuiMXDaZqPUfjTFcudpCOt00IhOfj+1BFAX+UFAlzCU+6WXr3GLFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.29.0",
        "@babel/types": "^7.29.0",
        "@jridgewell/gen-mapping": "^0.3.12",
        "@jridgewell/trace-mapping": "^0.3.28",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.28.6.tgz",
      "integrity": "sha512-JYtls3hqi15fcx5GaSNL7SCTJ2MNmjrkHXg4FSpOA/grxK8KwyZ5bubHsCq8FXCkua6xhuaaBit+3b7+VZRfcA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.28.6",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-globals": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.28.6.tgz",
      "integrity": "sha512-l5XkZK7r7wa9LucGw9LwZyyCUscb4x37JWTPz7swwFE/0FMQAGpiWUZn8u9DzkSBWEcK25jmvubfpw2dnAMdbw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.28.6.tgz",
      "integrity": "sha512-67oXFAYr2cDLDVGLXTEABjdBJZ6drElUSI7WKp70NrpyISso3plG9SAGEF6y7zbha/wOzUByWWTJvEDVNIUGcA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.28.6",
        "@babel/helper-validator-identifier": "^7.28.5",
        "@babel/traverse": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.28.6.tgz",
      "integrity": "sha512-S9gzZ/bz83GRysI7gAD4wPT/AI3uCnY+9xn+Mx/KPs2JwHJIz1W8PZkg2cqyt3RNOBM8ejcXhV6y8Og7ly/Dug==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.6.tgz",
      "integrity": "sha512-xOBvwq86HHdB7WUDTfKfT/Vuxh7gElQ+Sfti2Cy6yIWNW05P8iUslOVcZ4/sKbE+/jQaukQAdz/gf3724kYdqw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.29.0"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-self": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.27.1.tgz",
      "integrity": "sha512-6UzkCs+ejGdZ5mFFC/OCUrv028ab2fp1znZmCZjAOBKiBK2jXD1O+BPSfX8X2qjJ75fZBMSnQn3Rq2mrBJK2mw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-source": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.27.1.tgz",
      "integrity": "sha512-zbwoTsBruTeKB9hSq73ha66iFeJHuaFkUbwvqElnygoNbj/jHRsSeokowZFN3CZ64IvEqcmmkVe89OPXc7ldAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.28.6.tgz",
      "integrity": "sha512-05WQkdpL9COIMz4LjTxGpPNCdlpyimKppYNoJ5Di5EUObifl8t4tuLuUBBZEpoLYOmfvIWrsp9fCl0HoPRVTdA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.28.6.tgz",
      "integrity": "sha512-YA6Ma2KsCdGb+WC6UpBVFJGXL58MDA6oyONbjyF/+5sBgxY/dwkhLogbMT2GXXyU84/IhRw/2D1Os1B/giz+BQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.28.6",
        "@babel/parser": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.29.0.tgz",
      "integrity": "sha512-4HPiQr0X7+waHfyXPZpWPfWL/J7dcN1mx9gL6WdQVMbPnF3+ZhSMs8tCxN7oHddJE9fhNE7+lxdnlyemKfJRuA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.29.0",
        "@babel/generator": "^7.29.0",
        "@babel/helper-globals": "^7.28.0",
        "@babel/parser": "^7.29.0",
        "@babel/template": "^7.28.6",
        "@babel/types": "^7.29.0",
        "debug": "^4.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@bcoe/v8-coverage": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-1.0.2.tgz",
      "integrity": "sha512-6zABk/ECA/QYSCQ1NGiVwwbQerUCZ+TQbp64Q3AgmfNvurHH0j8TtXa1qbShXA6qqkpAj4V5W8pP6mLe1mcMqA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@csstools/color-helpers": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/@csstools/color-helpers/-/color-helpers-6.0.1.tgz",
      "integrity": "sha512-NmXRccUJMk2AWA5A7e5a//3bCIMyOu2hAtdRYrhPPHjDxINuCwX1w6rnIZ4xjLcp0ayv6h8Pc3X0eJUGiAAXHQ==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT-0",
      "engines": {
        "node": ">=20.19.0"
      }
    },
    "node_modules/@csstools/css-calc": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@csstools/css-calc/-/css-calc-3.0.0.tgz",
      "integrity": "sha512-q4d82GTl8BIlh/dTnVsWmxnbWJeb3kiU8eUH71UxlxnS+WIaALmtzTL8gR15PkYOexMQYVk0CO4qIG93C1IvPA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=20.19.0"
      },
      "peerDependencies": {
        "@csstools/css-parser-algorithms": "^4.0.0",
        "@csstools/css-tokenizer": "^4.0.0"
      }
    },
    "node_modules/@csstools/css-color-parser": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/@csstools/css-color-parser/-/css-color-parser-4.0.1.tgz",
      "integrity": "sha512-vYwO15eRBEkeF6xjAno/KQ61HacNhfQuuU/eGwH67DplL0zD5ZixUa563phQvUelA07yDczIXdtmYojCphKJcw==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "@csstools/color-helpers": "^6.0.1",
        "@csstools/css-calc": "^3.0.0"
      },
      "engines": {
        "node": ">=20.19.0"
      },
      "peerDependencies": {
        "@csstools/css-parser-algorithms": "^4.0.0",
        "@csstools/css-tokenizer": "^4.0.0"
      }
    },
    "node_modules/@csstools/css-parser-algorithms": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/@csstools/css-parser-algorithms/-/css-parser-algorithms-4.0.0.tgz",
      "integrity": "sha512-+B87qS7fIG3L5h3qwJ/IFbjoVoOe/bpOdh9hAjXbvx0o8ImEmUsGXN0inFOnk2ChCFgqkkGFQ+TpM5rbhkKe4w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=20.19.0"
      },
      "peerDependencies": {
        "@csstools/css-tokenizer": "^4.0.0"
      }
    },
    "node_modules/@csstools/css-syntax-patches-for-csstree": {
      "version": "1.0.27",
      "resolved": "https://registry.npmjs.org/@csstools/css-syntax-patches-for-csstree/-/css-syntax-patches-for-csstree-1.0.27.tgz",
      "integrity": "sha512-sxP33Jwg1bviSUXAV43cVYdmjt2TLnLXNqCWl9xmxHawWVjGz/kEbdkr7F9pxJNBN2Mh+dq0crgItbW6tQvyow==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT-0"
    },
    "node_modules/@csstools/css-tokenizer": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/@csstools/css-tokenizer/-/css-tokenizer-4.0.0.tgz",
      "integrity": "sha512-QxULHAm7cNu72w97JUNCBFODFaXpbDg+dP8b/oWFAZ2MTRppA3U00Y2L1HqaS4J6yBqxwa/Y3nMBaxVKbB/NsA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=20.19.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.25.12.tgz",
      "integrity": "sha512-Hhmwd6CInZ3dwpuGTF8fJG6yoWmsToE+vYgD4nytZVxcu1ulHpUQRAB1UJ8+N1Am3Mz4+xOByoQoSZf4D+CpkA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.25.12.tgz",
      "integrity": "sha512-VJ+sKvNA/GE7Ccacc9Cha7bpS8nyzVv0jdVgwNDaR4gDMC/2TTRc33Ip8qrNYUcpkOHUT5OZ0bUcNNVZQ9RLlg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.25.12.tgz",
      "integrity": "sha512-6AAmLG7zwD1Z159jCKPvAxZd4y/VTO0VkprYy+3N2FtJ8+BQWFXU+OxARIwA46c5tdD9SsKGZ/1ocqBS/gAKHg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.25.12.tgz",
      "integrity": "sha512-5jbb+2hhDHx5phYR2By8GTWEzn6I9UqR11Kwf22iKbNpYrsmRB18aX/9ivc5cabcUiAT/wM+YIZ6SG9QO6a8kg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.12.tgz",
      "integrity": "sha512-N3zl+lxHCifgIlcMUP5016ESkeQjLj/959RxxNYIthIg+CQHInujFuXeWbWMgnTo4cp5XVHqFPmpyu9J65C1Yg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.25.12.tgz",
      "integrity": "sha512-HQ9ka4Kx21qHXwtlTUVbKJOAnmG1ipXhdWTmNXiPzPfWKpXqASVcWdnf2bnL73wgjNrFXAa3yYvBSd9pzfEIpA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.25.12.tgz",
      "integrity": "sha512-gA0Bx759+7Jve03K1S0vkOu5Lg/85dou3EseOGUes8flVOGxbhDDh/iZaoek11Y8mtyKPGF3vP8XhnkDEAmzeg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.25.12.tgz",
      "integrity": "sha512-TGbO26Yw2xsHzxtbVFGEXBFH0FRAP7gtcPE7P5yP7wGy7cXK2oO7RyOhL5NLiqTlBh47XhmIUXuGciXEqYFfBQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.25.12.tgz",
      "integrity": "sha512-lPDGyC1JPDou8kGcywY0YILzWlhhnRjdof3UlcoqYmS9El818LLfJJc3PXXgZHrHCAKs/Z2SeZtDJr5MrkxtOw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.25.12.tgz",
      "integrity": "sha512-8bwX7a8FghIgrupcxb4aUmYDLp8pX06rGh5HqDT7bB+8Rdells6mHvrFHHW2JAOPZUbnjUpKTLg6ECyzvas2AQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.25.12.tgz",
      "integrity": "sha512-0y9KrdVnbMM2/vG8KfU0byhUN+EFCny9+8g202gYqSSVMonbsCfLjUO+rCci7pM0WBEtz+oK/PIwHkzxkyharA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.25.12.tgz",
      "integrity": "sha512-h///Lr5a9rib/v1GGqXVGzjL4TMvVTv+s1DPoxQdz7l/AYv6LDSxdIwzxkrPW438oUXiDtwM10o9PmwS/6Z0Ng==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.25.12.tgz",
      "integrity": "sha512-iyRrM1Pzy9GFMDLsXn1iHUm18nhKnNMWscjmp4+hpafcZjrr2WbT//d20xaGljXDBYHqRcl8HnxbX6uaA/eGVw==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.25.12.tgz",
      "integrity": "sha512-9meM/lRXxMi5PSUqEXRCtVjEZBGwB7P/D4yT8UG/mwIdze2aV4Vo6U5gD3+RsoHXKkHCfSxZKzmDssVlRj1QQA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.25.12.tgz",
      "integrity": "sha512-Zr7KR4hgKUpWAwb1f3o5ygT04MzqVrGEGXGLnj15YQDJErYu/BGg+wmFlIDOdJp0PmB0lLvxFIOXZgFRrdjR0w==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.25.12.tgz",
      "integrity": "sha512-MsKncOcgTNvdtiISc/jZs/Zf8d0cl/t3gYWX8J9ubBnVOwlk65UIEEvgBORTiljloIWnBzLs4qhzPkJcitIzIg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.25.12.tgz",
      "integrity": "sha512-uqZMTLr/zR/ed4jIGnwSLkaHmPjOjJvnm6TVVitAa08SLS9Z0VM8wIRx7gWbJB5/J54YuIMInDquWyYvQLZkgw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.25.12.tgz",
      "integrity": "sha512-xXwcTq4GhRM7J9A8Gv5boanHhRa/Q9KLVmcyXHCTaM4wKfIpWkdXiMog/KsnxzJ0A1+nD+zoecuzqPmCRyBGjg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.25.12.tgz",
      "integrity": "sha512-Ld5pTlzPy3YwGec4OuHh1aCVCRvOXdH8DgRjfDy/oumVovmuSzWfnSJg+VtakB9Cm0gxNO9BzWkj6mtO1FMXkQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.25.12.tgz",
      "integrity": "sha512-fF96T6KsBo/pkQI950FARU9apGNTSlZGsv1jZBAlcLL1MLjLNIWPBkj5NlSz8aAzYKg+eNqknrUJ24QBybeR5A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.25.12.tgz",
      "integrity": "sha512-MZyXUkZHjQxUvzK7rN8DJ3SRmrVrke8ZyRusHlP+kuwqTcfWLyqMOE3sScPPyeIXN/mDJIfGXvcMqCgYKekoQw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openharmony-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/openharmony-arm64/-/openharmony-arm64-0.25.12.tgz",
      "integrity": "sha512-rm0YWsqUSRrjncSXGA7Zv78Nbnw4XL6/dzr20cyrQf7ZmRcsovpcRBdhD43Nuk3y7XIoW2OxMVvwuRvk9XdASg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.25.12.tgz",
      "integrity": "sha512-3wGSCDyuTHQUzt0nV7bocDy72r2lI33QL3gkDNGkod22EsYl04sMf0qLb8luNKTOmgF/eDEDP5BFNwoBKH441w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.25.12.tgz",
      "integrity": "sha512-rMmLrur64A7+DKlnSuwqUdRKyd3UE7oPJZmnljqEptesKM8wx9J8gx5u0+9Pq0fQQW8vqeKebwNXdfOyP+8Bsg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.25.12.tgz",
      "integrity": "sha512-HkqnmmBoCbCwxUKKNPBixiWDGCpQGVsrQfJoVGYLPT41XWF8lHuE5N6WhVia2n4o5QK5M4tYr21827fNhi4byQ==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.25.12.tgz",
      "integrity": "sha512-alJC0uCZpTFrSL0CCDjcgleBXPnCrEAhTBILpeAp7M/OFgoqtAetfBzX0xM00MUsVVPpVjlPuMbREqnZCXaTnA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.9.1",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.9.1.tgz",
      "integrity": "sha512-phrYmNiYppR7znFEdqgfWHXR6NCkZEK7hwWDHZUjit/2/U0r6XvkDl0SYnoM51Hq7FhCGdLDT6zxCCOY1hexsQ==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "eslint-visitor-keys": "^3.4.3"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/eslint-utils/node_modules/eslint-visitor-keys": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
      "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
      "dev": true,
      "license": "Apache-2.0",
      "peer": true,
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.12.2",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.2.tgz",
      "integrity": "sha512-EriSTlt5OC9/7SXkRSCAhfSxxoSUgBm33OH+IkwbdpgoqsSsUg7y3uh+IICI/Qg4BBWr3U2i39RpmycbxMq4ew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/config-array": {
      "version": "0.21.1",
      "resolved": "https://registry.npmjs.org/@eslint/config-array/-/config-array-0.21.1.tgz",
      "integrity": "sha512-aw1gNayWpdI/jSYVgzN5pL0cfzU02GT3NBpeT/DXbx1/1x7ZKxFPd9bwrzygx/qiwIQiJ1sw/zD8qY/kRvlGHA==",
      "dev": true,
      "license": "Apache-2.0",
      "peer": true,
      "dependencies": {
        "@eslint/object-schema": "^2.1.7",
        "debug": "^4.3.1",
        "minimatch": "^3.1.2"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/config-array/node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/@eslint/config-array/node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "peer": true,
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/@eslint/config-helpers": {
      "version": "0.4.2",
      "resolved": "https://registry.npmjs.org/@eslint/config-helpers/-/config-helpers-0.4.2.tgz",
      "integrity": "sha512-gBrxN88gOIf3R7ja5K9slwNayVcZgK6SOUORm2uBzTeIEfeVaIhOpCtTox3P6R7o2jLFwLFTLnC7kU/RGcYEgw==",
      "dev": true,
      "license": "Apache-2.0",
      "peer": true,
      "dependencies": {
        "@eslint/core": "^0.17.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/core": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/@eslint/core/-/core-0.17.0.tgz",
      "integrity": "sha512-yL/sLrpmtDaFEiUj1osRP4TI2MDz1AddJL+jZ7KSqvBuliN4xqYY54IfdN8qD8Toa6g1iloph1fxQNkjOxrrpQ==",
      "dev": true,
      "license": "Apache-2.0",
      "peer": true,
      "dependencies": {
        "@types/json-schema": "^7.0.15"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-3.3.3.tgz",
      "integrity": "sha512-Kr+LPIUVKz2qkx1HAMH8q1q6azbqBAsXJUxBl/ODDuVPX45Z9DfwB8tPjTi6nNZ8BuM3nbJxC5zCAg5elnBUTQ==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^10.0.1",
        "globals": "^14.0.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.1",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "peer": true,
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/@eslint/js": {
      "version": "9.39.2",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-9.39.2.tgz",
      "integrity": "sha512-q1mjIoW1VX4IvSocvM/vbTiveKC4k9eLrajNEuSsmjymSDEbpGddtpfOoN7YGAqBK3NG+uqo8ia4PDTt8buCYA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      }
    },
    "node_modules/@eslint/object-schema": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/@eslint/object-schema/-/object-schema-2.1.7.tgz",
      "integrity": "sha512-VtAOaymWVfZcmZbp6E2mympDIHvyjXs/12LqWYjVw6qjrfF+VK+fyG33kChz3nnK+SU5/NeHOqrTEHS8sXO3OA==",
      "dev": true,
      "license": "Apache-2.0",
      "peer": true,
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/plugin-kit": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/@eslint/plugin-kit/-/plugin-kit-0.4.1.tgz",
      "integrity": "sha512-43/qtrDUokr7LJqoF2c3+RInu/t4zfrpYdoSDfYyhg52rwLV6TnOvdG4fXm7IkSB3wErkcmJS9iEhjVtOSEjjA==",
      "dev": true,
      "license": "Apache-2.0",
      "peer": true,
      "dependencies": {
        "@eslint/core": "^0.17.0",
        "levn": "^0.4.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@exodus/bytes": {
      "version": "1.12.0",
      "resolved": "https://registry.npmjs.org/@exodus/bytes/-/bytes-1.12.0.tgz",
      "integrity": "sha512-BuCOHA/EJdPN0qQ5MdgAiJSt9fYDHbghlgrj33gRdy/Yp1/FMCDhU6vJfcKrLC0TPWGSrfH3vYXBQWmFHxlddw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=24.0.0"
      },
      "peerDependencies": {
        "@noble/hashes": "^1.8.0 || ^2.0.0"
      },
      "peerDependenciesMeta": {
        "@noble/hashes": {
          "optional": true
        }
      }
    },
    "node_modules/@floating-ui/core": {
      "version": "1.7.4",
      "resolved": "https://registry.npmjs.org/@floating-ui/core/-/core-1.7.4.tgz",
      "integrity": "sha512-C3HlIdsBxszvm5McXlB8PeOEWfBhcGBTZGkGlWc2U0KFY5IwG5OQEuQ8rq52DZmcHDlPLd+YFBK+cZcytwIFWg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/utils": "^0.2.10"
      }
    },
    "node_modules/@floating-ui/dom": {
      "version": "1.7.5",
      "resolved": "https://registry.npmjs.org/@floating-ui/dom/-/dom-1.7.5.tgz",
      "integrity": "sha512-N0bD2kIPInNHUHehXhMke1rBGs1dwqvC9O9KYMyyjK7iXt7GAhnro7UlcuYcGdS/yYOlq0MAVgrow8IbWJwyqg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/core": "^1.7.4",
        "@floating-ui/utils": "^0.2.10"
      }
    },
    "node_modules/@floating-ui/react-dom": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/@floating-ui/react-dom/-/react-dom-2.1.7.tgz",
      "integrity": "sha512-0tLRojf/1Go2JgEVm+3Frg9A3IW8bJgKgdO0BN5RkF//ufuz2joZM63Npau2ff3J6lUVYgDSNzNkR+aH3IVfjg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/dom": "^1.7.5"
      },
      "peerDependencies": {
        "react": ">=16.8.0",
        "react-dom": ">=16.8.0"
      }
    },
    "node_modules/@floating-ui/utils": {
      "version": "0.2.10",
      "resolved": "https://registry.npmjs.org/@floating-ui/utils/-/utils-0.2.10.tgz",
      "integrity": "sha512-aGTxbpbg8/b5JfU1HXSrbH3wXZuLPJcNEcZQFMxLs3oSzgtVu6nFPkbbGGUvBcUjKV2YyB9Wxxabo+HEH9tcRQ==",
      "license": "MIT"
    },
    "node_modules/@humanfs/core": {
      "version": "0.19.1",
      "resolved": "https://registry.npmjs.org/@humanfs/core/-/core-0.19.1.tgz",
      "integrity": "sha512-5DyQ4+1JEUzejeK1JGICcideyfUbGixgS9jNgex5nqkW+cY7WZhxBigmieN5Qnw9ZosSNVC9KQKyb+GUaGyKUA==",
      "dev": true,
      "license": "Apache-2.0",
      "peer": true,
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanfs/node": {
      "version": "0.16.7",
      "resolved": "https://registry.npmjs.org/@humanfs/node/-/node-0.16.7.tgz",
      "integrity": "sha512-/zUx+yOsIrG4Y43Eh2peDeKCxlRt/gET6aHfaKpuq267qXdYDFViVHfMaLyygZOnl0kGWxFIgsBy8QFuTLUXEQ==",
      "dev": true,
      "license": "Apache-2.0",
      "peer": true,
      "dependencies": {
        "@humanfs/core": "^0.19.1",
        "@humanwhocodes/retry": "^0.4.0"
      },
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "license": "Apache-2.0",
      "peer": true,
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/retry": {
      "version": "0.4.3",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.4.3.tgz",
      "integrity": "sha512-bV0Tgo9K4hfPCek+aMAn81RppFKv2ySDQeMoSZuvTASywNTnVJCArCZE2FWqpvIatKu7VMRLWlR1EazvVhDyhQ==",
      "dev": true,
      "license": "Apache-2.0",
      "peer": true,
      "engines": {
        "node": ">=18.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@isaacs/balanced-match": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/@isaacs/balanced-match/-/balanced-match-4.0.1.tgz",
      "integrity": "sha512-yzMTt9lEb8Gv7zRioUilSglI0c0smZ9k5D65677DLWLtWJaXIS3CqcGyUFByYKlnUj6TkjLVs54fBl6+TiGQDQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "20 || >=22"
      }
    },
    "node_modules/@isaacs/brace-expansion": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/@isaacs/brace-expansion/-/brace-expansion-5.0.1.tgz",
      "integrity": "sha512-WMz71T1JS624nWj2n2fnYAuPovhv7EUhk69R6i9dsVyzxt5eM3bjwvgk9L+APE1TRscGysAVMANkB0jh0LQZrQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@isaacs/balanced-match": "^4.0.1"
      },
      "engines": {
        "node": "20 || >=22"
      }
    },
    "node_modules/@isaacs/cliui": {
      "version": "8.0.2",
      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "string-width": "^5.1.2",
        "string-width-cjs": "npm:string-width@^4.2.0",
        "strip-ansi": "^7.0.1",
        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
        "wrap-ansi": "^8.1.0",
        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@istanbuljs/schema": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.13",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/remapping": {
      "version": "2.3.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/remapping/-/remapping-2.3.5.tgz",
      "integrity": "sha512-LI9u/+laYG4Ds1TDKSJW2YPrIlcVYOwi2fUC6xB43lueCjgxV4lffOCZCtYFiH6TNOX+tQKXx97T4IKHbhyHEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.31",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "2.0.5",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.5",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@originjs/vite-plugin-federation": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/@originjs/vite-plugin-federation/-/vite-plugin-federation-1.4.1.tgz",
      "integrity": "sha512-Uo08jW5pj1t58OUKuZNkmzcfTN2pqeVuAWCCiKf/75/oll4Efq4cHOqSE1FXMlvwZNGDziNdDyBbQ5IANem3CQ==",
      "dev": true,
      "license": "MulanPSL-2.0",
      "dependencies": {
        "estree-walker": "^3.0.2",
        "magic-string": "^0.27.0"
      },
      "engines": {
        "node": ">=14.0.0",
        "pnpm": ">=7.0.1"
      }
    },
    "node_modules/@pkgjs/parseargs": {
      "version": "0.11.0",
      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
      "dev": true,
      "license": "MIT",
      "optional": true,
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/@radix-ui/number": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/number/-/number-1.1.1.tgz",
      "integrity": "sha512-MkKCwxlXTgz6CFoJx3pCwn07GKp36+aZyu/u2Ln2VrA5DcdyCZkASEDBTd8x5whTQQL5CiYf4prXKLcgQdv29g==",
      "license": "MIT"
    },
    "node_modules/@radix-ui/primitive": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/primitive/-/primitive-1.1.3.tgz",
      "integrity": "sha512-JTF99U/6XIjCBo0wqkU5sK10glYe27MRRsfwoiq5zzOEZLHU3A3KCMa5X/azekYRCJ0HlwI0crAXS/5dEHTzDg==",
      "license": "MIT"
    },
    "node_modules/@radix-ui/react-accordion": {
      "version": "1.2.12",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-accordion/-/react-accordion-1.2.12.tgz",
      "integrity": "sha512-T4nygeh9YE9dLRPhAHSeOZi7HBXo+0kYIPJXayZfvWOWA0+n3dESrZbjfDPUABkUNym6Hd+f2IR113To8D2GPA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-collapsible": "1.1.12",
        "@radix-ui/react-collection": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-alert-dialog": {
      "version": "1.1.15",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-alert-dialog/-/react-alert-dialog-1.1.15.tgz",
      "integrity": "sha512-oTVLkEw5GpdRe29BqJ0LSDFWI3qu0vR1M0mUkOQWDIUnY/QIkLpgDMWuKxP94c2NAC2LGcgVhG1ImF3jkZ5wXw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dialog": "1.1.15",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-alert-dialog/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-arrow": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-arrow/-/react-arrow-1.1.7.tgz",
      "integrity": "sha512-F+M1tLhO+mlQaOWspE8Wstg+z6PwxwRd8oQ8IXceWz92kfAmalTRf0EjrouQeo7QssEPfCn05B4Ihs1K9WQ/7w==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-checkbox": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-checkbox/-/react-checkbox-1.3.3.tgz",
      "integrity": "sha512-wBbpv+NQftHDdG86Qc0pIyXk5IR3tM8Vd0nWLKDcX8nNn4nXFOFwsKuqw2okA/1D/mpaAkmuyndrPJTYDNZtFw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-previous": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-collapsible": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-collapsible/-/react-collapsible-1.1.12.tgz",
      "integrity": "sha512-Uu+mSh4agx2ib1uIGPP4/CKNULyajb3p92LsVXmH2EHVMTfZWpll88XJ0j4W0z3f8NK1eYl1+Mf/szHPmcHzyA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-collection": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-collection/-/react-collection-1.1.7.tgz",
      "integrity": "sha512-Fh9rGN0MoI4ZFUNyfFVNU4y9LUz93u9/0K+yLgA2bwRojxM8JU1DyvvMBabnZPBgMWREAJvU2jjVzq+LrFUglw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-collection/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-compose-refs": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-compose-refs/-/react-compose-refs-1.1.2.tgz",
      "integrity": "sha512-z4eqJvfiNnFMHIIvXP3CY57y2WJs5g2v3X0zm9mEJkrkNv4rDxu+sg9Jh8EkXyeqBkB7SOcboo9dMVqhyrACIg==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-context": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-context/-/react-context-1.1.2.tgz",
      "integrity": "sha512-jCi/QKUM2r1Ju5a3J64TH2A5SpKAgh0LpknyqdQ4m6DCV0xJ2HG1xARRwNGPQfi1SLdLWZ1OJz6F4OMBBNiGJA==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dialog": {
      "version": "1.1.15",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dialog/-/react-dialog-1.1.15.tgz",
      "integrity": "sha512-TCglVRtzlffRNxRMEyR36DGBLJpeusFcgMVD9PZEzAKnUs1lKCgX5u9BmC2Yg+LL9MgZDugFFs1Vl+Jp4t/PGw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-focus-guards": "1.1.3",
        "@radix-ui/react-focus-scope": "1.1.7",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dialog/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-direction": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-direction/-/react-direction-1.1.1.tgz",
      "integrity": "sha512-1UEWRX6jnOA2y4H5WczZ44gOOjTEmlqv1uNW4GAJEO5+bauCBhv8snY65Iw5/VOS/ghKN9gr2KjnLKxrsvoMVw==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dismissable-layer": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dismissable-layer/-/react-dismissable-layer-1.1.11.tgz",
      "integrity": "sha512-Nqcp+t5cTB8BinFkZgXiMJniQH0PsUt2k51FUhbdfeKvc4ACcG2uQniY/8+h1Yv6Kza4Q7lD7PQV0z0oicE0Mg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-escape-keydown": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dropdown-menu": {
      "version": "2.1.16",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dropdown-menu/-/react-dropdown-menu-2.1.16.tgz",
      "integrity": "sha512-1PLGQEynI/3OX/ftV54COn+3Sud/Mn8vALg2rWnBLnRaGtJDduNW/22XjlGgPdpcIbiQxjKtb7BkcjP00nqfJw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-menu": "2.1.16",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-focus-guards": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-focus-guards/-/react-focus-guards-1.1.3.tgz",
      "integrity": "sha512-0rFg/Rj2Q62NCm62jZw0QX7a3sz6QCQU0LpZdNrJX8byRGaGVTqbrW9jAoIAHyMQqsNpeZ81YgSizOt5WXq0Pw==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-focus-scope": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-focus-scope/-/react-focus-scope-1.1.7.tgz",
      "integrity": "sha512-t2ODlkXBQyn7jkl6TNaw/MtVEVvIGelJDCG41Okq/KwUsJBwQ4XVZsHAVUkK4mBv3ewiAS3PGuUWuY2BoK4ZUw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-icons": {
      "version": "1.3.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-icons/-/react-icons-1.3.2.tgz",
      "integrity": "sha512-fyQIhGDhzfc9pK2kH6Pl9c4BDJGfMkPqkyIgYDthyNYoNg3wVhoJMMh19WS4Up/1KMPFVpNsT2q3WmXn2N1m6g==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^16.x || ^17.x || ^18.x || ^19.0.0 || ^19.0.0-rc"
      }
    },
    "node_modules/@radix-ui/react-id": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-id/-/react-id-1.1.1.tgz",
      "integrity": "sha512-kGkGegYIdQsOb4XjsfM97rXsiHaBwco+hFI66oO4s9LU+PLAC5oJ7khdOVFxkhsmlbpUqDAvXw11CluXP+jkHg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-label": {
      "version": "2.1.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-label/-/react-label-2.1.8.tgz",
      "integrity": "sha512-FmXs37I6hSBVDlO4y764TNz1rLgKwjJMQ0EGte6F3Cb3f4bIuHB/iLa/8I9VKkmOy+gNHq8rql3j686ACVV21A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.4"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-label/node_modules/@radix-ui/react-primitive": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-primitive/-/react-primitive-2.1.4.tgz",
      "integrity": "sha512-9hQc4+GNVtJAIEPEqlYqW5RiYdrr8ea5XQ0ZOnD6fgru+83kqT15mq2OCcbe8KnjRZl5vF3ks69AKz3kh1jrhg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-slot": "1.2.4"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-menu": {
      "version": "2.1.16",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-menu/-/react-menu-2.1.16.tgz",
      "integrity": "sha512-72F2T+PLlphrqLcAotYPp0uJMr5SjP5SL01wfEspJbru5Zs5vQaSHb4VB3ZMJPimgHHCHG7gMOeOB9H3Hdmtxg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-collection": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-focus-guards": "1.1.3",
        "@radix-ui/react-focus-scope": "1.1.7",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.8",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-roving-focus": "1.1.11",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-menu/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popover": {
      "version": "1.1.15",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-popover/-/react-popover-1.1.15.tgz",
      "integrity": "sha512-kr0X2+6Yy/vJzLYJUPCZEc8SfQcf+1COFoAqauJm74umQhta9M7lNJHP7QQS3vkvcGLQUbWpMzwrXYwrYztHKA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-focus-guards": "1.1.3",
        "@radix-ui/react-focus-scope": "1.1.7",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.8",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popper": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-popper/-/react-popper-1.2.8.tgz",
      "integrity": "sha512-0NJQ4LFFUuWkE7Oxf0htBKS6zLkkjBH+hM1uk7Ng705ReR8m/uelduy1DBo0PyBXPKVnBA6YBlU94MBGXrSBCw==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react-dom": "^2.0.0",
        "@radix-ui/react-arrow": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-layout-effect": "1.1.1",
        "@radix-ui/react-use-rect": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1",
        "@radix-ui/rect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-portal": {
      "version": "1.1.9",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-portal/-/react-portal-1.1.9.tgz",
      "integrity": "sha512-bpIxvq03if6UNwXZ+HTK71JLh4APvnXntDc6XOX8UVq4XQOVl7lwok0AvIl+b8zgCw3fSaVTZMpAPPagXbKmHQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-presence": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-presence/-/react-presence-1.1.5.tgz",
      "integrity": "sha512-/jfEwNDdQVBCNvjkGit4h6pMOzq8bHkopq458dPt2lMjx+eBQUohZNG9A7DtO/O5ukSbxuaNGXMjHicgwy6rQQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-primitive": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-primitive/-/react-primitive-2.1.3.tgz",
      "integrity": "sha512-m9gTwRkhy2lvCPe6QJp4d3G1TYEUHn/FzJUtq9MjH46an1wJU+GdoGC5VLof8RX8Ft/DlpshApkhswDLZzHIcQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-slot": "1.2.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-primitive/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-roving-focus": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-roving-focus/-/react-roving-focus-1.1.11.tgz",
      "integrity": "sha512-7A6S9jSgm/S+7MdtNDSb+IU859vQqJ/QAtcYQcfFC6W8RS4IxIZDldLR0xqCFZ6DCyrQLjLPsxtTNch5jVA4lA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-collection": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-scroll-area": {
      "version": "1.2.10",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-scroll-area/-/react-scroll-area-1.2.10.tgz",
      "integrity": "sha512-tAXIa1g3sM5CGpVT0uIbUx/U3Gs5N8T52IICuCtObaos1S8fzsrPXG5WObkQN3S6NVl6wKgPhAIiBGbWnvc97A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/number": "1.1.1",
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-select": {
      "version": "2.2.6",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-select/-/react-select-2.2.6.tgz",
      "integrity": "sha512-I30RydO+bnn2PQztvo25tswPH+wFBjehVGtmagkU78yMdwTwVf12wnAOF+AeP8S2N8xD+5UPbGhkUfPyvT+mwQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/number": "1.1.1",
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-collection": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-focus-guards": "1.1.3",
        "@radix-ui/react-focus-scope": "1.1.7",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.8",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-layout-effect": "1.1.1",
        "@radix-ui/react-use-previous": "1.1.1",
        "@radix-ui/react-visually-hidden": "1.2.3",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-separator": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-separator/-/react-separator-1.1.8.tgz",
      "integrity": "sha512-sDvqVY4itsKwwSMEe0jtKgfTh+72Sy3gPmQpjqcQneqQ4PFmr/1I0YA+2/puilhggCe2gJcx5EBAYFkWkdpa5g==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.4"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-separator/node_modules/@radix-ui/react-primitive": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-primitive/-/react-primitive-2.1.4.tgz",
      "integrity": "sha512-9hQc4+GNVtJAIEPEqlYqW5RiYdrr8ea5XQ0ZOnD6fgru+83kqT15mq2OCcbe8KnjRZl5vF3ks69AKz3kh1jrhg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-slot": "1.2.4"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-slot": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.4.tgz",
      "integrity": "sha512-Jl+bCv8HxKnlTLVrcDE8zTMJ09R9/ukw4qBs/oZClOfoQk/cOTbDn+NceXfV7j09YPVQUryJPHurafcSg6EVKA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-switch": {
      "version": "1.2.6",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-switch/-/react-switch-1.2.6.tgz",
      "integrity": "sha512-bByzr1+ep1zk4VubeEVViV592vu2lHE2BZY5OnzehZqOOgogN80+mNtCqPkhn2gklJqOpxWgPoYTSnhBCqpOXQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-previous": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-tabs": {
      "version": "1.1.13",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-tabs/-/react-tabs-1.1.13.tgz",
      "integrity": "sha512-7xdcatg7/U+7+Udyoj2zodtI9H/IIopqo+YOIcZOq1nJwXWBZ9p8xiu5llXlekDbZkca79a/fozEYQXIA4sW6A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-roving-focus": "1.1.11",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-toggle": {
      "version": "1.1.10",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-toggle/-/react-toggle-1.1.10.tgz",
      "integrity": "sha512-lS1odchhFTeZv3xwHH31YPObmJn8gOg7Lq12inrr0+BH/l3Tsq32VfjqH1oh80ARM3mlkfMic15n0kg4sD1poQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-toggle-group": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-toggle-group/-/react-toggle-group-1.1.11.tgz",
      "integrity": "sha512-5umnS0T8JQzQT6HbPyO7Hh9dgd82NmS36DQr+X/YJ9ctFNCiiQd6IJAYYZ33LUwm8M+taCz5t2ui29fHZc4Y6Q==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-roving-focus": "1.1.11",
        "@radix-ui/react-toggle": "1.1.10",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-tooltip": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-tooltip/-/react-tooltip-1.2.8.tgz",
      "integrity": "sha512-tY7sVt1yL9ozIxvmbtN5qtmH2krXcBCfjEiCgKGLqunJHvgvZG2Pcl2oQ3kbcZARb1BGEHdkLzcYGO8ynVlieg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.8",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-visually-hidden": "1.2.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-tooltip/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-callback-ref": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-callback-ref/-/react-use-callback-ref-1.1.1.tgz",
      "integrity": "sha512-FkBMwD+qbGQeMu1cOHnuGB6x4yzPjho8ap5WtbEJ26umhgqVXbhekKUQO+hZEL1vU92a3wHwdp0HAcqAUF5iDg==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-controllable-state": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-controllable-state/-/react-use-controllable-state-1.2.2.tgz",
      "integrity": "sha512-BjasUjixPFdS+NKkypcyyN5Pmg83Olst0+c6vGov0diwTEo6mgdqVR6hxcEgFuh4QrAs7Rc+9KuGJ9TVCj0Zzg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-effect-event": "0.0.2",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-effect-event": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-effect-event/-/react-use-effect-event-0.0.2.tgz",
      "integrity": "sha512-Qp8WbZOBe+blgpuUT+lw2xheLP8q0oatc9UpmiemEICxGvFLYmHm9QowVZGHtJlGbS6A6yJ3iViad/2cVjnOiA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-escape-keydown": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-escape-keydown/-/react-use-escape-keydown-1.1.1.tgz",
      "integrity": "sha512-Il0+boE7w/XebUHyBjroE+DbByORGR9KKmITzbR7MyQ4akpORYP/ZmbhAr0DG7RmmBqoOnZdy2QlvajJ2QA59g==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-callback-ref": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-layout-effect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-layout-effect/-/react-use-layout-effect-1.1.1.tgz",
      "integrity": "sha512-RbJRS4UWQFkzHTTwVymMTUv8EqYhOp8dOOviLj2ugtTiXRaRQS7GLGxZTLL1jWhMeoSCf5zmcZkqTl9IiYfXcQ==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-previous": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-previous/-/react-use-previous-1.1.1.tgz",
      "integrity": "sha512-2dHfToCj/pzca2Ck724OZ5L0EVrr3eHRNsG/b3xQJLA2hZpVCS99bLAX+hm1IHXDEnzU6by5z/5MIY794/a8NQ==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-rect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-rect/-/react-use-rect-1.1.1.tgz",
      "integrity": "sha512-QTYuDesS0VtuHNNvMh+CjlKJ4LJickCMUAqjlE3+j8w+RlRpwyX3apEQKGFzbZGdo7XNG1tXa+bQqIE7HIXT2w==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/rect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-size": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-size/-/react-use-size-1.1.1.tgz",
      "integrity": "sha512-ewrXRDTAqAXlkl6t/fkXWNAhFX9I+CkKlw6zjEwk86RSPKwZr3xpBRso655aqYafwtnbpHLj6toFzmd6xdVptQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-visually-hidden": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-visually-hidden/-/react-visually-hidden-1.2.3.tgz",
      "integrity": "sha512-pzJq12tEaaIhqjbzpCuv/OypJY/BPavOofm+dbab+MHLajy277+1lLm6JFcGgF5eskJ6mquGirhXY2GD/8u8Ug==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/rect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/rect/-/rect-1.1.1.tgz",
      "integrity": "sha512-HPwpGIzkl28mWyZqG52jiqDJ12waP11Pa1lGoiyUkIEuMLBP0oeK/C89esbXrxsky5we7dfd8U58nm0SgAWpVw==",
      "license": "MIT"
    },
    "node_modules/@rolldown/pluginutils": {
      "version": "1.0.0-beta.27",
      "resolved": "https://registry.npmjs.org/@rolldown/pluginutils/-/pluginutils-1.0.0-beta.27.tgz",
      "integrity": "sha512-+d0F4MKMCbeVUJwG96uQ4SgAznZNSq93I3V+9NHA4OpvqG8mRCpGdKmK8l/dl02h2CCDHwW2FqilnTyDcAnqjA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
      "integrity": "sha512-A6ehUVSiSaaliTxai040ZpZ2zTevHYbvu/lDoeAteHI8QnaosIzm4qwtezfRg1jOYaUmnzLX1AOD6Z+UJjtifg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.57.1.tgz",
      "integrity": "sha512-dQaAddCY9YgkFHZcFNS/606Exo8vcLHwArFZ7vxXq4rigo2bb494/xKMMwRRQW6ug7Js6yXmBZhSBRuBvCCQ3w==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.57.1.tgz",
      "integrity": "sha512-crNPrwJOrRxagUYeMn/DZwqN88SDmwaJ8Cvi/TN1HnWBU7GwknckyosC2gd0IqYRsHDEnXf328o9/HC6OkPgOg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.57.1.tgz",
      "integrity": "sha512-Ji8g8ChVbKrhFtig5QBV7iMaJrGtpHelkB3lsaKzadFBe58gmjfGXAOfI5FV0lYMH8wiqsxKQ1C9B0YTRXVy4w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.57.1.tgz",
      "integrity": "sha512-R+/WwhsjmwodAcz65guCGFRkMb4gKWTcIeLy60JJQbXrJ97BOXHxnkPFrP+YwFlaS0m+uWJTstrUA9o+UchFug==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.57.1.tgz",
      "integrity": "sha512-IEQTCHeiTOnAUC3IDQdzRAGj3jOAYNr9kBguI7MQAAZK3caezRrg0GxAb6Hchg4lxdZEI5Oq3iov/w/hnFWY9Q==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.57.1.tgz",
      "integrity": "sha512-F8sWbhZ7tyuEfsmOxwc2giKDQzN3+kuBLPwwZGyVkLlKGdV1nvnNwYD0fKQ8+XS6hp9nY7B+ZeK01EBUE7aHaw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.57.1.tgz",
      "integrity": "sha512-rGfNUfn0GIeXtBP1wL5MnzSj98+PZe/AXaGBCRmT0ts80lU5CATYGxXukeTX39XBKsxzFpEeK+Mrp9faXOlmrw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.57.1.tgz",
      "integrity": "sha512-MMtej3YHWeg/0klK2Qodf3yrNzz6CGjo2UntLvk2RSPlhzgLvYEB3frRvbEF2wRKh1Z2fDIg9KRPe1fawv7C+g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.57.1.tgz",
      "integrity": "sha512-1a/qhaaOXhqXGpMFMET9VqwZakkljWHLmZOX48R0I/YLbhdxr1m4gtG1Hq7++VhVUmf+L3sTAf9op4JlhQ5u1Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.57.1.tgz",
      "integrity": "sha512-QWO6RQTZ/cqYtJMtxhkRkidoNGXc7ERPbZN7dVW5SdURuLeVU7lwKMpo18XdcmpWYd0qsP1bwKPf7DNSUinhvA==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-musl/-/rollup-linux-loong64-musl-4.57.1.tgz",
      "integrity": "sha512-xpObYIf+8gprgWaPP32xiN5RVTi/s5FCR+XMXSKmhfoJjrpRAjCuuqQXyxUa/eJTdAE6eJ+KDKaoEqjZQxh3Gw==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.57.1.tgz",
      "integrity": "sha512-4BrCgrpZo4hvzMDKRqEaW1zeecScDCR+2nZ86ATLhAoJ5FQ+lbHVD3ttKe74/c7tNT9c6F2viwB3ufwp01Oh2w==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-musl/-/rollup-linux-ppc64-musl-4.57.1.tgz",
      "integrity": "sha512-NOlUuzesGauESAyEYFSe3QTUguL+lvrN1HtwEEsU2rOwdUDeTMJdO5dUYl/2hKf9jWydJrO9OL/XSSf65R5+Xw==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.57.1.tgz",
      "integrity": "sha512-ptA88htVp0AwUUqhVghwDIKlvJMD/fmL/wrQj99PRHFRAG6Z5nbWoWG4o81Nt9FT+IuqUQi+L31ZKAFeJ5Is+A==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.57.1.tgz",
      "integrity": "sha512-S51t7aMMTNdmAMPpBg7OOsTdn4tySRQvklmL3RpDRyknk87+Sp3xaumlatU+ppQ+5raY7sSTcC2beGgvhENfuw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.57.1.tgz",
      "integrity": "sha512-Bl00OFnVFkL82FHbEqy3k5CUCKH6OEJL54KCyx2oqsmZnFTR8IoNqBF+mjQVcRCT5sB6yOvK8A37LNm/kPJiZg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.57.1.tgz",
      "integrity": "sha512-ABca4ceT4N+Tv/GtotnWAeXZUZuM/9AQyCyKYyKnpk4yoA7QIAuBt6Hkgpw8kActYlew2mvckXkvx0FfoInnLg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.57.1.tgz",
      "integrity": "sha512-HFps0JeGtuOR2convgRRkHCekD7j+gdAuXM+/i6kGzQtFhlCtQkpwtNzkNj6QhCDp7DRJ7+qC/1Vg2jt5iSOFw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-openbsd-x64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openbsd-x64/-/rollup-openbsd-x64-4.57.1.tgz",
      "integrity": "sha512-H+hXEv9gdVQuDTgnqD+SQffoWoc0Of59AStSzTEj/feWTBAnSfSD3+Dql1ZruJQxmykT/JVY0dE8Ka7z0DH1hw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ]
    },
    "node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.57.1.tgz",
      "integrity": "sha512-4wYoDpNg6o/oPximyc/NG+mYUejZrCU2q+2w6YZqrAs2UcNUChIZXjtafAiiZSUc7On8v5NyNj34Kzj/Ltk6dQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.57.1.tgz",
      "integrity": "sha512-O54mtsV/6LW3P8qdTcamQmuC990HDfR71lo44oZMZlXU4tzLrbvTii87Ni9opq60ds0YzuAlEr/GNwuNluZyMQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.57.1.tgz",
      "integrity": "sha512-P3dLS+IerxCT/7D2q2FYcRdWRl22dNbrbBEtxdWhXrfIMPP9lQhb5h4Du04mdl5Woq05jVCDPCMF7Ub0NAjIew==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.57.1.tgz",
      "integrity": "sha512-VMBH2eOOaKGtIJYleXsi2B8CPVADrh+TyNxJ4mWPnKfLB/DBUmzW+5m1xUrcwWoMfSLagIRpjUFeW5CO5hyciQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.57.1.tgz",
      "integrity": "sha512-mxRFDdHIWRxg3UfIIAwCm6NzvxG0jDX/wBN6KsQFTvKFqqg9vTrWUE68qEjHt19A5wwx5X5aUi2zuZT7YR0jrA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@tanstack/query-core": {
      "version": "5.90.20",
      "resolved": "https://registry.npmjs.org/@tanstack/query-core/-/query-core-5.90.20.tgz",
      "integrity": "sha512-OMD2HLpNouXEfZJWcKeVKUgQ5n+n3A2JFmBaScpNDUqSrQSjiveC7dKMe53uJUg1nDG16ttFPz2xfilz6i2uVg==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      }
    },
    "node_modules/@tanstack/react-query": {
      "version": "5.90.20",
      "resolved": "https://registry.npmjs.org/@tanstack/react-query/-/react-query-5.90.20.tgz",
      "integrity": "sha512-vXBxa+qeyveVO7OA0jX1z+DeyCA4JKnThKv411jd5SORpBKgkcVnYKCiBgECvADvniBX7tobwBmg01qq9JmMJw==",
      "license": "MIT",
      "dependencies": {
        "@tanstack/query-core": "5.90.20"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      },
      "peerDependencies": {
        "react": "^18 || ^19"
      }
    },
    "node_modules/@testing-library/dom": {
      "version": "10.4.1",
      "resolved": "https://registry.npmjs.org/@testing-library/dom/-/dom-10.4.1.tgz",
      "integrity": "sha512-o4PXJQidqJl82ckFaXUeoAW+XysPLauYI43Abki5hABd853iMhitooc6znOnczgbTYmEP6U6/y1ZyKAIsvMKGg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.10.4",
        "@babel/runtime": "^7.12.5",
        "@types/aria-query": "^5.0.1",
        "aria-query": "5.3.0",
        "dom-accessibility-api": "^0.5.9",
        "lz-string": "^1.5.0",
        "picocolors": "1.1.1",
        "pretty-format": "^27.0.2"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@testing-library/jest-dom": {
      "version": "6.9.1",
      "resolved": "https://registry.npmjs.org/@testing-library/jest-dom/-/jest-dom-6.9.1.tgz",
      "integrity": "sha512-zIcONa+hVtVSSep9UT3jZ5rizo2BsxgyDYU7WFD5eICBE7no3881HGeb/QkGfsJs6JTkY1aQhT7rIPC7e+0nnA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@adobe/css-tools": "^4.4.0",
        "aria-query": "^5.0.0",
        "css.escape": "^1.5.1",
        "dom-accessibility-api": "^0.6.3",
        "picocolors": "^1.1.1",
        "redent": "^3.0.0"
      },
      "engines": {
        "node": ">=14",
        "npm": ">=6",
        "yarn": ">=1"
      }
    },
    "node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/dom-accessibility-api/-/dom-accessibility-api-0.6.3.tgz",
      "integrity": "sha512-7ZgogeTnjuHbo+ct10G9Ffp0mif17idi0IyWNVA/wcwcm7NPOD/WEHVP3n7n3MhXqxoIYm8d6MuZohYWIZ4T3w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@testing-library/react": {
      "version": "16.3.2",
      "resolved": "https://registry.npmjs.org/@testing-library/react/-/react-16.3.2.tgz",
      "integrity": "sha512-XU5/SytQM+ykqMnAnvB2umaJNIOsLF3PVv//1Ew4CTcpz0/BRyy/af40qqrt7SjKpDdT1saBMc42CUok5gaw+g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.12.5"
      },
      "engines": {
        "node": ">=18"
      },
      "peerDependencies": {
        "@testing-library/dom": "^10.0.0",
        "@types/react": "^18.0.0 || ^19.0.0",
        "@types/react-dom": "^18.0.0 || ^19.0.0",
        "react": "^18.0.0 || ^19.0.0",
        "react-dom": "^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@testing-library/user-event": {
      "version": "14.6.1",
      "resolved": "https://registry.npmjs.org/@testing-library/user-event/-/user-event-14.6.1.tgz",
      "integrity": "sha512-vq7fv0rnt+QTXgPxr5Hjc210p6YKq2kmdziLgnsZGgLJ9e6VAShx1pACLuRjd/AS/sr7phAR58OIIpf0LlmQNw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      },
      "peerDependencies": {
        "@testing-library/dom": ">=7.21.4"
      }
    },
    "node_modules/@types/aria-query": {
      "version": "5.0.4",
      "resolved": "https://registry.npmjs.org/@types/aria-query/-/aria-query-5.0.4.tgz",
      "integrity": "sha512-rfT93uj5s0PRL7EzccGMs3brplhcrghnDoV26NqKhCAS1hVo+WdNsPvE/yb6ilfr5hi2MEk6d5EWJTKdxg8jVw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.5",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.28.0.tgz",
      "integrity": "sha512-8PvcXf70gTDZBgt9ptxJ8elBeBjcLOAcOtoO/mPJjtji1+CdGbHgm77om1GrsPxsiE+uXIpNSK64UYaIwQXd4Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.2"
      }
    },
    "node_modules/@types/chai": {
      "version": "5.2.3",
      "resolved": "https://registry.npmjs.org/@types/chai/-/chai-5.2.3.tgz",
      "integrity": "sha512-Mw558oeA9fFbv65/y4mHtXDs9bPnFMZAL/jxdPFUpOHHIXX91mcgEHbS5Lahr+pwZFR8A7GQleRWeI6cGFC2UA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/deep-eql": "*",
        "assertion-error": "^2.0.1"
      }
    },
    "node_modules/@types/deep-eql": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/@types/deep-eql/-/deep-eql-4.0.2.tgz",
      "integrity": "sha512-c9h9dVVMigMPc4bwTvC5dxqtqJZwQPePsWjPlpSOnojbor6pGqdk541lfA7AqFQr5pB1BRdq0juY9db81BwyFw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/@types/react": {
      "version": "19.2.11",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.2.11.tgz",
      "integrity": "sha512-tORuanb01iEzWvMGVGv2ZDhYZVeRMrw453DCSAIn/5yvcSVnMoUMTyf33nQJLahYEnv9xqrTNbgz4qY5EfSh0g==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "csstype": "^3.2.2"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.2.3",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.2.3.tgz",
      "integrity": "sha512-jp2L/eY6fn+KgVVQAOqYItbF0VY/YApe5Mz2F0aykSO8gx31bYCZyvSeYxCHKvzHG5eZjc+zyaS5BrBWya2+kQ==",
      "devOptional": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.2.0"
      }
    },
    "node_modules/@typescript-eslint/parser": {
      "version": "8.55.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-8.55.0.tgz",
      "integrity": "sha512-4z2nCSBfVIMnbuu8uinj+f0o4qOeggYJLbjpPHka3KH1om7e+H9yLKTYgksTaHcGco+NClhhY2vyO3HsMH1RGw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/scope-manager": "8.55.0",
        "@typescript-eslint/types": "8.55.0",
        "@typescript-eslint/typescript-estree": "8.55.0",
        "@typescript-eslint/visitor-keys": "8.55.0",
        "debug": "^4.4.3"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/project-service": {
      "version": "8.55.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/project-service/-/project-service-8.55.0.tgz",
      "integrity": "sha512-zRcVVPFUYWa3kNnjaZGXSu3xkKV1zXy8M4nO/pElzQhFweb7PPtluDLQtKArEOGmjXoRjnUZ29NjOiF0eCDkcQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/tsconfig-utils": "^8.55.0",
        "@typescript-eslint/types": "^8.55.0",
        "debug": "^4.4.3"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/scope-manager": {
      "version": "8.55.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-8.55.0.tgz",
      "integrity": "sha512-fVu5Omrd3jeqeQLiB9f1YsuK/iHFOwb04bCtY4BSCLgjNbOD33ZdV6KyEqplHr+IlpgT0QTZ/iJ+wT7hvTx49Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.55.0",
        "@typescript-eslint/visitor-keys": "8.55.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/tsconfig-utils": {
      "version": "8.55.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/tsconfig-utils/-/tsconfig-utils-8.55.0.tgz",
      "integrity": "sha512-1R9cXqY7RQd7WuqSN47PK9EDpgFUK3VqdmbYrvWJZYDd0cavROGn+74ktWBlmJ13NXUQKlZ/iAEQHI/V0kKe0Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/types": {
      "version": "8.55.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-8.55.0.tgz",
      "integrity": "sha512-ujT0Je8GI5BJWi+/mMoR0wxwVEQaxM+pi30xuMiJETlX80OPovb2p9E8ss87gnSVtYXtJoU9U1Cowcr6w2FE0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree": {
      "version": "8.55.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-8.55.0.tgz",
      "integrity": "sha512-EwrH67bSWdx/3aRQhCoxDaHM+CrZjotc2UCCpEDVqfCE+7OjKAGWNY2HsCSTEVvWH2clYQK8pdeLp42EVs+xQw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/project-service": "8.55.0",
        "@typescript-eslint/tsconfig-utils": "8.55.0",
        "@typescript-eslint/types": "8.55.0",
        "@typescript-eslint/visitor-keys": "8.55.0",
        "debug": "^4.4.3",
        "minimatch": "^9.0.5",
        "semver": "^7.7.3",
        "tinyglobby": "^0.2.15",
        "ts-api-utils": "^2.4.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/semver": {
      "version": "7.7.4",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.4.tgz",
      "integrity": "sha512-vFKC2IEtQnVhpT78h1Yp8wzwrf8CM+MzKMHGJZfBtzhZNycRFnXsHk6E5TxIkkMsgNS7mdX3AGB7x2QM2di4lA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@typescript-eslint/visitor-keys": {
      "version": "8.55.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-8.55.0.tgz",
      "integrity": "sha512-AxNRwEie8Nn4eFS1FzDMJWIISMGoXMb037sgCBJ3UR6o0fQTzr2tqN9WT+DkWJPhIdQCfV7T6D387566VtnCJA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.55.0",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@vitejs/plugin-react": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-4.7.0.tgz",
      "integrity": "sha512-gUu9hwfWvvEDBBmgtAowQCojwZmJ5mcLn3aufeCsitijs3+f2NsrPtlAWIR6OPiqljl96GVCUbLe0HyqIpVaoA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.28.0",
        "@babel/plugin-transform-react-jsx-self": "^7.27.1",
        "@babel/plugin-transform-react-jsx-source": "^7.27.1",
        "@rolldown/pluginutils": "1.0.0-beta.27",
        "@types/babel__core": "^7.20.5",
        "react-refresh": "^0.17.0"
      },
      "engines": {
        "node": "^14.18.0 || >=16.0.0"
      },
      "peerDependencies": {
        "vite": "^4.2.0 || ^5.0.0 || ^6.0.0 || ^7.0.0"
      }
    },
    "node_modules/@vitest/coverage-istanbul": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/coverage-istanbul/-/coverage-istanbul-3.2.4.tgz",
      "integrity": "sha512-IDlpuFJiWU9rhcKLkpzj8mFu/lpe64gVgnV15ZOrYx1iFzxxrxCzbExiUEKtwwXRvEiEMUS6iZeYgnMxgbqbxQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@istanbuljs/schema": "^0.1.3",
        "debug": "^4.4.1",
        "istanbul-lib-coverage": "^3.2.2",
        "istanbul-lib-instrument": "^6.0.3",
        "istanbul-lib-report": "^3.0.1",
        "istanbul-lib-source-maps": "^5.0.6",
        "istanbul-reports": "^3.1.7",
        "magicast": "^0.3.5",
        "test-exclude": "^7.0.1",
        "tinyrainbow": "^2.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "vitest": "3.2.4"
      }
    },
    "node_modules/@vitest/coverage-v8": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-3.2.4.tgz",
      "integrity": "sha512-EyF9SXU6kS5Ku/U82E259WSnvg6c8KTjppUncuNdm5QHpe17mwREHnjDzozC8x9MZ0xfBUFSaLkRv4TMA75ALQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@ampproject/remapping": "^2.3.0",
        "@bcoe/v8-coverage": "^1.0.2",
        "ast-v8-to-istanbul": "^0.3.3",
        "debug": "^4.4.1",
        "istanbul-lib-coverage": "^3.2.2",
        "istanbul-lib-report": "^3.0.1",
        "istanbul-lib-source-maps": "^5.0.6",
        "istanbul-reports": "^3.1.7",
        "magic-string": "^0.30.17",
        "magicast": "^0.3.5",
        "std-env": "^3.9.0",
        "test-exclude": "^7.0.1",
        "tinyrainbow": "^2.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "@vitest/browser": "3.2.4",
        "vitest": "3.2.4"
      },
      "peerDependenciesMeta": {
        "@vitest/browser": {
          "optional": true
        }
      }
    },
    "node_modules/@vitest/coverage-v8/node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/@vitest/expect": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-3.2.4.tgz",
      "integrity": "sha512-Io0yyORnB6sikFlt8QW5K7slY4OjqNX9jmJQ02QDda8lyM6B5oNgVWoSoKPac8/kgnCUzuHQKrSLtu/uOqqrig==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/chai": "^5.2.2",
        "@vitest/spy": "3.2.4",
        "@vitest/utils": "3.2.4",
        "chai": "^5.2.0",
        "tinyrainbow": "^2.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/mocker": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/mocker/-/mocker-3.2.4.tgz",
      "integrity": "sha512-46ryTE9RZO/rfDd7pEqFl7etuyzekzEhUbTW3BvmeO/BcCMEgq59BKhek3dXDWgAj4oMK6OZi+vRr1wPW6qjEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/spy": "3.2.4",
        "estree-walker": "^3.0.3",
        "magic-string": "^0.30.17"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "msw": "^2.4.9",
        "vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0"
      },
      "peerDependenciesMeta": {
        "msw": {
          "optional": true
        },
        "vite": {
          "optional": true
        }
      }
    },
    "node_modules/@vitest/mocker/node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/@vitest/pretty-format": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/pretty-format/-/pretty-format-3.2.4.tgz",
      "integrity": "sha512-IVNZik8IVRJRTr9fxlitMKeJeXFFFN0JaB9PHPGQ8NKQbGpfjlTx9zO4RefN8gp7eqjNy8nyK3NZmBzOPeIxtA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tinyrainbow": "^2.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/runner": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/runner/-/runner-3.2.4.tgz",
      "integrity": "sha512-oukfKT9Mk41LreEW09vt45f8wx7DordoWUZMYdY/cyAk7w5TWkTRCNZYF7sX7n2wB7jyGAl74OxgwhPgKaqDMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/utils": "3.2.4",
        "pathe": "^2.0.3",
        "strip-literal": "^3.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/snapshot": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/snapshot/-/snapshot-3.2.4.tgz",
      "integrity": "sha512-dEYtS7qQP2CjU27QBC5oUOxLE/v5eLkGqPE0ZKEIDGMs4vKWe7IjgLOeauHsR0D5YuuycGRO5oSRXnwnmA78fQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/pretty-format": "3.2.4",
        "magic-string": "^0.30.17",
        "pathe": "^2.0.3"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/snapshot/node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/@vitest/spy": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/spy/-/spy-3.2.4.tgz",
      "integrity": "sha512-vAfasCOe6AIK70iP5UD11Ac4siNUNJ9i/9PZ3NKx07sG6sUxeag1LWdNrMWeKKYBLlzuK+Gn65Yd5nyL6ds+nw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tinyspy": "^4.0.3"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/utils": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/utils/-/utils-3.2.4.tgz",
      "integrity": "sha512-fB2V0JFrQSMsCo9HiSq3Ezpdv4iYaXRG1Sx8edX3MwxfyNn83mKiGzOcH+Fkxt4MHxr3y42fQi1oeAInqgX2QA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/pretty-format": "3.2.4",
        "loupe": "^3.1.4",
        "tinyrainbow": "^2.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/acorn": {
      "version": "8.15.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/agent-base": {
      "version": "7.1.4",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-7.1.4.tgz",
      "integrity": "sha512-MnA+YT8fwfJPgBx3m60MNqakm30XOkyIoH1y6huTQvC0PwZG7ki8NacLBcrPbNoo8vEZy7Jpuk7+jMO+CUovTQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ansi-regex": {
      "version": "6.2.2",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/ansi-styles": {
      "version": "6.2.3",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/any-promise": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/any-promise/-/any-promise-1.3.0.tgz",
      "integrity": "sha512-7UvmKalWRt1wgjL1RrGxoSJW/0QZFIegpeGvZG9kjp8vrRu55XTHbwnqq2GpXm9uLbcuhxm3IqX9OB4MZR1b2A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/arg": {
      "version": "5.0.2",
      "resolved": "https://registry.npmjs.org/arg/-/arg-5.0.2.tgz",
      "integrity": "sha512-PYjyFOLKQ9y57JvQ6QLo8dAgNqswh8M1RMJYdQduT6xbWSgK36P/Z/v+p888pM69jMMfS8Xd8F6I1kQ/I9HUGg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true,
      "license": "Python-2.0",
      "peer": true
    },
    "node_modules/aria-hidden": {
      "version": "1.2.6",
      "resolved": "https://registry.npmjs.org/aria-hidden/-/aria-hidden-1.2.6.tgz",
      "integrity": "sha512-ik3ZgC9dY/lYVVM++OISsaYDeg1tb0VtP5uL3ouh1koGOaUMDPpbFIei4JkFimWUFPn90sbMNMXQAIVOlnYKJA==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/aria-query": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/aria-query/-/aria-query-5.3.0.tgz",
      "integrity": "sha512-b0P0sZPKtyu8HkeRAfCq0IfURZK+SuwMjY1UXGBU27wpAiTwQAIlq56IbIO+ytk/JjS1fMR14ee5WBBfKi5J6A==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "dequal": "^2.0.3"
      }
    },
    "node_modules/assertion-error": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-2.0.1.tgz",
      "integrity": "sha512-Izi8RQcffqCeNVgFigKli1ssklIbpHnCYc6AknXGYoB6grJqyeby7jv12JUQgmTAnIDnbck1uxksT4dzN3PWBA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/ast-v8-to-istanbul": {
      "version": "0.3.11",
      "resolved": "https://registry.npmjs.org/ast-v8-to-istanbul/-/ast-v8-to-istanbul-0.3.11.tgz",
      "integrity": "sha512-Qya9fkoofMjCBNVdWINMjB5KZvkYfaO9/anwkWnjxibpWUxo5iHl2sOdP7/uAqaRuUYuoo8rDwnbaaKVFxoUvw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/trace-mapping": "^0.3.31",
        "estree-walker": "^3.0.3",
        "js-tokens": "^10.0.0"
      }
    },
    "node_modules/ast-v8-to-istanbul/node_modules/js-tokens": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-10.0.0.tgz",
      "integrity": "sha512-lM/UBzQmfJRo9ABXbPWemivdCW8V2G8FHaHdypQaIy523snUjog0W71ayWXTjiR+ixeMyVHN2XcpnTd/liPg/Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/autoprefixer": {
      "version": "10.4.24",
      "resolved": "https://registry.npmjs.org/autoprefixer/-/autoprefixer-10.4.24.tgz",
      "integrity": "sha512-uHZg7N9ULTVbutaIsDRoUkoS8/h3bdsmVJYZ5l3wv8Cp/6UIIoRDm90hZ+BwxUj/hGBEzLxdHNSKuFpn8WOyZw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/autoprefixer"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "browserslist": "^4.28.1",
        "caniuse-lite": "^1.0.30001766",
        "fraction.js": "^5.3.4",
        "picocolors": "^1.1.1",
        "postcss-value-parser": "^4.2.0"
      },
      "bin": {
        "autoprefixer": "bin/autoprefixer"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      },
      "peerDependencies": {
        "postcss": "^8.1.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/baseline-browser-mapping": {
      "version": "2.9.19",
      "resolved": "https://registry.npmjs.org/baseline-browser-mapping/-/baseline-browser-mapping-2.9.19.tgz",
      "integrity": "sha512-ipDqC8FrAl/76p2SSWKSI+H9tFwm7vYqXQrItCuiVPt26Km0jS+NzSsBWAaBusvSbQcfJG+JitdMm+wZAgTYqg==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "baseline-browser-mapping": "dist/cli.js"
      }
    },
    "node_modules/bidi-js": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/bidi-js/-/bidi-js-1.0.3.tgz",
      "integrity": "sha512-RKshQI1R3YQ+n9YJz2QQ147P66ELpa1FQEg20Dk8oW9t2KgLbpDLLp9aGZ7y8WHSshDknG0bknqGw5/tyCs5tw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "require-from-string": "^2.0.2"
      }
    },
    "node_modules/binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/brace-expansion": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/browserslist": {
      "version": "4.28.1",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.28.1.tgz",
      "integrity": "sha512-ZC5Bd0LgJXgwGqUknZY/vkUQ04r8NXnJZ3yYi4vDmSiZmC/pdSN0NbNRPxZpbtO4uAfDUAFffO8IZoM3Gj8IkA==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "baseline-browser-mapping": "^2.9.0",
        "caniuse-lite": "^1.0.30001759",
        "electron-to-chromium": "^1.5.263",
        "node-releases": "^2.0.27",
        "update-browserslist-db": "^1.2.0"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/builtin-modules": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/builtin-modules/-/builtin-modules-3.3.0.tgz",
      "integrity": "sha512-zhaCDicdLuWN5UbN5IMnFqNMhNfo919sH85y2/ea+5Yg9TsTkeZxpL+JLbp6cgYFS4sRLp3YV4S6yDuqVWHYOw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/cac": {
      "version": "6.7.14",
      "resolved": "https://registry.npmjs.org/cac/-/cac-6.7.14.tgz",
      "integrity": "sha512-b6Ilus+c3RrdDk+JhLKUAQfzzgLEPy6wcXqS7f/xe1EETvsDP6GORG7SFuOs6cID5YkqchW/LXZbX5bc8j7ZcQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/camelcase-css": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/camelcase-css/-/camelcase-css-2.0.1.tgz",
      "integrity": "sha512-QOSvevhslijgYwRx6Rv7zKdMF8lbRmx+uQGx2+vDc+KI/eBnsy9kit5aj23AgGu3pa4t9AgwbnXWqS+iOY+2aA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001767",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001767.tgz",
      "integrity": "sha512-34+zUAMhSH+r+9eKmYG+k2Rpt8XttfE4yXAjoZvkAPs15xcYQhyBYdalJ65BzivAvGRMViEjy6oKr/S91loekQ==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chai": {
      "version": "5.3.3",
      "resolved": "https://registry.npmjs.org/chai/-/chai-5.3.3.tgz",
      "integrity": "sha512-4zNhdJD/iOjSH0A05ea+Ke6MU5mmpQcbQsSOkgdaUMJ9zTlDTD/GYlwohmIE2u0gaxHYiVHEn1Fw9mZ/ktJWgw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "assertion-error": "^2.0.1",
        "check-error": "^2.1.1",
        "deep-eql": "^5.0.1",
        "loupe": "^3.1.0",
        "pathval": "^2.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/chalk/node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/check-error": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/check-error/-/check-error-2.1.3.tgz",
      "integrity": "sha512-PAJdDJusoxnwm1VwW07VWwUN1sl7smmC3OKggvndJFadxxDRyFJBX/ggnu/KE4kQAB7a3Dp8f/YXC1FlUprWmA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 16"
      }
    },
    "node_modules/chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/chokidar/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/class-variance-authority": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/class-variance-authority/-/class-variance-authority-0.7.1.tgz",
      "integrity": "sha512-Ka+9Trutv7G8M6WT6SeiRWz792K5qEqIGEGzXKhAE6xOWAY6pPH8U+9IY3oCMv6kqTmLsv7Xh/2w2RigkePMsg==",
      "license": "Apache-2.0",
      "dependencies": {
        "clsx": "^2.1.1"
      },
      "funding": {
        "url": "https://polar.sh/cva"
      }
    },
    "node_modules/clsx": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz",
      "integrity": "sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/commander": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/commander/-/commander-4.1.1.tgz",
      "integrity": "sha512-NOKm8xhkzAjzFx8B2v5OAHT+u5pRQc2UCa2Vq9jYL/31o2wi9mxBA7LIFs3sV5VSC49z6pEhfbMULvShKj26WA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/css-tree": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/css-tree/-/css-tree-3.1.0.tgz",
      "integrity": "sha512-0eW44TGN5SQXU1mWSkKwFstI/22X2bG1nYzZTYMAWjylYURhse752YgbE4Cx46AC+bAvI+/dYTPRk1LqSUnu6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "mdn-data": "2.12.2",
        "source-map-js": "^1.0.1"
      },
      "engines": {
        "node": "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0"
      }
    },
    "node_modules/css.escape": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/css.escape/-/css.escape-1.5.1.tgz",
      "integrity": "sha512-YUifsXXuknHlUsmlgyY0PKzgPOr7/FjCePfHNt0jxm83wHZi44VDMQ7/fGNkjY3/jV1MC+1CmZbaHzugyeRtpg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cssesc": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/cssesc/-/cssesc-3.0.0.tgz",
      "integrity": "sha512-/Tb/JcjK111nNScGob5MNtsntNM1aCNUDipB/TkwZFhyDrrE47SOx/18wF2bbjgc3ZzCSKW1T5nt5EbFoAz/Vg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "cssesc": "bin/cssesc"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/cssstyle": {
      "version": "5.3.7",
      "resolved": "https://registry.npmjs.org/cssstyle/-/cssstyle-5.3.7.tgz",
      "integrity": "sha512-7D2EPVltRrsTkhpQmksIu+LxeWAIEk6wRDMJ1qljlv+CKHJM+cJLlfhWIzNA44eAsHXSNe3+vO6DW1yCYx8SuQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@asamuzakjp/css-color": "^4.1.1",
        "@csstools/css-syntax-patches-for-csstree": "^1.0.21",
        "css-tree": "^3.1.0",
        "lru-cache": "^11.2.4"
      },
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/cssstyle/node_modules/lru-cache": {
      "version": "11.2.5",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-11.2.5.tgz",
      "integrity": "sha512-vFrFJkWtJvJnD5hg+hJvVE8Lh/TcMzKnTgCWmtBipwI5yLX/iX+5UB2tfuyODF5E7k9xEzMdYgGqaSb1c0c5Yw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "engines": {
        "node": "20 || >=22"
      }
    },
    "node_modules/csstype": {
      "version": "3.2.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.2.3.tgz",
      "integrity": "sha512-z1HGKcYy2xA8AGQfwrn0PAy+PB7X/GSj3UVJW9qKyn43xWa+gl5nXmU4qqLMRzWVLFC8KusUX8T/0kCiOYpAIQ==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/data-urls": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/data-urls/-/data-urls-7.0.0.tgz",
      "integrity": "sha512-23XHcCF+coGYevirZceTVD7NdJOqVn+49IHyxgszm+JIiHLoB2TkmPtsYkNWT1pvRSGkc35L6NHs0yHkN2SumA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "whatwg-mimetype": "^5.0.0",
        "whatwg-url": "^16.0.0"
      },
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=24.0.0"
      }
    },
    "node_modules/data-urls/node_modules/tr46": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-6.0.0.tgz",
      "integrity": "sha512-bLVMLPtstlZ4iMQHpFHTR7GAGj2jxi8Dg0s2h2MafAE4uSWF98FC/3MomU51iQAMf8/qDUbKWf5GxuvvVcXEhw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "punycode": "^2.3.1"
      },
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/data-urls/node_modules/webidl-conversions": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-8.0.1.tgz",
      "integrity": "sha512-BMhLD/Sw+GbJC21C/UgyaZX41nPt8bUTg+jWyDeg7e7YN4xOM05YPSIXceACnXVtqyEw/LMClUQMtMZ+PGGpqQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/data-urls/node_modules/whatwg-url": {
      "version": "16.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-16.0.0.tgz",
      "integrity": "sha512-9CcxtEKsf53UFwkSUZjG+9vydAsFO4lFHBpJUtjBcoJOCJpKnSJNwCw813zrYJHpCJ7sgfbtOe0V5Ku7Pa1XMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@exodus/bytes": "^1.11.0",
        "tr46": "^6.0.0",
        "webidl-conversions": "^8.0.1"
      },
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=24.0.0"
      }
    },
    "node_modules/date-fns": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/date-fns/-/date-fns-4.1.0.tgz",
      "integrity": "sha512-Ukq0owbQXxa/U3EGtsdVBkR1w7KOQ5gIBqdH2hkvknzZPYvBxb/aa6E8L7tmjFtkwZBu3UXBbjIgPo/Ez4xaNg==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/kossnocorp"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/decimal.js": {
      "version": "10.6.0",
      "resolved": "https://registry.npmjs.org/decimal.js/-/decimal.js-10.6.0.tgz",
      "integrity": "sha512-YpgQiITW3JXGntzdUmyUR1V812Hn8T1YVXhCu+wO3OpS4eU9l4YdD3qjyiKdV6mvV29zapkMeD390UVEf2lkUg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/deep-eql": {
      "version": "5.0.2",
      "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-5.0.2.tgz",
      "integrity": "sha512-h5k/5U50IJJFpzfL6nO9jaaumfjO/f2NjK/oYB2Djzm4p9L+3T9qWpZqZ2hAbLPuuYq9wrU08WQyBTL5GbPk5Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/dequal": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/dequal/-/dequal-2.0.3.tgz",
      "integrity": "sha512-0je+qPKHEMohvfRTCEo3CrPG6cAzAYgmzKyxRiYSSDkS6eGJdyVJm7WaYA5ECaAD9wLB2T4EEeymA5aFVcYXCA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/detect-node-es": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/detect-node-es/-/detect-node-es-1.1.0.tgz",
      "integrity": "sha512-ypdmJU/TbBby2Dxibuv7ZLW3Bs1QEmM7nHjEANfohJLvE0XVujisn1qPJcZxg+qDucsr+bP6fLD1rPS3AhJ7EQ==",
      "license": "MIT"
    },
    "node_modules/didyoumean": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/didyoumean/-/didyoumean-1.2.2.tgz",
      "integrity": "sha512-gxtyfqMg7GKyhQmb056K7M3xszy/myH8w+B4RT+QXBQsvAOdc3XymqDDPHx1BgPgsdAA5SIifona89YtRATDzw==",
      "dev": true,
      "license": "Apache-2.0"
    },
    "node_modules/dlv": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/dlv/-/dlv-1.1.3.tgz",
      "integrity": "sha512-+HlytyjlPKnIG8XuRG8WvmBP8xs8P71y+SKKS6ZXWoEgLuePxtDoUEiH7WkdePWrQ5JBpE6aoVqfZfJUQkjXwA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/dom-accessibility-api": {
      "version": "0.5.16",
      "resolved": "https://registry.npmjs.org/dom-accessibility-api/-/dom-accessibility-api-0.5.16.tgz",
      "integrity": "sha512-X7BJ2yElsnOJ30pZF4uIIDfBEVgF4XEBxL9Bxhy6dnrm5hkzqmsWHGTiHqRiITNhMyFLyAiWndIJP7Z1NTteDg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/eastasianwidth": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.286",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.286.tgz",
      "integrity": "sha512-9tfDXhJ4RKFNerfjdCcZfufu49vg620741MNs26a9+bhLThdB+plgMeou98CAaHu/WATj2iHOOHTp1hWtABj2A==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/emoji-regex": {
      "version": "9.2.2",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/entities": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/entities/-/entities-6.0.1.tgz",
      "integrity": "sha512-aN97NXWF6AWBTahfVOIrB/NShkzi5H7F9r1s9mD3cDj4Ko5f2qhhVoYMibXF7GlLveb/D2ioWay8lxI97Ven3g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.12"
      },
      "funding": {
        "url": "https://github.com/fb55/entities?sponsor=1"
      }
    },
    "node_modules/es-module-lexer": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-1.7.0.tgz",
      "integrity": "sha512-jEQoCwk8hyb2AZziIOLhDqpm5+2ww5uIE6lkO/6jcOCusfk6LhMHpXXfBLXTZ7Ydyt0j4VoUQv6uGNYbdW+kBA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/esbuild": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.25.12.tgz",
      "integrity": "sha512-bbPBYYrtZbkt6Os6FiTLCTFxvq4tt3JKall1vRwshA3fdVztsLAatFaZobhkBC8/BrPetoa0oksYoKXoG4ryJg==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.25.12",
        "@esbuild/android-arm": "0.25.12",
        "@esbuild/android-arm64": "0.25.12",
        "@esbuild/android-x64": "0.25.12",
        "@esbuild/darwin-arm64": "0.25.12",
        "@esbuild/darwin-x64": "0.25.12",
        "@esbuild/freebsd-arm64": "0.25.12",
        "@esbuild/freebsd-x64": "0.25.12",
        "@esbuild/linux-arm": "0.25.12",
        "@esbuild/linux-arm64": "0.25.12",
        "@esbuild/linux-ia32": "0.25.12",
        "@esbuild/linux-loong64": "0.25.12",
        "@esbuild/linux-mips64el": "0.25.12",
        "@esbuild/linux-ppc64": "0.25.12",
        "@esbuild/linux-riscv64": "0.25.12",
        "@esbuild/linux-s390x": "0.25.12",
        "@esbuild/linux-x64": "0.25.12",
        "@esbuild/netbsd-arm64": "0.25.12",
        "@esbuild/netbsd-x64": "0.25.12",
        "@esbuild/openbsd-arm64": "0.25.12",
        "@esbuild/openbsd-x64": "0.25.12",
        "@esbuild/openharmony-arm64": "0.25.12",
        "@esbuild/sunos-x64": "0.25.12",
        "@esbuild/win32-arm64": "0.25.12",
        "@esbuild/win32-ia32": "0.25.12",
        "@esbuild/win32-x64": "0.25.12"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint": {
      "version": "9.39.2",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-9.39.2.tgz",
      "integrity": "sha512-LEyamqS7W5HB3ujJyvi0HQK/dtVINZvd5mAAp9eT5S/ujByGjiZLCzPcHVzuXbpJDJF/cxwHlfceVUDZ2lnSTw==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.8.0",
        "@eslint-community/regexpp": "^4.12.1",
        "@eslint/config-array": "^0.21.1",
        "@eslint/config-helpers": "^0.4.2",
        "@eslint/core": "^0.17.0",
        "@eslint/eslintrc": "^3.3.1",
        "@eslint/js": "9.39.2",
        "@eslint/plugin-kit": "^0.4.1",
        "@humanfs/node": "^0.16.6",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@humanwhocodes/retry": "^0.4.2",
        "@types/estree": "^1.0.6",
        "ajv": "^6.12.4",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.6",
        "debug": "^4.3.2",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^8.4.0",
        "eslint-visitor-keys": "^4.2.1",
        "espree": "^10.4.0",
        "esquery": "^1.5.0",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^8.0.0",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        "ignore": "^5.2.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.1.2",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.3"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      },
      "peerDependencies": {
        "jiti": "*"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-plugin-sonarjs": {
      "version": "3.0.7",
      "resolved": "https://registry.npmjs.org/eslint-plugin-sonarjs/-/eslint-plugin-sonarjs-3.0.7.tgz",
      "integrity": "sha512-62jB20krIPvcwBLAyG3VVKa2ce2j2lL1yCb8Y0ylMRR/dLvCCTiQx8gQbXb+G81k1alPZ2/I3muZinqWQdBbzw==",
      "dev": true,
      "license": "LGPL-3.0-only",
      "dependencies": {
        "@eslint-community/regexpp": "4.12.2",
        "builtin-modules": "3.3.0",
        "bytes": "3.1.2",
        "functional-red-black-tree": "1.0.1",
        "jsx-ast-utils-x": "0.1.0",
        "lodash.merge": "4.6.2",
        "minimatch": "10.1.2",
        "scslre": "0.3.0",
        "semver": "7.7.4",
        "typescript": ">=5"
      },
      "peerDependencies": {
        "eslint": "^8.0.0 || ^9.0.0"
      }
    },
    "node_modules/eslint-plugin-sonarjs/node_modules/minimatch": {
      "version": "10.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-10.1.2.tgz",
      "integrity": "sha512-fu656aJ0n2kcXwsnwnv9g24tkU5uSmOlTjd6WyyaKm2Z+h1qmY6bAjrcaIxF/BslFqbZ8UBtbJi7KgQOZD2PTw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "@isaacs/brace-expansion": "^5.0.1"
      },
      "engines": {
        "node": "20 || >=22"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/eslint-plugin-sonarjs/node_modules/semver": {
      "version": "7.7.4",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.4.tgz",
      "integrity": "sha512-vFKC2IEtQnVhpT78h1Yp8wzwrf8CM+MzKMHGJZfBtzhZNycRFnXsHk6E5TxIkkMsgNS7mdX3AGB7x2QM2di4lA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/eslint-scope": {
      "version": "8.4.0",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-8.4.0.tgz",
      "integrity": "sha512-sNXOfKCn74rt8RICKMvJS7XKV/Xk9kA7DyJr8mJik3S7Cwgy3qlkkmyS2uQB3jiJg6VNdZd/pDBJu0nvG2NlTg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "peer": true,
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
      "integrity": "sha512-Uhdk5sfqcee/9H/rCOJikYz67o0a2Tw2hGRPOG2Y1R2dg7brRe1uG0yaNQDHu+TO/uQPF/5eCapvYSmHUjt7JQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint/node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/eslint/node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "peer": true,
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/espree": {
      "version": "10.4.0",
      "resolved": "https://registry.npmjs.org/espree/-/espree-10.4.0.tgz",
      "integrity": "sha512-j6PAQ2uUr79PZhBjP5C5fhl8e39FmRnOjsD5lGnWrFU8i2G776tBK7+nP8KuQUTTyAZUwfQqXAgrVH5MbH9CYQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "peer": true,
      "dependencies": {
        "acorn": "^8.15.0",
        "acorn-jsx": "^5.3.2",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/esquery": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.7.0.tgz",
      "integrity": "sha512-Ap6G0WQwcU/LHsvLwON1fAQX9Zp0A2Y6Y/cJBl9r/JbW90Zyg4/zbG6zzKa2OTALELarYHmKu0GhpM5EO+7T0g==",
      "dev": true,
      "license": "BSD-3-Clause",
      "peer": true,
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "license": "BSD-2-Clause",
      "peer": true,
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "peer": true,
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estree-walker": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/estree-walker/-/estree-walker-3.0.3.tgz",
      "integrity": "sha512-7RUKfXgSMMkzt6ZuXmqapOurLGPPfgj6l9uRZ7lRGolvk0y2yocc35LdcxKC5PQZdn2DMqioAQ2NoWcrTKmm6g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "^1.0.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "peer": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/expect-type": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/expect-type/-/expect-type-1.3.0.tgz",
      "integrity": "sha512-knvyeauYhqjOYvQ66MznSMs83wmHrCycNEN6Ao+2AeYEfxUIkuiVxdEa1qlGEPK+We3n0THiDciYSsCcgW/DoA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/fast-glob": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.3.tgz",
      "integrity": "sha512-7MptL8U0cqcFdzIzwOTHoilX9x5BrNqye7Z/LuC7kCMRio1EMSyqRK3BEAUD7sXRq4iT4AzTVuZdhgQ2TCvYLg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.2",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.8"
      },
      "engines": {
        "node": ">=8.6.0"
      }
    },
    "node_modules/fast-glob/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/fastq": {
      "version": "1.20.1",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.20.1.tgz",
      "integrity": "sha512-GGToxJ/w1x32s/D2EKND7kTil4n8OVk/9mycTc4VDza13lOvpUZTGX3mFSCtV9ksdGBVzvsyAVLM6mHFThxXxw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "reusify": "^1.0.4"
      }
    },
    "node_modules/file-entry-cache": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-8.0.0.tgz",
      "integrity": "sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "flat-cache": "^4.0.0"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/find-up": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "locate-path": "^6.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/flat-cache": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-4.0.1.tgz",
      "integrity": "sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "flatted": "^3.2.9",
        "keyv": "^4.5.4"
      },
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/flatted": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.3.tgz",
      "integrity": "sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==",
      "dev": true,
      "license": "ISC",
      "peer": true
    },
    "node_modules/foreground-child": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "cross-spawn": "^7.0.6",
        "signal-exit": "^4.0.1"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/fraction.js": {
      "version": "5.3.4",
      "resolved": "https://registry.npmjs.org/fraction.js/-/fraction.js-5.3.4.tgz",
      "integrity": "sha512-1X1NTtiJphryn/uLQz3whtY6jK3fTqoE3ohKs0tT+Ujr1W59oopxmoEh7Lu5p6vBaPbgoM0bzveAW4Qi5RyWDQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "*"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/rawify"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/functional-red-black-tree": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz",
      "integrity": "sha512-dsKNQNdj6xA3T+QlADDA7mOSlX0qiMINjn0cgr+eGHGsbSHzTabcIogz2+p/iqP1Xs6EP/sS2SbqH+brGTbq0g==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/get-nonce": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-nonce/-/get-nonce-1.0.1.tgz",
      "integrity": "sha512-FJhYRoDaiatfEkUK8HKlicmu/3SGFD51q3itKDGoSTysQJBnfOcxU5GxnhE1E6soB76MbT0MBtnKJuXyAx+96Q==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/glob": {
      "version": "10.5.0",
      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "foreground-child": "^3.1.0",
        "jackspeak": "^3.1.2",
        "minimatch": "^9.0.4",
        "minipass": "^7.1.2",
        "package-json-from-dist": "^1.0.0",
        "path-scurry": "^1.11.1"
      },
      "bin": {
        "glob": "dist/esm/bin.mjs"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/globals": {
      "version": "14.0.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-14.0.0.tgz",
      "integrity": "sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/html-encoding-sniffer": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/html-encoding-sniffer/-/html-encoding-sniffer-6.0.0.tgz",
      "integrity": "sha512-CV9TW3Y3f8/wT0BRFc1/KAVQ3TUHiXmaAb6VW9vtiMFf7SLoMd1PdAc4W3KFOFETBJUb90KatHqlsZMWV+R9Gg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@exodus/bytes": "^1.6.0"
      },
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=24.0.0"
      }
    },
    "node_modules/html-escaper": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/http-proxy-agent": {
      "version": "7.0.2",
      "resolved": "https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-7.0.2.tgz",
      "integrity": "sha512-T1gkAiYYDWYx3V5Bmyu7HcfcvL7mUrTWiM6yOfa3PIphViJ/gFPbvidQ+veqSOHci/PxBcDabeUNCzpOODJZig==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.0",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/https-proxy-agent": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-7.0.6.tgz",
      "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.2",
        "debug": "4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/ignore": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/indent-string": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/indent-string/-/indent-string-4.0.0.tgz",
      "integrity": "sha512-EdDDZu4A2OyIK7Lr/2zG+w5jmbuk1DVBnEwREQvBzspBJkCEbRa8GxU1lghYcaGJCnRWibjDXlq779X1/y5xwg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-potential-custom-element-name": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/is-potential-custom-element-name/-/is-potential-custom-element-name-1.0.1.tgz",
      "integrity": "sha512-bCYeRA2rVibKZd+s2625gGnGF/t7DSqDs4dP7CrLA1m7jKWz6pps0LpYLJN8Q64HtmPKJ1hrN3nzPNKFEKOUiQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/istanbul-lib-coverage": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/istanbul-lib-instrument": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/istanbul-lib-instrument/-/istanbul-lib-instrument-6.0.3.tgz",
      "integrity": "sha512-Vtgk7L/R2JHyyGW07spoFlB8/lpjiOLTjMdms6AFMraYt3BaJauod/NGrfnVG/y4Ix1JEuMRPDPEj2ua+zz1/Q==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@babel/core": "^7.23.9",
        "@babel/parser": "^7.23.9",
        "@istanbuljs/schema": "^0.1.3",
        "istanbul-lib-coverage": "^3.2.0",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-lib-instrument/node_modules/semver": {
      "version": "7.7.4",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.4.tgz",
      "integrity": "sha512-vFKC2IEtQnVhpT78h1Yp8wzwrf8CM+MzKMHGJZfBtzhZNycRFnXsHk6E5TxIkkMsgNS7mdX3AGB7x2QM2di4lA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-lib-report": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "istanbul-lib-coverage": "^3.0.0",
        "make-dir": "^4.0.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-lib-source-maps": {
      "version": "5.0.6",
      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@jridgewell/trace-mapping": "^0.3.23",
        "debug": "^4.1.1",
        "istanbul-lib-coverage": "^3.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-reports": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "html-escaper": "^2.0.0",
        "istanbul-lib-report": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/jackspeak": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "@isaacs/cliui": "^8.0.2"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      },
      "optionalDependencies": {
        "@pkgjs/parseargs": "^0.11.0"
      }
    },
    "node_modules/jiti": {
      "version": "1.21.7",
      "resolved": "https://registry.npmjs.org/jiti/-/jiti-1.21.7.tgz",
      "integrity": "sha512-/imKNG4EbWNrVjoNC/1H5/9GFy+tqjGBHCaSsN+P2RnPqjsLmv6UD3Ej+Kj8nBWaRAwyk7kK5ZUc+OEatnTR3A==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jiti": "bin/jiti.js"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/js-yaml": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
      "integrity": "sha512-qQKT4zQxXl8lLwBtHMWwaTcGfFOZviOJet3Oy/xmGk2gZH677CJM9EvtfdSkgWcATZhj/55JZ0rmy3myCT5lsA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/jsdom": {
      "version": "28.0.0",
      "resolved": "https://registry.npmjs.org/jsdom/-/jsdom-28.0.0.tgz",
      "integrity": "sha512-KDYJgZ6T2TKdU8yBfYueq5EPG/EylMsBvCaenWMJb2OXmjgczzwveRCoJ+Hgj1lXPDyasvrgneSn4GBuR1hYyA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@acemir/cssom": "^0.9.31",
        "@asamuzakjp/dom-selector": "^6.7.6",
        "@exodus/bytes": "^1.11.0",
        "cssstyle": "^5.3.7",
        "data-urls": "^7.0.0",
        "decimal.js": "^10.6.0",
        "html-encoding-sniffer": "^6.0.0",
        "http-proxy-agent": "^7.0.2",
        "https-proxy-agent": "^7.0.6",
        "is-potential-custom-element-name": "^1.0.1",
        "parse5": "^8.0.0",
        "saxes": "^6.0.0",
        "symbol-tree": "^3.2.4",
        "tough-cookie": "^6.0.0",
        "undici": "^7.20.0",
        "w3c-xmlserializer": "^5.0.0",
        "webidl-conversions": "^8.0.1",
        "whatwg-mimetype": "^5.0.0",
        "whatwg-url": "^16.0.0",
        "xml-name-validator": "^5.0.0"
      },
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=24.0.0"
      },
      "peerDependencies": {
        "canvas": "^3.0.0"
      },
      "peerDependenciesMeta": {
        "canvas": {
          "optional": true
        }
      }
    },
    "node_modules/jsdom/node_modules/tr46": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-6.0.0.tgz",
      "integrity": "sha512-bLVMLPtstlZ4iMQHpFHTR7GAGj2jxi8Dg0s2h2MafAE4uSWF98FC/3MomU51iQAMf8/qDUbKWf5GxuvvVcXEhw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "punycode": "^2.3.1"
      },
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/jsdom/node_modules/webidl-conversions": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-8.0.1.tgz",
      "integrity": "sha512-BMhLD/Sw+GbJC21C/UgyaZX41nPt8bUTg+jWyDeg7e7YN4xOM05YPSIXceACnXVtqyEw/LMClUQMtMZ+PGGpqQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/jsdom/node_modules/whatwg-url": {
      "version": "16.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-16.0.0.tgz",
      "integrity": "sha512-9CcxtEKsf53UFwkSUZjG+9vydAsFO4lFHBpJUtjBcoJOCJpKnSJNwCw813zrYJHpCJ7sgfbtOe0V5Ku7Pa1XMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@exodus/bytes": "^1.11.0",
        "tr46": "^6.0.0",
        "webidl-conversions": "^8.0.1"
      },
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=24.0.0"
      }
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json-buffer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
      "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/jsx-ast-utils-x": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/jsx-ast-utils-x/-/jsx-ast-utils-x-0.1.0.tgz",
      "integrity": "sha512-eQQBjBnsVtGacsG9uJNB8qOr3yA8rga4wAaGG1qRcBzSIvfhERLrWxMAM1hp5fcS6Abo8M4+bUBTekYR0qTPQw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/keyv": {
      "version": "4.5.4",
      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
      "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "json-buffer": "3.0.1"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/lilconfig": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/lilconfig/-/lilconfig-3.1.3.tgz",
      "integrity": "sha512-/vlFKAoH5Cgt3Ie+JLhRbwOsCQePABiU3tJ1egGvyQ+33R/vcwM2Zl2QR/LzjsBeItPt3oSVXapn+m4nQDvpzw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/antonk52"
      }
    },
    "node_modules/lines-and-columns": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
      "integrity": "sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/locate-path": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "p-locate": "^5.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/loupe": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/loupe/-/loupe-3.2.1.tgz",
      "integrity": "sha512-CdzqowRJCeLU72bHvWqwRBBlLcMEtIvGrlvef74kMnV2AolS9Y8xUv1I0U/MNAWMhBlKIoyuEgoJ0t/bbwHbLQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/lucide-react": {
      "version": "0.542.0",
      "resolved": "https://registry.npmjs.org/lucide-react/-/lucide-react-0.542.0.tgz",
      "integrity": "sha512-w3hD8/SQB7+lzU2r4VdFyzzOzKnUjTZIF/MQJGSSvni7Llewni4vuViRppfRAa2guOsY5k4jZyxw/i9DQHv+dw==",
      "license": "ISC",
      "peerDependencies": {
        "react": "^16.5.1 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/lz-string": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/lz-string/-/lz-string-1.5.0.tgz",
      "integrity": "sha512-h5bgJWpxJNswbU7qCrV0tIKQCaS3blPDrqKWx+QxzuzL1zGUzij9XCWLrSLsJPu5t+eWA/ycetzYAO5IOMcWAQ==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "lz-string": "bin/bin.js"
      }
    },
    "node_modules/magic-string": {
      "version": "0.27.0",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.27.0.tgz",
      "integrity": "sha512-8UnnX2PeRAPZuN12svgR9j7M1uWMovg/CEnIwIG0LFkXSJJe4PdfUGiTGl8V9bsBHFUtfVINcSyYxd7q+kx9fA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.4.13"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/magicast": {
      "version": "0.3.5",
      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.25.4",
        "@babel/types": "^7.25.4",
        "source-map-js": "^1.2.0"
      }
    },
    "node_modules/make-dir": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/make-dir/node_modules/semver": {
      "version": "7.7.4",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.4.tgz",
      "integrity": "sha512-vFKC2IEtQnVhpT78h1Yp8wzwrf8CM+MzKMHGJZfBtzhZNycRFnXsHk6E5TxIkkMsgNS7mdX3AGB7x2QM2di4lA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/mdn-data": {
      "version": "2.12.2",
      "resolved": "https://registry.npmjs.org/mdn-data/-/mdn-data-2.12.2.tgz",
      "integrity": "sha512-IEn+pegP1aManZuckezWCO+XZQDplx1366JoVhTpMpBB1sPey/SbveZQUosKiKiGYjg1wH4pMlNgXbCiYgihQA==",
      "dev": true,
      "license": "CC0-1.0"
    },
    "node_modules/merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/micromatch": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "braces": "^3.0.3",
        "picomatch": "^2.3.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/min-indent": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/min-indent/-/min-indent-1.0.1.tgz",
      "integrity": "sha512-I9jwMn07Sy/IwOj3zVkVik2JTvgpaykDZEigL6Rx6N9LbMywwUSMtxET+7lVoDLLd3O3IXwJwvuuns8UB/HeAg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/minimatch": {
      "version": "9.0.5",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
      "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/minipass": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=16 || 14 >=14.17"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/mz": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/mz/-/mz-2.7.0.tgz",
      "integrity": "sha512-z81GNO7nnYMEhrGh9LeymoE4+Yr0Wn5McHIZMK5cfQCl+NDX08sCZgUc9/6MHni9IWuFLm1Z3HTCXu2z9fN62Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "any-promise": "^1.0.0",
        "object-assign": "^4.0.1",
        "thenify-all": "^1.0.0"
      }
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/node-releases": {
      "version": "2.0.27",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.27.tgz",
      "integrity": "sha512-nmh3lCkYZ3grZvqcCH+fjmQ7X+H0OeZgP40OierEaAptX4XofMh5kwNbWh7lBduUzCcV/8kZ+NDLCwm2iorIlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-hash": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/object-hash/-/object-hash-3.0.0.tgz",
      "integrity": "sha512-RSn9F68PjH9HqtltsSnqYC1XXoWe9Bju5+213R98cNGttag9q9yAOTzdbsqvIa7aNm5WffBZFpWYr2aWrklWAw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.4",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
      "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.5"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "p-limit": "^3.0.2"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/package-json-from-dist": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
      "dev": true,
      "license": "BlueOak-1.0.0"
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/parse5": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/parse5/-/parse5-8.0.0.tgz",
      "integrity": "sha512-9m4m5GSgXjL4AjumKzq1Fgfp3Z8rsvjRNbnkVwfu2ImRqE5D0LnY2QfDen18FSY9C573YU5XxSapdHZTZ2WolA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "entities": "^6.0.0"
      },
      "funding": {
        "url": "https://github.com/inikulin/parse5?sponsor=1"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/path-scurry": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "lru-cache": "^10.2.0",
        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
      },
      "engines": {
        "node": ">=16 || 14 >=14.18"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/path-scurry/node_modules/lru-cache": {
      "version": "10.4.3",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/pathe": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/pathe/-/pathe-2.0.3.tgz",
      "integrity": "sha512-WUjGcAqP1gQacoQe+OBJsFA7Ld4DyXuUIjZ5cc75cLHvJ7dtNsTugphxIADwspS+AraAUePCKrSVtPLFj/F88w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/pathval": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/pathval/-/pathval-2.0.1.tgz",
      "integrity": "sha512-//nshmD55c46FuFw26xV/xFAaB5HF9Xdap7HJBBnrKdAd6/GxDBaNA1870O79+9ueg61cZLSVc+OaFlfmObYVQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 14.16"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/pify": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/pify/-/pify-2.3.0.tgz",
      "integrity": "sha512-udgsAY+fTnvv7kI7aaxbqwWNb0AHiB0qBO89PZKPkoTmGOgdbrHDKD+0B2X4uTfJ/FT1R09r9gTsjUjNJotuog==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/pirates": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/pirates/-/pirates-4.0.7.tgz",
      "integrity": "sha512-TfySrs/5nm8fQJDcBDuUng3VOUKsd7S+zqvbOTiGXHfxX4wK31ard+hoNuvkicM/2YFzlpDgABOevKSsB4G/FA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/postcss-import": {
      "version": "15.1.0",
      "resolved": "https://registry.npmjs.org/postcss-import/-/postcss-import-15.1.0.tgz",
      "integrity": "sha512-hpr+J05B2FVYUAXHeK1YyI267J/dDDhMU6B6civm8hSY1jYJnBXxzKDKDswzJmtLHryrjhnDjqqp/49t8FALew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "postcss-value-parser": "^4.0.0",
        "read-cache": "^1.0.0",
        "resolve": "^1.1.7"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "peerDependencies": {
        "postcss": "^8.0.0"
      }
    },
    "node_modules/postcss-js": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/postcss-js/-/postcss-js-4.1.0.tgz",
      "integrity": "sha512-oIAOTqgIo7q2EOwbhb8UalYePMvYoIeRY2YKntdpFQXNosSu3vLrniGgmH9OKs/qAkfoj5oB3le/7mINW1LCfw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "camelcase-css": "^2.0.1"
      },
      "engines": {
        "node": "^12 || ^14 || >= 16"
      },
      "peerDependencies": {
        "postcss": "^8.4.21"
      }
    },
    "node_modules/postcss-load-config": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/postcss-load-config/-/postcss-load-config-6.0.1.tgz",
      "integrity": "sha512-oPtTM4oerL+UXmx+93ytZVN82RrlY/wPUV8IeDxFrzIjXOLF1pN+EmKPLbubvKHT2HC20xXsCAH2Z+CKV6Oz/g==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "lilconfig": "^3.1.1"
      },
      "engines": {
        "node": ">= 18"
      },
      "peerDependencies": {
        "jiti": ">=1.21.0",
        "postcss": ">=8.0.9",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        },
        "postcss": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/postcss-nested": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/postcss-nested/-/postcss-nested-6.2.0.tgz",
      "integrity": "sha512-HQbt28KulC5AJzG+cZtj9kvKB93CFCdLvog1WFLf1D+xmMvPGlBstkpTEZfK5+AN9hfJocyBFCNiqyS48bpgzQ==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "postcss-selector-parser": "^6.1.1"
      },
      "engines": {
        "node": ">=12.0"
      },
      "peerDependencies": {
        "postcss": "^8.2.14"
      }
    },
    "node_modules/postcss-selector-parser": {
      "version": "6.1.2",
      "resolved": "https://registry.npmjs.org/postcss-selector-parser/-/postcss-selector-parser-6.1.2.tgz",
      "integrity": "sha512-Q8qQfPiZ+THO/3ZrOrO0cJJKfpYCagtMUkXbnEfmgUjwXg6z/WBeOyS9APBBPCTSiDV+s4SwQGu8yFsiMRIudg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cssesc": "^3.0.0",
        "util-deprecate": "^1.0.2"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/postcss-value-parser": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-4.2.0.tgz",
      "integrity": "sha512-1NNCs6uurfkVbeXG4S8JFT9t19m45ICnif8zWLd5oPSZ50QnwMfK+H3jv408d4jw/7Bttv5axS5IiHoLaVNHeQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/pretty-format": {
      "version": "27.5.1",
      "resolved": "https://registry.npmjs.org/pretty-format/-/pretty-format-27.5.1.tgz",
      "integrity": "sha512-Qb1gy5OrP5+zDf2Bvnzdl3jsTf1qXVMazbvCoKhtKqVs4/YK4ozX4gKQJJVyNe+cajNPn0KoC0MC3FUmaHWEmQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1",
        "ansi-styles": "^5.0.0",
        "react-is": "^17.0.1"
      },
      "engines": {
        "node": "^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"
      }
    },
    "node_modules/pretty-format/node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/pretty-format/node_modules/ansi-styles": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-5.2.0.tgz",
      "integrity": "sha512-Cxwpt2SfTzTtXcfOlzGEee8O+c+MmUgGrNiBcXnuWxuFJHe6a5Hz7qwhwe5OgaSYI0IJvkLqWX1ASG+cJOkEiA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/react": {
      "version": "19.2.0",
      "resolved": "https://registry.npmjs.org/react/-/react-19.2.0.tgz",
      "integrity": "sha512-tmbWg6W31tQLeB5cdIBOicJDJRR2KzXsV7uSK9iNfLWQ5bIZfxuPEHp7M8wiHyHnn0DD1i7w3Zmin0FtkrwoCQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.2.0",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.2.0.tgz",
      "integrity": "sha512-UlbRu4cAiGaIewkPyiRGJk0imDN2T3JjieT6spoL2UeSf5od4n5LB/mQ4ejmxhCFT1tYe8IvaFulzynWovsEFQ==",
      "license": "MIT",
      "dependencies": {
        "scheduler": "^0.27.0"
      },
      "peerDependencies": {
        "react": "^19.2.0"
      }
    },
    "node_modules/react-is": {
      "version": "17.0.2",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-17.0.2.tgz",
      "integrity": "sha512-w2GsyukL62IJnlaff/nRegPQR94C/XXamvMWmSHRJ4y7Ts/4ocGRmTHvOs8PSE6pB3dWOrD/nueuU5sduBsQ4w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/react-refresh": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/react-refresh/-/react-refresh-0.17.0.tgz",
      "integrity": "sha512-z6F7K9bV85EfseRCp2bzrpyQ0Gkw1uLoCel9XBVWPg/TjRj94SkJzUTGfOa4bs7iJvBWtQG0Wq7wnI0syw3EBQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-remove-scroll": {
      "version": "2.7.2",
      "resolved": "https://registry.npmjs.org/react-remove-scroll/-/react-remove-scroll-2.7.2.tgz",
      "integrity": "sha512-Iqb9NjCCTt6Hf+vOdNIZGdTiH1QSqr27H/Ek9sv/a97gfueI/5h1s3yRi1nngzMUaOOToin5dI1dXKdXiF+u0Q==",
      "license": "MIT",
      "dependencies": {
        "react-remove-scroll-bar": "^2.3.7",
        "react-style-singleton": "^2.2.3",
        "tslib": "^2.1.0",
        "use-callback-ref": "^1.3.3",
        "use-sidecar": "^1.1.3"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/react-remove-scroll-bar": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/react-remove-scroll-bar/-/react-remove-scroll-bar-2.3.8.tgz",
      "integrity": "sha512-9r+yi9+mgU33AKcj6IbT9oRCO78WriSj6t/cF8DWBZJ9aOGPOTEDvdUDz1FwKim7QXWwmHqtdHnRJfhAxEG46Q==",
      "license": "MIT",
      "dependencies": {
        "react-style-singleton": "^2.2.2",
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/react-style-singleton": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/react-style-singleton/-/react-style-singleton-2.2.3.tgz",
      "integrity": "sha512-b6jSvxvVnyptAiLjbkWLE/lOnR4lfTtDAl+eUC7RZy+QQWc6wRzIV2CE6xBuMmDxc2qIihtDCZD5NPOFl7fRBQ==",
      "license": "MIT",
      "dependencies": {
        "get-nonce": "^1.0.0",
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/read-cache": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/read-cache/-/read-cache-1.0.0.tgz",
      "integrity": "sha512-Owdv/Ft7IjOgm/i0xvNDZ1LrRANRfew4b2prF3OWMQLxLfu3bS8FVhCsrSCMK4lR56Y9ya+AThoTpDCTxCmpRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "pify": "^2.3.0"
      }
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/redent": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/redent/-/redent-3.0.0.tgz",
      "integrity": "sha512-6tDA8g98We0zd0GvVeMT9arEOnTw9qM03L9cJXaCjrip1OO764RDBLBfrB4cwzNGDj5OA5ioymC9GkizgWJDUg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "indent-string": "^4.0.0",
        "strip-indent": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/refa": {
      "version": "0.12.1",
      "resolved": "https://registry.npmjs.org/refa/-/refa-0.12.1.tgz",
      "integrity": "sha512-J8rn6v4DBb2nnFqkqwy6/NnTYMcgLA+sLr0iIO41qpv0n+ngb7ksag2tMRl0inb1bbO/esUwzW1vbJi7K0sI0g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/regexpp": "^4.8.0"
      },
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/regexp-ast-analysis": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/regexp-ast-analysis/-/regexp-ast-analysis-0.7.1.tgz",
      "integrity": "sha512-sZuz1dYW/ZsfG17WSAG7eS85r5a0dDsvg+7BiiYR5o6lKCAtUrEwdmRmaGF6rwVj3LcmAeYkOWKEPlbPzN3Y3A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/regexpp": "^4.8.0",
        "refa": "^0.12.1"
      },
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/require-from-string": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
      "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/resolve": {
      "version": "1.22.11",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.11.tgz",
      "integrity": "sha512-RfqAvLnMl313r7c9oclB1HhUEAezcpLjz95wFH4LVuhk9JF/r22qmVP9AMmOU4vMX7Q8pN8jwNg/CSpdFnMjTQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.1",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/reusify": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.1.0.tgz",
      "integrity": "sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "iojs": ">=1.0.0",
        "node": ">=0.10.0"
      }
    },
    "node_modules/rollup": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.57.1.tgz",
      "integrity": "sha512-oQL6lgK3e2QZeQ7gcgIkS2YZPg5slw37hYufJ3edKlfQSGGm8ICoxswK15ntSzF/a8+h7ekRy7k7oWc3BQ7y8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.57.1",
        "@rollup/rollup-android-arm64": "4.57.1",
        "@rollup/rollup-darwin-arm64": "4.57.1",
        "@rollup/rollup-darwin-x64": "4.57.1",
        "@rollup/rollup-freebsd-arm64": "4.57.1",
        "@rollup/rollup-freebsd-x64": "4.57.1",
        "@rollup/rollup-linux-arm-gnueabihf": "4.57.1",
        "@rollup/rollup-linux-arm-musleabihf": "4.57.1",
        "@rollup/rollup-linux-arm64-gnu": "4.57.1",
        "@rollup/rollup-linux-arm64-musl": "4.57.1",
        "@rollup/rollup-linux-loong64-gnu": "4.57.1",
        "@rollup/rollup-linux-loong64-musl": "4.57.1",
        "@rollup/rollup-linux-ppc64-gnu": "4.57.1",
        "@rollup/rollup-linux-ppc64-musl": "4.57.1",
        "@rollup/rollup-linux-riscv64-gnu": "4.57.1",
        "@rollup/rollup-linux-riscv64-musl": "4.57.1",
        "@rollup/rollup-linux-s390x-gnu": "4.57.1",
        "@rollup/rollup-linux-x64-gnu": "4.57.1",
        "@rollup/rollup-linux-x64-musl": "4.57.1",
        "@rollup/rollup-openbsd-x64": "4.57.1",
        "@rollup/rollup-openharmony-arm64": "4.57.1",
        "@rollup/rollup-win32-arm64-msvc": "4.57.1",
        "@rollup/rollup-win32-ia32-msvc": "4.57.1",
        "@rollup/rollup-win32-x64-gnu": "4.57.1",
        "@rollup/rollup-win32-x64-msvc": "4.57.1",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "queue-microtask": "^1.2.2"
      }
    },
    "node_modules/saxes": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/saxes/-/saxes-6.0.0.tgz",
      "integrity": "sha512-xAg7SOnEhrm5zI3puOOKyy1OMcMlIJZYNJY7xLBwSze0UjhPLnWfj2GF2EpT0jmzaJKIWKHLsaSSajf35bcYnA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "xmlchars": "^2.2.0"
      },
      "engines": {
        "node": ">=v12.22.7"
      }
    },
    "node_modules/scheduler": {
      "version": "0.27.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.27.0.tgz",
      "integrity": "sha512-eNv+WrVbKu1f3vbYJT/xtiF5syA5HPIMtf9IgY/nKg0sWqzAUEvqY/xm7OcZc/qafLx/iO9FgOmeSAp4v5ti/Q==",
      "license": "MIT"
    },
    "node_modules/scslre": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/scslre/-/scslre-0.3.0.tgz",
      "integrity": "sha512-3A6sD0WYP7+QrjbfNA2FN3FsOaGGFoekCVgTyypy53gPxhbkCIjtO6YWgdrfM+n/8sI8JeXZOIxsHjMTNxQ4nQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/regexpp": "^4.8.0",
        "refa": "^0.12.0",
        "regexp-ast-analysis": "^0.7.0"
      },
      "engines": {
        "node": "^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/siginfo": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/siginfo/-/siginfo-2.0.0.tgz",
      "integrity": "sha512-ybx0WO1/8bSBLEWXZvEd7gMW3Sn3JFlW3TvX1nREbDLRNQNaeNN8WK0meBwPdAaOI7TtRRRJn/Es1zhrrCHu7g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/signal-exit": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/stackback": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/stackback/-/stackback-0.0.2.tgz",
      "integrity": "sha512-1XMJE5fQo1jGH6Y/7ebnwPOBEkIEnT4QF32d5R1+VXdXveM0IBMJt8zfaxX1P3QhVwrYe+576+jkANtSS2mBbw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/std-env": {
      "version": "3.10.0",
      "resolved": "https://registry.npmjs.org/std-env/-/std-env-3.10.0.tgz",
      "integrity": "sha512-5GS12FdOZNliM5mAOxFRg7Ir0pWz8MdpYm6AY6VPkGpbA7ZzmbzNcBJQ0GPvvyWgcY7QAhCgf9Uy89I03faLkg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/string-width": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eastasianwidth": "^0.2.0",
        "emoji-regex": "^9.2.2",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/string-width-cjs": {
      "name": "string-width",
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/string-width-cjs/node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/string-width-cjs/node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/string-width-cjs/node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/strip-ansi-cjs": {
      "name": "strip-ansi",
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi-cjs/node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-indent": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/strip-indent/-/strip-indent-3.0.0.tgz",
      "integrity": "sha512-laJTa3Jb+VQpaC6DseHhF7dXVqHTfJPCRDaEbid/drOhgitgYku/letMUqOXFoWV0zIIUbjpdH2t+tYj4bQMRQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "min-indent": "^1.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/strip-literal": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/strip-literal/-/strip-literal-3.1.0.tgz",
      "integrity": "sha512-8r3mkIM/2+PpjHoOtiAW8Rg3jJLHaV7xPwG+YRGrv6FP0wwk/toTpATxWYOW0BKdWwl82VT2tFYi5DlROa0Mxg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "js-tokens": "^9.0.1"
      },
      "funding": {
        "url": "https://github.com/sponsors/antfu"
      }
    },
    "node_modules/strip-literal/node_modules/js-tokens": {
      "version": "9.0.1",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-9.0.1.tgz",
      "integrity": "sha512-mxa9E9ITFOt0ban3j6L5MpjwegGz6lBQmM1IJkWeBZGcMxto50+eWdjC/52xDbS2vy0k7vIMK0Fe2wfL9OQSpQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/sucrase": {
      "version": "3.35.1",
      "resolved": "https://registry.npmjs.org/sucrase/-/sucrase-3.35.1.tgz",
      "integrity": "sha512-DhuTmvZWux4H1UOnWMB3sk0sbaCVOoQZjv8u1rDoTV0HTdGem9hkAZtl4JZy8P2z4Bg0nT+YMeOFyVr4zcG5Tw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.2",
        "commander": "^4.0.0",
        "lines-and-columns": "^1.1.6",
        "mz": "^2.7.0",
        "pirates": "^4.0.1",
        "tinyglobby": "^0.2.11",
        "ts-interface-checker": "^0.1.9"
      },
      "bin": {
        "sucrase": "bin/sucrase",
        "sucrase-node": "bin/sucrase-node"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/symbol-tree": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/symbol-tree/-/symbol-tree-3.2.4.tgz",
      "integrity": "sha512-9QNk5KwDF+Bvz+PyObkmSYjI5ksVUYtjW7AU22r2NKcfLJcXp96hkDWU3+XndOsUb+AQ9QhfzfCT2O+CNWT5Tw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tailwind-merge": {
      "version": "3.4.0",
      "resolved": "https://registry.npmjs.org/tailwind-merge/-/tailwind-merge-3.4.0.tgz",
      "integrity": "sha512-uSaO4gnW+b3Y2aWoWfFpX62vn2sR3skfhbjsEnaBI81WD1wBLlHZe5sWf0AqjksNdYTbGBEd0UasQMT3SNV15g==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/dcastil"
      }
    },
    "node_modules/tailwindcss": {
      "version": "3.4.19",
      "resolved": "https://registry.npmjs.org/tailwindcss/-/tailwindcss-3.4.19.tgz",
      "integrity": "sha512-3ofp+LL8E+pK/JuPLPggVAIaEuhvIz4qNcf3nA1Xn2o/7fb7s/TYpHhwGDv1ZU3PkBluUVaF8PyCHcm48cKLWQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@alloc/quick-lru": "^5.2.0",
        "arg": "^5.0.2",
        "chokidar": "^3.6.0",
        "didyoumean": "^1.2.2",
        "dlv": "^1.1.3",
        "fast-glob": "^3.3.2",
        "glob-parent": "^6.0.2",
        "is-glob": "^4.0.3",
        "jiti": "^1.21.7",
        "lilconfig": "^3.1.3",
        "micromatch": "^4.0.8",
        "normalize-path": "^3.0.0",
        "object-hash": "^3.0.0",
        "picocolors": "^1.1.1",
        "postcss": "^8.4.47",
        "postcss-import": "^15.1.0",
        "postcss-js": "^4.0.1",
        "postcss-load-config": "^4.0.2 || ^5.0 || ^6.0",
        "postcss-nested": "^6.2.0",
        "postcss-selector-parser": "^6.1.2",
        "resolve": "^1.22.8",
        "sucrase": "^3.35.0"
      },
      "bin": {
        "tailwind": "lib/cli.js",
        "tailwindcss": "lib/cli.js"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/tailwindcss-animate": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/tailwindcss-animate/-/tailwindcss-animate-1.0.7.tgz",
      "integrity": "sha512-bl6mpH3T7I3UFxuvDEXLxy/VuFxBk5bbzplh7tXI68mwMokNYd1t9qPBHlnyTwfa4JGC4zP516I1hYYtQ/vspA==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "tailwindcss": ">=3.0.0 || insiders"
      }
    },
    "node_modules/test-exclude": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "@istanbuljs/schema": "^0.1.2",
        "glob": "^10.4.1",
        "minimatch": "^9.0.4"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/thenify": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/thenify/-/thenify-3.3.1.tgz",
      "integrity": "sha512-RVZSIV5IG10Hk3enotrhvz0T9em6cyHBLkH/YAZuKqd8hRkKhSfCGIcP2KUY0EPxndzANBmNllzWPwak+bheSw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "any-promise": "^1.0.0"
      }
    },
    "node_modules/thenify-all": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/thenify-all/-/thenify-all-1.6.0.tgz",
      "integrity": "sha512-RNxQH/qI8/t3thXJDwcstUO4zeqo64+Uy/+sNVRBx4Xn2OX+OZ9oP+iJnNFqplFra2ZUVeKCSa2oVWi3T4uVmA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "thenify": ">= 3.1.0 < 4"
      },
      "engines": {
        "node": ">=0.8"
      }
    },
    "node_modules/tinybench": {
      "version": "2.9.0",
      "resolved": "https://registry.npmjs.org/tinybench/-/tinybench-2.9.0.tgz",
      "integrity": "sha512-0+DUvqWMValLmha6lr4kD8iAMK1HzV0/aKnCtWb9v9641TnP/MFb7Pc2bxoxQjTXAErryXVgUOfv2YqNllqGeg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinyexec": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/tinyexec/-/tinyexec-0.3.2.tgz",
      "integrity": "sha512-KQQR9yN7R5+OSwaK0XQoj22pwHoTlgYqmUscPYoknOoWCWfj/5/ABTMRi69FrKU5ffPVh5QcFikpWJI/P1ocHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinyglobby": {
      "version": "0.2.15",
      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.15.tgz",
      "integrity": "sha512-j2Zq4NyQYG5XMST4cbs02Ak8iJUdxRM0XI5QyxXuZOzKOINmWurp3smXu3y5wDcJrptwpSjgXHzIQxR0omXljQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/SuperchupuDev"
      }
    },
    "node_modules/tinyglobby/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/tinyglobby/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/tinypool": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/tinypool/-/tinypool-1.1.1.tgz",
      "integrity": "sha512-Zba82s87IFq9A9XmjiX5uZA/ARWDrB03OHlq+Vw1fSdt0I+4/Kutwy8BP4Y/y/aORMo61FQ0vIb5j44vSo5Pkg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      }
    },
    "node_modules/tinyrainbow": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/tinyrainbow/-/tinyrainbow-2.0.0.tgz",
      "integrity": "sha512-op4nsTR47R6p0vMUUoYl/a+ljLFVtlfaXkLQmqfLR1qHma1h/ysYk4hEXZ880bf2CYgTskvTa/e196Vd5dDQXw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/tinyspy": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/tinyspy/-/tinyspy-4.0.4.tgz",
      "integrity": "sha512-azl+t0z7pw/z958Gy9svOTuzqIk6xq+NSheJzn5MMWtWTFywIacg2wUlzKFGtt3cthx0r2SxMK0yzJOR0IES7Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/tldts": {
      "version": "7.0.23",
      "resolved": "https://registry.npmjs.org/tldts/-/tldts-7.0.23.tgz",
      "integrity": "sha512-ASdhgQIBSay0R/eXggAkQ53G4nTJqTXqC2kbaBbdDwM7SkjyZyO0OaaN1/FH7U/yCeqOHDwFO5j8+Os/IS1dXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tldts-core": "^7.0.23"
      },
      "bin": {
        "tldts": "bin/cli.js"
      }
    },
    "node_modules/tldts-core": {
      "version": "7.0.23",
      "resolved": "https://registry.npmjs.org/tldts-core/-/tldts-core-7.0.23.tgz",
      "integrity": "sha512-0g9vrtDQLrNIiCj22HSe9d4mLVG3g5ph5DZ8zCKBr4OtrspmNB6ss7hVyzArAeE88ceZocIEGkyW1Ime7fxPtQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/tough-cookie": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-6.0.0.tgz",
      "integrity": "sha512-kXuRi1mtaKMrsLUxz3sQYvVl37B0Ns6MzfrtV5DvJceE9bPyspOqk9xxv7XbZWcfLWbFmm997vl83qUWVJA64w==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "tldts": "^7.0.5"
      },
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/ts-api-utils": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/ts-api-utils/-/ts-api-utils-2.4.0.tgz",
      "integrity": "sha512-3TaVTaAv2gTiMB35i3FiGJaRfwb3Pyn/j3m/bfAvGe8FB7CF6u+LMYqYlDh7reQf7UNvoTvdfAqHGmPGOSsPmA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18.12"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4"
      }
    },
    "node_modules/ts-interface-checker": {
      "version": "0.1.13",
      "resolved": "https://registry.npmjs.org/ts-interface-checker/-/ts-interface-checker-0.1.13.tgz",
      "integrity": "sha512-Y/arvbn+rrz3JCKl9C4kVNfTfSm2/mEp5FSz5EsZSANGPSlQrpRI5M4PKF+mJnE52jOO90PnPSc3Ur3bTQw0gA==",
      "dev": true,
      "license": "Apache-2.0"
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/typescript": {
      "version": "5.9.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
      "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici": {
      "version": "7.21.0",
      "resolved": "https://registry.npmjs.org/undici/-/undici-7.21.0.tgz",
      "integrity": "sha512-Hn2tCQpoDt1wv23a68Ctc8Cr/BHpUSfaPYrkajTXOS9IKpxVRx/X5m1K2YkbK2ipgZgxXSgsUinl3x+2YdSSfg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=20.18.1"
      }
    },
    "node_modules/update-browserslist-db": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.2.3.tgz",
      "integrity": "sha512-Js0m9cx+qOgDxo0eMiFGEueWztz+d4+M3rGlmKPT+T4IS/jP4ylw3Nwpu6cpTTP8R1MAC1kF4VbdLt3ARf209w==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "peer": true,
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/use-callback-ref": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/use-callback-ref/-/use-callback-ref-1.3.3.tgz",
      "integrity": "sha512-jQL3lRnocaFtu3V00JToYz/4QkNWswxijDaCVNZRiRTO3HQDLsdu1ZtmIUvV4yPp+rvWm5j0y0TG/S61cuijTg==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/use-sidecar": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/use-sidecar/-/use-sidecar-1.1.3.tgz",
      "integrity": "sha512-Fedw0aZvkhynoPYlA5WXrMCAMm+nSWdZt6lzJQ7Ok8S6Q+VsHmHpRWndVRJ8Be0ZbkfPc5LRYH+5XrzXcEeLRQ==",
      "license": "MIT",
      "dependencies": {
        "detect-node-es": "^1.1.0",
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/vite": {
      "version": "6.4.1",
      "resolved": "https://registry.npmjs.org/vite/-/vite-6.4.1.tgz",
      "integrity": "sha512-+Oxm7q9hDoLMyJOYfUYBuHQo+dkAloi33apOPP56pzj+vsdJDzr+j1NISE5pyaAuKL4A3UD34qd0lx5+kfKp2g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.25.0",
        "fdir": "^6.4.4",
        "picomatch": "^4.0.2",
        "postcss": "^8.5.3",
        "rollup": "^4.34.9",
        "tinyglobby": "^0.2.13"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || ^20.0.0 || >=22.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || ^20.0.0 || >=22.0.0",
        "jiti": ">=1.21.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.16.0",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "jiti": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/vite-node": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/vite-node/-/vite-node-3.2.4.tgz",
      "integrity": "sha512-EbKSKh+bh1E1IFxeO0pg1n4dvoOTt0UDiXMd/qn++r98+jPO1xtJilvXldeuQ8giIB5IkpjCgMleHMNEsGH6pg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cac": "^6.7.14",
        "debug": "^4.4.1",
        "es-module-lexer": "^1.7.0",
        "pathe": "^2.0.3",
        "vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0"
      },
      "bin": {
        "vite-node": "vite-node.mjs"
      },
      "engines": {
        "node": "^18.0.0 || ^20.0.0 || >=22.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/vite/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/vitest": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/vitest/-/vitest-3.2.4.tgz",
      "integrity": "sha512-LUCP5ev3GURDysTWiP47wRRUpLKMOfPh+yKTx3kVIEiu5KOMeqzpnYNsKyOoVrULivR8tLcks4+lga33Whn90A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/chai": "^5.2.2",
        "@vitest/expect": "3.2.4",
        "@vitest/mocker": "3.2.4",
        "@vitest/pretty-format": "^3.2.4",
        "@vitest/runner": "3.2.4",
        "@vitest/snapshot": "3.2.4",
        "@vitest/spy": "3.2.4",
        "@vitest/utils": "3.2.4",
        "chai": "^5.2.0",
        "debug": "^4.4.1",
        "expect-type": "^1.2.1",
        "magic-string": "^0.30.17",
        "pathe": "^2.0.3",
        "picomatch": "^4.0.2",
        "std-env": "^3.9.0",
        "tinybench": "^2.9.0",
        "tinyexec": "^0.3.2",
        "tinyglobby": "^0.2.14",
        "tinypool": "^1.1.1",
        "tinyrainbow": "^2.0.0",
        "vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0",
        "vite-node": "3.2.4",
        "why-is-node-running": "^2.3.0"
      },
      "bin": {
        "vitest": "vitest.mjs"
      },
      "engines": {
        "node": "^18.0.0 || ^20.0.0 || >=22.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "@edge-runtime/vm": "*",
        "@types/debug": "^4.1.12",
        "@types/node": "^18.0.0 || ^20.0.0 || >=22.0.0",
        "@vitest/browser": "3.2.4",
        "@vitest/ui": "3.2.4",
        "happy-dom": "*",
        "jsdom": "*"
      },
      "peerDependenciesMeta": {
        "@edge-runtime/vm": {
          "optional": true
        },
        "@types/debug": {
          "optional": true
        },
        "@types/node": {
          "optional": true
        },
        "@vitest/browser": {
          "optional": true
        },
        "@vitest/ui": {
          "optional": true
        },
        "happy-dom": {
          "optional": true
        },
        "jsdom": {
          "optional": true
        }
      }
    },
    "node_modules/vitest/node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/vitest/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/w3c-xmlserializer": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/w3c-xmlserializer/-/w3c-xmlserializer-5.0.0.tgz",
      "integrity": "sha512-o8qghlI8NZHU1lLPrpi2+Uq7abh4GGPpYANlalzWxyWteJOCsr/P+oPBA49TOLu5FTZO4d3F9MnWJfiMo4BkmA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "xml-name-validator": "^5.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/whatwg-mimetype": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-mimetype/-/whatwg-mimetype-5.0.0.tgz",
      "integrity": "sha512-sXcNcHOC51uPGF0P/D4NVtrkjSU2fNsm9iog4ZvZJsL3rjoDAzXZhkm2MWt1y+PUdggKAYVoMAIYcs78wJ51Cw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/why-is-node-running": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/why-is-node-running/-/why-is-node-running-2.3.0.tgz",
      "integrity": "sha512-hUrmaWBdVDcxvYqnyh09zunKzROWjbZTiNy8dBEjkS7ehEDQibXJ7XvlmtbwuTclUiIyN+CyXQD4Vmko8fNm8w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "siginfo": "^2.0.0",
        "stackback": "0.0.2"
      },
      "bin": {
        "why-is-node-running": "cli.js"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/word-wrap": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/wrap-ansi": {
      "version": "8.1.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^6.1.0",
        "string-width": "^5.0.1",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs": {
      "name": "wrap-ansi",
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/xml-name-validator": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/xml-name-validator/-/xml-name-validator-5.0.0.tgz",
      "integrity": "sha512-EvGK8EJ3DhaHfbRlETOWAS5pO9MZITeauHKJyb8wyajUfQUenkIg2MvLDTZ4T/TgIcm3HU0TFBgWWboAZ30UHg==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/xmlchars": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/xmlchars/-/xmlchars-2.2.0.tgz",
      "integrity": "sha512-JZnDKK8B0RCDw84FNdDAIpZK+JuJw+s7Lz8nksI7SIuU3UXJJslUthsi+uWBUYOwPFwW7W7PRLRfUKpxjtjFCw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/zustand": {
      "version": "5.0.11",
      "resolved": "https://registry.npmjs.org/zustand/-/zustand-5.0.11.tgz",
      "integrity": "sha512-fdZY+dk7zn/vbWNCYmzZULHRrss0jx5pPFiOuMZ/5HJN6Yv3u+1Wswy/4MpZEkEGhtNH+pwxZB8OKgUBPzYAGg==",
      "license": "MIT",
      "engines": {
        "node": ">=12.20.0"
      },
      "peerDependencies": {
        "@types/react": ">=18.0.0",
        "immer": ">=9.0.6",
        "react": ">=18.0.0",
        "use-sync-external-store": ">=1.2.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "immer": {
          "optional": true
        },
        "react": {
          "optional": true
        },
        "use-sync-external-store": {
          "optional": true
        }
      }
    }
  }
}
===ENDFILE

===FILE: package.json
{
  "name": "@ccaas/ccaas-admin-mfe",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "main": "dist/index.esm.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "dev": "vite --port 5185",
    "build": "vite build",
    "preview": "vite preview --port 5185",
    "type-check": "tsc -p tsconfig.json --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "clean": "rm -rf dist .__mf__temp node_modules"
  },
  "peerDependencies": {
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "dependencies": {
    "@radix-ui/react-accordion": "^1.2.12",
    "@radix-ui/react-alert-dialog": "^1.1.15",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-collapsible": "^1.1.12",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-icons": "^1.3.2",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-popover": "^1.1.9",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-toggle": "^1.1.10",
    "@radix-ui/react-toggle-group": "^1.1.11",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@tanstack/react-query": "^5.66.7",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.542.0",
    "tailwind-merge": "^3.3.1",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@originjs/vite-plugin-federation": "^1.4.1",
    "@testing-library/dom": "^10.4.1",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.2",
    "@testing-library/user-event": "^14.6.1",
    "@types/react": "^19.1.12",
    "@types/react-dom": "^19.1.9",
    "@typescript-eslint/parser": "^8.55.0",
    "@vitejs/plugin-react": "^4.6.0",
    "@vitest/coverage-istanbul": "^3.2.4",
    "@vitest/coverage-v8": "^3.2.4",
    "autoprefixer": "^10.4.14",
    "eslint-plugin-sonarjs": "^3.0.7",
    "jsdom": "^28.0.0",
    "postcss": "^8.4.24",
    "react": "19.2.0",
    "react-dom": "19.2.0",
    "tailwindcss": "^3.3.0",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5.9.2",
    "vite": "^6.0.0",
    "vitest": "^3.2.4"
  },
  "optionalDependencies": {
    "@rollup/rollup-linux-x64-gnu": "^4.50.0"
  }
}
===ENDFILE

===FILE: postcss.config.js
import tailwindcss from 'tailwindcss';
import autoprefixer from 'autoprefixer';

export default {
  plugins: [
    tailwindcss,
    autoprefixer
  ]
};
===ENDFILE

===FILE: src/AdminMFE.tsx
import { useEffect, Component, ErrorInfo as ReactErrorInfo, ReactNode } from 'react'
import { QueryClientProvider } from '@tanstack/react-query'
import { AdminScreen } from './components/admin/admin-screen'
import { ToastProvider } from './hooks/common/use-toast'
import { queryClient } from './lib/query-client'
import { setAuthToken } from './utils/auth/auth-token-manager'
import type { AdminPermissions } from './components/admin/admin-layout'
import type { AdminMFEProps, ErrorInfo as AdminErrorInfo } from './types'
import './index.css'

interface ErrorBoundaryProps {
  children: ReactNode
  onError?: (error: AdminErrorInfo) => void
}

interface ErrorBoundaryState {
  hasError: boolean
  error?: Error
  errorId?: string
}

const defaultPermissions: AdminPermissions = {
  canPreviewDashboards: false,
  canViewRoleTemplates: false,
  canViewAdGroups: false,
  canViewPendingApprovals: false,
  canApproveChanges: false,
  canEditBusinessInfo: false,
  canEditPermissions: false,
  canEditApplications: false,
  canEnableDisableGroups: false,
  canDirectSave: false,
  canViewNotices: false,
  canCreateNotice: false,
  canEditNotice: false,
  canPublishNotice: false,
  canArchiveNotice: false,
  canSaveDraft: false
}

class AdminMFEErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, info: ReactErrorInfo) {
    const errorId = `ADMIN-MFE-${Date.now()}-${Math.random().toString(36).slice(2, 11)}`

    if (this.props.onError) {
      this.props.onError({
        code: 'MFE_RENDER_ERROR',
        message: error.message,
        context: {
          errorId,
          componentStack: info.componentStack,
          stack: error.stack
        }
      })
    }

    this.setState({ hasError: true, error, errorId })
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="p-6 bg-red-50 border border-red-200 rounded-lg text-center">
          <p className="text-red-600 font-medium">Admin Panel temporarily unavailable</p>
          {this.state.errorId ? <p className="text-sm text-gray-500 mt-2">Error ID: {this.state.errorId}</p> : null}
          <button
            onClick={() => globalThis.location.reload()}
            className="mt-4 px-4 py-2 bg-red-600 text-white rounded text-sm hover:bg-red-700"
          >
            Reload Page
          </button>
        </div>
      )
    }

    return this.props.children
  }
}

function AdminMFEInner(props: AdminMFEProps) {
  const {
    authToken,
    permissions,
    currentRole = 'admin',
    onError
  } = props

  useEffect(() => {
    if (!authToken) {
      onError?.({
        code: 'MISSING_AUTH_TOKEN',
        message: 'Admin MFE requires authToken from host'
      })
      return
    }

    setAuthToken(authToken)
  }, [authToken, onError])

  return <AdminScreen permissions={permissions ?? defaultPermissions} currentRole={currentRole} />
}

export function AdminMFE(props: AdminMFEProps) {
  return (
    <AdminMFEErrorBoundary onError={props.onError}>
      <div className="admin-mfe-root h-full w-full">
        <QueryClientProvider client={queryClient}>
          <ToastProvider>
            <AdminMFEInner {...props} />
          </ToastProvider>
        </QueryClientProvider>
      </div>
    </AdminMFEErrorBoundary>
  )
}

export default AdminMFE
===ENDFILE

===FILE: src/__tests__/AdminMFE.test.tsx
import { describe, expect, it, vi, beforeEach } from 'vitest'
import { render, screen } from '@testing-library/react'

let shouldThrow = false

vi.mock('../components/admin/admin-screen', () => ({
  AdminScreen: ({ currentRole }: { currentRole: string }) => {
    if (shouldThrow) {
      throw new Error('Render explosion')
    }
    return <div data-testid="admin-screen" data-role={currentRole}>Admin Screen</div>
  }
}))

vi.mock('../hooks/common/use-toast', () => ({
  ToastProvider: ({ children }: { children: React.ReactNode }) => <div data-testid="toast-provider">{children}</div>
}))

vi.mock('../lib/query-client', () => ({
  queryClient: {
    mount: vi.fn(),
    unmount: vi.fn(),
    getDefaultOptions: () => ({}),
    setDefaultOptions: vi.fn(),
    getQueryCache: () => ({ subscribe: vi.fn(() => vi.fn()), findAll: () => [], notify: vi.fn() }),
    getMutationCache: () => ({ subscribe: vi.fn(() => vi.fn()), findAll: () => [], notify: vi.fn() })
  }
}))

const mockSetAuthToken = vi.fn()
vi.mock('../utils/auth/auth-token-manager', () => ({
  setAuthToken: (...args: unknown[]) => mockSetAuthToken(...args)
}))

vi.mock('../index.css', () => ({}))

vi.mock('@tanstack/react-query', () => ({
  QueryClientProvider: ({ children }: { children: React.ReactNode }) => (
    <div data-testid="query-provider">{children}</div>
  )
}))

import { AdminMFE } from '../AdminMFE'

describe('AdminMFE', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    shouldThrow = false
  })

  it('renders without crashing', () => {
    render(<AdminMFE authToken="test-token" />)
    expect(screen.getByTestId('admin-screen')).toBeInTheDocument()
  })

  it('wraps content in QueryClientProvider', () => {
    render(<AdminMFE authToken="test-token" />)
    expect(screen.getByTestId('query-provider')).toBeInTheDocument()
  })

  it('wraps content in ToastProvider', () => {
    render(<AdminMFE authToken="test-token" />)
    expect(screen.getByTestId('toast-provider')).toBeInTheDocument()
  })

  it('passes default currentRole', () => {
    render(<AdminMFE authToken="test-token" />)
    expect(screen.getByTestId('admin-screen')).toHaveAttribute('data-role', 'admin')
  })

  it('passes custom currentRole', () => {
    render(<AdminMFE authToken="test-token" currentRole="maker" />)
    expect(screen.getByTestId('admin-screen')).toHaveAttribute('data-role', 'maker')
  })

  it('calls setAuthToken with authToken', () => {
    render(<AdminMFE authToken="my-jwt-token" />)
    expect(mockSetAuthToken).toHaveBeenCalledWith('my-jwt-token')
  })

  it('calls onError for missing authToken', () => {
    const onError = vi.fn()
    render(<AdminMFE authToken="" onError={onError} />)
    expect(onError).toHaveBeenCalledWith(
      expect.objectContaining({ code: 'MISSING_AUTH_TOKEN' })
    )
  })

  it('has admin-mfe-root wrapper class', () => {
    const { container } = render(<AdminMFE authToken="test-token" />)
    expect(container.querySelector('.admin-mfe-root')).toBeInTheDocument()
  })

  it('does not call setAuthToken when authToken is empty', () => {
    render(<AdminMFE authToken="" />)
    expect(mockSetAuthToken).not.toHaveBeenCalled()
  })

  it('renders error boundary fallback when child throws', () => {
    // Suppress React error boundary console output
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})
    shouldThrow = true

    render(<AdminMFE authToken="test-token" />)

    expect(screen.getByText('Admin Panel temporarily unavailable')).toBeInTheDocument()
    expect(screen.getByText('Reload Page')).toBeInTheDocument()
    consoleSpy.mockRestore()
  })

  it('calls onError with MFE_RENDER_ERROR when child throws', () => {
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})
    shouldThrow = true
    const onError = vi.fn()

    render(<AdminMFE authToken="test-token" onError={onError} />)

    expect(onError).toHaveBeenCalledWith(
      expect.objectContaining({
        code: 'MFE_RENDER_ERROR',
        message: 'Render explosion'
      })
    )
    consoleSpy.mockRestore()
  })

  it('displays error ID in error boundary fallback', () => {
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})
    shouldThrow = true

    render(<AdminMFE authToken="test-token" />)

    const errorText = screen.getByText(/Error ID:/)
    expect(errorText).toBeInTheDocument()
    consoleSpy.mockRestore()
  })

  it('renders error boundary without onError callback', () => {
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})
    shouldThrow = true

    render(<AdminMFE authToken="test-token" />)

    expect(screen.getByText('Admin Panel temporarily unavailable')).toBeInTheDocument()
    consoleSpy.mockRestore()
  })

  it('passes default permissions when none provided', () => {
    render(<AdminMFE authToken="test-token" />)
    expect(screen.getByTestId('admin-screen')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/__tests__/main.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'

vi.mock('../AdminMFE', () => ({
  AdminMFE: (props: any) => <div data-testid="admin-mfe" data-auth={props.authToken}>{props.authToken}</div>
}))

vi.mock('../utils/core/debug', () => ({
  createLogger: () => ({
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
    debug: vi.fn()
  })
}))

describe('main.tsx', () => {
  beforeEach(() => {
    // Create a root element for ReactDOM
    const root = document.createElement('div')
    root.id = 'root'
    document.body.innerHTML = ''
    document.body.appendChild(root)
  })

  it('renders AdminMFE into root element', async () => {
    await import('../main')
    expect(document.getElementById('root')).toBeTruthy()
  })

  it('sets global base path', async () => {
    await import('../main')
    expect((globalThis as any).__ADMIN_MFE_BASE_PATH__).toBeDefined()
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/admin-layout-extra.test.tsx
import { describe, expect, it, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'
import type { AdminPermissions } from '../admin-layout'

vi.mock('../admin-sidebar', () => ({
  AdminSidebar: ({ activeView, onViewChange, mobile, collapsed, onToggleCollapse }: any) => (
    <div data-testid={mobile ? 'sidebar-mobile' : 'sidebar'} data-active={activeView} data-collapsed={collapsed}>
      <button data-testid="nav-notices" onClick={() => onViewChange('notices')}>notices</button>
      <button data-testid="nav-ad-groups" onClick={() => onViewChange('ad-groups')}>ad-groups</button>
      <button data-testid="nav-pending" onClick={() => onViewChange('pending-approvals')}>pending</button>
      {onToggleCollapse && <button data-testid="toggle-collapse" onClick={onToggleCollapse}>toggle</button>}
    </div>
  )
}))

vi.mock('@/components/common/brand-loader', () => ({
  BrandLoader: () => <div data-testid="brand-loader">Loading...</div>
}))

vi.mock('../ad-groups-view', () => ({
  AdGroupsView: () => <div data-testid="ad-groups-view">AD Groups</div>
}))

vi.mock('../pending-approvals-view/pending-approvals-view', () => ({
  PendingApprovalsView: () => <div data-testid="pending-approvals-view">Pending</div>
}))

vi.mock('../views/notice-management-view', () => ({
  NoticeManagementView: () => <div data-testid="notice-management-view">Notices</div>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>
}))

vi.mock('../../ui/sheet', () => ({
  Sheet: ({ children, open }: any) => open ? <div data-testid="mobile-sheet">{children}</div> : null,
  SheetContent: ({ children }: any) => <div>{children}</div>,
  SheetHeader: ({ children }: any) => <div>{children}</div>,
  SheetTitle: ({ children }: any) => <h2>{children}</h2>,
  SheetDescription: ({ children }: any) => <p>{children}</p>
}))

vi.mock('lucide-react', () => ({
  Menu: () => <span data-testid="menu-icon" />
}))

const allPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

describe('AdminLayout - extra coverage', () => {
  beforeEach(() => {
    localStorage.clear()
    vi.clearAllMocks()
  })

  it('renders mobile navigation button', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    expect(screen.getByText('Navigation')).toBeInTheDocument()
  })

  it('opens mobile nav on navigation button click', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    fireEvent.click(screen.getByText('Navigation'))
    expect(screen.getByTestId('mobile-sheet')).toBeInTheDocument()
  })

  it('closes mobile nav when selecting a view', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    // Open mobile nav
    fireEvent.click(screen.getByText('Navigation'))
    // Click a nav item in the mobile sidebar
    const mobileNav = screen.getByTestId('sidebar-mobile')
    const noticesBtn = mobileNav.querySelector('[data-testid="nav-notices"]')!
    fireEvent.click(noticesBtn)
    // Mobile sheet should close
    expect(screen.queryByTestId('mobile-sheet')).not.toBeInTheDocument()
  })

  it('toggles sidebar collapsed state', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    const toggle = screen.getByTestId('toggle-collapse')
    fireEvent.click(toggle)
    expect(localStorage.getItem('admin-sidebar-collapsed')).toBe('true')
  })

  it('restores collapsed state from localStorage', async () => {
    localStorage.setItem('admin-sidebar-collapsed', 'true')
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    const sidebar = screen.getByTestId('sidebar')
    expect(sidebar.dataset.collapsed).toBe('true')
  })

  it('defaults to ad-groups view when no saved view', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    expect(screen.getByTestId('sidebar')).toHaveAttribute('data-active', 'ad-groups')
  })

  it('falls back to first available view when saved view is invalid', async () => {
    localStorage.setItem('admin-active-view', 'nonexistent')
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    expect(screen.getByTestId('sidebar')).toHaveAttribute('data-active', 'ad-groups')
  })

  it('renders pending-approvals view when navigated', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    fireEvent.click(screen.getByTestId('nav-pending'))
    expect(localStorage.getItem('admin-active-view')).toBe('pending-approvals')
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/admin-layout-helpers.test.ts
// @vitest-environment jsdom
import { describe, it, expect, beforeEach } from 'vitest'
import {
  resolveAvailableViews,
  resolveInitialView,
  resolveActiveView,
  getSavedSidebarCollapsed,
  ADMIN_SIDEBAR_COLLAPSED_KEY
} from '../admin-layout-helpers'
import type { AdminPermissions } from '../admin-layout'

const makePermissions = (overrides: Partial<AdminPermissions> = {}): AdminPermissions => ({
  canPreviewDashboards: false,
  canViewRoleTemplates: false,
  canViewAdGroups: false,
  canViewPendingApprovals: false,
  canApproveChanges: false,
  canEditBusinessInfo: false,
  canEditPermissions: false,
  canEditApplications: false,
  canEnableDisableGroups: false,
  canDirectSave: false,
  canViewNotices: false,
  canCreateNotice: false,
  canEditNotice: false,
  canPublishNotice: false,
  canArchiveNotice: false,
  canSaveDraft: false,
  ...overrides
})

describe('resolveAvailableViews', () => {
  it('returns empty array when no permissions', () => {
    expect(resolveAvailableViews(makePermissions())).toEqual([])
  })

  it('includes ad-groups when canViewAdGroups is true', () => {
    const views = resolveAvailableViews(makePermissions({ canViewAdGroups: true }))
    expect(views).toContain('ad-groups')
  })

  it('includes pending-approvals when canViewPendingApprovals is true', () => {
    const views = resolveAvailableViews(makePermissions({ canViewPendingApprovals: true }))
    expect(views).toContain('pending-approvals')
  })

  it('includes notices when canViewNotices is true', () => {
    const views = resolveAvailableViews(makePermissions({ canViewNotices: true }))
    expect(views).toContain('notices')
  })

  it('returns all views when all permissions enabled', () => {
    const views = resolveAvailableViews(makePermissions({
      canViewAdGroups: true,
      canViewPendingApprovals: true,
      canViewNotices: true
    }))
    expect(views).toHaveLength(3)
  })
})

describe('resolveInitialView', () => {
  it('returns saved view if available', () => {
    expect(resolveInitialView('notices', ['ad-groups', 'notices'])).toBe('notices')
  })

  it('falls back to first available when saved view is not available', () => {
    expect(resolveInitialView('notices', ['ad-groups'])).toBe('ad-groups')
  })

  it('returns null when no views available', () => {
    expect(resolveInitialView(null, [])).toBeNull()
  })
})

describe('resolveActiveView', () => {
  it('keeps active view when still available', () => {
    expect(resolveActiveView('ad-groups', ['ad-groups', 'notices'])).toBe('ad-groups')
  })

  it('falls back to first when active no longer available', () => {
    expect(resolveActiveView('notices', ['ad-groups'])).toBe('ad-groups')
  })

  it('returns null when no views available', () => {
    expect(resolveActiveView(null, [])).toBeNull()
  })
})

describe('getSavedSidebarCollapsed', () => {
  beforeEach(() => {
    localStorage.clear()
  })

  it('returns false by default', () => {
    expect(getSavedSidebarCollapsed()).toBe(false)
  })

  it('returns true when stored as "true"', () => {
    localStorage.setItem(ADMIN_SIDEBAR_COLLAPSED_KEY, 'true')
    expect(getSavedSidebarCollapsed()).toBe(true)
  })

  it('returns false for other values', () => {
    localStorage.setItem(ADMIN_SIDEBAR_COLLAPSED_KEY, 'false')
    expect(getSavedSidebarCollapsed()).toBe(false)
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/admin-layout.test.ts
import { describe, expect, it } from 'vitest'
import { resolveActiveView, resolveAvailableViews, resolveInitialView, type AdminPermissions } from '../admin-layout'

function makePermissions(overrides: Partial<AdminPermissions> = {}): AdminPermissions {
  return {
    canPreviewDashboards: false,
    canViewRoleTemplates: false,
    canViewAdGroups: false,
    canViewPendingApprovals: false,
    canApproveChanges: false,
    canEditBusinessInfo: false,
    canEditPermissions: false,
    canEditApplications: false,
    canEnableDisableGroups: false,
    canDirectSave: false,
    canViewNotices: false,
    canCreateNotice: false,
    canEditNotice: false,
    canPublishNotice: false,
    canArchiveNotice: false,
    canSaveDraft: false,
    ...overrides
  }
}

describe('admin layout view resolution', () => {
  it('returns views in expected order by capability', () => {
    const permissions = makePermissions({
      canViewRoleTemplates: true,
      canViewAdGroups: true,
      canViewPendingApprovals: true,
      canViewNotices: true
    })

    expect(resolveAvailableViews(permissions)).toEqual([
      'ad-groups',
      'pending-approvals',
      'notices'
    ])
  })

  it('returns null when no views are available', () => {
    const views = resolveAvailableViews(makePermissions())
    expect(resolveInitialView(null, views)).toBeNull()
  })

  it('keeps saved view only when still available', () => {
    const views = resolveAvailableViews(makePermissions({ canViewAdGroups: true }))

    expect(resolveInitialView('ad-groups', views)).toBe('ad-groups')
    expect(resolveInitialView('notices', views)).toBe('ad-groups')
  })

  it('falls back to first available view when active view becomes unavailable', () => {
    const views = resolveAvailableViews(makePermissions({ canViewAdGroups: true }))
    expect(resolveActiveView('pending-approvals', views)).toBe('ad-groups')
  })

  it('keeps active view when still available', () => {
    const views = resolveAvailableViews(makePermissions({ canViewNotices: true }))
    expect(resolveActiveView('notices', views)).toBe('notices')
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/admin-layout.test.tsx
import { describe, expect, it, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'
import { resolveAvailableViews, resolveInitialView, resolveActiveView } from '../admin-layout'
import type { AdminPermissions } from '../admin-layout'

vi.mock('../admin-sidebar', () => ({
  AdminSidebar: ({ activeView, onViewChange }: { activeView: string; onViewChange: (v: string) => void }) => (
    <div data-testid="sidebar" data-active={activeView}>
      <button data-testid="nav-notices" onClick={() => onViewChange('notices')}>notices</button>
      <button data-testid="nav-ad-groups" onClick={() => onViewChange('ad-groups')}>ad-groups</button>
    </div>
  )
}))

vi.mock('@/components/common/brand-loader', () => ({
  BrandLoader: () => <div data-testid="brand-loader">Loading...</div>
}))

vi.mock('../ad-groups-view', () => ({
  AdGroupsView: () => <div data-testid="ad-groups-view">AD Groups</div>
}))

vi.mock('../pending-approvals-view/pending-approvals-view', () => ({
  PendingApprovalsView: () => <div data-testid="pending-approvals-view">Pending</div>
}))

vi.mock('../views/notice-management-view', () => ({
  NoticeManagementView: () => <div data-testid="notice-management-view">Notices</div>
}))

const allPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

const noPermissions: AdminPermissions = {
  canPreviewDashboards: false,
  canViewRoleTemplates: false,
  canViewAdGroups: false,
  canViewPendingApprovals: false,
  canApproveChanges: false,
  canEditBusinessInfo: false,
  canEditPermissions: false,
  canEditApplications: false,
  canEnableDisableGroups: false,
  canDirectSave: false,
  canViewNotices: false,
  canCreateNotice: false,
  canEditNotice: false,
  canPublishNotice: false,
  canArchiveNotice: false,
  canSaveDraft: false
}

describe('resolveAvailableViews', () => {
  it('returns all views when all permissions granted', () => {
    const views = resolveAvailableViews(allPermissions)
    expect(views).toEqual(['ad-groups', 'pending-approvals', 'notices'])
  })

  it('returns empty array when no permissions', () => {
    const views = resolveAvailableViews(noPermissions)
    expect(views).toEqual([])
  })

  it('returns only ad-groups when only that permission is set', () => {
    const views = resolveAvailableViews({ ...noPermissions, canViewAdGroups: true })
    expect(views).toEqual(['ad-groups'])
  })

  it('returns only notices when only that permission is set', () => {
    const views = resolveAvailableViews({ ...noPermissions, canViewNotices: true })
    expect(views).toEqual(['notices'])
  })
})

describe('resolveInitialView', () => {
  it('returns saved view if available', () => {
    expect(resolveInitialView('notices', ['ad-groups', 'notices'])).toBe('notices')
  })

  it('returns first available if saved not in list', () => {
    expect(resolveInitialView('notices', ['ad-groups'])).toBe('ad-groups')
  })

  it('returns null if no views available', () => {
    expect(resolveInitialView('notices', [])).toBeNull()
  })

  it('returns first available if saved is null', () => {
    expect(resolveInitialView(null, ['ad-groups', 'notices'])).toBe('ad-groups')
  })
})

describe('resolveActiveView', () => {
  it('returns active view if in available list', () => {
    expect(resolveActiveView('notices', ['ad-groups', 'notices'])).toBe('notices')
  })

  it('returns first available if active not in list', () => {
    expect(resolveActiveView('notices', ['ad-groups'])).toBe('ad-groups')
  })

  it('returns null if no views available', () => {
    expect(resolveActiveView('notices', [])).toBeNull()
  })

  it('returns first available if active is null', () => {
    expect(resolveActiveView(null, ['pending-approvals'])).toBe('pending-approvals')
  })
})

describe('AdminLayout component', () => {
  beforeEach(() => {
    localStorage.clear()
  })

  it('renders no-access message when no permissions', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={noPermissions} currentRole="admin" />)
    expect(screen.getByText('No admin access configured for your account')).toBeInTheDocument()
  })

  it('renders sidebar and main content with permissions', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    expect(screen.getByTestId('sidebar')).toBeInTheDocument()
  })

  it('navigates to a different view on sidebar click', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    fireEvent.click(screen.getByTestId('nav-notices'))
    expect(screen.getByTestId('sidebar')).toHaveAttribute('data-active', 'notices')
  })

  it('persists active view to localStorage', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    fireEvent.click(screen.getByTestId('nav-notices'))
    expect(localStorage.getItem('admin-active-view')).toBe('notices')
  })

  it('restores saved view from localStorage', async () => {
    localStorage.setItem('admin-active-view', 'notices')
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    expect(screen.getByTestId('sidebar')).toHaveAttribute('data-active', 'notices')
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/admin-screen.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../admin-layout', () => ({
  AdminLayout: ({ permissions, currentRole }: Record<string, unknown>) => (
    <div data-testid="admin-layout" data-role={currentRole}>
      {JSON.stringify(permissions)}
    </div>
  )
}))

import { AdminScreen } from '../admin-screen'

describe('AdminScreen', () => {
  const defaultPermissions = {
    canPreviewDashboards: false,
    canViewRoleTemplates: false,
    canViewAdGroups: true,
    canViewPendingApprovals: false,
    canApproveChanges: false,
    canEditBusinessInfo: false,
    canEditPermissions: false,
    canEditApplications: false,
    canEnableDisableGroups: false,
    canDirectSave: false,
    canViewNotices: false,
    canCreateNotice: false,
    canEditNotice: false,
    canPublishNotice: false,
    canArchiveNotice: false,
    canSaveDraft: false
  }

  it('renders AdminLayout with permissions and currentRole', () => {
    render(<AdminScreen permissions={defaultPermissions} currentRole="admin" />)
    const layout = screen.getByTestId('admin-layout')
    expect(layout).toBeInTheDocument()
    expect(layout).toHaveAttribute('data-role', 'admin')
  })

  it('passes permissions to AdminLayout', () => {
    render(<AdminScreen permissions={defaultPermissions} currentRole="maker" />)
    const layout = screen.getByTestId('admin-layout')
    expect(layout.textContent).toContain('"canViewAdGroups":true')
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/admin-sidebar.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../hooks/admin/use-pending-changes', () => ({
  usePendingChangesCount: () => ({ data: { total: 5 } })
}))

vi.mock('../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

vi.mock('lucide-react', () => ({
  Bell: (props: Record<string, unknown>) => <span data-testid="bell-icon" {...props} />,
  ClipboardCheck: (props: Record<string, unknown>) => <span data-testid="clipboard-icon" {...props} />,
  Users: (props: Record<string, unknown>) => <span data-testid="users-icon" {...props} />,
  ChevronLeft: (props: Record<string, unknown>) => <span data-testid="chevron-left-icon" {...props} />,
  ChevronRight: (props: Record<string, unknown>) => <span data-testid="chevron-right-icon" {...props} />
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, className, ...rest }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} className={className as string} {...rest}>{children as React.ReactNode}</button>
  )
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children, ...rest }: Record<string, unknown>) => <span {...rest}>{children as React.ReactNode}</span>
}))

import { AdminSidebar } from '../admin-sidebar'
import type { AdminPermissions } from '../admin-layout'

const allPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

const noPermissions: AdminPermissions = {
  canPreviewDashboards: false,
  canViewRoleTemplates: false,
  canViewAdGroups: false,
  canViewPendingApprovals: false,
  canApproveChanges: false,
  canEditBusinessInfo: false,
  canEditPermissions: false,
  canEditApplications: false,
  canEnableDisableGroups: false,
  canDirectSave: false,
  canViewNotices: false,
  canCreateNotice: false,
  canEditNotice: false,
  canPublishNotice: false,
  canArchiveNotice: false,
  canSaveDraft: false
}

describe('AdminSidebar', () => {
  it('renders navigation landmark', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={allPermissions}
      />
    )
    expect(screen.getByLabelText('Admin navigation')).toBeInTheDocument()
  })

  it('renders all nav items when permissions allow', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={allPermissions}
      />
    )
    expect(screen.getByText('AD Groups')).toBeInTheDocument()
    expect(screen.getByText('Pending Approvals')).toBeInTheDocument()
    expect(screen.getByText('System Notices')).toBeInTheDocument()
  })

  it('renders no nav items when no permissions', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={noPermissions}
      />
    )
    expect(screen.queryByText('AD Groups')).not.toBeInTheDocument()
    expect(screen.queryByText('Pending Approvals')).not.toBeInTheDocument()
    expect(screen.queryByText('System Notices')).not.toBeInTheDocument()
  })

  it('shows only permitted nav items', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={{ ...noPermissions, canViewAdGroups: true }}
      />
    )
    expect(screen.getByText('AD Groups')).toBeInTheDocument()
    expect(screen.queryByText('Pending Approvals')).not.toBeInTheDocument()
  })

  it('shows pending count badge', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={allPermissions}
      />
    )
    expect(screen.getByText('5')).toBeInTheDocument()
  })

  it('calls onViewChange when nav item clicked', () => {
    const onViewChange = vi.fn()
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={onViewChange}
        permissions={allPermissions}
      />
    )
    fireEvent.click(screen.getByText('System Notices'))
    expect(onViewChange).toHaveBeenCalledWith('notices')
  })

  it('renders description text for nav items', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={allPermissions}
      />
    )
    expect(screen.getByText('Manage Permissions')).toBeInTheDocument()
    expect(screen.getByText('Review Changes')).toBeInTheDocument()
    expect(screen.getByText('Broadcast Messages')).toBeInTheDocument()
  })

  it('renders collapse button in desktop mode', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={allPermissions}
        onToggleCollapse={vi.fn()}
      />
    )
    expect(screen.getByLabelText('Collapse navigation')).toBeInTheDocument()
  })

  it('hides descriptions when collapsed', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={allPermissions}
        collapsed
      />
    )
    expect(screen.queryByText('Manage Permissions')).not.toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/app-card.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  CheckCircle: (p: Record<string, unknown>) => <span data-testid="check-circle" {...p} />,
  Package: (p: Record<string, unknown>) => <span data-testid="package" {...p} />
}))

vi.mock('../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

vi.mock('../../ui/card', () => ({
  Card: ({ children, onClick, className }: any) => <div data-testid="card" className={className} onClick={onClick}>{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children }: any) => <span data-testid="badge">{children}</span>
}))

import { AppCard } from '../app-card'

const baseApp = {
  appIdentifier: 'app-1',
  titleText: 'Test App',
  descriptionText: 'Test description',
  categoryName: 'Category A',
  isAssignedIndicator: false,
  assignedFunctionKeys: [] as string[],
}

describe('AppCard', () => {
  it('renders app title and description', () => {
    render(<AppCard app={baseApp as any} selected={false} onClick={vi.fn()} />)
    expect(screen.getByText('Test App')).toBeInTheDocument()
    expect(screen.getByText('Test description')).toBeInTheDocument()
  })

  it('renders category badge', () => {
    render(<AppCard app={baseApp as any} selected={false} onClick={vi.fn()} />)
    expect(screen.getByText('Category A')).toBeInTheDocument()
  })

  it('calls onClick when clicked', () => {
    const onClick = vi.fn()
    render(<AppCard app={baseApp as any} selected={false} onClick={onClick} />)
    fireEvent.click(screen.getByTestId('card'))
    expect(onClick).toHaveBeenCalled()
  })

  it('shows check icon when assigned', () => {
    const assigned = { ...baseApp, isAssignedIndicator: true, assignedFunctionKeys: ['f1', 'f2'] }
    render(<AppCard app={assigned as any} selected={false} onClick={vi.fn()} />)
    expect(screen.getByTestId('check-circle')).toBeInTheDocument()
  })

  it('shows function count badge when assigned', () => {
    const assigned = { ...baseApp, isAssignedIndicator: true, assignedFunctionKeys: ['f1', 'f2'] }
    render(<AppCard app={assigned as any} selected={false} onClick={vi.fn()} />)
    expect(screen.getByText('2 features')).toBeInTheDocument()
  })

  it('does not show check icon when not assigned', () => {
    render(<AppCard app={baseApp as any} selected={false} onClick={vi.fn()} />)
    expect(screen.queryByTestId('check-circle')).not.toBeInTheDocument()
  })

  it('applies selected styles', () => {
    render(<AppCard app={baseApp as any} selected={true} onClick={vi.fn()} />)
    const card = screen.getByTestId('card')
    expect(card.className).toContain('border-blue-500')
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/bulk-copy-confirmation-dialog.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import type { AdGroup } from '../../../types/features/ad-group-config'
import type { BulkCopyExecutionOptions } from '../../../hooks/admin/use-ad-groups-selection'

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} disabled={disabled as boolean}>{children as React.ReactNode}</button>
  )
}))

vi.mock('../../ui/checkbox', () => ({
  Checkbox: ({ id, checked }: Record<string, unknown>) => (
    <input type="checkbox" data-testid={`checkbox-${id}`} defaultChecked={checked as boolean} readOnly />
  )
}))

vi.mock('../../ui/label', () => ({
  Label: ({ children, htmlFor }: { children: React.ReactNode; htmlFor?: string }) => (
    <label htmlFor={htmlFor}>{children}</label>
  )
}))

vi.mock('../../ui/dialog', () => ({
  Dialog: ({ children, open }: { children: React.ReactNode; open: boolean }) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  DialogHeader: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  DialogTitle: ({ children }: { children: React.ReactNode }) => <h2>{children}</h2>,
  DialogDescription: ({ children }: { children: React.ReactNode }) => <p>{children}</p>,
  DialogFooter: ({ children }: { children: React.ReactNode }) => <div>{children}</div>
}))

vi.mock('../../ui/select', () => ({
  Select: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  SelectContent: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  SelectItem: ({ children, value }: { children: React.ReactNode; value: string }) => <option value={value}>{children}</option>,
  SelectTrigger: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  SelectValue: () => <span />
}))

import { BulkCopyConfirmationDialog } from '../bulk-copy-confirmation-dialog'

const makeGroup = (overrides: Partial<AdGroup> = {}): AdGroup => ({
  id: '1',
  groupIdentifier: 'CN=test-group',
  isActive: true,
  logicalName: 'Test Group',
  ...overrides
} as AdGroup)

const defaultOptions: BulkCopyExecutionOptions = {
  copyRoleAndPermissionsFlag: true,
  copyBusinessInfoFlag: true,
  copyApplicationsFlag: true,
  copyWorkflowModeCode: 'SUBMIT_FOR_APPROVAL',
  functionMismatchPolicyCode: 'FAIL_ON_MISMATCH'
}

describe('BulkCopyConfirmationDialog', () => {
  const baseProps = {
    open: true,
    sourceGroup: makeGroup({ logicalName: 'Source Group' }),
    targetGroups: [makeGroup({ id: '2', logicalName: 'Target A' }), makeGroup({ id: '3', logicalName: 'Target B' })],
    targetCount: 2,
    copyOptions: defaultOptions,
    onCopyOptionsChange: vi.fn(),
    isProcessing: false,
    onConfirm: vi.fn(),
    onCancel: vi.fn()
  }

  it('renders dialog title when open', () => {
    render(<BulkCopyConfirmationDialog {...baseProps} />)
    expect(screen.getByText('Confirm bulk copy')).toBeInTheDocument()
  })

  it('does not render when closed', () => {
    render(<BulkCopyConfirmationDialog {...baseProps} open={false} />)
    expect(screen.queryByText('Confirm bulk copy')).not.toBeInTheDocument()
  })

  it('displays source group name', () => {
    render(<BulkCopyConfirmationDialog {...baseProps} />)
    expect(screen.getByText('Source Group')).toBeInTheDocument()
  })

  it('displays target groups count', () => {
    render(<BulkCopyConfirmationDialog {...baseProps} />)
    expect(screen.getByText('Target groups (2)')).toBeInTheDocument()
  })

  it('displays target group names', () => {
    render(<BulkCopyConfirmationDialog {...baseProps} />)
    expect(screen.getByText('Target A')).toBeInTheDocument()
    expect(screen.getByText('Target B')).toBeInTheDocument()
  })

  it('shows copy option labels', () => {
    render(<BulkCopyConfirmationDialog {...baseProps} />)
    expect(screen.getByText('Role and permission settings')).toBeInTheDocument()
    expect(screen.getByText('Business information')).toBeInTheDocument()
    expect(screen.getByText('Applications and functions')).toBeInTheDocument()
  })

  it('shows Confirm copy button', () => {
    render(<BulkCopyConfirmationDialog {...baseProps} />)
    expect(screen.getByText('Confirm copy')).toBeInTheDocument()
  })

  it('shows Copying... when processing', () => {
    render(<BulkCopyConfirmationDialog {...baseProps} isProcessing={true} />)
    expect(screen.getByText('Copying...')).toBeInTheDocument()
  })

  it('disables confirm when no targets', () => {
    render(<BulkCopyConfirmationDialog {...baseProps} targetCount={0} targetGroups={[]} />)
    expect(screen.getByText('Confirm copy')).toBeDisabled()
  })

  it('disables confirm when no copy sections selected', () => {
    const noCopyOptions: BulkCopyExecutionOptions = {
      ...defaultOptions,
      copyRoleAndPermissionsFlag: false,
      copyBusinessInfoFlag: false,
      copyApplicationsFlag: false
    }
    render(<BulkCopyConfirmationDialog {...baseProps} copyOptions={noCopyOptions} />)
    expect(screen.getByText('Select at least one section to copy.')).toBeInTheDocument()
    expect(screen.getByText('Confirm copy')).toBeDisabled()
  })

  it('shows no groups selected message when empty targets', () => {
    render(<BulkCopyConfirmationDialog {...baseProps} targetGroups={[]} targetCount={0} />)
    expect(screen.getByText('No groups selected.')).toBeInTheDocument()
  })

  it('shows Unconfigured Group when logicalName is missing', () => {
    const targets = [makeGroup({ id: '2', logicalName: undefined })]
    render(<BulkCopyConfirmationDialog {...baseProps} targetGroups={targets} />)
    expect(screen.getByText('Unconfigured Group')).toBeInTheDocument()
  })

  it('shows group identifiers', () => {
    render(<BulkCopyConfirmationDialog {...baseProps} />)
    const identifiers = screen.getAllByText('CN=test-group')
    expect(identifiers.length).toBeGreaterThanOrEqual(1)
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/bulk-operations-helpers.test.ts
import { describe, it, expect } from 'vitest'
import { getDefaultCopyOptions, resolvePendingTargetGroups } from '../bulk-operations-helpers'

describe('getDefaultCopyOptions', () => {
  it('returns default options with all flags enabled', () => {
    const options = getDefaultCopyOptions()
    expect(options.copyRoleAndPermissionsFlag).toBe(true)
    expect(options.copyBusinessInfoFlag).toBe(true)
    expect(options.copyApplicationsFlag).toBe(true)
  })

  it('defaults to SUBMIT_FOR_APPROVAL workflow mode', () => {
    const options = getDefaultCopyOptions()
    expect(options.copyWorkflowModeCode).toBe('SUBMIT_FOR_APPROVAL')
  })

  it('defaults to FAIL_ON_MISMATCH policy', () => {
    const options = getDefaultCopyOptions()
    expect(options.functionMismatchPolicyCode).toBe('FAIL_ON_MISMATCH')
  })
})

describe('resolvePendingTargetGroups', () => {
  const makeGroup = (id: string) => ({
    id,
    groupIdentifier: `CN=${id}`,
    isActive: true,
    roleName: 'voice_agent'
  })

  it('returns empty array when no pending IDs', () => {
    expect(resolvePendingTargetGroups([], [makeGroup('a')])).toEqual([])
  })

  it('resolves groups from the available groups list', () => {
    const groups = [makeGroup('a'), makeGroup('b'), makeGroup('c')]
    const result = resolvePendingTargetGroups(['a', 'c'], groups as never[])
    expect(result).toHaveLength(2)
    expect(result[0].id).toBe('a')
    expect(result[1].id).toBe('c')
  })

  it('filters out IDs not found in the groups list', () => {
    const groups = [makeGroup('a')]
    const result = resolvePendingTargetGroups(['a', 'missing'], groups as never[])
    expect(result).toHaveLength(1)
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/bulk-operations-toolbar-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'

vi.mock('../../../lib/utils', () => ({
  cn: (...a: unknown[]) => a.filter(Boolean).join(' ')
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled, variant, size, className }: any) => (
    <button onClick={onClick} disabled={disabled} data-variant={variant} className={className}>{children}</button>
  )
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

let copyModalOnSelect: any = null
vi.mock('../copy-source-selection-modal', () => ({
  CopySourceSelectionModal: ({ open, onSelect }: any) => {
    copyModalOnSelect = onSelect
    return open ? <div data-testid="copy-modal"><button data-testid="select-source" onClick={() => onSelect({ id: 'src', groupIdentifier: 'CN=src', logicalName: 'Source' })}>Select Source</button></div> : null
  }
}))

let confirmOnConfirm: any = null
let confirmOnCancel: any = null
vi.mock('../bulk-copy-confirmation-dialog', () => ({
  BulkCopyConfirmationDialog: ({ open, onConfirm, onCancel, sourceGroup, targetCount }: any) => {
    confirmOnConfirm = onConfirm
    confirmOnCancel = onCancel
    return open ? (
      <div data-testid="confirm-dialog">
        <span>Source: {sourceGroup?.logicalName}</span>
        <span>Targets: {targetCount}</span>
        <button data-testid="confirm-copy" onClick={onConfirm}>Confirm</button>
        <button data-testid="cancel-copy" onClick={onCancel}>Cancel</button>
      </div>
    ) : null
  }
}))

vi.mock('lucide-react', () => ({
  Copy: () => <span data-testid="copy-icon" />,
  CheckSquare: () => <span data-testid="check-square" />,
  Square: () => <span data-testid="square" />,
  MinusSquare: () => <span data-testid="minus-square" />,
  X: () => <span data-testid="x-icon" />
}))

vi.mock('../bulk-operations-helpers', () => ({
  getDefaultCopyOptions: () => ({ copyBusinessInfo: true, copyPermissions: true, copyApps: true }),
  resolvePendingTargetGroups: (ids: string[], groups: any[]) => groups.filter((g: any) => ids.includes(g.groupIdentifier))
}))

import { BulkOperationsToolbar } from '../bulk-operations-toolbar'

describe('BulkOperationsToolbar - extra coverage', () => {
  const baseProps = {
    selectedCount: 2,
    selectedVisibleCount: 2,
    totalCount: 10,
    visibleCount: 5,
    selectedGroups: ['CN=g1', 'CN=g2'],
    allAdGroups: [
      { id: '1', groupIdentifier: 'CN=g1', logicalName: 'Group 1' },
      { id: '2', groupIdentifier: 'CN=g2', logicalName: 'Group 2' },
      { id: '3', groupIdentifier: 'CN=src', logicalName: 'Source' }
    ] as any[],
    onSelectAll: vi.fn(),
    onDeselectAll: vi.fn(),
    onCopyFrom: vi.fn().mockResolvedValue(undefined),
    onSearchAdGroups: vi.fn().mockResolvedValue([]),
    isLookupLoading: false
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('shows visible count info', () => {
    render(<BulkOperationsToolbar {...baseProps} />)
    expect(screen.getByText('of 5 visible')).toBeInTheDocument()
  })

  it('shows total count when different from visible', () => {
    render(<BulkOperationsToolbar {...baseProps} />)
    expect(screen.getByText('(10 total)')).toBeInTheDocument()
  })

  it('hides total count when same as visible', () => {
    render(<BulkOperationsToolbar {...baseProps} totalCount={5} />)
    expect(screen.queryByText(/total\)/)).not.toBeInTheDocument()
  })

  it('shows CheckSquare when all visible selected', () => {
    render(<BulkOperationsToolbar {...baseProps} selectedVisibleCount={5} />)
    expect(screen.getByTestId('check-square')).toBeInTheDocument()
  })

  it('shows MinusSquare for partial selection', () => {
    render(<BulkOperationsToolbar {...baseProps} selectedVisibleCount={3} />)
    expect(screen.getByTestId('minus-square')).toBeInTheDocument()
  })

  it('shows Square when nothing selected on page', () => {
    render(<BulkOperationsToolbar {...baseProps} selectedVisibleCount={0} />)
    expect(screen.getByTestId('square')).toBeInTheDocument()
  })

  it('calls onDeselectAll when all are selected and toggle clicked', () => {
    render(<BulkOperationsToolbar {...baseProps} selectedVisibleCount={5} />)
    // Click the selection toggle button (the one containing the icon)
    const toggle = screen.getByTestId('check-square').closest('button')!
    fireEvent.click(toggle)
    expect(baseProps.onDeselectAll).toHaveBeenCalled()
  })

  it('calls onSelectAll when not all are selected and toggle clicked', () => {
    render(<BulkOperationsToolbar {...baseProps} selectedVisibleCount={3} />)
    const toggle = screen.getByTestId('minus-square').closest('button')!
    fireEvent.click(toggle)
    expect(baseProps.onSelectAll).toHaveBeenCalled()
  })

  it('opens copy modal then shows confirmation on source select', () => {
    render(<BulkOperationsToolbar {...baseProps} />)
    // Open copy modal
    fireEvent.click(screen.getByText('Copy From Another Group'))
    expect(screen.getByTestId('copy-modal')).toBeInTheDocument()
    // Select a source
    fireEvent.click(screen.getByTestId('select-source'))
    // Confirmation should now be showing
    expect(screen.getByTestId('confirm-dialog')).toBeInTheDocument()
    expect(screen.getByText('Source: Source')).toBeInTheDocument()
  })

  it('calls onCopyFrom when copy is confirmed', async () => {
    render(<BulkOperationsToolbar {...baseProps} />)
    // Open modal, select source
    fireEvent.click(screen.getByText('Copy From Another Group'))
    fireEvent.click(screen.getByTestId('select-source'))
    // Confirm
    fireEvent.click(screen.getByTestId('confirm-copy'))
    await waitFor(() => {
      expect(baseProps.onCopyFrom).toHaveBeenCalled()
    })
  })

  it('cancels confirmation dialog', () => {
    render(<BulkOperationsToolbar {...baseProps} />)
    fireEvent.click(screen.getByText('Copy From Another Group'))
    fireEvent.click(screen.getByTestId('select-source'))
    expect(screen.getByTestId('confirm-dialog')).toBeInTheDocument()
    fireEvent.click(screen.getByTestId('cancel-copy'))
    expect(screen.queryByTestId('confirm-dialog')).not.toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/bulk-operations-toolbar.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react'

vi.mock('../../../lib/utils', () => ({
  cn: (...a: unknown[]) => a.filter(Boolean).join(' ')
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled, variant, size, className }: any) => (
    <button onClick={onClick} disabled={disabled} data-variant={variant} className={className}>{children}</button>
  )
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('../../ui/checkbox', () => ({
  Checkbox: ({ id, checked, onCheckedChange }: any) => (
    <input type="checkbox" data-testid={`checkbox-${id}`} checked={checked} onChange={(e: any) => onCheckedChange?.(e.target.checked)} />
  )
}))

vi.mock('../../ui/label', () => ({
  Label: ({ children, htmlFor }: any) => <label htmlFor={htmlFor}>{children}</label>
}))

vi.mock('../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="confirm-dialog">{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))

vi.mock('../../ui/select', () => ({
  Select: ({ children }: any) => <div>{children}</div>,
  SelectContent: ({ children }: any) => <div>{children}</div>,
  SelectItem: ({ children }: any) => <div>{children}</div>,
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: () => <span />
}))

vi.mock('../copy-source-selection-modal', () => ({
  CopySourceSelectionModal: ({ open, onSelect }: any) =>
    open ? <div data-testid="copy-modal"><button data-testid="select-source" onClick={() => onSelect({ id: 'source', groupIdentifier: 'CN=source', logicalName: 'Source Group' })}>Select Source</button></div> : null
}))

vi.mock('../bulk-copy-confirmation-dialog', () => ({
  BulkCopyConfirmationDialog: ({ open, onConfirm, onCancel, isProcessing }: any) =>
    open ? <div data-testid="bulk-confirm"><button data-testid="confirm-copy" onClick={onConfirm}>Confirm</button><button data-testid="cancel-copy" onClick={onCancel}>Cancel</button></div> : null
}))

vi.mock('lucide-react', () => ({
  Copy: (p: any) => <span data-testid="copy-icon" {...p} />,
  CheckSquare: (p: any) => <span data-testid="check-square" {...p} />,
  Square: (p: any) => <span data-testid="square" {...p} />,
  MinusSquare: (p: any) => <span data-testid="minus-square" {...p} />,
  X: (p: any) => <span data-testid="x-icon" {...p} />
}))

import { BulkOperationsToolbar } from '../bulk-operations-toolbar'

describe('BulkOperationsToolbar', () => {
  const defaultProps = {
    selectedCount: 3,
    selectedVisibleCount: 3,
    totalCount: 10,
    visibleCount: 8,
    selectedGroups: ['g1', 'g2', 'g3'],
    allAdGroups: [
      { id: 'g1', groupIdentifier: 'CN=g1', logicalName: 'Group 1' },
      { id: 'g2', groupIdentifier: 'CN=g2', logicalName: 'Group 2' },
      { id: 'g3', groupIdentifier: 'CN=g3', logicalName: 'Group 3' }
    ] as any[],
    onSelectAll: vi.fn(),
    onDeselectAll: vi.fn(),
    onCopyFrom: vi.fn(),
    onSearchAdGroups: vi.fn(),
    isLookupLoading: false
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders nothing when no groups selected', () => {
    const { container } = render(
      <BulkOperationsToolbar {...defaultProps} selectedCount={0} />
    )
    expect(container.innerHTML).toBe('')
  })

  it('renders toolbar with selection count', () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    expect(screen.getByText(/3 selected/)).toBeInTheDocument()
  })

  it('renders clear selection button', () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    expect(screen.getByText('Clear selection')).toBeInTheDocument()
  })

  it('calls onDeselectAll when clear selection clicked', () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    fireEvent.click(screen.getByText('Clear selection'))
    expect(defaultProps.onDeselectAll).toHaveBeenCalled()
  })

  it('renders copy from another group button', () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    expect(screen.getByText('Copy From Another Group')).toBeInTheDocument()
  })

  it('opens copy modal on button click', () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    expect(screen.queryByTestId('copy-modal')).not.toBeInTheDocument()
    fireEvent.click(screen.getByText('Copy From Another Group'))
    expect(screen.getByTestId('copy-modal')).toBeInTheDocument()
  })

  it('shows total count when different from visible count', () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    expect(screen.getByText('(10 total)')).toBeInTheDocument()
  })

  it('hides total count when same as visible count', () => {
    render(<BulkOperationsToolbar {...defaultProps} totalCount={8} />)
    expect(screen.queryByText(/total/)).not.toBeInTheDocument()
  })

  it('shows visible count', () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    expect(screen.getByText('of 8 visible')).toBeInTheDocument()
  })

  it('shows check square icon when all visible selected', () => {
    render(<BulkOperationsToolbar {...defaultProps} selectedVisibleCount={8} visibleCount={8} />)
    expect(screen.getByTestId('check-square')).toBeInTheDocument()
  })

  it('shows minus square icon when partially selected', () => {
    render(<BulkOperationsToolbar {...defaultProps} selectedVisibleCount={3} visibleCount={8} />)
    expect(screen.getByTestId('minus-square')).toBeInTheDocument()
  })

  it('toggles to deselect when all selected', () => {
    render(<BulkOperationsToolbar {...defaultProps} selectedVisibleCount={8} visibleCount={8} />)
    fireEvent.click(screen.getByTestId('check-square').closest('button')!)
    expect(defaultProps.onDeselectAll).toHaveBeenCalled()
  })

  it('toggles to select all when partially selected', () => {
    render(<BulkOperationsToolbar {...defaultProps} selectedVisibleCount={3} visibleCount={8} />)
    fireEvent.click(screen.getByTestId('minus-square').closest('button')!)
    expect(defaultProps.onSelectAll).toHaveBeenCalled()
  })

  it('shows confirmation dialog after selecting source group', async () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    fireEvent.click(screen.getByText('Copy From Another Group'))
    await act(async () => {
      fireEvent.click(screen.getByTestId('select-source'))
    })
    expect(screen.getByTestId('bulk-confirm')).toBeInTheDocument()
  })

  it('executes copy on confirm', async () => {
    defaultProps.onCopyFrom.mockResolvedValue(undefined)
    render(<BulkOperationsToolbar {...defaultProps} />)
    fireEvent.click(screen.getByText('Copy From Another Group'))
    await act(async () => {
      fireEvent.click(screen.getByTestId('select-source'))
    })
    await act(async () => {
      fireEvent.click(screen.getByTestId('confirm-copy'))
    })
    expect(defaultProps.onCopyFrom).toHaveBeenCalled()
  })

  it('cancels confirmation dialog', async () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    fireEvent.click(screen.getByText('Copy From Another Group'))
    await act(async () => {
      fireEvent.click(screen.getByTestId('select-source'))
    })
    expect(screen.getByTestId('bulk-confirm')).toBeInTheDocument()
    fireEvent.click(screen.getByTestId('cancel-copy'))
    expect(screen.queryByTestId('bulk-confirm')).not.toBeInTheDocument()
  })

  it('applies custom className', () => {
    const { container } = render(<BulkOperationsToolbar {...defaultProps} className="custom-class" />)
    expect(container.innerHTML).toContain('custom-class')
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/business-relevant-toggles.test.ts
import { describe, expect, it } from 'vitest'
import { businessRelevantToggles, isToggleBusinessRelevant } from '../business-relevant-toggles'

describe('businessRelevantToggles', () => {
  it('has capabilities section with correct title', () => {
    expect(businessRelevantToggles.capabilities.title).toBe('Access Controls')
  })

  it('has workspacePreferences section with correct title', () => {
    expect(businessRelevantToggles.workspacePreferences.title).toBe('Workspace & Preferences')
  })

  it('capabilities has exactly 5 toggles', () => {
    expect(Object.keys(businessRelevantToggles.capabilities.toggles).length).toBe(5)
  })

  it('workspacePreferences has exactly 5 toggles', () => {
    expect(Object.keys(businessRelevantToggles.workspacePreferences.toggles).length).toBe(5)
  })

  it('capabilities contains the correct 5 toggle keys', () => {
    const keys = Object.keys(businessRelevantToggles.capabilities.toggles)
    expect(keys).toEqual([
      'columns.kms',
      'columns.embeddedApps',
      'columns.spaceCopilot',
      'columns.chat',
      'micro_frontends.mediaBar'
    ])
  })

  it('workspacePreferences contains the correct 5 toggle keys', () => {
    const keys = Object.keys(businessRelevantToggles.workspacePreferences.toggles)
    expect(keys).toEqual([
      'settings_options.calls.autoAccept',
      'settings_options.calls.doNotDisturb.duration',
      'settings_options.interface.showTranscript',
      'settings_options.interface.autoCloseKnowledgeOnCallEnd',
      'settings_options.interface.spaceCopilotMode'
    ])
  })

  it('has linkedKeys on Knowledge Base toggle', () => {
    const toggle = businessRelevantToggles.capabilities.toggles['columns.kms']
    expect(toggle.linkedKeys).toEqual(['features.search.knowledgeBase'])
  })

  it('has linkedKeys on Banking Applications toggle', () => {
    const toggle = businessRelevantToggles.capabilities.toggles['columns.embeddedApps']
    expect(toggle.linkedKeys).toEqual(['features.search.embeddedApps'])
  })

  it('has linkedKeys on AI Assistant toggle', () => {
    const toggle = businessRelevantToggles.capabilities.toggles['columns.spaceCopilot']
    expect(toggle.linkedKeys).toEqual(['micro_frontends.spaceCopilot'])
  })

  it('has linkedKeys on Media Controls toggle', () => {
    const toggle = businessRelevantToggles.capabilities.toggles['micro_frontends.mediaBar']
    expect(toggle.linkedKeys).toEqual(['widgets.mediaBar.callControls'])
  })

  it('Chat Interface has no linkedKeys', () => {
    const toggle = businessRelevantToggles.capabilities.toggles['columns.chat']
    expect(toggle.linkedKeys).toBeUndefined()
  })

  it('workspacePreferences toggles have no linkedKeys', () => {
    const toggles = businessRelevantToggles.workspacePreferences.toggles
    Object.values(toggles).forEach(toggle => {
      expect(toggle.linkedKeys).toBeUndefined()
    })
  })

  it('has no duplicate toggle keys across capabilities and workspacePreferences', () => {
    const capKeys = Object.keys(businessRelevantToggles.capabilities.toggles)
    const wpKeys = Object.keys(businessRelevantToggles.workspacePreferences.toggles)
    const allKeys = [...capKeys, ...wpKeys]
    expect(new Set(allKeys).size).toBe(allKeys.length)
  })

  it('capabilities toggles have section properties', () => {
    const toggles = businessRelevantToggles.capabilities.toggles
    expect(toggles['columns.kms'].section).toBe('Dashboard Access')
    expect(toggles['micro_frontends.mediaBar'].section).toBe('Platform Apps')
  })

  it('workspacePreferences toggles have section properties', () => {
    const toggles = businessRelevantToggles.workspacePreferences.toggles
    expect(toggles['settings_options.calls.autoAccept'].section).toBe('Call Preferences')
    expect(toggles['settings_options.interface.showTranscript'].section).toBe('Privacy & Display')
    expect(toggles['settings_options.interface.spaceCopilotMode'].section).toBe('AI Preference')
  })

  it('includes autoCloseKnowledgeOnCallEnd setting', () => {
    const toggle = businessRelevantToggles.workspacePreferences.toggles['settings_options.interface.autoCloseKnowledgeOnCallEnd']
    expect(toggle.visible).toBe(true)
    expect(toggle.businessName).toBe('Auto-Close Knowledge')
  })

  it('has admin views section', () => {
    expect(businessRelevantToggles.adminViews).toBeDefined()
    expect(businessRelevantToggles.adminViews.toggles['admin.roleTemplatesView'].visible).toBe(true)
  })

  it('has admin actions section', () => {
    expect(businessRelevantToggles.adminActions).toBeDefined()
    expect(businessRelevantToggles.adminActions.toggles['admin.editPermissions'].visible).toBe(true)
  })

  it('does not have standalone legacy sections', () => {
    expect(businessRelevantToggles['columns']).toBeUndefined()
    expect(businessRelevantToggles['features']).toBeUndefined()
    expect(businessRelevantToggles['widgets']).toBeUndefined()
    expect(businessRelevantToggles['settings_tabs']).toBeUndefined()
    expect(businessRelevantToggles['settings_options']).toBeUndefined()
    expect(businessRelevantToggles['micro_frontends']).toBeUndefined()
  })
})

describe('isToggleBusinessRelevant', () => {
  it('returns true for visible capabilities toggles', () => {
    expect(isToggleBusinessRelevant('capabilities', 'columns.kms')).toBe(true)
    expect(isToggleBusinessRelevant('capabilities', 'micro_frontends.mediaBar')).toBe(true)
  })

  it('returns true for visible workspacePreferences toggles', () => {
    expect(isToggleBusinessRelevant('workspacePreferences', 'settings_options.calls.autoAccept')).toBe(true)
    expect(isToggleBusinessRelevant('workspacePreferences', 'settings_options.interface.spaceCopilotMode')).toBe(true)
  })

  it('returns false for removed toggles', () => {
    expect(isToggleBusinessRelevant('workspacePreferences', 'widgets.customer.info')).toBe(false)
    expect(isToggleBusinessRelevant('workspacePreferences', 'settings_tabs.help')).toBe(false)
    expect(isToggleBusinessRelevant('capabilities', 'features.search.knowledgeBase')).toBe(false)
    expect(isToggleBusinessRelevant('capabilities', 'micro_frontends.spaceCopilot')).toBe(false)
  })

  it('returns false for unknown category', () => {
    expect(isToggleBusinessRelevant('nonexistent', 'key')).toBe(false)
  })

  it('returns false for unknown toggle key', () => {
    expect(isToggleBusinessRelevant('capabilities', 'nonexistent.key')).toBe(false)
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/copy-source-selection-modal-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: any) => (
    <button onClick={onClick} disabled={disabled}>{children}</button>
  )
}))

vi.mock('../../ui/input', () => ({
  Input: ({ onChange, value, placeholder }: any) => (
    <input data-testid="search-input" onChange={onChange} value={value} placeholder={placeholder} />
  )
}))

vi.mock('lucide-react', () => ({
  Search: () => <span />,
  Copy: () => <span />,
  X: () => <span data-testid="x-clear" />
}))

vi.mock('@/hooks/features/use-business-terminology', () => ({
  useBusinessRoles: () => ({})
}))

let lastOnSelect: any = null
vi.mock('../copy-source-sub-components', () => ({
  filterAndSortGroups: (groups: any[], excludeIds: string[]) =>
    groups.filter((g: any) => !excludeIds.includes(g.groupIdentifier)),
  GroupsListContent: ({ filteredGroups, onSelect, selectedGroup }: any) => {
    lastOnSelect = onSelect
    return (
      <div data-testid="groups-list">
        {filteredGroups.map((g: any) => (
          <button key={g.id} data-testid={`group-${g.id}`} onClick={() => onSelect(g)}>{g.logicalName}</button>
        ))}
      </div>
    )
  }
}))

import { CopySourceSelectionModal } from '../copy-source-selection-modal'

describe('CopySourceSelectionModal - extra coverage', () => {
  const groups = [
    { id: '1', groupIdentifier: 'CN=g1', logicalName: 'Alpha Group', roleName: 'voice_agent' },
    { id: '2', groupIdentifier: 'CN=g2', logicalName: 'Beta Group', roleName: 'chat_agent' }
  ] as any[]

  const baseProps = {
    open: true,
    onOpenChange: vi.fn(),
    adGroups: groups,
    excludeGroupIds: [],
    onSelect: vi.fn(),
    isLoading: false
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('shows group count plural', () => {
    render(<CopySourceSelectionModal {...baseProps} />)
    expect(screen.getByText('2 groups available')).toBeInTheDocument()
  })

  it('shows group count singular for 1 group', () => {
    render(<CopySourceSelectionModal {...baseProps} adGroups={[groups[0]]} />)
    expect(screen.getByText('1 group available')).toBeInTheDocument()
  })

  it('enables copy button after selecting a group', () => {
    render(<CopySourceSelectionModal {...baseProps} />)
    expect(screen.getByText('Copy Configuration')).toBeDisabled()
    fireEvent.click(screen.getByTestId('group-1'))
    expect(screen.getByText('Copy Configuration')).not.toBeDisabled()
  })

  it('calls onSelect with selected group on copy click', () => {
    render(<CopySourceSelectionModal {...baseProps} />)
    fireEvent.click(screen.getByTestId('group-1'))
    fireEvent.click(screen.getByText('Copy Configuration'))
    expect(baseProps.onSelect).toHaveBeenCalledWith(groups[0])
  })

  it('resets state on cancel', () => {
    render(<CopySourceSelectionModal {...baseProps} />)
    fireEvent.click(screen.getByTestId('group-1'))
    fireEvent.click(screen.getByText('Cancel'))
    expect(baseProps.onOpenChange).toHaveBeenCalledWith(false)
  })

  it('shows Copying... when loading', () => {
    render(<CopySourceSelectionModal {...baseProps} isLoading={true} />)
    expect(screen.getByText('Copying...')).toBeInTheDocument()
  })

  it('disables cancel when loading', () => {
    render(<CopySourceSelectionModal {...baseProps} isLoading={true} />)
    expect(screen.getByText('Cancel')).toBeDisabled()
  })

  it('updates search input', () => {
    render(<CopySourceSelectionModal {...baseProps} />)
    const input = screen.getByTestId('search-input')
    fireEvent.change(input, { target: { value: 'alpha' } })
    expect(input).toHaveValue('alpha')
  })

  it('shows clear button when search has value', () => {
    render(<CopySourceSelectionModal {...baseProps} />)
    const input = screen.getByTestId('search-input')
    fireEvent.change(input, { target: { value: 'test' } })
    expect(screen.getByTestId('x-clear')).toBeInTheDocument()
  })

  it('clears search on clear button click', () => {
    render(<CopySourceSelectionModal {...baseProps} />)
    const input = screen.getByTestId('search-input')
    fireEvent.change(input, { target: { value: 'test' } })
    const clearBtn = screen.getByTestId('x-clear').closest('button')!
    fireEvent.click(clearBtn)
    expect(input).toHaveValue('')
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/copy-source-selection-modal.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('@/hooks/features/use-business-terminology', () => ({
  useBusinessRoles: () => ({
    voice_agent: { displayName: 'Voice Agent', description: '', category: '' }
  })
}))

vi.mock('../../../utils/admin/notice-validators', () => ({
  isConfiguredGroup: ({ group }: any) => Boolean(group.logicalName && group.roleName)
}))

vi.mock('@/components/common/brand-loader', () => ({
  BrandLoader: ({ message }: any) => <div data-testid="brand-loader">{message}</div>
}))

vi.mock('../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children, className }: any) => <div className={className}>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children, className }: any) => <div className={className}>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children, className }: any) => <h2 className={className}>{children}</h2>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: any) => (
    <button onClick={onClick} disabled={disabled}>{children}</button>
  )
}))

vi.mock('../../ui/input', () => ({
  Input: ({ value, onChange, placeholder, className }: any) => (
    <input data-testid="search-input" value={value} onChange={onChange} placeholder={placeholder} className={className} />
  )
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children }: any) => <span data-testid="badge">{children}</span>
}))

vi.mock('lucide-react', () => ({
  Search: (p: any) => <span data-testid="search-icon" {...p} />,
  Copy: (p: any) => <span data-testid="copy-icon" {...p} />,
  X: (p: any) => <span data-testid="x-icon" {...p} />
}))

import { CopySourceSelectionModal } from '../copy-source-selection-modal'
import type { AdGroup } from '../../../types/features/ad-group-config'

const makeGroup = (id: string, logicalName: string): AdGroup => ({
  id,
  groupIdentifier: `CN=${id}`,
  logicalName,
  roleName: 'voice_agent',
  market: 'UK',
  region: 'EMEA',
  country: 'GB',
  isActive: true
} as any)

describe('CopySourceSelectionModal', () => {
  const baseProps = {
    open: true,
    onOpenChange: vi.fn(),
    adGroups: [makeGroup('g1', 'Group One'), makeGroup('g2', 'Group Two')],
    excludeGroupIds: [] as string[],
    onSelect: vi.fn(),
    isLoading: false
  }

  it('renders dialog with title when open', () => {
    render(<CopySourceSelectionModal {...baseProps} />)
    expect(screen.getByText('Copy Configuration From Another Group')).toBeInTheDocument()
    expect(screen.getByText('Select a source AD group to copy configuration from. The role, permissions, and location metadata will be copied.')).toBeInTheDocument()
  })

  it('does not render when closed', () => {
    render(<CopySourceSelectionModal {...baseProps} open={false} />)
    expect(screen.queryByText('Copy Configuration From Another Group')).not.toBeInTheDocument()
  })

  it('renders filtered group list excluding excluded IDs', () => {
    render(<CopySourceSelectionModal {...baseProps} excludeGroupIds={['g1']} />)
    expect(screen.queryByText('Group One')).not.toBeInTheDocument()
    expect(screen.getByText('Group Two')).toBeInTheDocument()
  })

  it('shows loading state', () => {
    render(<CopySourceSelectionModal {...baseProps} isLoading={true} />)
    expect(screen.getByTestId('brand-loader')).toBeInTheDocument()
  })

  it('shows empty state when no configured groups', () => {
    const unconfigured = [{ id: 'g3', groupIdentifier: 'CN=g3', logicalName: '', roleName: '' } as any]
    render(<CopySourceSelectionModal {...baseProps} adGroups={unconfigured} />)
    expect(screen.getByText('No configured groups available')).toBeInTheDocument()
  })

  it('renders search input', () => {
    render(<CopySourceSelectionModal {...baseProps} />)
    expect(screen.getByTestId('search-input')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/copy-source-sub-components-extra.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('lucide-react', () => ({
  Search: () => <span data-testid="search-icon" />,
  Copy: () => <span data-testid="copy-icon" />
}))

vi.mock('@/hooks/features/use-business-terminology', () => ({
  useBusinessRoles: () => ({
    voice_agent: { displayName: 'Voice Agent', description: '', category: '' },
    chat_agent: { displayName: 'Chat Agent', description: '', category: '' }
  })
}))

vi.mock('@/components/common/brand-loader', () => ({
  BrandLoader: ({ message }: any) => <div data-testid="brand-loader">{message}</div>
}))

vi.mock('../../../utils/admin/notice-validators', () => ({
  isConfiguredGroup: ({ group }: any) => Boolean(group.logicalName)
}))

import {
  GroupLocationInfo,
  matchesSearchQuery,
  filterAndSortGroups,
  GroupsListContent
} from '../copy-source-sub-components'

describe('GroupLocationInfo', () => {
  it('renders nothing when no location data', () => {
    const group = { market: undefined, region: undefined, country: undefined } as any
    const { container } = render(<GroupLocationInfo group={group} />)
    expect(container.innerHTML).toBe('')
  })

  it('renders market info', () => {
    const group = { market: 'AMER', region: undefined, country: undefined } as any
    render(<GroupLocationInfo group={group} />)
    expect(screen.getByText('AMER')).toBeInTheDocument()
  })

  it('renders all location parts', () => {
    const group = { market: 'AMER', region: 'US East', country: 'USA' } as any
    render(<GroupLocationInfo group={group} />)
    expect(screen.getByText('AMER')).toBeInTheDocument()
    expect(screen.getByText(/US East/)).toBeInTheDocument()
    expect(screen.getByText(/USA/)).toBeInTheDocument()
  })
})

describe('matchesSearchQuery', () => {
  const group = {
    logicalName: 'Test Group',
    groupIdentifier: 'CN=test-group',
    roleName: 'voice_agent',
    market: 'AMER',
    region: 'US East'
  } as any

  it('matches logicalName', () => {
    expect(matchesSearchQuery(group, 'test group')).toBe(true)
  })

  it('matches groupIdentifier', () => {
    expect(matchesSearchQuery(group, 'cn=test')).toBe(true)
  })

  it('matches roleName', () => {
    expect(matchesSearchQuery(group, 'voice')).toBe(true)
  })

  it('matches market', () => {
    expect(matchesSearchQuery(group, 'amer')).toBe(true)
  })

  it('matches region', () => {
    expect(matchesSearchQuery(group, 'us east')).toBe(true)
  })

  it('returns false for non-matching query', () => {
    expect(matchesSearchQuery(group, 'xyz123')).toBe(false)
  })
})

describe('filterAndSortGroups', () => {
  const groups = [
    { id: '1', logicalName: 'Bravo Group', groupIdentifier: 'CN=bravo', roleName: 'voice_agent' },
    { id: '2', logicalName: 'Alpha Group', groupIdentifier: 'CN=alpha', roleName: 'chat_agent' },
    { id: '3', logicalName: undefined, groupIdentifier: 'CN=unconfigured' },
    { id: '4', logicalName: 'Delta Group', groupIdentifier: 'CN=delta', roleName: 'voice_agent' }
  ] as any[]

  it('excludes specified group IDs', () => {
    const result = filterAndSortGroups(groups, ['1'], '')
    expect(result.find(g => g.id === '1')).toBeUndefined()
  })

  it('excludes unconfigured groups', () => {
    const result = filterAndSortGroups(groups, [], '')
    expect(result.find(g => g.id === '3')).toBeUndefined()
  })

  it('sorts by logical name', () => {
    const result = filterAndSortGroups(groups, [], '')
    expect(result[0].logicalName).toBe('Alpha Group')
    expect(result[1].logicalName).toBe('Bravo Group')
  })

  it('filters by search query', () => {
    const result = filterAndSortGroups(groups, [], 'alpha')
    expect(result).toHaveLength(1)
    expect(result[0].logicalName).toBe('Alpha Group')
  })
})

describe('GroupsListContent', () => {
  const defaultProps = {
    isLoading: false,
    filteredGroups: [] as any[],
    searchQuery: '',
    selectedGroup: null,
    businessRoles: {
      voice_agent: { displayName: 'Voice Agent', description: '', category: '' },
      chat_agent: { displayName: 'Chat Agent', description: '', category: '' }
    } as any,
    onSelect: vi.fn()
  }

  it('shows loading state', () => {
    render(<GroupsListContent {...defaultProps} isLoading={true} />)
    expect(screen.getByTestId('brand-loader')).toBeInTheDocument()
  })

  it('shows empty state with search query', () => {
    render(<GroupsListContent {...defaultProps} searchQuery="test" />)
    expect(screen.getByText('No matching groups found')).toBeInTheDocument()
  })

  it('shows empty state without search query', () => {
    render(<GroupsListContent {...defaultProps} />)
    expect(screen.getByText('No configured groups available')).toBeInTheDocument()
  })

  it('renders group cards', () => {
    const groups = [
      { id: '1', logicalName: 'Group A', groupIdentifier: 'CN=group-a', roleName: 'voice_agent' },
      { id: '2', logicalName: 'Group B', groupIdentifier: 'CN=group-b', roleName: 'chat_agent' }
    ] as any[]
    render(<GroupsListContent {...defaultProps} filteredGroups={groups} />)
    expect(screen.getByText('Group A')).toBeInTheDocument()
    expect(screen.getByText('Group B')).toBeInTheDocument()
  })

  it('calls onSelect when group is clicked', () => {
    const onSelect = vi.fn()
    const groups = [
      { id: '1', logicalName: 'Group A', groupIdentifier: 'CN=group-a', roleName: 'voice_agent' }
    ] as any[]
    render(<GroupsListContent {...defaultProps} filteredGroups={groups} onSelect={onSelect} />)
    fireEvent.click(screen.getByText('Group A'))
    expect(onSelect).toHaveBeenCalledWith(groups[0])
  })

  it('shows selected state for selected group', () => {
    const groups = [
      { id: '1', logicalName: 'Group A', groupIdentifier: 'CN=group-a', roleName: 'voice_agent' }
    ] as any[]
    render(<GroupsListContent {...defaultProps} filteredGroups={groups} selectedGroup={groups[0]} />)
    expect(screen.getByTestId('copy-icon')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/copy-source-sub-components.test.ts
import { describe, it, expect } from 'vitest'
import { matchesSearchQuery, filterAndSortGroups } from '../copy-source-sub-components'
import type { AdGroup } from '../../../types/features/ad-group-config'

const makeGroup = (overrides: Partial<AdGroup> = {}): AdGroup => ({
  id: '1',
  groupIdentifier: 'CN=test-group',
  isActive: true,
  ...overrides
} as AdGroup)

describe('copy-source-sub-components', () => {
  describe('matchesSearchQuery', () => {
    it('matches on logicalName', () => {
      const group = makeGroup({ logicalName: 'APAC Voice Team' })
      expect(matchesSearchQuery(group, 'apac')).toBe(true)
    })

    it('matches on groupIdentifier', () => {
      const group = makeGroup({ groupIdentifier: 'CN=apac-voice-group' })
      expect(matchesSearchQuery(group, 'apac-voice')).toBe(true)
    })

    it('matches on roleName', () => {
      const group = makeGroup({ roleName: 'voice_agent' })
      expect(matchesSearchQuery(group, 'voice_agent')).toBe(true)
    })

    it('matches on market', () => {
      const group = makeGroup({ market: 'Asia Pacific' })
      expect(matchesSearchQuery(group, 'asia')).toBe(true)
    })

    it('matches on region', () => {
      const group = makeGroup({ region: 'APAC' })
      expect(matchesSearchQuery(group, 'apac')).toBe(true)
    })

    it('returns false when no fields match', () => {
      const group = makeGroup({ logicalName: 'EMEA Team' })
      expect(matchesSearchQuery(group, 'amer')).toBe(false)
    })
  })

  describe('filterAndSortGroups', () => {
    const configuredGroup = (id: string, name: string) => makeGroup({
      id,
      logicalName: name,
      roleName: 'voice_agent',
      region: 'APAC',
      country: 'HK'
    })

    it('excludes groups by ID', () => {
      const groups = [configuredGroup('1', 'Alpha'), configuredGroup('2', 'Beta')]
      const result = filterAndSortGroups(groups, ['1'], '')
      expect(result).toHaveLength(1)
      expect(result[0].id).toBe('2')
    })

    it('excludes unconfigured groups', () => {
      const groups = [
        configuredGroup('1', 'Configured'),
        makeGroup({ id: '2', logicalName: 'Incomplete' }) // no roleName/region/country
      ]
      const result = filterAndSortGroups(groups, [], '')
      expect(result).toHaveLength(1)
      expect(result[0].logicalName).toBe('Configured')
    })

    it('filters by search query', () => {
      const groups = [configuredGroup('1', 'Alpha Team'), configuredGroup('2', 'Beta Team')]
      const result = filterAndSortGroups(groups, [], 'alpha')
      expect(result).toHaveLength(1)
      expect(result[0].logicalName).toBe('Alpha Team')
    })

    it('sorts alphabetically by logicalName', () => {
      const groups = [configuredGroup('1', 'Charlie'), configuredGroup('2', 'Alpha'), configuredGroup('3', 'Beta')]
      const result = filterAndSortGroups(groups, [], '')
      expect(result.map(g => g.logicalName)).toEqual(['Alpha', 'Beta', 'Charlie'])
    })

    it('returns empty array when all groups are excluded', () => {
      const groups = [configuredGroup('1', 'Alpha')]
      const result = filterAndSortGroups(groups, ['1'], '')
      expect(result).toHaveLength(0)
    })
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/function-assignment-panel-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

const mockUseFunctionSelection = vi.fn()
vi.mock('../../../hooks/admin/use-function-selection', () => ({
  useFunctionSelection: (...args: unknown[]) => mockUseFunctionSelection(...args)
}))

vi.mock('../../ui/card', () => ({
  Card: ({ children, className }: any) => <div data-testid="card" className={className}>{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>,
  CardDescription: ({ children }: any) => <p>{children}</p>,
  CardHeader: ({ children, className }: any) => <div className={className}>{children}</div>,
  CardTitle: ({ children, className }: any) => <h3 className={className}>{children}</h3>
}))

vi.mock('../../ui/checkbox', () => ({
  Checkbox: ({ id, checked, disabled, onCheckedChange }: any) => (
    <input
      type="checkbox"
      data-testid={`checkbox-${id}`}
      checked={checked}
      disabled={disabled}
      onChange={(e: any) => onCheckedChange?.(e.target.checked)}
    />
  )
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled, className, variant }: any) => (
    <button onClick={onClick} disabled={disabled} className={className} data-variant={variant}>{children}</button>
  )
}))

vi.mock('../../ui/label', () => ({
  Label: ({ children, htmlFor, className }: any) => <label htmlFor={htmlFor} className={className}>{children}</label>
}))

vi.mock('../../ui/alert-dialog', () => ({
  AlertDialog: ({ children, open }: any) => open ? <div data-testid="alert-dialog">{children}</div> : null,
  AlertDialogAction: ({ children, onClick }: any) => <button data-testid="alert-action" onClick={onClick}>{children}</button>,
  AlertDialogCancel: ({ children, onClick }: any) => <button data-testid="alert-cancel" onClick={onClick}>{children}</button>,
  AlertDialogContent: ({ children }: any) => <div>{children}</div>,
  AlertDialogDescription: ({ children }: any) => <p>{children}</p>,
  AlertDialogFooter: ({ children }: any) => <div>{children}</div>,
  AlertDialogHeader: ({ children }: any) => <div>{children}</div>,
  AlertDialogTitle: ({ children }: any) => <h4>{children}</h4>
}))

vi.mock('lucide-react', () => ({
  Package: (p: any) => <span data-testid="package-icon" {...p} />,
  Settings: (p: any) => <span data-testid="settings-icon" {...p} />,
  Save: (p: any) => <span data-testid="save-icon" {...p} />,
  X: (p: any) => <span data-testid="x-icon" {...p} />
}))

vi.mock('../../../lib/utils', () => ({
  cn: (...a: unknown[]) => a.filter(Boolean).join(' ')
}))

import { FunctionAssignmentPanel } from '../function-assignment-panel'

const baseApp = {
  appIdentifier: 'app-1',
  titleText: 'Test Application',
  descriptionText: 'A test app description',
  categoryName: 'Banking',
  isAssignedIndicator: false,
  assignedFunctionKeys: [] as string[],
  defaultFunctionKey: undefined,
  functionDefinitionsObject: {
    'func-a': { displayName: 'Function A', description: 'Desc A', categoryText: 'write' },
    'func-b': { displayName: 'Function B', description: 'Desc B', categoryText: 'read' },
    'func-c': { displayName: 'Function C', description: 'Desc C', categoryText: 'write' }
  }
}

describe('FunctionAssignmentPanel - extended', () => {
  const defaultProps = {
    app: baseApp as any,
    groupName: 'Test AD Group',
    onSave: vi.fn(),
    isLoading: false,
    isReadOnly: false
  }

  beforeEach(() => {
    vi.clearAllMocks()
    mockUseFunctionSelection.mockReturnValue({
      selectedFunctions: ['func-a'],
      defaultFunction: undefined,
      hasChanges: () => false,
      handleFunctionToggle: vi.fn(),
      handleSelectAllFiltered: vi.fn(),
      handleClearSelection: vi.fn(),
      handleReset: vi.fn()
    })
  })

  it('renders app title and description', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('Test Application')).toBeInTheDocument()
    expect(screen.getByText('A test app description')).toBeInTheDocument()
  })

  it('shows no-changes message when no changes', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('Current assignment saved')).toBeInTheDocument()
  })

  it('shows save button when there are changes', () => {
    mockUseFunctionSelection.mockReturnValue({
      selectedFunctions: ['func-a', 'func-b'],
      defaultFunction: undefined,
      hasChanges: () => true,
      handleFunctionToggle: vi.fn(),
      handleSelectAllFiltered: vi.fn(),
      handleClearSelection: vi.fn(),
      handleReset: vi.fn()
    })
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('Save Assignment')).toBeInTheDocument()
  })

  it('renders with onSelectionChange callback', () => {
    const onSelectionChange = vi.fn()
    mockUseFunctionSelection.mockReturnValue({
      selectedFunctions: ['func-a'],
      defaultFunction: undefined,
      hasChanges: () => true,
      handleFunctionToggle: vi.fn(),
      handleSelectAllFiltered: vi.fn(),
      handleClearSelection: vi.fn(),
      handleReset: vi.fn()
    })
    render(<FunctionAssignmentPanel {...defaultProps} onSelectionChange={onSelectionChange} />)
    expect(onSelectionChange).toHaveBeenCalled()
  })

  it('shows empty function message when no functions available', () => {
    const emptyApp = { ...baseApp, functionDefinitionsObject: {} }
    render(<FunctionAssignmentPanel {...defaultProps} app={emptyApp as any} />)
    expect(screen.getByText('No features available for this application')).toBeInTheDocument()
  })

  it('shows unassign button when app is assigned', () => {
    const assignedApp = { ...baseApp, isAssignedIndicator: true, assignedFunctionKeys: ['func-a'] }
    render(<FunctionAssignmentPanel {...defaultProps} app={assignedApp as any} />)
    expect(screen.getByText('Unassign Application')).toBeInTheDocument()
  })

  it('shows save and reset buttons when changes exist', () => {
    mockUseFunctionSelection.mockReturnValue({
      selectedFunctions: ['func-a', 'func-b'],
      defaultFunction: undefined,
      hasChanges: () => true,
      handleFunctionToggle: vi.fn(),
      handleSelectAllFiltered: vi.fn(),
      handleClearSelection: vi.fn(),
      handleReset: vi.fn()
    })
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('Save Assignment')).toBeInTheDocument()
    expect(screen.getByText('Reset')).toBeInTheDocument()
  })

  it('calls handleReset when reset is clicked', () => {
    const handleReset = vi.fn()
    mockUseFunctionSelection.mockReturnValue({
      selectedFunctions: ['func-a', 'func-b'],
      defaultFunction: undefined,
      hasChanges: () => true,
      handleFunctionToggle: vi.fn(),
      handleSelectAllFiltered: vi.fn(),
      handleClearSelection: vi.fn(),
      handleReset
    })
    render(<FunctionAssignmentPanel {...defaultProps} />)
    fireEvent.click(screen.getByText('Reset'))
    expect(handleReset).toHaveBeenCalled()
  })

  it('shows assigned badge for assigned app', () => {
    const assignedApp = { ...baseApp, isAssignedIndicator: true }
    render(<FunctionAssignmentPanel {...defaultProps} app={assignedApp as any} />)
    expect(screen.getByText('Assigned')).toBeInTheDocument()
  })

  it('renders selected count badge', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('1 of 3 selected')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/function-assignment-panel.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, act, waitFor } from '@testing-library/react'

const mockHandleFunctionToggle = vi.fn()
const mockHandleSelectAllFiltered = vi.fn()
const mockHandleClearSelection = vi.fn()
const mockHandleReset = vi.fn()
let mockSelectedFunctions = ['func-a']
let mockHasChanges = false

vi.mock('../../../hooks/admin/use-function-selection', () => ({
  useFunctionSelection: () => ({
    selectedFunctions: mockSelectedFunctions,
    defaultFunction: undefined,
    hasChanges: () => mockHasChanges,
    handleFunctionToggle: mockHandleFunctionToggle,
    handleSelectAllFiltered: mockHandleSelectAllFiltered,
    handleClearSelection: mockHandleClearSelection,
    handleReset: mockHandleReset
  })
}))

vi.mock('../../ui/card', () => ({
  Card: ({ children, className }: any) => <div data-testid="card" className={className}>{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>,
  CardDescription: ({ children }: any) => <p>{children}</p>,
  CardHeader: ({ children, className }: any) => <div className={className}>{children}</div>,
  CardTitle: ({ children, className }: any) => <h3 className={className}>{children}</h3>
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled, className, variant }: any) => (
    <button onClick={onClick} disabled={disabled} className={className} data-variant={variant}>{children}</button>
  )
}))

vi.mock('../../ui/label', () => ({
  Label: ({ children, htmlFor, className }: any) => <label htmlFor={htmlFor} className={className}>{children}</label>
}))

vi.mock('../../ui/alert-dialog', () => ({
  AlertDialog: ({ children, open }: any) => open ? <div data-testid="alert-dialog">{children}</div> : null,
  AlertDialogAction: ({ children, onClick }: any) => <button data-testid="alert-action" onClick={onClick}>{children}</button>,
  AlertDialogCancel: ({ children, onClick }: any) => <button data-testid="alert-cancel" onClick={onClick}>{children}</button>,
  AlertDialogContent: ({ children }: any) => <div>{children}</div>,
  AlertDialogDescription: ({ children }: any) => <p>{children}</p>,
  AlertDialogFooter: ({ children }: any) => <div>{children}</div>,
  AlertDialogHeader: ({ children }: any) => <div>{children}</div>,
  AlertDialogTitle: ({ children }: any) => <h4>{children}</h4>
}))

vi.mock('lucide-react', () => ({
  Package: (p: any) => <span data-testid="package-icon" {...p} />,
  Settings: (p: any) => <span data-testid="settings-icon" {...p} />,
  Save: (p: any) => <span data-testid="save-icon" {...p} />,
  X: (p: any) => <span data-testid="x-icon" {...p} />
}))

vi.mock('../../../lib/utils', () => ({
  cn: (...a: unknown[]) => a.filter(Boolean).join(' ')
}))

import { FunctionAssignmentPanel } from '../function-assignment-panel'

const baseApp = {
  appIdentifier: 'app-1',
  titleText: 'Test Application',
  descriptionText: 'A test app description',
  categoryName: 'Banking',
  isAssignedIndicator: false,
  assignedFunctionKeys: [] as string[],
  defaultFunctionKey: undefined,
  functionDefinitionsObject: {
    'func-a': { displayName: 'Function A', description: 'Desc A', categoryText: 'write' },
    'func-b': { displayName: 'Function B', description: 'Desc B', categoryText: 'read' }
  }
}

describe('FunctionAssignmentPanel', () => {
  const defaultProps = {
    app: baseApp as any,
    groupName: 'Test AD Group',
    onSave: vi.fn(),
    isLoading: false
  }

  beforeEach(() => {
    vi.clearAllMocks()
    mockSelectedFunctions = ['func-a']
    mockHasChanges = false
  })

  it('renders app title and description', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('Test Application')).toBeInTheDocument()
    expect(screen.getByText('A test app description')).toBeInTheDocument()
  })

  it('renders available function definitions', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('Function A')).toBeInTheDocument()
    expect(screen.getByText('Function B')).toBeInTheDocument()
  })

  it('shows assigned badge when app is assigned', () => {
    const assignedApp = { ...baseApp, isAssignedIndicator: true, assignedFunctionKeys: ['func-a'] }
    render(<FunctionAssignmentPanel {...defaultProps} app={assignedApp as any} />)
    expect(screen.getByText('Assigned')).toBeInTheDocument()
  })

  it('shows unassign button when app is assigned', () => {
    const assignedApp = { ...baseApp, isAssignedIndicator: true, assignedFunctionKeys: ['func-a'] }
    render(<FunctionAssignmentPanel {...defaultProps} app={assignedApp as any} />)
    expect(screen.getByText('Unassign Application')).toBeInTheDocument()
  })

  it('shows no-changes message when there are no changes', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('Current assignment saved')).toBeInTheDocument()
  })

  it('renders permission filter buttons', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('All (2)')).toBeInTheDocument()
    expect(screen.getByText('Write (1)')).toBeInTheDocument()
    expect(screen.getByText('Read (1)')).toBeInTheDocument()
  })

  it('does not show assigned badge when not assigned', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.queryByText('Assigned')).not.toBeInTheDocument()
  })

  it('shows empty state when no functions available with filter', () => {
    const emptyApp = { ...baseApp, functionDefinitionsObject: {} }
    render(<FunctionAssignmentPanel {...defaultProps} app={emptyApp as any} />)
    expect(screen.getByText('No features available for this application')).toBeInTheDocument()
  })

  it('handles unassign button click', async () => {
    const assignedApp = { ...baseApp, isAssignedIndicator: true, assignedFunctionKeys: ['func-a'] }
    render(<FunctionAssignmentPanel {...defaultProps} app={assignedApp as any} />)
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Unassign Application' }))
    })
    expect(screen.getByTestId('alert-dialog')).toBeInTheDocument()
  })

  it('handles save button click and shows confirmation', async () => {
    mockHasChanges = true
    render(<FunctionAssignmentPanel {...defaultProps} />)
    const saveButton = screen.getByRole('button', { name: 'Save Assignment' })
    await act(async () => {
      fireEvent.click(saveButton)
    })
    await waitFor(() => {
      expect(screen.getByTestId('alert-dialog')).toBeInTheDocument()
    })
  })

  it('calls onSelectionChange when hasChanges and callback provided', () => {
    mockHasChanges = true
    const onSelectionChange = vi.fn()
    render(<FunctionAssignmentPanel {...defaultProps} onSelectionChange={onSelectionChange} />)
    expect(onSelectionChange).toHaveBeenCalled()
  })

  it('renders in read-only mode', () => {
    render(<FunctionAssignmentPanel {...defaultProps} isReadOnly={true} />)
    expect(screen.queryByText('Save Changes')).not.toBeInTheDocument()
  })

  it('shows selection count badge', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('1 of 2 selected')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/function-assignment-utils.test.ts
import { describe, it, expect } from 'vitest'
import {
  determineSaveModalState,
  getFunctionItemStyle,
  getFilteredFunctions,
  countByCategory,
  LABEL_UNASSIGN
} from '../function-assignment-utils'
import type { EmbeddedAppWithStatus } from '../../../types/integration/embedded-apps'

const makeApp = (overrides: Partial<EmbeddedAppWithStatus> = {}): EmbeddedAppWithStatus => ({
  appKey: 'credit-card',
  titleText: 'Credit Card',
  descriptionText: 'Credit card app',
  assignedFunctionKeys: [],
  defaultFunctionKey: 'view-balance',
  functions: {},
  ...overrides
} as EmbeddedAppWithStatus)

const functionDefs = {
  'view-balance': { displayName: 'View Balance' },
  'transfer': { displayName: 'Transfer' }
}

describe('function-assignment-utils', () => {
  describe('LABEL_UNASSIGN', () => {
    it('has the expected value', () => {
      expect(LABEL_UNASSIGN).toBe('Unassign Application')
    })
  })

  describe('determineSaveModalState', () => {
    it('returns default modal when only default feature selected and no original assignments', () => {
      const result = determineSaveModalState(
        ['view-balance'],
        makeApp({ assignedFunctionKeys: [] }),
        'Test Group',
        functionDefs
      )
      expect(result.modalState.type).toBe('default')
      expect(result.modalState.title).toBe('Default feature included')
      expect(result.pendingSave).toEqual({ functions: ['view-balance'], defaultFunction: 'view-balance' })
    })

    it('returns missing modal when no functions selected and no original assignments', () => {
      const result = determineSaveModalState(
        [],
        makeApp({ assignedFunctionKeys: [] }),
        'Test Group',
        functionDefs
      )
      expect(result.modalState.type).toBe('missing')
      expect(result.pendingSave).toBeNull()
    })

    it('returns removal modal when no functions selected but had original assignments', () => {
      const result = determineSaveModalState(
        [],
        makeApp({ assignedFunctionKeys: ['view-balance'] }),
        'Test Group',
        functionDefs
      )
      expect(result.modalState.type).toBe('removal')
      expect(result.modalState.context).toBe('save-removal')
      expect(result.pendingSave).toEqual({ functions: [] })
    })

    it('returns standard modal for normal selections', () => {
      const result = determineSaveModalState(
        ['view-balance', 'transfer'],
        makeApp(),
        'Test Group',
        functionDefs
      )
      expect(result.modalState.type).toBe('standard')
      expect(result.modalState.title).toBe('Confirm feature assignment')
      expect(result.pendingSave).toEqual({ functions: ['view-balance', 'transfer'] })
    })

    it('uses singular form for single function', () => {
      const result = determineSaveModalState(
        ['transfer'],
        makeApp(),
        'Test Group',
        functionDefs
      )
      expect(result.modalState.description).toContain('1 feature')
    })

    it('uses plural form for multiple functions', () => {
      const result = determineSaveModalState(
        ['view-balance', 'transfer'],
        makeApp(),
        'Test Group',
        functionDefs
      )
      expect(result.modalState.description).toContain('2 features')
    })
  })

  describe('getFunctionItemStyle', () => {
    it('returns unchecked style when not checked', () => {
      expect(getFunctionItemStyle(false, false)).toContain('border-gray-200')
    })

    it('returns default feature style when checked and is default', () => {
      expect(getFunctionItemStyle(true, true)).toContain('border-green-200')
    })

    it('returns checked style when checked and not default', () => {
      expect(getFunctionItemStyle(true, false)).toContain('border-blue-200')
    })
  })

  describe('getFilteredFunctions', () => {
    const functions = ['fn1', 'fn2', 'fn3']
    const definitions = {
      fn1: { categoryText: 'write' },
      fn2: { categoryText: 'read' },
      fn3: { categoryText: 'write' }
    }

    it('returns all functions when filter is all', () => {
      expect(getFilteredFunctions(functions, definitions, 'all')).toEqual(functions)
    })

    it('filters by write category', () => {
      expect(getFilteredFunctions(functions, definitions, 'write')).toEqual(['fn1', 'fn3'])
    })

    it('filters by read category', () => {
      expect(getFilteredFunctions(functions, definitions, 'read')).toEqual(['fn2'])
    })
  })

  describe('countByCategory', () => {
    const functions = ['fn1', 'fn2', 'fn3']
    const definitions = {
      fn1: { categoryText: 'write' },
      fn2: { categoryText: 'read' },
      fn3: { categoryText: 'write' }
    }

    it('counts functions in a category', () => {
      expect(countByCategory(functions, definitions, 'write')).toBe(2)
      expect(countByCategory(functions, definitions, 'read')).toBe(1)
    })

    it('returns 0 for non-existent category', () => {
      expect(countByCategory(functions, definitions, 'admin')).toBe(0)
    })
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/function-confirmation-dialog.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'

vi.mock('../../ui/alert-dialog', () => ({
  AlertDialog: ({ children, open }: any) => open ? <div data-testid="alert-dialog">{children}</div> : null,
  AlertDialogAction: ({ children, onClick }: any) => <button data-testid="alert-action" onClick={onClick}>{children}</button>,
  AlertDialogCancel: ({ children, onClick }: any) => <button data-testid="alert-cancel" onClick={onClick}>{children}</button>,
  AlertDialogContent: ({ children }: any) => <div>{children}</div>,
  AlertDialogDescription: ({ children }: any) => <p>{children}</p>,
  AlertDialogFooter: ({ children }: any) => <div>{children}</div>,
  AlertDialogHeader: ({ children }: any) => <div>{children}</div>,
  AlertDialogTitle: ({ children }: any) => <h4>{children}</h4>
}))

import { FunctionConfirmationDialog } from '../function-confirmation-dialog'

describe('FunctionConfirmationDialog', () => {
  const defaultProps = {
    modalState: {
      type: 'assign' as const,
      title: 'Confirm Assignment',
      description: 'Assign functions to this group?',
      confirmLabel: 'Assign',
      cancelLabel: 'Cancel'
    },
    onConfirm: vi.fn().mockResolvedValue(undefined),
    onCancel: vi.fn(),
    isOpen: true
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders when open', () => {
    render(<FunctionConfirmationDialog {...defaultProps} />)
    expect(screen.getByText('Confirm Assignment')).toBeInTheDocument()
    expect(screen.getByText('Assign functions to this group?')).toBeInTheDocument()
  })

  it('does not render when closed', () => {
    render(<FunctionConfirmationDialog {...defaultProps} isOpen={false} />)
    expect(screen.queryByText('Confirm Assignment')).not.toBeInTheDocument()
  })

  it('calls onConfirm when action button clicked', async () => {
    render(<FunctionConfirmationDialog {...defaultProps} />)
    const event = { preventDefault: vi.fn() }
    fireEvent.click(screen.getByTestId('alert-action'))
    await waitFor(() => {
      expect(defaultProps.onConfirm).toHaveBeenCalled()
    })
  })

  it('calls onCancel when cancel button clicked', () => {
    render(<FunctionConfirmationDialog {...defaultProps} />)
    const event = { preventDefault: vi.fn() }
    fireEvent.click(screen.getByTestId('alert-cancel'))
    expect(defaultProps.onCancel).toHaveBeenCalled()
  })

  it('renders confirm label', () => {
    render(<FunctionConfirmationDialog {...defaultProps} />)
    expect(screen.getByText('Assign')).toBeInTheDocument()
  })

  it('renders "Continue" when no confirmLabel', () => {
    const props = {
      ...defaultProps,
      modalState: { ...defaultProps.modalState, confirmLabel: undefined }
    }
    render(<FunctionConfirmationDialog {...props} />)
    expect(screen.getByText('Continue')).toBeInTheDocument()
  })

  it('hides cancel button when type is missing', () => {
    const props = {
      ...defaultProps,
      modalState: { type: 'missing' as const, title: 'Missing', description: 'Missing description', confirmLabel: 'OK', cancelLabel: 'Cancel' }
    }
    render(<FunctionConfirmationDialog {...props} />)
    expect(screen.queryByTestId('alert-cancel')).not.toBeInTheDocument()
  })

  it('renders without description', () => {
    const props = {
      ...defaultProps,
      modalState: { ...defaultProps.modalState, description: undefined }
    }
    render(<FunctionConfirmationDialog {...props} />)
    expect(screen.getByText('Confirm Assignment')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/function-panel-sections-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../ui/checkbox', () => ({
  Checkbox: ({ id, checked, disabled, onCheckedChange }: any) => (
    <input type="checkbox" data-testid={`checkbox-${id}`} checked={checked} disabled={disabled}
      onChange={(e: any) => onCheckedChange?.(e.target.checked)} />
  )
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled, variant, className }: any) => (
    <button onClick={onClick} disabled={disabled} data-variant={variant} className={className}>{children}</button>
  )
}))

vi.mock('../../ui/label', () => ({
  Label: ({ children, htmlFor, className }: any) => <label htmlFor={htmlFor} className={className}>{children}</label>
}))

vi.mock('../../ui/alert-dialog', () => ({
  AlertDialog: ({ children, open }: any) => open ? <div>{children}</div> : null,
  AlertDialogContent: ({ children }: any) => <div>{children}</div>,
  AlertDialogHeader: ({ children }: any) => <div>{children}</div>,
  AlertDialogTitle: ({ children }: any) => <h2>{children}</h2>,
  AlertDialogDescription: ({ children }: any) => <p>{children}</p>,
  AlertDialogFooter: ({ children }: any) => <div>{children}</div>,
  AlertDialogAction: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>,
  AlertDialogCancel: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>
}))

vi.mock('lucide-react', () => ({
  Save: () => <span data-testid="save-icon" />,
  X: () => <span data-testid="x-icon" />
}))

vi.mock('../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

import { FunctionListItem, PanelFooterSection, PermissionFilterBar, BulkActionsBar } from '../function-panel-sections'

describe('FunctionListItem - extra coverage', () => {
  it('calls onToggle with correct params', () => {
    const onToggle = vi.fn()
    render(
      <FunctionListItem
        functionKey="fn1"
        definition={{ displayName: 'Fn 1' }}
        defaultFunctionKey={undefined}
        selectedFunctions={[]}
        isReadOnly={false}
        onToggle={onToggle}
      />
    )
    fireEvent.click(screen.getByTestId('checkbox-fn1'))
    expect(onToggle).toHaveBeenCalledWith({ functionKey: 'fn1', checked: true })
  })

  it('disables checkbox when default function', () => {
    render(
      <FunctionListItem
        functionKey="fn1"
        definition={{ displayName: 'Fn 1' }}
        defaultFunctionKey="fn1"
        selectedFunctions={[]}
        isReadOnly={false}
        onToggle={vi.fn()}
      />
    )
    const checkbox = screen.getByTestId('checkbox-fn1') as HTMLInputElement
    expect(checkbox.disabled).toBe(true)
  })

  it('is checked when in selectedFunctions', () => {
    render(
      <FunctionListItem
        functionKey="fn1"
        definition={{ displayName: 'Fn 1' }}
        defaultFunctionKey={undefined}
        selectedFunctions={['fn1']}
        isReadOnly={false}
        onToggle={vi.fn()}
      />
    )
    const checkbox = screen.getByTestId('checkbox-fn1') as HTMLInputElement
    expect(checkbox.checked).toBe(true)
  })

  it('is unchecked when not in selectedFunctions', () => {
    render(
      <FunctionListItem
        functionKey="fn1"
        definition={{ displayName: 'Fn 1' }}
        defaultFunctionKey={undefined}
        selectedFunctions={[]}
        isReadOnly={false}
        onToggle={vi.fn()}
      />
    )
    const checkbox = screen.getByTestId('checkbox-fn1') as HTMLInputElement
    expect(checkbox.checked).toBe(false)
  })

  it('renders without category or description', () => {
    render(
      <FunctionListItem
        functionKey="fn1"
        definition={{ displayName: 'Fn 1' }}
        defaultFunctionKey={undefined}
        selectedFunctions={[]}
        isReadOnly={false}
        onToggle={vi.fn()}
      />
    )
    expect(screen.getByText('Fn 1')).toBeInTheDocument()
  })
})

describe('PanelFooterSection - extra coverage', () => {
  it('calls onSave when save button is clicked', () => {
    const onSave = vi.fn()
    render(
      <PanelFooterSection
        isReadOnly={false}
        selectedCount={2}
        hasChanges={true}
        isLoading={false}
        isAssigned={false}
        onSave={onSave}
        onReset={vi.fn()}
        onUnassign={vi.fn()}
      />
    )
    fireEvent.click(screen.getByText('Save Assignment'))
    expect(onSave).toHaveBeenCalled()
  })

  it('calls onReset when reset button is clicked', () => {
    const onReset = vi.fn()
    render(
      <PanelFooterSection
        isReadOnly={false}
        selectedCount={2}
        hasChanges={true}
        isLoading={false}
        isAssigned={false}
        onSave={vi.fn()}
        onReset={onReset}
        onUnassign={vi.fn()}
      />
    )
    fireEvent.click(screen.getByText('Reset'))
    expect(onReset).toHaveBeenCalled()
  })

  it('shows Saving... when isLoading and hasChanges', () => {
    render(
      <PanelFooterSection
        isReadOnly={false}
        selectedCount={2}
        hasChanges={true}
        isLoading={true}
        isAssigned={false}
        onSave={vi.fn()}
        onReset={vi.fn()}
        onUnassign={vi.fn()}
      />
    )
    expect(screen.getByText('Saving...')).toBeInTheDocument()
  })

  it('disables unassign when loading', () => {
    render(
      <PanelFooterSection
        isReadOnly={false}
        selectedCount={2}
        hasChanges={false}
        isLoading={true}
        isAssigned={true}
        onSave={vi.fn()}
        onReset={vi.fn()}
        onUnassign={vi.fn()}
      />
    )
    expect(screen.getByText('Unassign Application')).toBeDisabled()
  })

  it('calls onUnassign when unassign clicked', () => {
    const onUnassign = vi.fn()
    render(
      <PanelFooterSection
        isReadOnly={false}
        selectedCount={2}
        hasChanges={false}
        isLoading={false}
        isAssigned={true}
        onSave={vi.fn()}
        onReset={vi.fn()}
        onUnassign={onUnassign}
      />
    )
    fireEvent.click(screen.getByText('Unassign Application'))
    expect(onUnassign).toHaveBeenCalled()
  })
})

describe('PermissionFilterBar - extra coverage', () => {
  it('calls setPermissionFilter with all on click', () => {
    const setPermissionFilter = vi.fn()
    render(
      <PermissionFilterBar
        permissionFilter="write"
        setPermissionFilter={setPermissionFilter}
        availableFunctions={['a']}
        writeCount={1}
        readCount={0}
      />
    )
    fireEvent.click(screen.getByText('All (1)'))
    expect(setPermissionFilter).toHaveBeenCalledWith('all')
  })

  it('calls setPermissionFilter with read on click', () => {
    const setPermissionFilter = vi.fn()
    render(
      <PermissionFilterBar
        permissionFilter="all"
        setPermissionFilter={setPermissionFilter}
        availableFunctions={['a', 'b']}
        writeCount={1}
        readCount={1}
      />
    )
    fireEvent.click(screen.getByText('Read (1)'))
    expect(setPermissionFilter).toHaveBeenCalledWith('read')
  })
})

describe('BulkActionsBar - extra coverage', () => {
  it('calls onSelectAll with filteredFunctions when select all clicked', () => {
    const onSelectAll = vi.fn()
    render(
      <BulkActionsBar
        permissionFilter="write"
        writeCount={2}
        readCount={0}
        filteredFunctions={['fn1', 'fn2']}
        onSelectAll={onSelectAll}
        onClear={vi.fn()}
      />
    )
    fireEvent.click(screen.getByText('Select All Write (2)'))
    expect(onSelectAll).toHaveBeenCalledWith({ filteredFunctions: ['fn1', 'fn2'] })
  })

  it('calls onClear when clear selection clicked', () => {
    const onClear = vi.fn()
    render(
      <BulkActionsBar
        permissionFilter="read"
        writeCount={0}
        readCount={3}
        filteredFunctions={['fn1']}
        onSelectAll={vi.fn()}
        onClear={onClear}
      />
    )
    fireEvent.click(screen.getByText('Clear Selection'))
    expect(onClear).toHaveBeenCalled()
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/function-panel-sections.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../ui/checkbox', () => ({
  Checkbox: ({ id, checked, disabled, onCheckedChange }: Record<string, unknown>) => (
    <input
      type="checkbox"
      data-testid={`checkbox-${id}`}
      checked={checked as boolean}
      disabled={disabled as boolean}
      onChange={(e) => (onCheckedChange as (v: boolean) => void)?.(e.target.checked)}
    />
  )
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children }: { children: React.ReactNode }) => <span data-testid="badge">{children}</span>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled, ...props }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} disabled={disabled as boolean} className={props.className as string}>
      {children as React.ReactNode}
    </button>
  )
}))

vi.mock('../../ui/label', () => ({
  Label: ({ children, htmlFor }: { children: React.ReactNode; htmlFor?: string }) => (
    <label htmlFor={htmlFor}>{children}</label>
  )
}))

vi.mock('../../ui/alert-dialog', () => ({
  AlertDialog: ({ children, open }: { children: React.ReactNode; open: boolean }) => open ? <div data-testid="alert-dialog">{children}</div> : null,
  AlertDialogContent: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  AlertDialogHeader: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  AlertDialogTitle: ({ children }: { children: React.ReactNode }) => <h2>{children}</h2>,
  AlertDialogDescription: ({ children }: { children: React.ReactNode }) => <p>{children}</p>,
  AlertDialogFooter: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  AlertDialogAction: ({ children, onClick }: { children: React.ReactNode; onClick: () => void }) => (
    <button onClick={onClick}>{children}</button>
  ),
  AlertDialogCancel: ({ children, onClick }: { children: React.ReactNode; onClick: () => void }) => (
    <button onClick={onClick}>{children}</button>
  )
}))

vi.mock('lucide-react', () => ({
  Save: () => <span data-testid="save-icon" />,
  X: () => <span data-testid="x-icon" />
}))

vi.mock('../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

import { FunctionListItem, PanelFooterSection, PermissionFilterBar, BulkActionsBar, FunctionConfirmationDialog } from '../function-panel-sections'

describe('FunctionListItem', () => {
  const baseProps = {
    functionKey: 'balance-check',
    definition: { displayName: 'Balance Check', description: 'Check account balance', categoryText: 'Read' },
    defaultFunctionKey: undefined,
    selectedFunctions: ['balance-check'],
    isReadOnly: false,
    onToggle: vi.fn()
  }

  it('renders function display name', () => {
    render(<FunctionListItem {...baseProps} />)
    expect(screen.getByText('Balance Check')).toBeInTheDocument()
  })

  it('renders function description', () => {
    render(<FunctionListItem {...baseProps} />)
    expect(screen.getByText('Check account balance')).toBeInTheDocument()
  })

  it('renders category badge', () => {
    render(<FunctionListItem {...baseProps} />)
    expect(screen.getByText('Read')).toBeInTheDocument()
  })

  it('shows Required badge for default function', () => {
    render(<FunctionListItem {...baseProps} defaultFunctionKey="balance-check" />)
    expect(screen.getByText('Required')).toBeInTheDocument()
  })

  it('falls back to functionKey when no displayName', () => {
    render(<FunctionListItem {...baseProps} definition={undefined} />)
    expect(screen.getByText('balance-check')).toBeInTheDocument()
  })
})

describe('PanelFooterSection', () => {
  const baseProps = {
    isReadOnly: false,
    selectedCount: 3,
    hasChanges: false,
    isLoading: false,
    isAssigned: true,
    onSave: vi.fn(),
    onReset: vi.fn(),
    onUnassign: vi.fn()
  }

  it('shows read-only message when isReadOnly', () => {
    render(<PanelFooterSection {...baseProps} isReadOnly={true} />)
    expect(screen.getByText('Current assignment saved')).toBeInTheDocument()
  })

  it('shows no features message when read-only and empty', () => {
    render(<PanelFooterSection {...baseProps} isReadOnly={true} selectedCount={0} />)
    expect(screen.getByText('No features assigned to this application')).toBeInTheDocument()
  })

  it('shows Save and Reset buttons when hasChanges', () => {
    render(<PanelFooterSection {...baseProps} hasChanges={true} />)
    expect(screen.getByText('Save Assignment')).toBeInTheDocument()
    expect(screen.getByText('Reset')).toBeInTheDocument()
  })

  it('shows unassign button when assigned and not read-only', () => {
    render(<PanelFooterSection {...baseProps} />)
    expect(screen.getByText('Unassign Application')).toBeInTheDocument()
  })

  it('hides unassign button when read-only', () => {
    render(<PanelFooterSection {...baseProps} isReadOnly={true} />)
    expect(screen.queryByText('Unassign Application')).not.toBeInTheDocument()
  })
})

describe('PermissionFilterBar', () => {
  it('renders all filter buttons with counts', () => {
    render(
      <PermissionFilterBar
        permissionFilter="all"
        setPermissionFilter={vi.fn()}
        availableFunctions={['a', 'b', 'c']}
        writeCount={2}
        readCount={1}
      />
    )
    expect(screen.getByText('All (3)')).toBeInTheDocument()
    expect(screen.getByText('Write (2)')).toBeInTheDocument()
    expect(screen.getByText('Read (1)')).toBeInTheDocument()
  })

  it('calls setPermissionFilter on button click', () => {
    const setPermissionFilter = vi.fn()
    render(
      <PermissionFilterBar
        permissionFilter="all"
        setPermissionFilter={setPermissionFilter}
        availableFunctions={[]}
        writeCount={0}
        readCount={0}
      />
    )
    fireEvent.click(screen.getByText('Write (0)'))
    expect(setPermissionFilter).toHaveBeenCalledWith('write')
  })
})

describe('BulkActionsBar', () => {
  it('returns null when permissionFilter is all', () => {
    const { container } = render(
      <BulkActionsBar
        permissionFilter="all"
        writeCount={0}
        readCount={0}
        filteredFunctions={['a']}
        onSelectAll={vi.fn()}
        onClear={vi.fn()}
      />
    )
    expect(container.firstChild).toBeNull()
  })

  it('returns null when filteredFunctions is empty', () => {
    const { container } = render(
      <BulkActionsBar
        permissionFilter="write"
        writeCount={0}
        readCount={0}
        filteredFunctions={[]}
        onSelectAll={vi.fn()}
        onClear={vi.fn()}
      />
    )
    expect(container.firstChild).toBeNull()
  })

  it('renders select all and clear buttons for write filter', () => {
    render(
      <BulkActionsBar
        permissionFilter="write"
        writeCount={5}
        readCount={3}
        filteredFunctions={['a', 'b']}
        onSelectAll={vi.fn()}
        onClear={vi.fn()}
      />
    )
    expect(screen.getByText('Select All Write (5)')).toBeInTheDocument()
    expect(screen.getByText('Clear Selection')).toBeInTheDocument()
  })
})

describe('FunctionConfirmationDialog', () => {
  it('renders dialog title when open', () => {
    render(
      <FunctionConfirmationDialog
        isOpen={true}
        modalState={{ type: 'standard', title: 'Confirm Save', description: 'Save changes?', confirmLabel: 'Save', cancelLabel: 'Cancel' }}
        onConfirm={vi.fn()}
        onCancel={vi.fn()}
      />
    )
    expect(screen.getByText('Confirm Save')).toBeInTheDocument()
    expect(screen.getByText('Save changes?')).toBeInTheDocument()
  })

  it('does not render when closed', () => {
    render(
      <FunctionConfirmationDialog
        isOpen={false}
        modalState={{ type: 'standard', title: 'Confirm', confirmLabel: 'OK', cancelLabel: 'Cancel' }}
        onConfirm={vi.fn()}
        onCancel={vi.fn()}
      />
    )
    expect(screen.queryByText('Confirm')).not.toBeInTheDocument()
  })

  it('hides cancel button for missing type', () => {
    render(
      <FunctionConfirmationDialog
        isOpen={true}
        modalState={{ type: 'missing', title: 'Missing', confirmLabel: 'OK', cancelLabel: 'Cancel' }}
        onConfirm={vi.fn()}
        onCancel={vi.fn()}
      />
    )
    expect(screen.queryByText('Cancel')).not.toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/iframe-layout-preview-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  RefreshCw: ({ className }: any) => <span data-testid="refresh-icon" className={className} />,
  ExternalLink: () => <span data-testid="external-icon" />
}))

vi.mock('../../ui/card', () => ({
  Card: ({ children, className }: any) => <div data-testid="card" className={className}>{children}</div>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: any) => <button onClick={onClick} disabled={disabled}>{children}</button>
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children }: any) => <span data-testid="badge">{children}</span>
}))

import { IframeLayoutPreview } from '../iframe-layout-preview'

const mockRole = {
  roleName: 'voice_agent',
  displayName: 'Voice Agent',
  columns: []
}

describe('IframeLayoutPreview - extra coverage', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('calls handleIframeLoad on iframe load event', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    const iframe = document.getElementById('preview-iframe') as HTMLIFrameElement
    fireEvent.load(iframe)
    // After load, the Refresh button should not be disabled
    expect(screen.getByText('Refresh')).not.toBeDisabled()
  })

  it('refreshes preview on refresh button click', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    const iframe = document.getElementById('preview-iframe') as HTMLIFrameElement
    // Simulate iframe loaded
    fireEvent.load(iframe)
    // Click refresh
    fireEvent.click(screen.getByText('Refresh'))
    // Refresh button should be disabled while loading
    expect(screen.getByText('Refresh')).toBeDisabled()
  })

  it('shows ad group override text in description when adGroup provided', () => {
    render(<IframeLayoutPreview role={mockRole as any} adGroup="UK Retail" />)
    expect(screen.getByText(/UK Retail AD group overrides applied/)).toBeInTheDocument()
  })

  it('does not show ad group badge when not provided', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    expect(screen.queryByText(/AD Group:/)).not.toBeInTheDocument()
  })

  it('constructs iframe URL with template parameter', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    const iframe = document.getElementById('preview-iframe') as HTMLIFrameElement
    expect(iframe.src).toContain('mode=preview')
    expect(iframe.src).toContain('role=voice_agent')
    expect(iframe.src).toContain('template=')
  })

  it('includes adGroup in URL when provided', () => {
    render(<IframeLayoutPreview role={mockRole as any} adGroup="TestGroup" />)
    const iframe = document.getElementById('preview-iframe') as HTMLIFrameElement
    expect(iframe.src).toContain('adGroup=TestGroup')
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/iframe-layout-preview.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  RefreshCw: (p: Record<string, unknown>) => <span data-testid="refresh" {...p} />,
  ExternalLink: (p: Record<string, unknown>) => <span data-testid="external" {...p} />
}))

vi.mock('../../ui/card', () => ({
  Card: ({ children, className }: any) => <div data-testid="card" className={className}>{children}</div>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: any) => <button onClick={onClick} disabled={disabled}>{children}</button>
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children }: any) => <span data-testid="badge">{children}</span>
}))

import { IframeLayoutPreview } from '../iframe-layout-preview'

const mockRole = {
  roleName: 'voice_agent',
  displayName: 'Voice Agent',
  columns: [],
}

describe('IframeLayoutPreview', () => {
  it('renders preview title with role name', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    expect(screen.getByText('Voice Agent Layout Preview')).toBeInTheDocument()
  })

  it('renders iframe with correct title', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    const iframe = document.getElementById('preview-iframe') as HTMLIFrameElement
    expect(iframe).toBeTruthy()
    expect(iframe.title).toBe('Voice Agent Dashboard Preview')
  })

  it('shows ad group badge when provided', () => {
    render(<IframeLayoutPreview role={mockRole as any} adGroup="TestGroup" />)
    expect(screen.getByText('AD Group: TestGroup')).toBeInTheDocument()
  })

  it('renders refresh button', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    expect(screen.getByText('Refresh')).toBeInTheDocument()
  })

  it('renders open in new tab button', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    expect(screen.getByText('Open Full')).toBeInTheDocument()
  })

  it('opens new tab on button click', () => {
    const openSpy = vi.spyOn(window, 'open').mockImplementation(() => null)
    render(<IframeLayoutPreview role={mockRole as any} />)
    fireEvent.click(screen.getByText('Open Full'))
    expect(openSpy).toHaveBeenCalled()
    openSpy.mockRestore()
  })

  it('renders preview description', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    expect(screen.getByText(/This preview shows the exact dashboard interface/)).toBeInTheDocument()
    expect(screen.getByText(/Real components with demo data/)).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/layout-preview-modal-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  Eye: (p: any) => <span data-testid="eye" {...p} />
}))

vi.mock('../iframe-layout-preview', () => ({
  IframeLayoutPreview: ({ role, adGroup }: any) => <div data-testid="iframe-preview" data-adgroup={adGroup}>{role?.roleName}</div>
}))

vi.mock('../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => <div data-testid="dialog" data-open={String(open)}>{children}</div>,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogTrigger: ({ children }: any) => <div data-testid="trigger">{children}</div>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>
}))

import { LayoutPreviewModal } from '../layout-preview-modal'

describe('LayoutPreviewModal - extra coverage', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('shows no layout message when no role and no fetchLayout', () => {
    render(<LayoutPreviewModal />)
    expect(screen.getByText('No layout data available')).toBeInTheDocument()
  })

  it('renders IframeLayoutPreview when role provided', () => {
    const role = { roleName: 'voice_agent', columns: [] } as any
    render(<LayoutPreviewModal role={role} />)
    expect(screen.getByTestId('iframe-preview')).toBeInTheDocument()
  })

  it('shows ad group name in title when adGroup has logicalName', () => {
    const role = { roleName: 'voice_agent' } as any
    const adGroup = { logicalName: 'UK Retail', groupIdentifier: 'CN=uk' } as any
    render(<LayoutPreviewModal role={role} adGroup={adGroup} />)
    expect(screen.getByText(/UK Retail/)).toBeInTheDocument()
  })

  it('falls back to groupIdentifier when logicalName is absent', () => {
    const role = { roleName: 'voice_agent' } as any
    const adGroup = { groupIdentifier: 'CN=uk-retail' } as any
    render(<LayoutPreviewModal role={role} adGroup={adGroup} />)
    expect(screen.getByText(/CN=uk-retail/)).toBeInTheDocument()
  })

  it('shows AD group override text in description', () => {
    const role = { roleName: 'voice_agent' } as any
    const adGroup = { logicalName: 'Test', groupIdentifier: 'CN=test' } as any
    render(<LayoutPreviewModal role={role} adGroup={adGroup} />)
    expect(screen.getByText(/AD group-specific overrides/)).toBeInTheDocument()
  })

  it('shows base description without adGroup', () => {
    const role = { roleName: 'voice_agent' } as any
    render(<LayoutPreviewModal role={role} />)
    expect(screen.getByText(/Live preview showing the exact interface this role sees/)).toBeInTheDocument()
  })

  it('passes adGroup name to IframeLayoutPreview', () => {
    const role = { roleName: 'voice_agent' } as any
    const adGroup = { logicalName: 'UK Retail', groupIdentifier: 'CN=uk' } as any
    render(<LayoutPreviewModal role={role} adGroup={adGroup} />)
    expect(screen.getByTestId('iframe-preview').dataset.adgroup).toBe('UK Retail')
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/layout-preview-modal-fetch.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, act, waitFor } from '@testing-library/react'

let dialogOnOpenChange: ((open: boolean) => void) | null = null

vi.mock('lucide-react', () => ({
  Eye: (p: any) => <span data-testid="eye" {...p} />
}))

vi.mock('../iframe-layout-preview', () => ({
  IframeLayoutPreview: ({ role }: any) => <div data-testid="iframe-preview">{role?.roleName}</div>
}))

vi.mock('../../ui/dialog', () => ({
  Dialog: ({ children, open, onOpenChange }: any) => {
    dialogOnOpenChange = onOpenChange
    return open ? <div data-testid="dialog-open">{children}</div> : <div data-testid="dialog-closed">{children}</div>
  },
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogTrigger: ({ children }: any) => <div data-testid="trigger">{children}</div>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>
}))

import { LayoutPreviewModal } from '../layout-preview-modal'

describe('LayoutPreviewModal - fetchLayout flow', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    dialogOnOpenChange = null
  })

  it('calls fetchLayout when dialog opens and no pre-loaded role', async () => {
    const fetchedRole = { roleName: 'fetched_role', columns: [] }
    const fetchLayout = vi.fn().mockResolvedValue(fetchedRole)

    render(<LayoutPreviewModal fetchLayout={fetchLayout} />)

    expect(fetchLayout).not.toHaveBeenCalled()

    await act(async () => {
      dialogOnOpenChange?.(true)
    })

    await waitFor(() => {
      expect(fetchLayout).toHaveBeenCalledTimes(1)
    })
  })

  it('displays fetched role after fetchLayout resolves', async () => {
    const fetchedRole = { roleName: 'fetched_role', columns: [] }
    const fetchLayout = vi.fn().mockResolvedValue(fetchedRole)

    const { rerender } = render(<LayoutPreviewModal fetchLayout={fetchLayout} />)

    await act(async () => {
      dialogOnOpenChange?.(true)
    })

    // Rerender with new open state
    rerender(<LayoutPreviewModal fetchLayout={fetchLayout} />)

    await waitFor(() => {
      expect(screen.getByTestId('iframe-preview')).toBeInTheDocument()
    })
  })

  it('handles fetchLayout rejection gracefully', async () => {
    const fetchLayout = vi.fn().mockRejectedValue(new Error('Network error'))

    render(<LayoutPreviewModal fetchLayout={fetchLayout} />)

    await act(async () => {
      dialogOnOpenChange?.(true)
    })

    await waitFor(() => {
      expect(fetchLayout).toHaveBeenCalledTimes(1)
    })
  })

  it('resets loadedRole when dialog closes with fetchLayout', async () => {
    const fetchedRole = { roleName: 'fetched_role', columns: [] }
    const fetchLayout = vi.fn().mockResolvedValue(fetchedRole)

    render(<LayoutPreviewModal fetchLayout={fetchLayout} />)

    // Open dialog
    await act(async () => {
      dialogOnOpenChange?.(true)
    })

    await waitFor(() => {
      expect(fetchLayout).toHaveBeenCalledTimes(1)
    })

    // Close dialog
    await act(async () => {
      dialogOnOpenChange?.(false)
    })

    // Should show no layout data since loadedRole was reset
    expect(screen.getByText('No layout data available')).toBeInTheDocument()
  })

  it('does not call fetchLayout when role is pre-loaded', async () => {
    const role = { roleName: 'preloaded', columns: [] } as any
    const fetchLayout = vi.fn().mockResolvedValue({ roleName: 'other' })

    render(<LayoutPreviewModal role={role} fetchLayout={fetchLayout} />)

    await act(async () => {
      dialogOnOpenChange?.(true)
    })

    // fetchLayout should not be called since role is already available
    expect(screen.getByTestId('iframe-preview')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/__tests__/layout-preview-modal.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  Eye: (p: Record<string, unknown>) => <span data-testid="eye" {...p} />
}))

vi.mock('../iframe-layout-preview', () => ({
  IframeLayoutPreview: ({ role }: any) => <div data-testid="iframe-preview">{role?.roleName}</div>
}))

vi.mock('../../ui/dialog', () => ({
  Dialog: ({ children }: any) => <div data-testid="dialog">{children}</div>,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogTrigger: ({ children }: any) => <div data-testid="trigger">{children}</div>,
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>
}))

import { LayoutPreviewModal } from '../layout-preview-modal'

const mockRole = { roleName: 'voice_agent', displayName: 'Voice Agent', columns: [] }

describe('LayoutPreviewModal', () => {
  it('renders trigger with eye icon', () => {
    render(<LayoutPreviewModal role={mockRole as any} />)
    expect(screen.getByTestId('trigger')).toBeInTheDocument()
    expect(screen.getByText('Preview Dashboard')).toBeInTheDocument()
  })

  it('renders custom trigger children', () => {
    render(<LayoutPreviewModal role={mockRole as any}><span>Custom Trigger</span></LayoutPreviewModal>)
    expect(screen.getByText('Custom Trigger')).toBeInTheDocument()
  })

  it('renders dialog container', () => {
    render(<LayoutPreviewModal role={mockRole as any} />)
    expect(screen.getByTestId('dialog')).toBeInTheDocument()
  })

  it('shows preview title', () => {
    render(<LayoutPreviewModal role={mockRole as any} />)
    expect(screen.getByText('Dashboard Layout Preview')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/ad-group-config/__tests__/ad-group-config-modal.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children, className }: any) => <div data-testid="dialog-content" className={className}>{children}</div>,
  DialogDescription: ({ children, className }: any) => <p className={className}>{children}</p>,
  DialogFooter: ({ children, className }: any) => <div data-testid="dialog-footer" className={className}>{children}</div>,
  DialogHeader: ({ children, className }: any) => <div className={className}>{children}</div>,
  DialogTitle: ({ children, className }: any) => <h2 className={className}>{children}</h2>
}))

vi.mock('../../../ui/button', () => ({
  Button: ({ children, onClick, disabled, variant }: any) => (
    <button onClick={onClick} disabled={disabled} data-variant={variant}>{children}</button>
  )
}))

vi.mock('../../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('../../../ui/tabs', () => ({
  Tabs: ({ children, value }: any) => <div data-testid="tabs" data-value={value}>{children}</div>,
  TabsList: ({ children, className }: any) => <div className={className}>{children}</div>,
  TabsTrigger: ({ children, value }: any) => <button data-testid={`tab-trigger-${value}`}>{children}</button>,
  TabsContent: ({ children, value }: any) => <div data-testid={`tab-content-${value}`}>{children}</div>
}))

vi.mock('lucide-react', () => ({
  Building2: (p: any) => <span data-testid="building-icon" {...p} />,
  Settings: (p: any) => <span data-testid="settings-icon" {...p} />,
  Package: (p: any) => <span data-testid="package-icon" {...p} />,
  AlertTriangle: (p: any) => <span data-testid="alert-icon" {...p} />
}))

const mockUpdateFormData = vi.fn()
const mockSetPendingChanges = vi.fn()
const mockClearStagedAppChanges = vi.fn()

vi.mock('../../../../hooks/admin/use-ad-group-form', () => ({
  useAdGroupForm: () => ({
    formData: { logicalName: 'Test Group', groupIdentifier: 'CN=test', roleName: 'voice_agent' },
    roleTemplate: { name: 'voice_agent', permissions: {} },
    isLoadingRoleTemplate: false,
    permissionOverrides: {},
    pendingChanges: { permissions: {} },
    isLoadingAdGroup: false,
    updateFormData: mockUpdateFormData,
    updatePermissionOverrides: vi.fn(),
    setPendingChanges: mockSetPendingChanges,
    updateAdGroupConfig: vi.fn()
  })
}))

vi.mock('../../../../hooks/admin/use-application-assignment', () => ({
  useApplicationAssignment: () => ({
    selectedApp: null,
    appSearchTerm: '',
    filteredApps: [],
    isLoadingApps: false,
    isSavingAppAssignment: false,
    stagedAppChanges: [],
    setAppSearchTerm: vi.fn(),
    handleAppSelect: vi.fn(),
    handleSaveAppAssignment: vi.fn(),
    clearStagedAppChanges: mockClearStagedAppChanges
  })
}))

vi.mock('../../../../hooks/admin/use-permission-toggle', () => ({
  usePermissionToggle: () => ({
    loadingPermission: null,
    handleTogglePermission: vi.fn()
  })
}))

vi.mock('../../../../hooks/admin/use-config-save', () => ({
  useConfigSave: () => ({
    showSaveDialog: false,
    setShowSaveDialog: vi.fn(),
    handleSaveClick: vi.fn(),
    handleDirectSaveClick: vi.fn(),
    handleConfirmSave: vi.fn(),
    isDirectSave: false
  })
}))

vi.mock('../dialogs/save-confirmation-dialog', () => ({
  SaveConfirmationDialog: () => null
}))

vi.mock('../dialogs/unsaved-changes-dialog', () => ({
  UnsavedChangesDialog: () => null
}))

vi.mock('../../tabs/business-info-tab', () => ({
  BusinessInfoTab: () => <div data-testid="business-info-tab">Business Info</div>
}))

vi.mock('../../tabs/permissions-tab', () => ({
  PermissionsTab: () => <div data-testid="permissions-tab">Permissions</div>
}))

vi.mock('../../tabs/applications-tab', () => ({
  ApplicationsTab: () => <div data-testid="applications-tab">Applications</div>
}))

vi.mock('../utils/permission-helpers', () => ({
  hasUnsavedChanges: () => false,
  isBusinessInfoComplete: () => true
}))

import { AdGroupConfigModal } from '../ad-group-config-modal'

const baseGroup = {
  id: 'g1',
  groupIdentifier: 'CN=test-group',
  logicalName: 'Test Group',
  roleName: 'voice_agent',
  accessLevel: 'MAKER'
} as any

const allPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: false,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

describe('AdGroupConfigModal', () => {
  const defaultProps = {
    group: baseGroup,
    open: true,
    onClose: vi.fn(),
    onSave: vi.fn(),
    permissions: allPermissions
  }

  it('renders dialog with group name when open', () => {
    render(<AdGroupConfigModal {...defaultProps} />)
    expect(screen.getByText('Test Group')).toBeInTheDocument()
    expect(screen.getByText('CN=test-group')).toBeInTheDocument()
  })

  it('does not render when closed', () => {
    render(<AdGroupConfigModal {...defaultProps} open={false} />)
    expect(screen.queryByTestId('dialog')).not.toBeInTheDocument()
  })

  it('renders all three tab triggers when permissions allow', () => {
    render(<AdGroupConfigModal {...defaultProps} />)
    expect(screen.getByTestId('tab-trigger-basic')).toBeInTheDocument()
    expect(screen.getByTestId('tab-trigger-permissions')).toBeInTheDocument()
    expect(screen.getByTestId('tab-trigger-applications')).toBeInTheDocument()
  })

  it('hides tabs when permissions deny access', () => {
    const restricted = {
      ...allPermissions,
      canEditBusinessInfo: false,
      canEditPermissions: false,
      canEditApplications: false
    }
    render(<AdGroupConfigModal {...defaultProps} permissions={restricted} />)
    expect(screen.queryByTestId('tab-trigger-basic')).not.toBeInTheDocument()
    expect(screen.queryByTestId('tab-trigger-permissions')).not.toBeInTheDocument()
    expect(screen.queryByTestId('tab-trigger-applications')).not.toBeInTheDocument()
  })

  it('shows submit for approval button for non-SUPER_ADMIN', () => {
    render(<AdGroupConfigModal {...defaultProps} />)
    expect(screen.getByText('Submit for Approval')).toBeInTheDocument()
  })

  it('shows save changes button for SUPER_ADMIN access level', () => {
    const superGroup = { ...baseGroup, accessLevel: 'SUPER_ADMIN' }
    render(<AdGroupConfigModal {...defaultProps} group={superGroup} />)
    expect(screen.getByText('Save Changes')).toBeInTheDocument()
  })

  it('uses max-viewport dialog sizing classes', () => {
    render(<AdGroupConfigModal {...defaultProps} />)
    const dialogContent = screen.getByTestId('dialog-content')
    expect(dialogContent.className).toContain('!w-screen')
    expect(dialogContent.className).toContain('!max-w-none')
    expect(dialogContent.className).toContain('!h-[100dvh]')
  })
})
===ENDFILE

===FILE: src/components/admin/ad-group-config/__tests__/config-modal-sub-components.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../ui/button', () => ({
  Button: ({ children, onClick, disabled, variant, title }: any) => (
    <button onClick={onClick} disabled={disabled} data-variant={variant} title={title}>{children}</button>
  )
}))

vi.mock('../../../ui/badge', () => ({
  Badge: ({ children, className, variant }: any) => <span data-testid="badge" className={className} data-variant={variant}>{children}</span>
}))

vi.mock('../../../ui/tabs', () => ({
  TabsTrigger: ({ children, value, className }: any) => <button data-testid={`tab-${value}`} className={className}>{children}</button>
}))

vi.mock('lucide-react', () => ({
  Building2: (p: any) => <span data-testid="building-icon" {...p} />,
  Settings: (p: any) => <span data-testid="settings-icon" {...p} />,
  Package: (p: any) => <span data-testid="package-icon" {...p} />
}))

import { getTabGridClass, getGroupDisplayName, ConfigModalTabTriggers, ConfigModalFooterActions } from '../config-modal-sub-components'

describe('getTabGridClass', () => {
  it('returns grid-cols-3 for 3', () => {
    expect(getTabGridClass(3)).toBe('grid-cols-3')
  })

  it('returns grid-cols-2 for 2', () => {
    expect(getTabGridClass(2)).toBe('grid-cols-2')
  })

  it('returns grid-cols-1 for 1', () => {
    expect(getTabGridClass(1)).toBe('grid-cols-1')
  })

  it('returns grid-cols-1 for 0', () => {
    expect(getTabGridClass(0)).toBe('grid-cols-1')
  })
})

describe('getGroupDisplayName', () => {
  it('returns logicalName when present', () => {
    expect(getGroupDisplayName({ logicalName: 'UK Retail', groupIdentifier: 'CN=group' })).toBe('UK Retail')
  })

  it('falls back to groupIdentifier', () => {
    expect(getGroupDisplayName({ groupIdentifier: 'CN=group' })).toBe('CN=group')
  })
})

describe('ConfigModalTabTriggers', () => {
  it('renders all tabs when all permissions true', () => {
    render(
      <ConfigModalTabTriggers
        canEditBusinessInfo={true}
        canEditPermissions={true}
        canEditApplications={true}
        stagedAppChangesCount={0}
      />
    )
    expect(screen.getByText('Business Info')).toBeInTheDocument()
    expect(screen.getByText('Permissions')).toBeInTheDocument()
    expect(screen.getByText('Applications')).toBeInTheDocument()
  })

  it('hides business info tab when not permitted', () => {
    render(
      <ConfigModalTabTriggers
        canEditBusinessInfo={false}
        canEditPermissions={true}
        canEditApplications={true}
        stagedAppChangesCount={0}
      />
    )
    expect(screen.queryByText('Business Info')).not.toBeInTheDocument()
  })

  it('shows staged changes badge when count > 0', () => {
    render(
      <ConfigModalTabTriggers
        canEditBusinessInfo={false}
        canEditPermissions={false}
        canEditApplications={true}
        stagedAppChangesCount={3}
      />
    )
    expect(screen.getByText('3')).toBeInTheDocument()
  })

  it('hides staged changes badge when count is 0', () => {
    render(
      <ConfigModalTabTriggers
        canEditBusinessInfo={false}
        canEditPermissions={false}
        canEditApplications={true}
        stagedAppChangesCount={0}
      />
    )
    expect(screen.queryByTestId('badge')).not.toBeInTheDocument()
  })
})

describe('ConfigModalFooterActions', () => {
  const baseProps = {
    isReadOnly: false,
    canDirectSave: false,
    isBusinessComplete: true,
    isLoadingAdGroup: false,
    isLoadingRoleTemplate: false,
    onClose: vi.fn(),
    onDirectSave: vi.fn(),
    onSubmit: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders Cancel button in edit mode', () => {
    render(<ConfigModalFooterActions {...baseProps} />)
    expect(screen.getByText('Cancel')).toBeInTheDocument()
  })

  it('renders Close button in read-only mode', () => {
    render(<ConfigModalFooterActions {...baseProps} isReadOnly={true} />)
    expect(screen.getByText('Close')).toBeInTheDocument()
    expect(screen.getByText('Read-only access')).toBeInTheDocument()
  })

  it('renders Submit for Approval when not direct save', () => {
    render(<ConfigModalFooterActions {...baseProps} />)
    expect(screen.getByText('Submit for Approval')).toBeInTheDocument()
  })

  it('renders Save Changes when direct save', () => {
    render(<ConfigModalFooterActions {...baseProps} canDirectSave={true} />)
    expect(screen.getByText('Save Changes')).toBeInTheDocument()
  })

  it('calls onClose when cancel clicked', () => {
    render(<ConfigModalFooterActions {...baseProps} />)
    fireEvent.click(screen.getByText('Cancel'))
    expect(baseProps.onClose).toHaveBeenCalled()
  })

  it('calls onSubmit when submit clicked', () => {
    render(<ConfigModalFooterActions {...baseProps} />)
    fireEvent.click(screen.getByText('Submit for Approval'))
    expect(baseProps.onSubmit).toHaveBeenCalled()
  })

  it('calls onDirectSave when save clicked', () => {
    render(<ConfigModalFooterActions {...baseProps} canDirectSave={true} />)
    fireEvent.click(screen.getByText('Save Changes'))
    expect(baseProps.onDirectSave).toHaveBeenCalled()
  })

  it('disables save when business info incomplete', () => {
    render(<ConfigModalFooterActions {...baseProps} isBusinessComplete={false} />)
    expect(screen.getByText('Submit for Approval')).toBeDisabled()
  })

  it('disables save when loading ad group', () => {
    render(<ConfigModalFooterActions {...baseProps} isLoadingAdGroup={true} />)
    expect(screen.getByText('Submit for Approval')).toBeDisabled()
  })

  it('hides save/submit in read-only mode', () => {
    render(<ConfigModalFooterActions {...baseProps} isReadOnly={true} />)
    expect(screen.queryByText('Submit for Approval')).not.toBeInTheDocument()
    expect(screen.queryByText('Save Changes')).not.toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/ad-group-config/ad-group-config-modal.tsx
import { useState } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '../../ui/dialog'
import { Badge } from '../../ui/badge'
import { Tabs, TabsContent, TabsList } from '../../ui/tabs'
import {
  Building2,
  AlertTriangle
} from 'lucide-react'

// Import hooks
import { useAdGroupForm } from '../../../hooks/admin/use-ad-group-form'
import { useApplicationAssignment } from '../../../hooks/admin/use-application-assignment'
import { usePermissionToggle } from '../../../hooks/admin/use-permission-toggle'
import { useConfigSave } from '../../../hooks/admin/use-config-save'

// Import components
import { SaveConfirmationDialog } from './dialogs/save-confirmation-dialog'
import { UnsavedChangesDialog } from './dialogs/unsaved-changes-dialog'
import { BusinessInfoTab } from '../tabs/business-info-tab'
import { PermissionsTab } from '../tabs/permissions-tab'
import { ApplicationsTab } from '../tabs/applications-tab'
import {
  getTabGridClass,
  getGroupDisplayName,
  ConfigModalTabTriggers,
  ConfigModalFooterActions
} from './config-modal-sub-components'

// Import types and utils
import type { AdGroupConfigModalProps } from '../../../types/features/ad-group-config'
import type { AdminPermissions } from '../admin-layout'
import {
  hasUnsavedChanges,
  isBusinessInfoComplete
} from './utils/permission-helpers'

/** Re-export sub-components for backward compatibility */
export { getTabGridClass, getGroupDisplayName, ConfigModalTabTriggers, ConfigModalFooterActions } from './config-modal-sub-components'

/** Extended props for the AD group config modal that include the caller's admin permissions. */
interface AdGroupConfigModalWithPermissionsProps extends AdGroupConfigModalProps {
  /** The admin permissions controlling which tabs and actions are available */
  permissions: AdminPermissions
}

/**
 * Full-screen modal for configuring an AD group's business info, permissions, and applications.
 * Integrates the maker/checker approval workflow for non-super-admin users.
 * @param props - The modal props including group data, callbacks, and permissions
 */
export function AdGroupConfigModal({
  group,
  open,
  onClose,
  onSave,
  permissions
}: Readonly<AdGroupConfigModalWithPermissionsProps>) {
  const [activeTab, setActiveTab] = useState('basic')
  const [searchTerm, setSearchTerm] = useState('')
  const [showUnsavedChangesDialog, setShowUnsavedChangesDialog] = useState(false)

  // Extract tab permissions from props (following agent role pattern)
  const { canEditBusinessInfo, canEditPermissions, canEditApplications } = permissions

  // Per-group access level determines save behavior (not global entitlement)
  // SUPER_ADMIN on this specific group = can bypass approval workflow
  const canDirectSave = group.accessLevel === 'SUPER_ADMIN'
  // VIEWER on this specific group = read-only, no editing allowed
  const isReadOnly = group.accessLevel === 'VIEWER'

  // Form and permission management
  const {
    formData,
    roleTemplate,
    isLoadingRoleTemplate,
    permissionOverrides,
    pendingChanges,
    isLoadingAdGroup,
    updateFormData,
    updatePermissionOverrides,
    setPendingChanges,
    updateAdGroupConfig,
  } = useAdGroupForm({ initialGroup: group, open })

  // Application assignment management
  const {
    selectedApp,
    appSearchTerm,
    filteredApps,
    isLoadingApps,
    isSavingAppAssignment,
    stagedAppChanges,
    setAppSearchTerm,
    handleAppSelect,
    handleSaveAppAssignment,
    handleFunctionSelectionChange,
    flushUnsavedFunctions,
    clearStagedAppChanges,
  } = useApplicationAssignment({
    groupIdentifier: group.groupIdentifier,
    groupDisplayName: getGroupDisplayName(group),
    open,
    activeTab,
    canDirectSave
  })

  // Permission toggle management
  const { loadingPermission, handleTogglePermission } = usePermissionToggle({
    roleTemplate,
    permissionOverrides,
    pendingChanges,
    setPendingChanges
  })

  // Save configuration management
  const {
    showSaveDialog,
    setShowSaveDialog,
    handleSaveClick,
    handleDirectSaveClick,
    handleConfirmSave,
    isDirectSave
  } = useConfigSave({
    formData,
    group,
    permissionOverrides,
    pendingChanges,
    stagedAppChanges,
    canDirectSave,
    updateAdGroupConfig,
    updatePermissionOverrides,
    setPendingChanges,
    clearStagedAppChanges,
    flushUnsavedFunctions,
    onSave,
    onClose
  })

  const isBusinessComplete = isBusinessInfoComplete(formData)
  const hasAnyUnsavedChanges = hasUnsavedChanges(pendingChanges) || stagedAppChanges.length > 0

  const handleClose = () => {
    if (hasAnyUnsavedChanges) {
      setShowUnsavedChangesDialog(true)
    } else {
      onClose()
    }
  }

  const handleConfirmClose = () => {
    setPendingChanges({ permissions: {} })
    clearStagedAppChanges()
    setShowUnsavedChangesDialog(false)
    onClose()
  }

  return (
    <>
      <Dialog open={open} onOpenChange={handleClose}>
        <DialogContent className="!h-[100dvh] !max-h-[100dvh] !w-screen !max-w-none min-h-0 flex flex-col rounded-none p-4 sm:p-6">
          <DialogHeader className="shrink-0">
            <DialogTitle className="flex items-center gap-2">
              <Building2 className="h-5 w-5" />
              {isBusinessComplete ? 'Edit AD Group Configuration' : 'Configure AD Group'}
              {hasAnyUnsavedChanges && (
                <Badge variant="secondary" className="bg-orange-100 text-orange-700 border-orange-200">
                  <AlertTriangle className="h-3 w-3 mr-1" />
                  Unsaved Changes
                </Badge>
              )}
            </DialogTitle>
            <DialogDescription className="sr-only">
              Configure business information and permissions for this Active Directory group.
            </DialogDescription>
            <div className="mt-2">
              <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
                <p className="text-sm text-blue-900 font-medium">Active Directory Group</p>
                <p className="text-sm font-medium mt-1">{group.logicalName}</p>
                <p className="text-xs text-gray-600">{group.groupIdentifier}</p>
              </div>
              <p className="text-sm text-gray-600 mt-3">
                Configure business information and permissions for this Active Directory group.
              </p>
            </div>
          </DialogHeader>

          <div className="mt-4 min-h-0 flex-1 overflow-hidden">
            <Tabs value={activeTab} onValueChange={setActiveTab} className="flex h-full min-h-0 flex-col">
              {/* Dynamic grid layout based on visible tabs */}
              <TabsList className={`grid w-full ${getTabGridClass([canEditBusinessInfo, canEditPermissions, canEditApplications].filter(Boolean).length)}`}>
                <ConfigModalTabTriggers
                  canEditBusinessInfo={canEditBusinessInfo}
                  canEditPermissions={canEditPermissions}
                  canEditApplications={canEditApplications}
                  stagedAppChangesCount={stagedAppChanges.length}
                />
              </TabsList>

              <div className="mt-6 min-h-0 flex-1 overflow-hidden">
                {canEditBusinessInfo && (
                  <TabsContent value="basic" className="mt-0 h-full min-h-0 overflow-hidden">
                    <div className="h-full min-h-0 w-full overflow-y-auto pr-2 scrollbar-visible">
                      <BusinessInfoTab
                        formData={formData}
                        pendingChanges={pendingChanges}
                        onFormDataChange={updateFormData}
                        onPendingChangesUpdate={setPendingChanges}
                        isReadOnly={isReadOnly}
                      />
                    </div>
                  </TabsContent>
                )}

                {canEditPermissions && (
                  <TabsContent value="permissions" className="mt-0 h-full min-h-0 overflow-hidden">
                    <div className="h-full min-h-0 w-full overflow-y-auto pr-2 scrollbar-visible">
                      <PermissionsTab
                        formData={formData}
                        roleTemplate={roleTemplate}
                        permissionOverrides={permissionOverrides}
                        pendingChanges={pendingChanges}
                        searchTerm={searchTerm}
                        loadingPermission={loadingPermission}
                        isLoadingTemplate={isLoadingRoleTemplate}
                        onSearchTermChange={setSearchTerm}
                        onTogglePermission={(level, key, value) => handleTogglePermission({ level, key, value })}
                        isReadOnly={isReadOnly}
                      />
                    </div>
                  </TabsContent>
                )}

                {canEditApplications && (
                  <TabsContent value="applications" className="mt-0 h-full min-h-0 overflow-hidden">
                    <div className="h-full min-h-0 w-full overflow-y-auto pr-2 scrollbar-visible">
                      <ApplicationsTab
                        availableApps={filteredApps}
                        selectedApp={selectedApp}
                        appSearchTerm={appSearchTerm}
                        groupDisplayName={getGroupDisplayName(group)}
                        isLoadingApps={isLoadingApps}
                        isSavingAppAssignment={isSavingAppAssignment}
                        onAppSearchTermChange={setAppSearchTerm}
                        onAppSelect={handleAppSelect}
                        onAppSave={handleSaveAppAssignment}
                        onFunctionSelectionChange={handleFunctionSelectionChange}
                        isReadOnly={isReadOnly}
                      />
                    </div>
                  </TabsContent>
                )}
              </div>
            </Tabs>
          </div>

          <DialogFooter className="shrink-0">
            <ConfigModalFooterActions
              isReadOnly={isReadOnly}
              canDirectSave={canDirectSave}
              isBusinessComplete={isBusinessComplete}
              isLoadingAdGroup={isLoadingAdGroup}
              isLoadingRoleTemplate={isLoadingRoleTemplate}
              onClose={handleClose}
              onDirectSave={handleDirectSaveClick}
              onSubmit={handleSaveClick}
            />
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <SaveConfirmationDialog
        open={showSaveDialog}
        onClose={() => setShowSaveDialog(false)}
        onConfirm={handleConfirmSave}
        pendingChanges={pendingChanges}
        groupName={formData.logicalName || 'Unknown Group'}
        isDirectSave={isDirectSave}
      />

      <UnsavedChangesDialog
        open={showUnsavedChangesDialog}
        onClose={() => setShowUnsavedChangesDialog(false)}
        onConfirm={handleConfirmClose}
      />
    </>
  )
}
===ENDFILE

===FILE: src/components/admin/ad-group-config/config-modal-sub-components.tsx
/**
 * Config Modal Sub-Components
 * Extracted presentational components for the AD group configuration modal.
 */

import { Button } from '../../ui/button'
import { Badge } from '../../ui/badge'
import { TabsTrigger } from '../../ui/tabs'
import { Building2, Settings, Package } from 'lucide-react'

/** Returns the Tailwind grid class based on how many tabs are visible. */
export function getTabGridClass(visibleCount: number): string {
  if (visibleCount === 3) return 'grid-cols-3'
  if (visibleCount === 2) return 'grid-cols-2'
  return 'grid-cols-1'
}

/** Resolves the display name for an AD group. */
export function getGroupDisplayName(group: { logicalName?: string; groupIdentifier: string }): string {
  return group.logicalName || group.groupIdentifier
}

/** Renders the tab triggers for the config modal based on visible permissions. */
export function ConfigModalTabTriggers({ canEditBusinessInfo, canEditPermissions, canEditApplications, stagedAppChangesCount }: Readonly<{
  canEditBusinessInfo: boolean
  canEditPermissions: boolean
  canEditApplications: boolean
  stagedAppChangesCount: number
}>) {
  return (
    <>
      {canEditBusinessInfo && (
        <TabsTrigger value="basic" className="flex items-center gap-2">
          <Building2 className="h-4 w-4" />
          Business Info
        </TabsTrigger>
      )}
      {canEditPermissions && (
        <TabsTrigger value="permissions" className="flex items-center gap-2">
          <Settings className="h-4 w-4" />
          Permissions
        </TabsTrigger>
      )}
      {canEditApplications && (
        <TabsTrigger value="applications" className="flex items-center gap-2">
          <Package className="h-4 w-4" />
          Applications
          {stagedAppChangesCount > 0 && (
            <Badge variant="secondary" className="bg-orange-100 text-orange-700 text-xs px-1.5 py-0">
              {stagedAppChangesCount}
            </Badge>
          )}
        </TabsTrigger>
      )}
    </>
  )
}

function SaveButton({ canDirectSave, isSaveDisabled, incompleteTitle, onDirectSave, onSubmit }: Readonly<{
  canDirectSave: boolean; isSaveDisabled: boolean; incompleteTitle: string | undefined
  onDirectSave: () => void; onSubmit: () => void
}>) {
  if (canDirectSave) return <Button onClick={onDirectSave} disabled={isSaveDisabled} title={incompleteTitle}>Save Changes</Button>
  return <Button onClick={onSubmit} disabled={isSaveDisabled} title={incompleteTitle}>Submit for Approval</Button>
}

/** Renders the footer action buttons for the config modal. */
export function ConfigModalFooterActions({ isReadOnly, canDirectSave, isBusinessComplete, isLoadingAdGroup, isLoadingRoleTemplate, onClose, onDirectSave, onSubmit }: Readonly<{
  isReadOnly: boolean
  canDirectSave: boolean
  isBusinessComplete: boolean
  isLoadingAdGroup: boolean
  isLoadingRoleTemplate: boolean
  onClose: () => void
  onDirectSave: () => void
  onSubmit: () => void
}>) {
  const isSaveDisabled = isLoadingAdGroup || isLoadingRoleTemplate || !isBusinessComplete
  const incompleteTitle = isBusinessComplete ? undefined : 'Complete all required business info fields before saving'

  return (
    <>
      {isReadOnly && (
        <div className="flex-1 flex items-center">
          <Badge variant="secondary" className="bg-gray-100 text-gray-600 border-gray-300">Read-only access</Badge>
        </div>
      )}
      <Button variant="outline" onClick={onClose}>{isReadOnly ? 'Close' : 'Cancel'}</Button>
      {!isReadOnly && <SaveButton canDirectSave={canDirectSave} isSaveDisabled={isSaveDisabled} incompleteTitle={incompleteTitle} onDirectSave={onDirectSave} onSubmit={onSubmit} />}
    </>
  )
}
===ENDFILE

===FILE: src/components/admin/ad-group-config/dialogs/__tests__/save-confirmation-dialog-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../../ui/alert-dialog', () => ({
  AlertDialog: ({ children, open }: any) => open ? <div data-testid="alert-dialog">{children}</div> : null,
  AlertDialogAction: ({ children, onClick }: any) => <button data-testid="alert-action" onClick={onClick}>{children}</button>,
  AlertDialogCancel: ({ children, onClick }: any) => <button data-testid="alert-cancel" onClick={onClick}>{children}</button>,
  AlertDialogContent: ({ children }: any) => <div>{children}</div>,
  AlertDialogDescription: ({ children, asChild }: any) => <div>{children}</div>,
  AlertDialogFooter: ({ children }: any) => <div>{children}</div>,
  AlertDialogHeader: ({ children }: any) => <div>{children}</div>,
  AlertDialogTitle: ({ children }: any) => <h4>{children}</h4>
}))

vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('lucide-react', () => ({
  CheckCircle: () => <span data-testid="check-icon" />,
  Building2: () => <span data-testid="building-icon" />
}))

vi.mock('../../utils/permission-format-helpers', () => ({
  countPendingChangesByType: (changes: any) => ({
    businessInfoCount: Object.keys(changes.businessInfo || {}).length,
    permissionCount: Object.keys(changes.permissions || {}).length
  }),
  summarizePermissionChanges: (permissions: any) => {
    if (!permissions || Object.keys(permissions).length === 0) return []
    return [{ label: 'Access Controls', count: Object.keys(permissions).length, items: Object.keys(permissions) }]
  }
}))

import { SaveConfirmationDialog } from '../save-confirmation-dialog'

describe('SaveConfirmationDialog - extra coverage', () => {
  const baseProps = {
    open: true,
    onClose: vi.fn(),
    onConfirm: vi.fn(),
    pendingChanges: {
      businessInfo: {},
      permissions: {}
    } as any,
    groupName: 'UK Retail Agents'
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('shows approval flow messaging by default', () => {
    render(<SaveConfirmationDialog {...baseProps} />)
    expect(screen.getByText(/submit configuration changes for/)).toBeInTheDocument()
    expect(screen.getByText(/reviewer will need to approve/)).toBeInTheDocument()
    expect(screen.getByText('Submit for Approval')).toBeInTheDocument()
  })

  it('shows direct save warning when isDirectSave', () => {
    render(<SaveConfirmationDialog {...baseProps} isDirectSave={true} />)
    expect(screen.getByText(/apply configuration changes directly/)).toBeInTheDocument()
    expect(screen.getByText(/Super Admin/)).toBeInTheDocument()
    expect(screen.getByText('Save Changes')).toBeInTheDocument()
  })

  it('hides reviewer note when isDirectSave', () => {
    render(<SaveConfirmationDialog {...baseProps} isDirectSave={true} />)
    expect(screen.queryByText(/reviewer will need to approve/)).not.toBeInTheDocument()
  })

  it('shows business info section when there are business changes', () => {
    const changes = {
      businessInfo: { logicalName: 'New Name', region: 'APAC' },
      permissions: {}
    } as any
    render(<SaveConfirmationDialog {...baseProps} pendingChanges={changes} />)
    expect(screen.getByText(/business information fields will be updated/)).toBeInTheDocument()
  })

  it('uses singular for 1 business field', () => {
    const changes = {
      businessInfo: { logicalName: 'New Name' },
      permissions: {}
    } as any
    render(<SaveConfirmationDialog {...baseProps} pendingChanges={changes} />)
    expect(screen.getByText(/1 business information field will be updated/)).toBeInTheDocument()
  })

  it('shows permission changes section with summaries', () => {
    const changes = {
      businessInfo: {},
      permissions: { 'toggle-a': 'VISIBLE', 'toggle-b': 'HIDDEN' }
    } as any
    render(<SaveConfirmationDialog {...baseProps} pendingChanges={changes} />)
    expect(screen.getByText(/permission changes will be submitted/)).toBeInTheDocument()
    expect(screen.getByText('Access Controls')).toBeInTheDocument()
  })

  it('calls onConfirm when action button clicked', () => {
    render(<SaveConfirmationDialog {...baseProps} />)
    fireEvent.click(screen.getByTestId('alert-action'))
    expect(baseProps.onConfirm).toHaveBeenCalled()
  })

  it('calls onClose when cancel button clicked', () => {
    render(<SaveConfirmationDialog {...baseProps} />)
    fireEvent.click(screen.getByTestId('alert-cancel'))
    expect(baseProps.onClose).toHaveBeenCalled()
  })

  it('includes group name in messaging', () => {
    render(<SaveConfirmationDialog {...baseProps} />)
    expect(screen.getByText(/UK Retail Agents/)).toBeInTheDocument()
  })

  it('hides business section when no business changes', () => {
    render(<SaveConfirmationDialog {...baseProps} />)
    expect(screen.queryByText(/business information field/)).not.toBeInTheDocument()
  })

  it('hides permission section when no permission changes', () => {
    render(<SaveConfirmationDialog {...baseProps} />)
    expect(screen.queryByText(/permission change/)).not.toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/ad-group-config/dialogs/__tests__/save-confirmation-dialog.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../ui/alert-dialog', () => ({
  AlertDialog: ({ children, open }: any) => open ? <div data-testid="alert-dialog">{children}</div> : null,
  AlertDialogAction: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>,
  AlertDialogCancel: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>,
  AlertDialogContent: ({ children }: any) => <div>{children}</div>,
  AlertDialogDescription: ({ children }: any) => <div>{children}</div>,
  AlertDialogFooter: ({ children }: any) => <div>{children}</div>,
  AlertDialogHeader: ({ children }: any) => <div>{children}</div>,
  AlertDialogTitle: ({ children }: any) => <h2>{children}</h2>
}))
vi.mock('../../../../ui/badge', () => ({ Badge: ({ children }: any) => <span>{children}</span> }))
vi.mock('lucide-react', () => ({
  CheckCircle: (p: any) => <span {...p} />,
  Building2: (p: any) => <span {...p} />
}))
vi.mock('../../utils/permission-format-helpers', () => ({
  countPendingChangesByType: () => ({ businessInfoCount: 1, permissionCount: 2, appCount: 0 }),
  summarizePermissionChanges: () => [{ label: 'Enabled', count: 1, items: ['voice'] }]
}))

import { SaveConfirmationDialog } from '../save-confirmation-dialog'

const basePendingChanges = { businessInfo: {}, permissions: {}, apps: {} } as any

describe('SaveConfirmationDialog', () => {
  it('renders nothing when closed', () => {
    const { container } = render(
      <SaveConfirmationDialog open={false} onClose={vi.fn()} onConfirm={vi.fn()} pendingChanges={basePendingChanges} groupName="Test" />
    )
    expect(container.querySelector('[data-testid="alert-dialog"]')).toBeNull()
  })

  it('renders submit for approval title by default', () => {
    render(
      <SaveConfirmationDialog open={true} onClose={vi.fn()} onConfirm={vi.fn()} pendingChanges={basePendingChanges} groupName="Test" />
    )
    expect(screen.getByText('Submit Changes for Approval?')).toBeInTheDocument()
  })

  it('renders direct save title when isDirectSave', () => {
    render(
      <SaveConfirmationDialog open={true} onClose={vi.fn()} onConfirm={vi.fn()} pendingChanges={basePendingChanges} groupName="Test" isDirectSave />
    )
    expect(screen.getByText('Apply Changes Immediately?')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/ad-group-config/dialogs/__tests__/unsaved-changes-dialog.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../ui/alert-dialog', () => ({
  AlertDialog: ({ children, open }: any) => open ? <div data-testid="alert-dialog">{children}</div> : null,
  AlertDialogAction: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>,
  AlertDialogCancel: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>,
  AlertDialogContent: ({ children }: any) => <div>{children}</div>,
  AlertDialogDescription: ({ children }: any) => <div>{children}</div>,
  AlertDialogFooter: ({ children }: any) => <div>{children}</div>,
  AlertDialogHeader: ({ children }: any) => <div>{children}</div>,
  AlertDialogTitle: ({ children }: any) => <h2>{children}</h2>
}))
vi.mock('lucide-react', () => ({
  AlertTriangle: (p: any) => <span {...p} />
}))

import { UnsavedChangesDialog } from '../unsaved-changes-dialog'

describe('UnsavedChangesDialog', () => {
  it('renders nothing when closed', () => {
    const { container } = render(
      <UnsavedChangesDialog open={false} onClose={vi.fn()} onConfirm={vi.fn()} />
    )
    expect(container.querySelector('[data-testid="alert-dialog"]')).toBeNull()
  })

  it('renders dialog when open', () => {
    render(<UnsavedChangesDialog open={true} onClose={vi.fn()} onConfirm={vi.fn()} />)
    expect(screen.getByTestId('alert-dialog')).toBeInTheDocument()
    expect(screen.getByText('Unsaved Changes')).toBeInTheDocument()
  })

  it('renders continue editing and discard buttons', () => {
    render(<UnsavedChangesDialog open={true} onClose={vi.fn()} onConfirm={vi.fn()} />)
    expect(screen.getByText('Continue Editing')).toBeInTheDocument()
    expect(screen.getByText('Discard Changes')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/ad-group-config/dialogs/save-confirmation-dialog.tsx
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '../../../ui/alert-dialog'
import { Badge } from '../../../ui/badge'
import { CheckCircle, Building2 } from 'lucide-react'
import type { PendingChanges } from '../../../../types/features/ad-group-config'
import { countPendingChangesByType, summarizePermissionChanges } from '../utils/permission-format-helpers'

/**
 * Returns a pluralized string based on count.
 * @param count - The quantity to check
 * @param singular - The singular form of the noun
 * @param plural - The plural form of the noun
 * @returns Formatted string with count and appropriate noun form
 */
function pluralize(count: number, singular: string, plural: string): string {
  return count === 1 ? `${count} ${singular}` : `${count} ${plural}`
}

/** Props for the SaveConfirmationDialog component. */
interface SaveConfirmationDialogProps {
  /** Whether the dialog is open */
  open: boolean
  /** Callback invoked when the dialog is closed */
  onClose: () => void
  /** Callback invoked when the user confirms the save action */
  onConfirm: () => void
  /** The pending changes to summarize in the confirmation dialog */
  pendingChanges: PendingChanges
  /** Display name of the AD group being modified */
  groupName: string
  /** When true, shows super admin direct save messaging instead of approval flow */
  isDirectSave?: boolean
}

/**
 * Confirmation dialog shown before submitting or directly saving AD group changes.
 * Summarizes business info and permission changes with appropriate messaging
 * based on whether the save is direct (super admin) or requires approval.
 */
export function SaveConfirmationDialog({
  open,
  onClose,
  onConfirm,
  pendingChanges,
  groupName,
  isDirectSave = false
}: Readonly<SaveConfirmationDialogProps>) {
  const counts = countPendingChangesByType(pendingChanges)
  const summaries = summarizePermissionChanges(pendingChanges.permissions)

  return (
    <AlertDialog open={open} onOpenChange={onClose}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>{isDirectSave ? 'Apply Changes Immediately?' : 'Submit Changes for Approval?'}</AlertDialogTitle>
          <AlertDialogDescription asChild>
            <div className="space-y-3">
              <p>
                {isDirectSave
                  ? `You are about to apply configuration changes directly to ${groupName}. These changes will take effect immediately without requiring approval.`
                  : `You are about to submit configuration changes for ${groupName} for review.`}
              </p>

              {isDirectSave && (
                <div className="bg-amber-50 border border-amber-200 rounded-lg p-3">
                  <p className="text-sm font-medium text-amber-900">
                    As a Super Admin, you are bypassing the standard approval workflow. Please ensure these changes are correct.
                  </p>
                </div>
              )}

              {counts.businessInfoCount > 0 && (
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
                  <p className="text-sm font-medium text-blue-900 flex items-center gap-2">
                    <Building2 className="h-4 w-4" />
                    {`${pluralize(counts.businessInfoCount, 'business information field', 'business information fields')} will be updated`}
                  </p>
                </div>
              )}

              {counts.permissionCount > 0 && (
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
                  <p className="text-sm font-medium text-blue-900 flex items-center gap-2">
                    <CheckCircle className="h-4 w-4" />
                    {`${pluralize(counts.permissionCount, 'permission change', 'permission changes')} will be submitted`}
                  </p>
                  {summaries.length > 0 && (
                    <div className="mt-2 space-y-1">
                      {summaries.map(summary => (
                        <div key={summary.label} className="text-xs text-blue-900/90">
                          <span className="font-semibold">{summary.label}</span>
                          <span className="ml-1 text-blue-900/70">
                            ({pluralize(summary.count, 'change', 'changes')})
                          </span>
                          <div className="mt-0.5 flex flex-wrap gap-1.5">
                            {summary.items.map(item => (
                              <Badge key={item} variant="secondary" className="text-[11px] capitalize">
                                {item}
                              </Badge>
                            ))}
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}

              {!isDirectSave && (
                <p className="text-sm text-gray-600">
                  A reviewer will need to approve these changes before they take effect.
                </p>
              )}
            </div>
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel onClick={onClose}>Cancel</AlertDialogCancel>
          <AlertDialogAction onClick={onConfirm}>{isDirectSave ? 'Save Changes' : 'Submit for Approval'}</AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  )
}
===ENDFILE

===FILE: src/components/admin/ad-group-config/dialogs/unsaved-changes-dialog.tsx
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '../../../ui/alert-dialog'
import { AlertTriangle } from 'lucide-react'

/** Props for the UnsavedChangesDialog component. */
interface UnsavedChangesDialogProps {
  /** Whether the dialog is open */
  open: boolean
  /** Callback invoked when the user chooses to continue editing */
  onClose: () => void
  /** Callback invoked when the user confirms discarding changes */
  onConfirm: () => void
}

/**
 * Warning dialog shown when the user attempts to close a modal with unsaved changes.
 * Offers the choice between continuing editing or discarding all pending modifications.
 */
export function UnsavedChangesDialog({
  open,
  onClose,
  onConfirm
}: Readonly<UnsavedChangesDialogProps>) {
  return (
    <AlertDialog open={open} onOpenChange={onClose}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle className="flex items-center gap-2">
            <AlertTriangle className="h-5 w-5 text-amber-500" />
            Unsaved Changes
          </AlertDialogTitle>
          <AlertDialogDescription asChild>
            <div className="space-y-3">
              <p>
                You have unsaved changes that will be lost if you close this dialog.
              </p>
              <div className="bg-amber-50 border border-amber-200 rounded-lg p-3">
                <p className="text-sm font-medium text-amber-900">
                  Any changes you've made will not be saved.
                </p>
              </div>
              <p className="text-sm text-gray-600">
                Are you sure you want to close without saving?
              </p>
            </div>
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel onClick={onClose}>Continue Editing</AlertDialogCancel>
          <AlertDialogAction
            onClick={onConfirm}
            className="bg-red-600 hover:bg-red-700 focus:ring-red-600"
          >
            Discard Changes
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  )
}
===ENDFILE

===FILE: src/components/admin/ad-group-config/utils/__tests__/permission-helpers.test.ts
import { describe, expect, it } from 'vitest'
import {
  hasUnsavedChanges,
  getTemplateSection,
  convertOverridesToAssignments,
  isBusinessInfoComplete
} from '../permission-helpers'
import {
  countPendingChangesByType,
  summarizePermissionChanges
} from '../permission-format-helpers'

describe('hasUnsavedChanges', () => {
  it('returns false for empty pending changes', () => {
    expect(hasUnsavedChanges({ permissions: {} })).toBe(false)
  })

  it('returns true when permission changes exist', () => {
    expect(hasUnsavedChanges({
      permissions: { columns: { kms: true } }
    })).toBe(true)
  })

  it('returns true when business info changes exist', () => {
    expect(hasUnsavedChanges({
      permissions: {},
      businessInfo: { logicalName: 'New Name' }
    })).toBe(true)
  })

  it('returns false when permissions levels are empty objects', () => {
    expect(hasUnsavedChanges({
      permissions: { columns: {} }
    })).toBe(false)
  })
})

describe('countPendingChangesByType', () => {
  it('counts zero for empty changes', () => {
    const result = countPendingChangesByType({ permissions: {} })
    expect(result).toEqual({ permissionCount: 0, businessInfoCount: 0, total: 0 })
  })

  it('counts permission changes across levels', () => {
    const result = countPendingChangesByType({
      permissions: {
        columns: { kms: true, chat: false },
        widgets: { 'customer.info': true }
      }
    })
    expect(result.permissionCount).toBe(3)
    expect(result.total).toBe(3)
  })

  it('counts business info changes', () => {
    const result = countPendingChangesByType({
      permissions: {},
      businessInfo: { logicalName: 'X', roleName: 'Y' }
    })
    expect(result.businessInfoCount).toBe(2)
    expect(result.total).toBe(2)
  })
})

describe('summarizePermissionChanges', () => {
  it('returns empty array for no changes', () => {
    expect(summarizePermissionChanges({})).toEqual([])
  })

  it('skips levels with empty changes', () => {
    expect(summarizePermissionChanges({ columns: {} })).toEqual([])
  })

  it('summarizes permission changes with labels', () => {
    const result = summarizePermissionChanges({
      columns: { kms: true },
      widgets: { embeddedApps: false }
    })
    expect(result).toHaveLength(2)
    expect(result[0].count).toBe(1)
    expect(result[1].count).toBe(1)
  })

  it('uses workspacePreferences label', () => {
    const result = summarizePermissionChanges({
      workspacePreferences: { 'widgets.customer.info': true }
    })
    expect(result[0].label).toBe('Workspace & Preferences')
  })
})

describe('getTemplateSection', () => {
  it('returns empty object for null template', () => {
    expect(getTemplateSection(null, 'columns')).toEqual({})
  })

  it('returns the template section', () => {
    const template = {
      roleName: 'voice_agent',
      columns: { kms: { state: 'enabled' } }
    }
    expect(getTemplateSection(template as any, 'columns')).toEqual({ kms: { state: 'enabled' } })
  })

  it('returns empty object for missing section', () => {
    const template = { roleName: 'voice_agent' }
    expect(getTemplateSection(template as any, 'columns')).toEqual({})
  })

  it('returns empty object for non-object section', () => {
    const template = { roleName: 'voice_agent', columns: 'invalid' }
    expect(getTemplateSection(template as any, 'columns')).toEqual({})
  })
})

describe('convertOverridesToAssignments', () => {
  it('returns empty for empty overrides', () => {
    expect(convertOverridesToAssignments({})).toEqual({})
  })

  it('converts direct level overrides', () => {
    const result = convertOverridesToAssignments({
      columns: { kms: true, chat: false }
    })
    expect(result.columnAssignments).toEqual({
      kms: { state: 'enabled' },
      chat: { state: 'disabled' }
    })
  })

  it('converts capabilities with columns prefix', () => {
    const result = convertOverridesToAssignments({
      capabilities: { 'columns.kms': true }
    })
    expect(result.columnAssignments).toEqual({
      kms: { state: 'enabled' }
    })
  })

  it('converts capabilities with features prefix', () => {
    const result = convertOverridesToAssignments({
      capabilities: { 'features.search.knowledgeBase': false }
    })
    expect(result.featureAssignments).toEqual({
      'search.knowledgeBase': { state: 'disabled' }
    })
  })

  it('converts capabilities with micro_frontends prefix', () => {
    const result = convertOverridesToAssignments({
      capabilities: { 'micro_frontends.mediaBar': true }
    })
    expect(result.microFrontendAssignments).toEqual({
      mediaBar: { state: 'enabled' }
    })
  })

  it('converts workspacePreferences with widgets prefix', () => {
    const result = convertOverridesToAssignments({
      workspacePreferences: { 'widgets.customer.info': true }
    })
    expect(result.widgetAssignments).toEqual({
      'customer.info': { state: 'enabled' }
    })
  })

  it('converts workspacePreferences with settings_tabs prefix', () => {
    const result = convertOverridesToAssignments({
      workspacePreferences: { 'settings_tabs.help': false }
    })
    expect(result.settingsTabAssignments).toEqual({
      help: { state: 'disabled' }
    })
  })

  it('converts workspacePreferences with settings_options prefix', () => {
    const result = convertOverridesToAssignments({
      workspacePreferences: { 'settings_options.calls.autoAccept': true }
    })
    expect(result.settingsOptionAssignments).toEqual({
      'calls.autoAccept': { state: 'enabled' }
    })
  })

  it('converts widget overrides', () => {
    const result = convertOverridesToAssignments({
      widgets: { 'customer.info': true }
    })
    expect(result.widgetAssignments).toEqual({
      'customer.info': { state: 'enabled' }
    })
  })

  it('converts all direct level types', () => {
    const result = convertOverridesToAssignments({
      columns: { a: true },
      widgets: { b: true },
      features: { c: true },
      settings_tabs: { d: true },
      settings_options: { e: true },
      micro_frontends: { f: true }
    })
    expect(result.columnAssignments).toBeDefined()
    expect(result.widgetAssignments).toBeDefined()
    expect(result.featureAssignments).toBeDefined()
    expect(result.settingsTabAssignments).toBeDefined()
    expect(result.settingsOptionAssignments).toBeDefined()
    expect(result.microFrontendAssignments).toBeDefined()
  })
})

describe('isBusinessInfoComplete', () => {
  it('returns true when all required fields are present', () => {
    expect(isBusinessInfoComplete({
      id: '1',
      groupIdentifier: 'g1',
      isActive: true,
      logicalName: 'Test',
      roleName: 'voice_agent',
      region: 'EMEA',
      market: 'UK_RETAIL',
      country: 'UK',
      businessUnit: 'WPB'
    } as any)).toBe(true)
  })

  it('returns false when logicalName is missing', () => {
    expect(isBusinessInfoComplete({
      id: '1',
      groupIdentifier: 'g1',
      isActive: true,
      roleName: 'voice_agent',
      region: 'EMEA',
      country: 'UK'
    } as any)).toBe(false)
  })

  it('returns false when region is missing', () => {
    expect(isBusinessInfoComplete({
      id: '1',
      groupIdentifier: 'g1',
      isActive: true,
      logicalName: 'Test',
      roleName: 'voice_agent',
      country: 'UK'
    } as any)).toBe(false)
  })

  it('returns false when market is missing', () => {
    expect(isBusinessInfoComplete({
      id: '1',
      groupIdentifier: 'g1',
      isActive: true,
      logicalName: 'Test',
      roleName: 'voice_agent',
      region: 'EMEA',
      country: 'UK',
      businessUnit: 'WPB'
    } as any)).toBe(false)
  })

  it('returns false when businessUnit is missing', () => {
    expect(isBusinessInfoComplete({
      id: '1',
      groupIdentifier: 'g1',
      isActive: true,
      logicalName: 'Test',
      roleName: 'voice_agent',
      region: 'EMEA',
      market: 'UK_RETAIL',
      country: 'UK'
    } as any)).toBe(false)
  })
})
===ENDFILE

===FILE: src/components/admin/ad-group-config/utils/permission-format-helpers.ts
/**
 * Permission Format Helpers - Formatting and counting utilities for the save confirmation dialog.
 * Converts technical permission keys into business-friendly labels.
 */

import type { PendingChanges } from '../../../../types/features/ad-group-config'

const LEVEL_LABELS: Record<string, string> = {
  capabilities: 'Access Controls',
  workspacePreferences: 'Workspace & Preferences',
  columns: 'Dashboard Layout overrides',
  widgets: 'Workspace Tools',
  features: 'Feature Access',
  settings_tabs: 'Settings sections',
  settings_options: 'Settings controls',
  micro_frontends: 'Embedded apps'
}

const TOGGLE_LABEL_OVERRIDES: Record<string, string> = {
  kms: 'Knowledge Base',
  embeddedApps: 'Embedded Apps Panel',
  spaceCopilot: 'Space Copilot',
  chat: 'Conversation Panel'
}

function formatPermissionLabel(key: string): string {
  return key
    .split('.')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ')
    .replaceAll(/([A-Z])/g, ' $1')
    .trim()
}

/**
 * Counts pending changes by category for the save confirmation summary.
 * @param pendingChanges - Current pending changes state
 * @returns Counts for permission changes, business info changes, and total
 */
export function countPendingChangesByType(pendingChanges: PendingChanges): {
  permissionCount: number
  businessInfoCount: number
  total: number
} {
  const permissionCount = Object.values(pendingChanges.permissions).reduce((acc, level) => acc + Object.keys(level).length, 0)
  const businessInfoCount = pendingChanges.businessInfo ? Object.keys(pendingChanges.businessInfo).length : 0
  return {
    permissionCount,
    businessInfoCount,
    total: permissionCount + businessInfoCount
  }
}

/**
 * Groups permission changes by level and formats them with business-friendly labels.
 * Used to render the permission changes summary in the save confirmation dialog.
 * @param permissions - Permission changes keyed by level
 * @returns Array of level summaries with label, count, and formatted item names
 */
export function summarizePermissionChanges(permissions: PendingChanges['permissions']): { label: string; count: number; items: string[] }[] {
  return Object.entries(permissions)
    .map(([level, changes]) => {
      const keys = Object.keys(changes || {})
      if (keys.length === 0) return null

      const label = LEVEL_LABELS[level] || level
      const items = keys.map(key => formatPermissionLabel(TOGGLE_LABEL_OVERRIDES[key] || key))

      return {
        label,
        count: keys.length,
        items
      }
    })
    .filter((entry): entry is { label: string; count: number; items: string[] } => Boolean(entry))
}
===ENDFILE

===FILE: src/components/admin/ad-group-config/utils/permission-helpers.ts
import type {
  PermissionOverrides,
  RoleTemplate,
  PermissionState
} from '../../../../types/features/ad-group-config'
import {
  applyCapabilityOverrides,
  applyWorkspacePreferencesOverrides,
  applyLevelOverrides,
  type AssignmentResult
} from './permission-override-appliers'

// Re-export validators for backward compatibility
export { hasUnsavedChanges, isBusinessInfoComplete } from './permission-validators'

/**
 * Extracts a permission section from a role template by level key.
 * Returns an empty object if the template is null or the section is missing.
 * @param roleTemplate - The base role template
 * @param level - Permission level key (e.g., 'columns', 'widgets', 'settings_options')
 * @returns Permission state map for the requested level
 */
export function getTemplateSection(roleTemplate: RoleTemplate | null, level: string): Record<string, PermissionState> {
  if (!roleTemplate) return {}
  const section = roleTemplate[level as keyof RoleTemplate]
  if (section && typeof section === 'object' && !Array.isArray(section)) {
    return section as Record<string, PermissionState>
  }
  return {}
}

const LEVEL_MAPPINGS = [
  { override: 'columns', assignment: 'columnAssignments' },
  { override: 'widgets', assignment: 'widgetAssignments' },
  { override: 'features', assignment: 'featureAssignments' },
  { override: 'settings_tabs', assignment: 'settingsTabAssignments' },
  { override: 'settings_options', assignment: 'settingsOptionAssignments' },
  { override: 'micro_frontends', assignment: 'microFrontendAssignments' }
]

/**
 * Converts permission overrides (keyed by compound UI levels) into assignment maps
 * (keyed by actual template section names). Handles capabilities -> columns/features/micro_frontends
 * and workspacePreferences -> widgets/settings_tabs/settings_options decomposition.
 * @param permissionOverrides - Override map from the permission toggle UI
 * @returns Assignment result with separate maps for each template section
 */
export function convertOverridesToAssignments(
  permissionOverrides: PermissionOverrides
): AssignmentResult {
  const assignments: AssignmentResult = {}

  // Handle capabilities compound level
  const capabilitiesOverrides = permissionOverrides.capabilities || {}
  if (Object.keys(capabilitiesOverrides).length > 0) {
    applyCapabilityOverrides(capabilitiesOverrides, assignments)
  }

  // Handle workspacePreferences compound level
  const workspaceOverrides = permissionOverrides.workspacePreferences || {}
  if (Object.keys(workspaceOverrides).length > 0) {
    applyWorkspacePreferencesOverrides(workspaceOverrides, assignments)
  }

  // Handle direct level overrides (actual template section keys)
  for (const { override, assignment } of LEVEL_MAPPINGS) {
    applyLevelOverrides(permissionOverrides[override] || {}, assignment, assignments)
  }

  return assignments
}
===ENDFILE

===FILE: src/components/admin/ad-group-config/utils/permission-override-appliers.ts
/**
 * Permission Override Appliers - Functions for applying capability and workspace preference overrides
 */

import type { PermissionState } from '../../../../types/features/ad-group-config'

interface AssignmentResult {
  columnAssignments?: Record<string, PermissionState>
  widgetAssignments?: Record<string, PermissionState>
  featureAssignments?: Record<string, PermissionState>
  settingsTabAssignments?: Record<string, PermissionState>
  settingsOptionAssignments?: Record<string, PermissionState>
  microFrontendAssignments?: Record<string, PermissionState>
  [key: string]: Record<string, PermissionState> | undefined
}

function toPermissionState(enabled: boolean): PermissionState {
  return { state: enabled ? 'enabled' : 'disabled' }
}

const CAPABILITY_PREFIX_MAP: Record<string, string> = {
  'columns.': 'columnAssignments',
  'features.': 'featureAssignments',
  'micro_frontends.': 'microFrontendAssignments'
}

const WORKSPACE_PREFIX_MAP: Record<string, string> = {
  'widgets.': 'widgetAssignments',
  'settings_tabs.': 'settingsTabAssignments',
  'settings_options.': 'settingsOptionAssignments'
}

function resolvePrefix(key: string, prefixMap: Record<string, string>): { assignmentKey: string; strippedKey: string } | null {
  for (const [prefix, assignmentKey] of Object.entries(prefixMap)) {
    if (key.startsWith(prefix)) return { assignmentKey, strippedKey: key.slice(prefix.length) }
  }
  return null
}

function applyPrefixedOverrides(
  overrides: Record<string, boolean>,
  prefixMap: Record<string, string>,
  assignments: AssignmentResult
): void {
  for (const [key, enabled] of Object.entries(overrides)) {
    const resolved = resolvePrefix(key, prefixMap)
    if (!resolved) continue
    assignments[resolved.assignmentKey] ??= {}
    assignments[resolved.assignmentKey]![resolved.strippedKey] = toPermissionState(enabled)
  }
}

export function applyCapabilityOverrides(
  capabilitiesOverrides: Record<string, boolean>,
  assignments: AssignmentResult
): void {
  applyPrefixedOverrides(capabilitiesOverrides, CAPABILITY_PREFIX_MAP, assignments)
}

export function applyWorkspacePreferencesOverrides(
  overrides: Record<string, boolean>,
  assignments: AssignmentResult
): void {
  applyPrefixedOverrides(overrides, WORKSPACE_PREFIX_MAP, assignments)
}

export function applyLevelOverrides(
  overrides: Record<string, boolean>,
  assignmentKey: string,
  assignments: AssignmentResult
): void {
  if (Object.keys(overrides).length === 0) return
  const assignmentBlock = assignments[assignmentKey] ?? {}
  assignments[assignmentKey] = assignmentBlock
  for (const [key, enabled] of Object.entries(overrides)) {
    assignmentBlock[key] = toPermissionState(enabled)
  }
}

export type { AssignmentResult }
===ENDFILE

===FILE: src/components/admin/ad-group-config/utils/permission-validators.ts
/**
 * Permission Validators
 * Pure validation functions for AD group permission state.
 * Extracted from permission-helpers.ts to separate validation from conversion logic.
 */

import type {
  PendingChanges,
  AdGroup
} from '../../../../types/features/ad-group-config'

/**
 * Checks if there are any unsaved changes in the pending changes object.
 * Considers both business info modifications and permission toggle changes.
 * @param pendingChanges - The current pending changes state
 * @returns True if any business info or permission changes exist
 */
export function hasUnsavedChanges(pendingChanges: PendingChanges): boolean {
  const businessInfoChanged = !!pendingChanges.businessInfo && Object.keys(pendingChanges.businessInfo).length > 0
  const permissionChanges = Object.values(pendingChanges.permissions).some(level => Object.keys(level).length > 0)
  return businessInfoChanged || permissionChanges
}

/**
 * Validates that all required business info fields are populated.
 * Used to enable/disable the save button on the business info tab.
 */
export function isBusinessInfoComplete(formData: AdGroup): boolean {
  return !!(
    formData.logicalName &&
    formData.roleName &&
    formData.region &&
    formData.market &&
    formData.country &&
    formData.businessUnit
  )
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/__tests__/ad-groups-view-hooks.test.ts
import { describe, it, expect } from 'vitest'
import { computePageRange, computeGroupCounts, buildFetchParams } from '../ad-groups-view-hooks'

describe('computePageRange', () => {
  it('returns zero range when totalCount is 0', () => {
    expect(computePageRange(1, 0)).toEqual({ pageStart: 0, pageEnd: 0 })
  })

  it('returns first page range', () => {
    const result = computePageRange(1, 50)
    expect(result.pageStart).toBe(1)
    expect(result.pageEnd).toBeLessThanOrEqual(50)
  })

  it('returns second page range', () => {
    const result = computePageRange(2, 50)
    expect(result.pageStart).toBeGreaterThan(1)
  })

  it('caps pageEnd at totalCount', () => {
    const result = computePageRange(1, 5)
    expect(result.pageEnd).toBe(5)
  })
})

describe('computeGroupCounts', () => {
  const makeGroup = (id: string, isActive = true, roleName?: string) => ({
    id,
    groupIdentifier: `CN=${id}`,
    isActive,
    roleName,
    logicalName: id,
    columnAssignments: {}
  })

  it('uses summary values when provided', () => {
    const result = computeGroupCounts(
      [],
      new Set<string>(),
      { activeConfigured: 10, needsConfiguration: 5 }
    )
    expect(result.activeCount).toBe(10)
    expect(result.unconfiguredCount).toBe(5)
  })

  it('counts selected visible groups', () => {
    const groups = [makeGroup('a'), makeGroup('b'), makeGroup('c')]
    const selected = new Set(['a', 'c'])
    const result = computeGroupCounts(groups, selected, {})
    expect(result.selectedVisibleCount).toBe(2)
  })

  it('returns 0 selectedVisibleCount when none selected', () => {
    const groups = [makeGroup('a')]
    const result = computeGroupCounts(groups, new Set(), {})
    expect(result.selectedVisibleCount).toBe(0)
  })
})

describe('buildFetchParams', () => {
  it('builds params with search', () => {
    const result = buildFetchParams(1, {
      search: 'test', role: 'voice_agent', status: 'active',
      market: 'all', region: 'AMER', country: 'all', businessUnit: 'all'
    })
    expect(result.page).toBe(1)
    expect(result.search).toBe('test')
    expect(result.role).toBe('voice_agent')
    expect(result.region).toBe('AMER')
  })

  it('sets search to undefined when empty', () => {
    const result = buildFetchParams(2, {
      search: '', role: 'all', status: 'all',
      market: 'all', region: 'all', country: 'all', businessUnit: 'all'
    })
    expect(result.search).toBeUndefined()
    expect(result.page).toBe(2)
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/__tests__/ad-groups-view-utils.test.ts
import { describe, it, expect } from 'vitest'
import { isGroupConfigured, getGroupWithDefaults, PAGE_SIZE } from '../ad-groups-view-utils'
import type { AdGroup } from '../../../../types/features/ad-group-config'

const makeGroup = (overrides: Partial<AdGroup> = {}): AdGroup => ({
  id: '1',
  groupIdentifier: 'CN=test-group',
  isActive: true,
  ...overrides
} as AdGroup)

describe('ad-groups-view-utils', () => {
  describe('PAGE_SIZE', () => {
    it('is 25', () => {
      expect(PAGE_SIZE).toBe(25)
    })
  })

  describe('isGroupConfigured', () => {
    it('returns true when all required fields are present', () => {
      const group = makeGroup({
        logicalName: 'Test Group',
        roleName: 'voice_agent',
        region: 'APAC',
        country: 'HK'
      })
      expect(isGroupConfigured(group)).toBe(true)
    })

    it('returns false when logicalName is missing', () => {
      const group = makeGroup({ roleName: 'voice_agent', region: 'APAC', country: 'HK' })
      expect(isGroupConfigured(group)).toBe(false)
    })

    it('returns false when roleName is missing', () => {
      const group = makeGroup({ logicalName: 'Test', region: 'APAC', country: 'HK' })
      expect(isGroupConfigured(group)).toBe(false)
    })

    it('returns false when region is missing', () => {
      const group = makeGroup({ logicalName: 'Test', roleName: 'voice_agent', country: 'HK' })
      expect(isGroupConfigured(group)).toBe(false)
    })

    it('returns false when country is missing', () => {
      const group = makeGroup({ logicalName: 'Test', roleName: 'voice_agent', region: 'APAC' })
      expect(isGroupConfigured(group)).toBe(false)
    })

    it('returns false when all optional fields are missing', () => {
      const group = makeGroup()
      expect(isGroupConfigured(group)).toBe(false)
    })
  })

  describe('getGroupWithDefaults', () => {
    it('fills missing optional fields with empty strings', () => {
      const group = makeGroup()
      const result = getGroupWithDefaults(group)
      expect(result.logicalName).toBe('')
      expect(result.roleName).toBe('')
      expect(result.market).toBe('')
      expect(result.region).toBe('')
      expect(result.country).toBe('')
      expect(result.businessUnit).toBe('')
    })

    it('preserves existing field values', () => {
      const group = makeGroup({
        logicalName: 'Test Group',
        roleName: 'voice_agent',
        market: 'ASIA',
        region: 'APAC',
        country: 'HK',
        businessUnit: 'WPB'
      })
      const result = getGroupWithDefaults(group)
      expect(result.logicalName).toBe('Test Group')
      expect(result.roleName).toBe('voice_agent')
      expect(result.market).toBe('ASIA')
      expect(result.region).toBe('APAC')
      expect(result.country).toBe('HK')
      expect(result.businessUnit).toBe('WPB')
    })

    it('preserves non-defaulted fields', () => {
      const group = makeGroup({ id: '123', groupIdentifier: 'CN=test', isActive: true })
      const result = getGroupWithDefaults(group)
      expect(result.id).toBe('123')
      expect(result.groupIdentifier).toBe('CN=test')
      expect(result.isActive).toBe(true)
    })
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/__tests__/ad-groups-view.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react'

const mockFetchAdGroups = vi.fn().mockResolvedValue(undefined)
const mockSaveScrollPosition = vi.fn()
const mockRestoreScrollPosition = vi.fn()
const mockGetGroupById = vi.fn()

vi.mock('../../../../hooks/admin/use-ad-groups-data', () => ({
  useAdGroupsData: () => ({
    adGroups: [
      { id: '1', groupIdentifier: 'CN=group-1', logicalName: 'UK Retail', roleName: 'voice_agent', isActive: true, region: 'EMEA', country: 'GB' },
      { id: '2', groupIdentifier: 'CN=group-2', logicalName: 'APAC Chat', roleName: 'chat_agent', isActive: false, region: 'APAC', country: 'HK' }
    ],
    loading: false,
    totalCount: 2,
    totalPages: 1,
    summary: { total: 2, active: 1, unconfigured: 0 },
    fetchAdGroups: mockFetchAdGroups,
    saveScrollPosition: mockSaveScrollPosition,
    restoreScrollPosition: mockRestoreScrollPosition,
    tableContainerRef: { current: null },
    getGroupById: mockGetGroupById
  })
}))

const mockHandleSelectGroup = vi.fn()
const mockHandleSelectAll = vi.fn()
const mockHandleDeselectAll = vi.fn()
const mockHandleSelectGroups = vi.fn()
const mockHandleDeselectGroups = vi.fn()
const mockHandleCopyFrom = vi.fn()
const mockHandleToggleActive = vi.fn()
const mockConfirmToggleActive = vi.fn()
const mockSetToggleConfirmOpen = vi.fn()
const mockSearchAdGroups = vi.fn()

let mockSelectedGroups = new Set<string>()
let mockToggleConfirmOpen = false

vi.mock('../../../../hooks/admin/use-ad-groups-selection', () => ({
  useAdGroupsSelection: () => ({
    selectedGroups: mockSelectedGroups,
    handleSelectGroup: mockHandleSelectGroup,
    handleSelectAll: mockHandleSelectAll,
    handleDeselectAll: mockHandleDeselectAll,
    handleSelectGroups: mockHandleSelectGroups,
    handleDeselectGroups: mockHandleDeselectGroups,
    handleCopyFrom: mockHandleCopyFrom,
    handleToggleActive: mockHandleToggleActive,
    confirmToggleActive: mockConfirmToggleActive,
    toggleConfirmOpen: mockToggleConfirmOpen,
    setToggleConfirmOpen: mockSetToggleConfirmOpen,
    groupToToggle: null,
    availableGroupsForSelection: [],
    searchAdGroups: mockSearchAdGroups,
    isLookupLoading: false
  })
}))

vi.mock('../../../../hooks/api/use-reference-data', () => ({
  useReferenceData: () => ({
    regions: [{ regionCode: 'EMEA', regionName: 'Europe' }],
    businessUnits: [{ unitCode: 'WPB', unitName: 'Wealth' }],
    countries: [{ countryCode: 'GB', countryName: 'United Kingdom' }],
    isLoading: false
  })
}))

vi.mock('../../ad-group-config/ad-group-config-modal', () => ({
  AdGroupConfigModal: ({ open, onClose, onSave }: any) => open ? (
    <div data-testid="config-modal">
      <button data-testid="close-modal" onClick={() => onClose()}>Close</button>
      <button data-testid="save-modal" onClick={() => onSave({ groupIdentifier: 'CN=group-1' })}>Save</button>
    </div>
  ) : null
}))

vi.mock('../../bulk-operations-toolbar', () => ({
  BulkOperationsToolbar: ({ selectedCount, onSelectAll, onDeselectAll }: any) => (
    <div data-testid="bulk-toolbar">
      <span>{selectedCount} selected</span>
      <button data-testid="select-all-btn" onClick={onSelectAll}>Select All</button>
      <button data-testid="deselect-all-btn" onClick={onDeselectAll}>Deselect All</button>
    </div>
  )
}))

vi.mock('../components/ad-groups-stats-cards', () => ({
  AdGroupsStatsCards: ({ totalCount, activeCount, unconfiguredCount }: any) => (
    <div data-testid="stats-cards">Total: {totalCount}, Active: {activeCount}, Unconfigured: {unconfiguredCount}</div>
  )
}))

vi.mock('../components/ad-groups-filters-bar', () => ({
  AdGroupsFiltersBar: ({ onSearchTermChange, onRoleFilterChange, onStatusFilterChange, searchTerm }: any) => (
    <div data-testid="filters-bar">
      <input data-testid="search" value={searchTerm} onChange={(e: any) => onSearchTermChange(e.target.value)} />
      <button data-testid="role-filter" onClick={() => onRoleFilterChange('voice_agent')}>Role</button>
      <button data-testid="status-filter" onClick={() => onStatusFilterChange('active')}>Status</button>
      <button data-testid="same-value-filter" onClick={() => onSearchTermChange('')}>Same</button>
    </div>
  )
}))

vi.mock('../components/ad-groups-table', () => ({
  AdGroupsTable: ({ groups, onConfigureGroup, onSelectAll, onDeselectAll, onToggleActive }: any) => (
    <div data-testid="groups-table">
      {groups.map((g: any) => (
        <button key={g.id} data-testid={`configure-${g.id}`} onClick={() => onConfigureGroup(g)}>{g.logicalName}</button>
      ))}
      <button data-testid="table-select-all" onClick={onSelectAll}>Table Select All</button>
      <button data-testid="table-deselect-all" onClick={onDeselectAll}>Table Deselect All</button>
    </div>
  )
}))

vi.mock('../components/ad-groups-toggle-dialog', () => ({
  AdGroupsToggleDialog: ({ open }: any) => <div data-testid="toggle-dialog" data-open={open} />
}))

vi.mock('../components/active-filters-chips', () => ({
  ActiveFiltersChips: () => <div data-testid="filter-chips" />
}))

vi.mock('../components/ad-groups-pagination', () => ({
  AdGroupsPagination: ({ currentPage, onPageChange }: any) => (
    <div data-testid="pagination">
      <span>Page {currentPage}</span>
      <button data-testid="next-page" onClick={() => onPageChange(2)}>Next</button>
    </div>
  )
}))

vi.mock('../ad-groups-view-utils', () => ({
  isGroupConfigured: (group: any) => Boolean(group.logicalName && group.roleName && group.region && group.country),
  getGroupWithDefaults: (group: any) => ({ ...group, logicalName: group.logicalName || '', roleName: group.roleName || '' })
}))

vi.mock('../ad-groups-view-hooks', () => ({
  computePageRange: (page: number, total: number) => ({ pageStart: total === 0 ? 0 : (page - 1) * 25 + 1, pageEnd: Math.min(page * 25, total) }),
  computeGroupCounts: () => ({ activeCount: 1, unconfiguredCount: 0, selectedVisibleCount: 0 }),
  buildFetchParams: (page: number, filters: any) => ({ page, size: 25, ...filters })
}))

import { AdGroupsView } from '../ad-groups-view'

const allPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
} as any

describe('AdGroupsView', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockSelectedGroups = new Set()
    mockToggleConfirmOpen = false
  })

  it('renders header', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    expect(screen.getByText('Team Access Management')).toBeInTheDocument()
    expect(screen.getByText(/Manage team access groups/)).toBeInTheDocument()
  })

  it('renders stats cards with counts', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    expect(screen.getByTestId('stats-cards')).toBeInTheDocument()
  })

  it('renders filters bar', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    expect(screen.getByTestId('filters-bar')).toBeInTheDocument()
  })

  it('renders groups table', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    expect(screen.getByTestId('groups-table')).toBeInTheDocument()
  })

  it('renders pagination', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    expect(screen.getByTestId('pagination')).toBeInTheDocument()
  })

  it('renders toggle dialog', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    expect(screen.getByTestId('toggle-dialog')).toBeInTheDocument()
  })

  it('renders filter chips', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    expect(screen.getByTestId('filter-chips')).toBeInTheDocument()
  })

  it('renders group names in table', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    expect(screen.getByText('UK Retail')).toBeInTheDocument()
    expect(screen.getByText('APAC Chat')).toBeInTheDocument()
  })

  it('opens config modal when group is clicked', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    fireEvent.click(screen.getByTestId('configure-1'))
    expect(screen.getByTestId('config-modal')).toBeInTheDocument()
  })

  it('closes config modal when close button clicked', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    fireEvent.click(screen.getByTestId('configure-1'))
    expect(screen.getByTestId('config-modal')).toBeInTheDocument()
    fireEvent.click(screen.getByTestId('close-modal'))
    expect(screen.queryByTestId('config-modal')).not.toBeInTheDocument()
  })

  it('handles config save and refetches data', async () => {
    render(<AdGroupsView permissions={allPermissions} />)
    fireEvent.click(screen.getByTestId('configure-1'))
    await act(async () => {
      fireEvent.click(screen.getByTestId('save-modal'))
    })
    await waitFor(() => {
      expect(mockSaveScrollPosition).toHaveBeenCalled()
      expect(mockFetchAdGroups).toHaveBeenCalled()
    })
  })

  it('calls fetchAdGroups on mount', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    expect(mockFetchAdGroups).toHaveBeenCalled()
  })

  it('triggers search filter update', async () => {
    render(<AdGroupsView permissions={allPermissions} />)
    await act(async () => {
      fireEvent.change(screen.getByTestId('search'), { target: { value: 'test' } })
    })
    // fetchAdGroups should be called again on filter change
    await waitFor(() => {
      expect(mockFetchAdGroups).toHaveBeenCalled()
    })
  })

  it('handles role filter change and resets page to 1', async () => {
    render(<AdGroupsView permissions={allPermissions} />)
    // First change page
    await act(async () => {
      fireEvent.click(screen.getByTestId('next-page'))
    })
    // Then change role filter
    await act(async () => {
      fireEvent.click(screen.getByTestId('role-filter'))
    })
    // Page should reset to 1
    await waitFor(() => {
      expect(screen.getByText('Page 1')).toBeInTheDocument()
    })
  })

  it('handles status filter change', async () => {
    render(<AdGroupsView permissions={allPermissions} />)
    await act(async () => {
      fireEvent.click(screen.getByTestId('status-filter'))
    })
    await waitFor(() => {
      expect(mockFetchAdGroups).toHaveBeenCalled()
    })
  })

  it('does not update filter state when same value is set', async () => {
    render(<AdGroupsView permissions={allPermissions} />)
    const callsBefore = mockFetchAdGroups.mock.calls.length
    await act(async () => {
      fireEvent.click(screen.getByTestId('same-value-filter'))
    })
    // Should not trigger re-fetch if value did not change
    // search was already '' and we set it to ''
    expect(mockFetchAdGroups.mock.calls.length).toBe(callsBefore)
  })

  it('passes correct onSelectAll to table', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    fireEvent.click(screen.getByTestId('table-select-all'))
    expect(mockHandleSelectGroups).toHaveBeenCalled()
  })

  it('passes correct onDeselectAll to table', () => {
    render(<AdGroupsView permissions={allPermissions} />)
    fireEvent.click(screen.getByTestId('table-deselect-all'))
    expect(mockHandleDeselectGroups).toHaveBeenCalled()
  })

  it('shows bulk toolbar when groups are selected', () => {
    mockSelectedGroups = new Set(['1', '2'])
    render(<AdGroupsView permissions={allPermissions} />)
    expect(screen.getByTestId('bulk-toolbar')).toBeInTheDocument()
    expect(screen.getByText('2 selected')).toBeInTheDocument()
  })

  it('hides bulk toolbar when no groups are selected', () => {
    mockSelectedGroups = new Set()
    render(<AdGroupsView permissions={allPermissions} />)
    expect(screen.queryByTestId('bulk-toolbar')).not.toBeInTheDocument()
  })

  it('handles page change via pagination', async () => {
    render(<AdGroupsView permissions={allPermissions} />)
    await act(async () => {
      fireEvent.click(screen.getByTestId('next-page'))
    })
    await waitFor(() => {
      expect(screen.getByText('Page 2')).toBeInTheDocument()
    })
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/ad-groups-view-handlers.ts
/**
 * AD Groups View Handlers
 * Pure handler factory functions and state update logic for the AD groups view.
 * Extracted from ad-groups-view.tsx to reduce per-file complexity.
 */

import type { AdGroup } from '../../../types/features/ad-group-config'
import type { FiltersState } from './ad-groups-view-utils'
import { buildFetchParams } from './ad-groups-view-hooks'

/**
 * Updates a single filter field in the filters state and resets pagination to page 1
 * when the filter value actually changes.
 */
export function applyFilterUpdate(
  key: keyof FiltersState,
  value: string,
  setFilters: React.Dispatch<React.SetStateAction<FiltersState>>,
  setCurrentPage: React.Dispatch<React.SetStateAction<number>>
): void {
  let changed = false
  setFilters(prev => {
    if (prev[key] === value) {
      return prev
    }
    changed = true
    return { ...prev, [key]: value }
  })
  if (changed) {
    setCurrentPage(prev => (prev === 1 ? prev : 1))
  }
}

/**
 * Handles opening the configuration modal for a selected AD group.
 */
export function openGroupConfig(
  group: AdGroup,
  setSelectedGroup: (group: AdGroup | null) => void,
  setConfigModalOpen: (open: boolean) => void
): void {
  setSelectedGroup(group)
  setConfigModalOpen(true)
}

/** Options for the handleGroupSaved post-save cleanup function. */
export interface HandleGroupSavedOptions {
  updatedGroup: AdGroup
  saveScrollPosition: () => void
  setSavingGroupId: (id: string | null) => void
  setConfigModalOpen: (open: boolean) => void
  setSelectedGroup: (group: AdGroup | null) => void
  fetchAdGroups: (params: { page: number; size: number; search?: string; role: string; status: string; market: string; region: string; country: string; businessUnit: string }) => Promise<unknown>
  currentPage: number
  filters: FiltersState
  restoreScrollPosition: () => void
}

/**
 * Handles post-save cleanup: closes the modal, clears selection,
 * refreshes data, and restores scroll position.
 */
export async function handleGroupSaved(options: HandleGroupSavedOptions): Promise<void> {
  const {
    updatedGroup, saveScrollPosition, setSavingGroupId,
    setConfigModalOpen, setSelectedGroup, fetchAdGroups,
    currentPage, filters, restoreScrollPosition
  } = options
  saveScrollPosition()
  setSavingGroupId(updatedGroup.groupIdentifier)
  setConfigModalOpen(false)
  setSelectedGroup(null)
  await fetchAdGroups(buildFetchParams(currentPage, filters))
  restoreScrollPosition()
  setSavingGroupId(null)
}

/**
 * Clamps the current page to be within the valid range when total pages changes.
 */
export function clampPage(currentPage: number, totalPages: number): number {
  if (totalPages < 1) {
    return 1
  }
  return Math.min(currentPage, totalPages)
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/ad-groups-view-hooks.ts
/**
 * AD Groups View Hooks
 * Derived state computations for the AD groups view.
 */

import type { AdGroup } from '../../../types/features/ad-group-config'
import { isGroupConfigured, PAGE_SIZE } from './ad-groups-view-utils'

export interface PageRange {
  pageStart: number
  pageEnd: number
}

/** Computes the visible page range (1-indexed start and end) for the current page. */
export function computePageRange(currentPage: number, totalCount: number): PageRange {
  return {
    pageStart: totalCount === 0 ? 0 : (currentPage - 1) * PAGE_SIZE + 1,
    pageEnd: totalCount === 0 ? 0 : Math.min(currentPage * PAGE_SIZE, totalCount)
  }
}

export interface GroupCounts {
  activeCount: number
  unconfiguredCount: number
  selectedVisibleCount: number
}

/** Computes aggregate counts for stats cards and toolbar display. */
export function computeGroupCounts(
  adGroups: AdGroup[],
  selectedGroups: Set<string>,
  summary: { activeConfigured?: number; needsConfiguration?: number }
): GroupCounts {
  return {
    activeCount: summary.activeConfigured ?? adGroups.filter(group => group.isActive && isGroupConfigured(group)).length,
    unconfiguredCount: summary.needsConfiguration ?? adGroups.filter(group => !isGroupConfigured(group)).length,
    selectedVisibleCount: adGroups.filter(group => selectedGroups.has(group.id)).length
  }
}

export interface FetchParams {
  page: number
  size: number
  search?: string
  role: string
  status: string
  market: string
  region: string
  country: string
  businessUnit: string
}

/** Builds fetch parameters for the AD groups API call. */
export function buildFetchParams(
  page: number,
  filters: { search: string; role: string; status: string; market: string; region: string; country: string; businessUnit: string }
): FetchParams {
  return {
    page,
    size: PAGE_SIZE,
    search: filters.search || undefined,
    role: filters.role,
    status: filters.status,
    market: filters.market,
    region: filters.region,
    country: filters.country,
    businessUnit: filters.businessUnit
  }
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/ad-groups-view-utils.ts
/**
 * AD Groups View Utilities - Filter state types, page size constant,
 * and helper functions for the AD groups list view.
 */

import type { AdGroup } from '../../../types/features/ad-group-config'

/** Current state of all filter controls in the AD groups list view. */
export interface FiltersState {
  search: string
  role: string
  status: string
  market: string
  region: string
  country: string
  businessUnit: string
}

export const PAGE_SIZE = 25

/** Checks if an AD group has all required configuration fields populated. */
export function isGroupConfigured(group: AdGroup): boolean {
  return Boolean(group.logicalName && group.roleName && group.region && group.country)
}

/** Returns a copy of the group with empty strings for any undefined optional fields. */
export function getGroupWithDefaults(group: AdGroup) {
  return {
    ...group,
    logicalName: group.logicalName || '',
    roleName: group.roleName || '',
    market: group.market || '',
    region: group.region || '',
    country: group.country || '',
    businessUnit: group.businessUnit || ''
  }
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/ad-groups-view.tsx
import { useCallback, useEffect, useState, memo } from 'react'
import { AdGroupConfigModal } from '../ad-group-config/ad-group-config-modal'
import { BulkOperationsToolbar } from '../bulk-operations-toolbar'
import type { AdGroup } from '../../../types/features/ad-group-config'
import type { AdminPermissions } from '../admin-layout'

import { useAdGroupsData } from '../../../hooks/admin/use-ad-groups-data'
import { useAdGroupsSelection } from '../../../hooks/admin/use-ad-groups-selection'
import { useReferenceData } from '../../../hooks/api/use-reference-data'

// Components
import { AdGroupsStatsCards } from './components/ad-groups-stats-cards'
import { AdGroupsFiltersBar } from './components/ad-groups-filters-bar'
import { AdGroupsTable } from './components/ad-groups-table'
import { AdGroupsToggleDialog } from './components/ad-groups-toggle-dialog'
import { ActiveFiltersChips } from './components/active-filters-chips'
import { AdGroupsPagination } from './components/ad-groups-pagination'

import { isGroupConfigured, getGroupWithDefaults } from './ad-groups-view-utils'
import type { FiltersState } from './ad-groups-view-utils'
import { computePageRange, computeGroupCounts, buildFetchParams } from './ad-groups-view-hooks'
import { applyFilterUpdate, openGroupConfig, handleGroupSaved, clampPage } from './ad-groups-view-handlers'

/** Props for the AD Groups management view. */
interface AdGroupsViewProps {
  /** Admin permissions controlling which actions are available */
  permissions: AdminPermissions
}

/**
 * Main management view for AD groups. Provides a searchable, filterable table
 * with pagination, bulk operations, and configuration modals for individual groups.
 */
function AdGroupsViewComponent({ permissions }: Readonly<AdGroupsViewProps>) {
  const [selectedGroup, setSelectedGroup] = useState<AdGroup | null>(null)
  const [configModalOpen, setConfigModalOpen] = useState(false)
  const [savingGroupId, setSavingGroupId] = useState<string | null>(null)
  const [currentPage, setCurrentPage] = useState(1)
  const [filters, setFilters] = useState<FiltersState>({
    search: '',
    role: 'all',
    status: 'all',
    market: 'all',
    region: 'all',
    country: 'all',
    businessUnit: 'all'
  })

  const {
    adGroups,
    loading,
    totalCount,
    totalPages,
    summary,
    fetchAdGroups,
    saveScrollPosition,
    restoreScrollPosition,
    tableContainerRef,
    getGroupById
  } = useAdGroupsData()

  const { regions, businessUnits, countries, isLoading: referenceDataLoading } = useReferenceData()

  const buildFetchParamsForPage = useCallback((page: number) =>
    buildFetchParams(page, filters)
  , [filters])

  useEffect(() => {
    let ignore = false
    const params = buildFetchParamsForPage(currentPage)
    fetchAdGroups(params).then(() => {
      if (ignore) return
    })
    return () => { ignore = true }
  }, [fetchAdGroups, currentPage, buildFetchParamsForPage])

  useEffect(() => {
    setCurrentPage(prev => clampPage(prev, totalPages))
  }, [totalPages])

  const updateFilter = (key: keyof FiltersState, value: string) => {
    applyFilterUpdate(key, value, setFilters, setCurrentPage)
  }

  const {
    selectedGroups,
    handleSelectGroup,
    handleSelectAll,
    handleDeselectAll,
    handleSelectGroups,
    handleDeselectGroups,
    handleCopyFrom,
    handleToggleActive,
    confirmToggleActive,
    toggleConfirmOpen,
    setToggleConfirmOpen,
    groupToToggle,
    availableGroupsForSelection,
    searchAdGroups,
    isLookupLoading
  } = useAdGroupsSelection({
    currentGroups: adGroups,
    getGroupById,
    onRefresh: async () => {
      await fetchAdGroups(buildFetchParamsForPage(currentPage))
    },
    saveScrollPosition,
    restoreScrollPosition
  })

  const { pageStart, pageEnd } = computePageRange(currentPage, totalCount)
  const { activeCount, unconfiguredCount, selectedVisibleCount } = computeGroupCounts(adGroups, selectedGroups, summary)

  const handleConfigureGroup = (group: AdGroup) => {
    openGroupConfig(group, setSelectedGroup, setConfigModalOpen)
  }

  const handleConfigSave = async (updatedGroup: AdGroup) => {
    await handleGroupSaved({
      updatedGroup,
      saveScrollPosition,
      setSavingGroupId,
      setConfigModalOpen,
      setSelectedGroup,
      fetchAdGroups,
      currentPage,
      filters,
      restoreScrollPosition
    })
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-semibold tracking-tight">Team Access Management</h1>
          <p className="text-muted-foreground">
            Manage team access groups and permissions for your organization
          </p>
        </div>
      </div>

      {/* Stats Cards */}
      <AdGroupsStatsCards
        unconfiguredCount={unconfiguredCount}
        activeCount={activeCount}
        totalCount={totalCount}
      />

      {/* Bulk Operations Toolbar - Shows when items are selected */}
      {selectedGroups.size > 0 && (
        <BulkOperationsToolbar
          selectedCount={selectedGroups.size}
          selectedVisibleCount={selectedVisibleCount}
          totalCount={totalCount}
          visibleCount={adGroups.length}
          selectedGroups={Array.from(selectedGroups)}
          allAdGroups={availableGroupsForSelection}
          onSelectAll={handleSelectAll}
          onDeselectAll={handleDeselectAll}
          onCopyFrom={handleCopyFrom}
          onSearchAdGroups={searchAdGroups}
          isLookupLoading={isLookupLoading}
        />
      )}

      {/* Search and Filters */}
      <div className="space-y-4">
        <AdGroupsFiltersBar
          searchTerm={filters.search}
          onSearchTermChange={(value) => updateFilter('search', value)}
          roleFilter={filters.role}
          onRoleFilterChange={(value) => updateFilter('role', value)}
          statusFilter={filters.status}
          onStatusFilterChange={(value) => updateFilter('status', value)}
          marketFilter={filters.market}
          onMarketFilterChange={(value) => updateFilter('market', value)}
          regionFilter={filters.region}
          onRegionFilterChange={(value) => updateFilter('region', value)}
          countryFilter={filters.country}
          onCountryFilterChange={(value) => updateFilter('country', value)}
          businessUnitFilter={filters.businessUnit}
          onBusinessUnitFilterChange={(value) => updateFilter('businessUnit', value)}
          regions={regions}
          countries={countries}
          businessUnits={businessUnits}
          isLoading={referenceDataLoading}
        />

        {/* Active Filters Chips */}
        <ActiveFiltersChips
          searchTerm={filters.search}
          roleFilter={filters.role}
          statusFilter={filters.status}
          marketFilter={filters.market}
          regionFilter={filters.region}
          countryFilter={filters.country}
          businessUnitFilter={filters.businessUnit}
          onSearchTermChange={(value) => updateFilter('search', value)}
          onRoleFilterChange={(value) => updateFilter('role', value)}
          onStatusFilterChange={(value) => updateFilter('status', value)}
          onMarketFilterChange={(value) => updateFilter('market', value)}
          onRegionFilterChange={(value) => updateFilter('region', value)}
          onCountryFilterChange={(value) => updateFilter('country', value)}
          onBusinessUnitFilterChange={(value) => updateFilter('businessUnit', value)}
          regions={regions}
          countries={countries}
          businessUnits={businessUnits}
        />
      </div>

      {/* Table */}
      <AdGroupsTable
        groups={adGroups}
        selectedGroups={selectedGroups}
        loading={loading}
        savingGroupId={savingGroupId}
        onSelectGroup={handleSelectGroup}
        onSelectAll={() => handleSelectGroups(adGroups)}
        onDeselectAll={() => handleDeselectGroups(adGroups.map(group => group.id))}
        onConfigureGroup={handleConfigureGroup}
        onToggleActive={handleToggleActive}
        isConfigured={isGroupConfigured}
        tableContainerRef={tableContainerRef}
        permissions={permissions}
        countries={countries}
      />

      {/* Pagination Controls */}
      <AdGroupsPagination
        currentPage={currentPage}
        totalPages={totalPages}
        pageStart={pageStart}
        pageEnd={pageEnd}
        totalCount={totalCount}
        onPageChange={setCurrentPage}
      />

      {/* Configuration Modal */}
      {selectedGroup && (
        <AdGroupConfigModal
          group={getGroupWithDefaults(selectedGroup)}
          open={configModalOpen}
          onClose={() => {
            setConfigModalOpen(false)
            setSelectedGroup(null)
          }}
          onSave={handleConfigSave}
          permissions={permissions}
        />
      )}

      {/* Toggle Confirmation Dialog */}
      <AdGroupsToggleDialog
        group={groupToToggle}
        open={toggleConfirmOpen}
        onOpenChange={setToggleConfirmOpen}
        onConfirm={confirmToggleActive}
      />
    </div>
  )
}

/** Memoized AD groups view to prevent unnecessary re-renders during parent state changes. */
export const AdGroupsView = memo(AdGroupsViewComponent)
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/__tests__/active-filters-chips.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('@/hooks/features/use-business-terminology', () => ({
  useBusinessRoles: () => ({
    voice_agent: { displayName: 'Voice Agent' },
    chat_agent: { displayName: 'Chat Agent' }
  }),
  useBusinessStatus: () => ({
    active: { label: 'Active' },
    disabled: { label: 'Disabled' }
  })
}))

vi.mock('lucide-react', () => ({
  X: () => <span data-testid="x-icon" />
}))

vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children, ...rest }: Record<string, unknown>) => (
    <span data-testid="badge" {...rest}>{children as React.ReactNode}</span>
  )
}))

import { ActiveFiltersChips } from '../active-filters-chips'

const defaultProps = {
  searchTerm: '',
  roleFilter: 'all',
  statusFilter: 'all',
  marketFilter: 'all',
  regionFilter: 'all',
  countryFilter: 'all',
  businessUnitFilter: 'all',
  onSearchTermChange: vi.fn(),
  onRoleFilterChange: vi.fn(),
  onStatusFilterChange: vi.fn(),
  onMarketFilterChange: vi.fn(),
  onRegionFilterChange: vi.fn(),
  onCountryFilterChange: vi.fn(),
  onBusinessUnitFilterChange: vi.fn(),
  regions: [{ regionCode: 'APAC', regionName: 'Asia Pacific', displayOrder: 1, isActive: true }],
  countries: [{ countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true }],
  businessUnits: [{ unitCode: 'WPB', unitName: 'Wealth', description: '', effectiveDate: '', displayOrder: 1, isActive: true }]
}

describe('ActiveFiltersChips', () => {
  it('renders nothing when no filters active', () => {
    const { container } = render(<ActiveFiltersChips {...defaultProps} />)
    expect(container.innerHTML).toBe('')
  })

  it('renders search filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} searchTerm="test" />)
    expect(screen.getByText('Active filters:')).toBeInTheDocument()
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders role filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} roleFilter="voice_agent" />)
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders status filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} statusFilter="active" />)
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders market filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} marketFilter="HK" />)
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders region filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} regionFilter="APAC" />)
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders country filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} countryFilter="HK" />)
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders business unit filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} businessUnitFilter="WPB" />)
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders multiple chips when multiple filters active', () => {
    render(
      <ActiveFiltersChips
        {...defaultProps}
        searchTerm="test"
        roleFilter="voice_agent"
        statusFilter="active"
      />
    )
    expect(screen.getAllByTestId('badge').length).toBe(3)
  })

  it('calls onSearchTermChange on remove', () => {
    const onSearchTermChange = vi.fn()
    render(
      <ActiveFiltersChips
        {...defaultProps}
        searchTerm="test"
        onSearchTermChange={onSearchTermChange}
      />
    )
    const removeButtons = screen.getAllByRole('button')
    fireEvent.click(removeButtons[0])
    expect(onSearchTermChange).toHaveBeenCalledWith('')
  })

  it('calls onRoleFilterChange on remove', () => {
    const onRoleFilterChange = vi.fn()
    render(
      <ActiveFiltersChips
        {...defaultProps}
        roleFilter="voice_agent"
        onRoleFilterChange={onRoleFilterChange}
      />
    )
    const removeButtons = screen.getAllByRole('button')
    fireEvent.click(removeButtons[0])
    expect(onRoleFilterChange).toHaveBeenCalledWith('all')
  })

  it('resolves region name from code', () => {
    render(<ActiveFiltersChips {...defaultProps} regionFilter="APAC" />)
    const badge = screen.getByTestId('badge')
    expect(badge.textContent).toContain('Asia Pacific')
  })

  it('resolves country name from code', () => {
    render(<ActiveFiltersChips {...defaultProps} countryFilter="HK" />)
    const badge = screen.getByTestId('badge')
    expect(badge.textContent).toContain('Hong Kong')
  })

  it('resolves business unit name from code', () => {
    render(<ActiveFiltersChips {...defaultProps} businessUnitFilter="WPB" />)
    const badge = screen.getByTestId('badge')
    expect(badge.textContent).toContain('Wealth')
  })

  it('falls back to code when name not found', () => {
    render(<ActiveFiltersChips {...defaultProps} regionFilter="UNKNOWN" />)
    const badge = screen.getByTestId('badge')
    expect(badge.textContent).toContain('UNKNOWN')
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/__tests__/ad-group-table-cells.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'
import type { AdGroup } from '../../../../../types/features/ad-group-config'
import type { AdminPermissions } from '../../../admin-layout'

vi.mock('lucide-react', () => ({
  Settings: () => <span data-testid="settings-icon" />,
  AlertTriangle: () => <span data-testid="alert-icon" />,
  CheckCircle: () => <span data-testid="check-icon" />,
  PowerOff: () => <span data-testid="poweroff-icon" />,
  ToggleRight: () => <span data-testid="toggle-right-icon" />,
  ToggleLeft: () => <span data-testid="toggle-left-icon" />,
  Shield: () => <span data-testid="shield-icon" />,
  ShieldCheck: () => <span data-testid="shield-check-icon" />,
  ShieldAlert: () => <span data-testid="shield-alert-icon" />,
  Crown: () => <span data-testid="crown-icon" />
}))

vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children }: { children: React.ReactNode }) => <span data-testid="badge">{children}</span>
}))

vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, ...props }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} aria-label={props['aria-label'] as string}>
      {children as React.ReactNode}
    </button>
  )
}))

vi.mock('../../../../ui/tooltip', () => ({
  Tooltip: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  TooltipTrigger: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  TooltipContent: ({ children }: { children: React.ReactNode }) => <div>{children}</div>
}))

import { AccessLevelBadge, GroupStatusBadge, GroupActionButtons } from '../ad-group-table-cells'

const makeGroup = (overrides: Partial<AdGroup> = {}): AdGroup => ({
  id: '1',
  groupIdentifier: 'CN=test-group',
  isActive: true,
  logicalName: 'Test Group',
  ...overrides
} as AdGroup)

describe('AccessLevelBadge', () => {
  it('renders Super Admin label', () => {
    render(<AccessLevelBadge accessLevel="SUPER_ADMIN" />)
    expect(screen.getByText('Super Admin')).toBeInTheDocument()
  })

  it('renders Checker label', () => {
    render(<AccessLevelBadge accessLevel="CHECKER" />)
    expect(screen.getByText('Checker')).toBeInTheDocument()
  })

  it('renders Maker label', () => {
    render(<AccessLevelBadge accessLevel="MAKER" />)
    expect(screen.getByText('Maker')).toBeInTheDocument()
  })

  it('renders Viewer label', () => {
    render(<AccessLevelBadge accessLevel="VIEWER" />)
    expect(screen.getByText('Viewer')).toBeInTheDocument()
  })

  it('falls back to raw value for unknown level', () => {
    render(<AccessLevelBadge accessLevel="UNKNOWN" />)
    expect(screen.getByText('UNKNOWN')).toBeInTheDocument()
  })
})

describe('GroupStatusBadge', () => {
  it('shows Needs Setup when not configured', () => {
    render(<GroupStatusBadge group={makeGroup()} configured={false} businessStatus={{}} />)
    expect(screen.getByText('Needs Setup')).toBeInTheDocument()
  })

  it('shows Active when configured and active', () => {
    render(<GroupStatusBadge group={makeGroup({ isActive: true })} configured={true} businessStatus={{}} />)
    expect(screen.getByText('Active')).toBeInTheDocument()
  })

  it('shows Disabled when configured but inactive', () => {
    render(<GroupStatusBadge group={makeGroup({ isActive: false })} configured={true} businessStatus={{}} />)
    expect(screen.getByText('Disabled')).toBeInTheDocument()
  })

  it('shows Pending badge when pendingChangeIndicator is true', () => {
    render(<GroupStatusBadge group={makeGroup({ pendingChangeIndicator: true })} configured={true} businessStatus={{}} />)
    expect(screen.getByText('Pending')).toBeInTheDocument()
  })

  it('uses custom business status labels', () => {
    render(<GroupStatusBadge group={makeGroup()} configured={false} businessStatus={{ needs_setup: { label: 'Configure Now' } }} />)
    expect(screen.getByText('Configure Now')).toBeInTheDocument()
  })
})

describe('GroupActionButtons', () => {
  const permissions = {
    canEnableDisableGroups: true,
    canConfigureGroups: true
  } as unknown as AdminPermissions

  it('shows configure button when canConfigureGroups is true', () => {
    render(
      <GroupActionButtons
        group={makeGroup()}
        permissions={permissions}
        configured={true}
        canConfigureGroups={true}
        onToggleActive={vi.fn()}
        onConfigureGroup={vi.fn()}
      />
    )
    expect(screen.getByLabelText('Configure Test Group')).toBeInTheDocument()
  })

  it('calls onConfigureGroup when configure button clicked', () => {
    const onConfigureGroup = vi.fn()
    const group = makeGroup()
    render(
      <GroupActionButtons
        group={group}
        permissions={permissions}
        configured={true}
        canConfigureGroups={true}
        onToggleActive={vi.fn()}
        onConfigureGroup={onConfigureGroup}
      />
    )
    fireEvent.click(screen.getByLabelText('Configure Test Group'))
    expect(onConfigureGroup).toHaveBeenCalledWith(group)
  })

  it('calls onToggleActive when toggle button clicked', () => {
    const onToggleActive = vi.fn()
    const group = makeGroup({ isActive: true })
    render(
      <GroupActionButtons
        group={group}
        permissions={permissions}
        configured={true}
        canConfigureGroups={false}
        onToggleActive={onToggleActive}
        onConfigureGroup={vi.fn()}
      />
    )
    fireEvent.click(screen.getByLabelText('Disable Test Group'))
    expect(onToggleActive).toHaveBeenCalledWith(group)
  })

  it('shows Enable label when group is inactive', () => {
    render(
      <GroupActionButtons
        group={makeGroup({ isActive: false })}
        permissions={permissions}
        configured={true}
        canConfigureGroups={false}
        onToggleActive={vi.fn()}
        onConfigureGroup={vi.fn()}
      />
    )
    expect(screen.getByLabelText('Enable Test Group')).toBeInTheDocument()
  })

  it('uses groupIdentifier when logicalName is missing', () => {
    render(
      <GroupActionButtons
        group={makeGroup({ logicalName: undefined })}
        permissions={permissions}
        configured={true}
        canConfigureGroups={true}
        onToggleActive={vi.fn()}
        onConfigureGroup={vi.fn()}
      />
    )
    expect(screen.getByLabelText('Configure CN=test-group')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/__tests__/ad-groups-filters-bar.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('@/hooks/features/use-business-terminology', () => ({
  useBusinessRoles: () => ({
    voice_agent: { displayName: 'Voice Agent' },
    chat_agent: { displayName: 'Chat Agent' },
    supervisor: { displayName: 'Supervisor' },
    admin: { displayName: 'Administrator' }
  }),
  useBusinessStatus: () => ({
    active: { label: 'Active' },
    disabled: { label: 'Disabled' },
    needs_setup: { label: 'Needs Setup' }
  })
}))

vi.mock('lucide-react', () => ({
  Search: () => <span data-testid="search-icon" />,
  Filter: () => <span data-testid="filter-icon" />
}))

vi.mock('../advanced-filters-sheet', () => ({
  AdvancedFiltersSheet: () => <div data-testid="advanced-filters" />
}))

vi.mock('../../../../ui/input', () => ({
  Input: ({ value, onChange, placeholder, ...rest }: Record<string, unknown>) => (
    <input
      value={value as string}
      onChange={onChange as React.ChangeEventHandler<HTMLInputElement>}
      placeholder={placeholder as string}
      data-testid="search-input"
      {...rest}
    />
  )
}))

vi.mock('../../../../ui/select', () => ({
  Select: ({ value, onValueChange, children }: Record<string, unknown>) => (
    <div data-testid="select" data-value={value}>
      {(children as React.ReactNode)}
      <button data-testid={`select-change-${value}`} onClick={() => (onValueChange as (v: string) => void)('voice_agent')}>change</button>
    </div>
  ),
  SelectContent: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  SelectItem: ({ children, value }: { children: React.ReactNode; value: string }) => (
    <option value={value}>{children}</option>
  ),
  SelectTrigger: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  SelectValue: ({ placeholder }: { placeholder: string }) => <span>{placeholder}</span>
}))

import { AdGroupsFiltersBar } from '../ad-groups-filters-bar'

const defaultProps = {
  searchTerm: '',
  onSearchTermChange: vi.fn(),
  roleFilter: 'all',
  onRoleFilterChange: vi.fn(),
  statusFilter: 'all',
  onStatusFilterChange: vi.fn(),
  marketFilter: 'all',
  onMarketFilterChange: vi.fn(),
  regionFilter: 'all',
  onRegionFilterChange: vi.fn(),
  countryFilter: 'all',
  onCountryFilterChange: vi.fn(),
  businessUnitFilter: 'all',
  onBusinessUnitFilterChange: vi.fn(),
  regions: [],
  countries: [],
  businessUnits: [],
  isLoading: false
}

describe('AdGroupsFiltersBar', () => {
  it('renders search input', () => {
    render(<AdGroupsFiltersBar {...defaultProps} />)
    expect(screen.getByTestId('search-input')).toBeInTheDocument()
  })

  it('renders search icon', () => {
    render(<AdGroupsFiltersBar {...defaultProps} />)
    expect(screen.getByTestId('search-icon')).toBeInTheDocument()
  })

  it('renders filter icon', () => {
    render(<AdGroupsFiltersBar {...defaultProps} />)
    expect(screen.getByTestId('filter-icon')).toBeInTheDocument()
  })

  it('calls onSearchTermChange on input', () => {
    const onSearchTermChange = vi.fn()
    render(<AdGroupsFiltersBar {...defaultProps} onSearchTermChange={onSearchTermChange} />)
    fireEvent.change(screen.getByTestId('search-input'), { target: { value: 'test' } })
    expect(onSearchTermChange).toHaveBeenCalledWith('test')
  })

  it('renders role filter select options', () => {
    render(<AdGroupsFiltersBar {...defaultProps} />)
    expect(screen.getByText('Voice Agent')).toBeInTheDocument()
    expect(screen.getByText('Chat Agent')).toBeInTheDocument()
    expect(screen.getByText('Supervisor')).toBeInTheDocument()
  })

  it('renders status filter select options', () => {
    render(<AdGroupsFiltersBar {...defaultProps} />)
    expect(screen.getByText('Active')).toBeInTheDocument()
    expect(screen.getByText('Needs Setup')).toBeInTheDocument()
  })

  it('renders advanced filters sheet', () => {
    render(<AdGroupsFiltersBar {...defaultProps} />)
    expect(screen.getByTestId('advanced-filters')).toBeInTheDocument()
  })

  it('displays current search term', () => {
    render(<AdGroupsFiltersBar {...defaultProps} searchTerm="hello" />)
    expect(screen.getByTestId('search-input')).toHaveValue('hello')
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/__tests__/ad-groups-pagination.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, disabled, ...props }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} disabled={disabled as boolean} {...props}>{children as React.ReactNode}</button>
  )
}))

import { AdGroupsPagination } from '../ad-groups-pagination'

describe('AdGroupsPagination', () => {
  const defaultProps = {
    currentPage: 2,
    totalPages: 5,
    pageStart: 26,
    pageEnd: 50,
    totalCount: 120,
    onPageChange: vi.fn()
  }

  it('renders null when totalPages <= 1', () => {
    const { container } = render(
      <AdGroupsPagination {...defaultProps} totalPages={1} />
    )
    expect(container.firstChild).toBeNull()
  })

  it('displays page range text', () => {
    render(<AdGroupsPagination {...defaultProps} />)
    expect(screen.getByText('Showing 26-50 of 120 groups')).toBeInTheDocument()
  })

  it('displays current page info', () => {
    render(<AdGroupsPagination {...defaultProps} />)
    expect(screen.getByText('Page 2 of 5')).toBeInTheDocument()
  })

  it('calls onPageChange with previous page on Previous click', () => {
    const onPageChange = vi.fn()
    render(<AdGroupsPagination {...defaultProps} onPageChange={onPageChange} />)
    fireEvent.click(screen.getByText('Previous'))
    expect(onPageChange).toHaveBeenCalledWith(1)
  })

  it('calls onPageChange with next page on Next click', () => {
    const onPageChange = vi.fn()
    render(<AdGroupsPagination {...defaultProps} onPageChange={onPageChange} />)
    fireEvent.click(screen.getByText('Next'))
    expect(onPageChange).toHaveBeenCalledWith(3)
  })

  it('disables Previous button on first page', () => {
    render(<AdGroupsPagination {...defaultProps} currentPage={1} />)
    expect(screen.getByText('Previous')).toBeDisabled()
  })

  it('disables Next button on last page', () => {
    render(<AdGroupsPagination {...defaultProps} currentPage={5} />)
    expect(screen.getByText('Next')).toBeDisabled()
  })

  it('clamps page to min 1 when clicking Previous on page 1', () => {
    render(<AdGroupsPagination {...defaultProps} currentPage={1} />)
    expect(screen.getByText('Previous')).toBeDisabled()
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/__tests__/ad-groups-stats-cards.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  AlertTriangle: () => <span data-testid="alert-icon" />,
  CheckCircle: () => <span data-testid="check-icon" />,
  Users: () => <span data-testid="users-icon" />
}))

vi.mock('../../../../ui/card', () => ({
  Card: ({ children }: { children: React.ReactNode }) => <div data-testid="card">{children}</div>,
  CardHeader: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  CardTitle: ({ children }: { children: React.ReactNode }) => <h3>{children}</h3>,
  CardContent: ({ children }: { children: React.ReactNode }) => <div>{children}</div>
}))

import { AdGroupsStatsCards } from '../ad-groups-stats-cards'

describe('AdGroupsStatsCards', () => {
  it('renders three stat cards', () => {
    render(<AdGroupsStatsCards unconfiguredCount={3} activeCount={10} totalCount={15} />)
    const cards = screen.getAllByTestId('card')
    expect(cards).toHaveLength(3)
  })

  it('displays unconfigured count', () => {
    render(<AdGroupsStatsCards unconfiguredCount={7} activeCount={10} totalCount={20} />)
    expect(screen.getByText('7')).toBeInTheDocument()
  })

  it('displays active count', () => {
    render(<AdGroupsStatsCards unconfiguredCount={3} activeCount={12} totalCount={20} />)
    expect(screen.getByText('12')).toBeInTheDocument()
  })

  it('displays total count', () => {
    render(<AdGroupsStatsCards unconfiguredCount={3} activeCount={10} totalCount={25} />)
    expect(screen.getByText('25')).toBeInTheDocument()
  })

  it('renders stat labels', () => {
    render(<AdGroupsStatsCards unconfiguredCount={0} activeCount={0} totalCount={0} />)
    expect(screen.getByText('Needs Configuration')).toBeInTheDocument()
    expect(screen.getByText('Active Groups')).toBeInTheDocument()
    expect(screen.getByText('Total Groups')).toBeInTheDocument()
  })

  it('renders description text', () => {
    render(<AdGroupsStatsCards unconfiguredCount={0} activeCount={0} totalCount={0} />)
    expect(screen.getByText('Groups requiring setup')).toBeInTheDocument()
    expect(screen.getByText('Configured and active')).toBeInTheDocument()
    expect(screen.getByText('All AD groups')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/__tests__/ad-groups-table-helpers.test.ts
import { describe, it, expect } from 'vitest'
import { buildCountryNameMap, computeSelectionState } from '../ad-groups-table-helpers'
import type { CountryDto } from '@/services/api/reference-data.service'

describe('buildCountryNameMap', () => {
  it('builds map from country list', () => {
    const countries = [
      { countryCode: 'us', countryName: 'United States' },
      { countryCode: 'gb', countryName: 'United Kingdom' }
    ] as CountryDto[]
    const map = buildCountryNameMap(countries)
    expect(map.get('US')).toBe('United States')
    expect(map.get('GB')).toBe('United Kingdom')
  })

  it('returns empty map for empty input', () => {
    const map = buildCountryNameMap([])
    expect(map.size).toBe(0)
  })
})

describe('computeSelectionState', () => {
  it('returns allPageSelected when all groups on page are selected', () => {
    const groups = [{ id: 'a' }, { id: 'b' }]
    const selected = new Set(['a', 'b'])
    const result = computeSelectionState(groups, selected)
    expect(result.allPageSelected).toBe(true)
    expect(result.partiallySelected).toBe(false)
  })

  it('returns partiallySelected when some groups are selected', () => {
    const groups = [{ id: 'a' }, { id: 'b' }, { id: 'c' }]
    const selected = new Set(['a'])
    const result = computeSelectionState(groups, selected)
    expect(result.allPageSelected).toBe(false)
    expect(result.partiallySelected).toBe(true)
  })

  it('returns both false when no groups are selected', () => {
    const groups = [{ id: 'a' }, { id: 'b' }]
    const selected = new Set<string>()
    const result = computeSelectionState(groups, selected)
    expect(result.allPageSelected).toBe(false)
    expect(result.partiallySelected).toBe(false)
  })

  it('returns both false when groups list is empty', () => {
    const result = computeSelectionState([], new Set(['a']))
    expect(result.allPageSelected).toBe(false)
    expect(result.partiallySelected).toBe(false)
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/__tests__/ad-groups-table.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('@/hooks/features/use-business-terminology', () => ({
  useBusinessRoles: () => ({
    voice_agent: { displayName: 'Voice Agent' },
    chat_agent: { displayName: 'Chat Agent' }
  }),
  useBusinessStatus: () => ({
    needs_setup: { label: 'Needs Setup' },
    active: { label: 'Active' },
    disabled: { label: 'Disabled' }
  })
}))

vi.mock('../../../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

vi.mock('@/components/common/brand-loader', () => ({
  BrandLoader: ({ message }: { message: string }) => <div data-testid="loader">{message}</div>
}))

vi.mock('lucide-react', () => ({
  Settings: () => <span data-testid="settings-icon" />,
  Users: () => <span data-testid="users-icon" />,
  MapPin: () => <span data-testid="map-pin" />,
  AlertTriangle: () => <span data-testid="alert-icon" />,
  CheckCircle: () => <span data-testid="check-icon" />,
  PowerOff: () => <span data-testid="power-icon" />,
  ToggleRight: () => <span data-testid="toggle-right" />,
  ToggleLeft: () => <span data-testid="toggle-left" />,
  Shield: () => <span data-testid="shield" />,
  ShieldCheck: () => <span data-testid="shield-check" />,
  ShieldAlert: () => <span data-testid="shield-alert" />,
  Crown: () => <span data-testid="crown" />
}))

vi.mock('../../../../ui/table', () => ({
  Table: ({ children }: { children: React.ReactNode }) => <table>{children}</table>,
  TableBody: ({ children }: { children: React.ReactNode }) => <tbody>{children}</tbody>,
  TableCell: ({ children, colSpan, ...rest }: Record<string, unknown>) => (
    <td colSpan={colSpan as number} {...rest}>{children as React.ReactNode}</td>
  ),
  TableHead: ({ children }: { children: React.ReactNode }) => <th>{children}</th>,
  TableHeader: ({ children }: { children: React.ReactNode }) => <thead>{children}</thead>,
  TableRow: ({ children }: { children: React.ReactNode }) => <tr>{children}</tr>
}))

vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, ...rest }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} {...rest}>{children as React.ReactNode}</button>
  )
}))

vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children }: { children: React.ReactNode }) => <span data-testid="badge">{children}</span>
}))

vi.mock('../../../../ui/checkbox', () => ({
  Checkbox: ({ onCheckedChange, checked, ...rest }: Record<string, unknown>) => (
    <input
      type="checkbox"
      checked={checked as boolean}
      onChange={() => (onCheckedChange as (v: boolean) => void)(!checked)}
      {...rest}
    />
  )
}))

vi.mock('../../../../ui/tooltip', () => ({
  TooltipProvider: ({ children }: { children: React.ReactNode }) => <>{children}</>,
  Tooltip: ({ children }: { children: React.ReactNode }) => <>{children}</>,
  TooltipTrigger: ({ children }: { children: React.ReactNode }) => <>{children}</>,
  TooltipContent: ({ children }: { children: React.ReactNode }) => <span data-testid="tooltip">{children}</span>
}))

import { AdGroupsTable } from '../ad-groups-table'
import type { AdminPermissions } from '../../../admin-layout'

const allPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

const mockGroups = [
  {
    id: 'g1',
    groupIdentifier: 'CN=group1',
    logicalName: 'Group One',
    roleName: 'voice_agent',
    isActive: true,
    country: 'HK',
    region: 'APAC',
    accessLevel: 'MAKER',
    userCount: 42,
    pendingChangeIndicator: false
  },
  {
    id: 'g2',
    groupIdentifier: 'CN=group2',
    logicalName: '',
    roleName: '',
    isActive: false,
    country: '',
    region: '',
    pendingChangeIndicator: true
  }
]

const defaultProps = {
  groups: mockGroups as any,
  selectedGroups: new Set<string>(),
  loading: false,
  savingGroupId: null,
  onSelectGroup: vi.fn(),
  onSelectAll: vi.fn(),
  onDeselectAll: vi.fn(),
  onConfigureGroup: vi.fn(),
  onToggleActive: vi.fn(),
  isConfigured: (g: any) => Boolean(g.logicalName && g.roleName && g.region && g.country),
  tableContainerRef: { current: null },
  permissions: allPermissions,
  countries: [
    { countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true }
  ]
}

describe('AdGroupsTable', () => {
  it('renders table headers', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Team Group')).toBeInTheDocument()
    expect(screen.getByText('Role')).toBeInTheDocument()
    expect(screen.getByText('Status')).toBeInTheDocument()
  })

  it('renders loading state', () => {
    render(<AdGroupsTable {...defaultProps} loading={true} groups={[]} />)
    expect(screen.getByTestId('loader')).toBeInTheDocument()
  })

  it('renders empty state', () => {
    render(<AdGroupsTable {...defaultProps} groups={[]} />)
    expect(screen.getByText('No team groups found')).toBeInTheDocument()
  })

  it('renders group rows', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Group One')).toBeInTheDocument()
    expect(screen.getByText('CN=group1')).toBeInTheDocument()
  })

  it('renders role display name', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Voice Agent')).toBeInTheDocument()
  })

  it('renders country name from code', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Hong Kong')).toBeInTheDocument()
  })

  it('renders "not set" for unconfigured fields', () => {
    render(<AdGroupsTable {...defaultProps} />)
    const notSetElements = screen.getAllByText('Not set')
    expect(notSetElements.length).toBeGreaterThan(0)
  })

  it('renders user count', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('42')).toBeInTheDocument()
  })

  it('renders active badge for configured active group', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Active')).toBeInTheDocument()
  })

  it('renders needs setup badge for unconfigured group', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Needs Setup')).toBeInTheDocument()
  })

  it('renders pending badge', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Pending')).toBeInTheDocument()
  })

  it('calls onSelectGroup when checkbox clicked', () => {
    const onSelectGroup = vi.fn()
    render(<AdGroupsTable {...defaultProps} onSelectGroup={onSelectGroup} />)
    const checkboxes = screen.getAllByRole('checkbox')
    // First checkbox is select-all, rest are per-row
    fireEvent.click(checkboxes[1])
    expect(onSelectGroup).toHaveBeenCalledWith('g1')
  })

  it('calls onSelectAll when header checkbox clicked', () => {
    const onSelectAll = vi.fn()
    render(<AdGroupsTable {...defaultProps} onSelectAll={onSelectAll} />)
    const checkboxes = screen.getAllByRole('checkbox')
    fireEvent.click(checkboxes[0])
    expect(onSelectAll).toHaveBeenCalled()
  })

  it('calls onConfigureGroup when configure button clicked', () => {
    const onConfigureGroup = vi.fn()
    render(<AdGroupsTable {...defaultProps} onConfigureGroup={onConfigureGroup} />)
    const settingsIcons = screen.getAllByTestId('settings-icon')
    // Click the button wrapping the first settings icon
    fireEvent.click(settingsIcons[0].closest('button')!)
    expect(onConfigureGroup).toHaveBeenCalledWith(mockGroups[0])
  })

  it('calls onToggleActive when toggle button clicked', () => {
    const onToggleActive = vi.fn()
    render(<AdGroupsTable {...defaultProps} onToggleActive={onToggleActive} />)
    // The toggle button has ToggleRight icon for active group
    const toggleIcon = screen.getByTestId('toggle-right')
    fireEvent.click(toggleIcon.closest('button')!)
    expect(onToggleActive).toHaveBeenCalledWith(mockGroups[0])
  })

  it('renders access level badge', () => {
    render(<AdGroupsTable {...defaultProps} />)
    // MAKER access level renders with shield-alert icon
    expect(screen.getByTestId('shield-alert')).toBeInTheDocument()
  })

  it('hides toggle button without permission', () => {
    render(
      <AdGroupsTable
        {...defaultProps}
        permissions={{ ...allPermissions, canEnableDisableGroups: false }}
      />
    )
    expect(screen.queryByTestId('toggle-right')).not.toBeInTheDocument()
  })

  it('hides configure button without edit permissions', () => {
    render(
      <AdGroupsTable
        {...defaultProps}
        permissions={{
          ...allPermissions,
          canEditBusinessInfo: false,
          canEditPermissions: false,
          canEditApplications: false
        }}
      />
    )
    expect(screen.queryByTestId('settings-icon')).not.toBeInTheDocument()
  })

  it('renders unconfigured group name fallback', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Unconfigured Group')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/__tests__/ad-groups-toggle-dialog.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  ShieldOff: (props: Record<string, unknown>) => <span data-testid="shield-off" {...props} />,
  CheckCircle: (props: Record<string, unknown>) => <span data-testid="check-circle" {...props} />
}))

vi.mock('../../../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

vi.mock('../../../../ui/dialog', () => ({
  Dialog: ({ open, children }: { open: boolean; children: React.ReactNode }) =>
    open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  DialogHeader: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  DialogTitle: ({ children, className }: { children: React.ReactNode; className?: string }) =>
    <h2 className={className}>{children}</h2>,
  DialogDescription: ({ children }: { children: React.ReactNode }) => <p>{children}</p>,
  DialogFooter: ({ children }: { children: React.ReactNode }) => <div>{children}</div>
}))

vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, ...rest }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} {...rest}>{children as React.ReactNode}</button>
  )
}))

import { AdGroupsToggleDialog } from '../ad-groups-toggle-dialog'

const activeGroup = {
  id: 'g1',
  groupIdentifier: 'CN=test-group',
  logicalName: 'Test Group',
  isActive: true,
  roleName: 'voice_agent',
  pendingChangeIndicator: false
}

const inactiveGroup = {
  id: 'g2',
  groupIdentifier: 'CN=inactive-group',
  logicalName: 'Inactive Group',
  isActive: false,
  roleName: 'chat_agent',
  pendingChangeIndicator: false
}

describe('AdGroupsToggleDialog', () => {
  it('renders nothing when group is null', () => {
    const { container } = render(
      <AdGroupsToggleDialog
        group={null}
        open={true}
        onOpenChange={vi.fn()}
        onConfirm={vi.fn()}
      />
    )
    expect(container.innerHTML).toBe('')
  })

  it('renders nothing when closed', () => {
    const { container } = render(
      <AdGroupsToggleDialog
        group={activeGroup as any}
        open={false}
        onOpenChange={vi.fn()}
        onConfirm={vi.fn()}
      />
    )
    expect(container.querySelector('[data-testid="dialog"]')).not.toBeInTheDocument()
  })

  it('shows disable dialog for active group', () => {
    render(
      <AdGroupsToggleDialog
        group={activeGroup as any}
        open={true}
        onOpenChange={vi.fn()}
        onConfirm={vi.fn()}
      />
    )
    expect(screen.getByTestId('shield-off')).toBeInTheDocument()
    expect(screen.getByText('This will prevent users in this group from accessing the system.')).toBeInTheDocument()
  })

  it('shows enable dialog for inactive group', () => {
    render(
      <AdGroupsToggleDialog
        group={inactiveGroup as any}
        open={true}
        onOpenChange={vi.fn()}
        onConfirm={vi.fn()}
      />
    )
    expect(screen.getByTestId('check-circle')).toBeInTheDocument()
    expect(screen.getByText('This will allow users in this group to access the system.')).toBeInTheDocument()
  })

  it('calls onConfirm when confirm button clicked', () => {
    const onConfirm = vi.fn()
    render(
      <AdGroupsToggleDialog
        group={activeGroup as any}
        open={true}
        onOpenChange={vi.fn()}
        onConfirm={onConfirm}
      />
    )
    // Find the button with disable text (last one since there are two buttons)
    const buttons = screen.getAllByRole('button')
    const confirmBtn = buttons.find(btn => btn.textContent === 'Disable Group')
    fireEvent.click(confirmBtn!)
    expect(onConfirm).toHaveBeenCalled()
  })

  it('calls onOpenChange when cancel button clicked', () => {
    const onOpenChange = vi.fn()
    render(
      <AdGroupsToggleDialog
        group={activeGroup as any}
        open={true}
        onOpenChange={onOpenChange}
        onConfirm={vi.fn()}
      />
    )
    fireEvent.click(screen.getByText('Cancel'))
    expect(onOpenChange).toHaveBeenCalledWith(false)
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/__tests__/advanced-filters-helpers.test.ts
import { describe, it, expect, vi } from 'vitest'
import { countActiveFilters, buildFilterChips } from '../advanced-filters-helpers'

describe('countActiveFilters', () => {
  it('returns 0 when all filters are "all"', () => {
    expect(countActiveFilters('all', 'all', 'all')).toBe(0)
  })

  it('returns 1 when one filter is active', () => {
    expect(countActiveFilters('AMER', 'all', 'all')).toBe(1)
  })

  it('returns 2 when two filters are active', () => {
    expect(countActiveFilters('AMER', 'US', 'all')).toBe(2)
  })

  it('returns 3 when all filters are active', () => {
    expect(countActiveFilters('AMER', 'US', 'WPB')).toBe(3)
  })
})

describe('buildFilterChips', () => {
  const noop = vi.fn()

  it('returns empty array when all filters are "all"', () => {
    const chips = buildFilterChips('all', 'all', 'all', noop, noop, noop)
    expect(chips).toHaveLength(0)
  })

  it('returns chips for active filters only', () => {
    const chips = buildFilterChips('AMER', 'all', 'WPB', noop, noop, noop)
    expect(chips).toHaveLength(2)
    expect(chips[0].label).toBe('Region')
    expect(chips[0].value).toBe('AMER')
    expect(chips[1].label).toBe('Department')
    expect(chips[1].value).toBe('WPB')
  })

  it('attaches correct clear callbacks', () => {
    const onRegion = vi.fn()
    const onCountry = vi.fn()
    const onBU = vi.fn()

    const chips = buildFilterChips('AMER', 'US', 'WPB', onRegion, onCountry, onBU)
    expect(chips).toHaveLength(3)

    chips[0].onClear()
    expect(onRegion).toHaveBeenCalled()

    chips[1].onClear()
    expect(onCountry).toHaveBeenCalled()

    chips[2].onClear()
    expect(onBU).toHaveBeenCalled()
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/__tests__/advanced-filters-sheet.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../ui/sheet', () => ({
  Sheet: ({ children }: any) => <div data-testid="sheet">{children}</div>,
  SheetContent: ({ children }: any) => <div data-testid="sheet-content">{children}</div>,
  SheetHeader: ({ children }: any) => <div>{children}</div>,
  SheetTitle: ({ children }: any) => <h2>{children}</h2>,
  SheetTrigger: ({ children }: any) => <div data-testid="sheet-trigger">{children}</div>,
  SheetFooter: ({ children }: any) => <div>{children}</div>
}))
vi.mock('../../../../ui/select', () => ({
  Select: ({ children }: any) => <div>{children}</div>,
  SelectContent: ({ children }: any) => <div>{children}</div>,
  SelectItem: ({ children, value }: any) => <div data-testid={`select-item-${value}`}>{children}</div>,
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: ({ placeholder }: any) => <span>{placeholder}</span>
}))
vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: any) => (
    <button onClick={onClick} disabled={disabled}>{children}</button>
  )
}))
vi.mock('../../../../ui/badge', () => ({ Badge: ({ children }: any) => <span data-testid="badge">{children}</span> }))
vi.mock('lucide-react', () => ({
  SlidersHorizontal: (p: any) => <span {...p} />,
  X: (p: any) => <span {...p} />
}))
vi.mock('@/hooks/features/use-business-terminology', () => ({
  getBusinessField: (field: string) => field
}))

import { AdvancedFiltersSheet } from '../advanced-filters-sheet'

describe('AdvancedFiltersSheet', () => {
  const baseProps = {
    marketFilter: 'all',
    onMarketFilterChange: vi.fn(),
    regionFilter: 'all',
    onRegionFilterChange: vi.fn(),
    countryFilter: 'all',
    onCountryFilterChange: vi.fn(),
    businessUnitFilter: 'all',
    onBusinessUnitFilterChange: vi.fn(),
    onClearAll: vi.fn(),
    regions: [
      { regionCode: 'EMEA', regionName: 'Europe, Middle East & Africa' },
      { regionCode: 'APAC', regionName: 'Asia Pacific' }
    ] as any[],
    countries: [
      { countryCode: 'GB', countryName: 'United Kingdom' }
    ] as any[],
    businessUnits: [
      { unitCode: 'WPB', unitName: 'Wealth & Personal Banking' }
    ] as any[],
    isLoading: false
  }

  it('renders sheet trigger with filter label', () => {
    render(<AdvancedFiltersSheet {...baseProps} />)
    expect(screen.getByTestId('sheet-trigger')).toBeInTheDocument()
    expect(screen.getByText('More Filters')).toBeInTheDocument()
  })

  it('renders filter title', () => {
    render(<AdvancedFiltersSheet {...baseProps} />)
    expect(screen.getByText('Advanced Filters')).toBeInTheDocument()
  })

  it('renders filter section labels', () => {
    render(<AdvancedFiltersSheet {...baseProps} />)
    // Multiple elements may have the label text (one as label, one could be in chips)
    expect(screen.getAllByText('Region').length).toBeGreaterThan(0)
    expect(screen.getAllByText('Country').length).toBeGreaterThan(0)
    expect(screen.getAllByText('Department').length).toBeGreaterThan(0)
  })

  it('shows active filter count badge when filters are set', () => {
    render(<AdvancedFiltersSheet {...baseProps} regionFilter="EMEA" />)
    const badges = screen.getAllByTestId('badge')
    const countBadge = badges.find(b => b.textContent === '1')
    expect(countBadge).toBeTruthy()
  })

  it('shows active filters section when filters selected', () => {
    render(<AdvancedFiltersSheet {...baseProps} regionFilter="EMEA" countryFilter="GB" />)
    expect(screen.getByText('Active Filters')).toBeInTheDocument()
  })

  it('hides active filters section when all filters are default', () => {
    render(<AdvancedFiltersSheet {...baseProps} />)
    expect(screen.queryByText('Active Filters')).not.toBeInTheDocument()
  })

  it('disables clear all button when no filters active', () => {
    render(<AdvancedFiltersSheet {...baseProps} />)
    const clearBtn = screen.getByText('Clear All')
    expect(clearBtn).toBeDisabled()
  })

  it('enables clear all button when filters active', () => {
    render(<AdvancedFiltersSheet {...baseProps} regionFilter="EMEA" />)
    const clearBtn = screen.getByText('Clear All')
    expect(clearBtn).not.toBeDisabled()
  })
})
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/active-filters-chips.tsx
import { Badge } from '../../../ui/badge'
import { X } from 'lucide-react'
import { useBusinessRoles, useBusinessStatus } from '@/hooks/features/use-business-terminology'
import type { RegionDto, BusinessUnitDto, CountryDto } from '@/services/api/reference-data.service'

/** Props for the ActiveFiltersChips component. */
interface ActiveFiltersChipsProps {
  /** Current search text entered by the user */
  searchTerm: string
  /** Selected role filter code or 'all' */
  roleFilter: string
  /** Selected status filter value or 'all' */
  statusFilter: string
  /** Selected market filter value or 'all' */
  marketFilter: string
  /** Selected region filter code or 'all' */
  regionFilter: string
  /** Selected country filter code or 'all' */
  countryFilter: string
  /** Selected business unit filter code or 'all' */
  businessUnitFilter: string
  /** Callback to clear or update the search term */
  onSearchTermChange: (value: string) => void
  /** Callback to reset or change the role filter */
  onRoleFilterChange: (value: string) => void
  /** Callback to reset or change the status filter */
  onStatusFilterChange: (value: string) => void
  /** Callback to reset or change the market filter */
  onMarketFilterChange: (value: string) => void
  /** Callback to reset or change the region filter */
  onRegionFilterChange: (value: string) => void
  /** Callback to reset or change the country filter */
  onCountryFilterChange: (value: string) => void
  /** Callback to reset or change the business unit filter */
  onBusinessUnitFilterChange: (value: string) => void
  /** Available region reference data for resolving codes to names */
  regions: RegionDto[]
  /** Available country reference data for resolving codes to names */
  countries: CountryDto[]
  /** Available business unit reference data for resolving codes to names */
  businessUnits: BusinessUnitDto[]
}

/**
 * Renders dismissible badge chips for each active table filter. Each chip shows
 * the filter category and value, with an X button to clear that individual filter.
 * Returns null when no filters are active.
 */
export function ActiveFiltersChips({
  searchTerm,
  roleFilter,
  statusFilter,
  marketFilter,
  regionFilter,
  countryFilter,
  businessUnitFilter,
  onSearchTermChange,
  onRoleFilterChange,
  onStatusFilterChange,
  onMarketFilterChange,
  onRegionFilterChange,
  onCountryFilterChange,
  onBusinessUnitFilterChange,

  regions,
  countries,
  businessUnits
}: Readonly<ActiveFiltersChipsProps>) {
  const businessRoles = useBusinessRoles()
  const businessStatus = useBusinessStatus()

  const getRegionName = (code: string) => regions.find(r => r.regionCode === code)?.regionName || code
  const getCountryName = (code: string) => countries.find(c => c.countryCode === code)?.countryName || code
  const getBusinessUnitName = (code: string) => businessUnits.find(u => u.unitCode === code)?.unitName || code

  const filterDefinitions: Array<{ value: string; check: string; label: string; onRemove: () => void }> = [
    { value: searchTerm, check: '', label: `Search: "${searchTerm}"`, onRemove: () => onSearchTermChange('') },
    { value: roleFilter, check: 'all', label: `Role: ${businessRoles[roleFilter]?.displayName || roleFilter}`, onRemove: () => onRoleFilterChange('all') },
    { value: statusFilter, check: 'all', label: `Status: ${businessStatus[statusFilter]?.label || statusFilter}`, onRemove: () => onStatusFilterChange('all') },
    { value: marketFilter, check: 'all', label: `Market: ${marketFilter}`, onRemove: () => onMarketFilterChange('all') },
    { value: regionFilter, check: 'all', label: `Region: ${getRegionName(regionFilter)}`, onRemove: () => onRegionFilterChange('all') },
    { value: countryFilter, check: 'all', label: `Country: ${getCountryName(countryFilter)}`, onRemove: () => onCountryFilterChange('all') },
    { value: businessUnitFilter, check: 'all', label: `Department: ${getBusinessUnitName(businessUnitFilter)}`, onRemove: () => onBusinessUnitFilterChange('all') }
  ]

  const activeFilters = filterDefinitions.filter(f =>
    f.check === '' ? Boolean(f.value) : f.value !== f.check
  )

  if (activeFilters.length === 0) {
    return null
  }

  return (
    <div className="flex flex-wrap items-center gap-2">
      <span className="text-sm text-muted-foreground">Active filters:</span>
      {activeFilters.map((filter) => (
        <Badge key={filter.label} variant="secondary" className="gap-1.5 pr-1">
          <span className="text-xs">{filter.label}</span>
          <button
            onClick={filter.onRemove}
            className="ml-1 hover:text-destructive transition-colors"
            aria-label={`Remove filter: ${filter.label}`}
          >
            <X className="h-3 w-3" />
          </button>
        </Badge>
      ))}
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/ad-group-table-cells.tsx
/**
 * AD Group Table Cells
 * Sub-components for rendering individual table row cells and badges
 * in the AD Groups table.
 */

import { Badge } from '../../../ui/badge'
import { Button } from '../../../ui/button'
import { Tooltip, TooltipContent, TooltipTrigger } from '../../../ui/tooltip'
import {
  Settings,
  AlertTriangle,
  CheckCircle,
  PowerOff,
  ToggleRight,
  ToggleLeft,
  Shield,
  ShieldCheck,
  ShieldAlert,
  Crown
} from 'lucide-react'
import { cn } from '../../../../lib/utils'
import type { AdGroup } from '../../../../types/features/ad-group-config'
import type { AdminPermissions } from '../../admin-layout'

/** Maps access level keys to their Tailwind CSS badge colour classes. */
const ACCESS_LEVEL_STYLES: Record<string, string> = {
  SUPER_ADMIN: 'bg-purple-50 text-purple-700 border-purple-200',
  CHECKER: 'bg-blue-50 text-blue-700 border-blue-200',
  MAKER: 'bg-amber-50 text-amber-700 border-amber-200',
  VIEWER: 'bg-gray-50 text-gray-600 border-gray-200'
}

/** Maps access level keys to their lucide icon components. */
const ACCESS_LEVEL_ICONS: Record<string, React.ComponentType<{ className?: string }>> = {
  SUPER_ADMIN: Crown,
  CHECKER: ShieldCheck,
  MAKER: ShieldAlert,
  VIEWER: Shield
}

/** Maps lowercase access level keys to human-readable display labels. */
const ACCESS_LEVEL_LABELS: Record<string, string> = {
  super_admin: 'Super Admin',
  checker: 'Checker',
  maker: 'Maker',
  viewer: 'Viewer'
}

/** Renders a coloured badge with icon indicating the group's access level (Super Admin, Checker, Maker, Viewer). */
export function AccessLevelBadge({ accessLevel }: Readonly<{ accessLevel: string }>) {
  const Icon = ACCESS_LEVEL_ICONS[accessLevel]
  return (
    <Badge variant="outline" className={cn("font-medium", ACCESS_LEVEL_STYLES[accessLevel])}>
      {Icon && <Icon className="h-3 w-3 mr-1" />}
      {ACCESS_LEVEL_LABELS[accessLevel.toLowerCase()] || accessLevel}
    </Badge>
  )
}

function resolveStatusBadgeConfig(configured: boolean, isActive: boolean, businessStatus: Record<string, { label?: string } | undefined>) {
  if (!configured) return { className: 'bg-orange-50 text-orange-700 border-orange-200', Icon: AlertTriangle, label: businessStatus['needs_setup']?.label || 'Needs Setup' }
  if (isActive) return { className: 'bg-emerald-50 text-emerald-800 border-emerald-200', Icon: CheckCircle, label: businessStatus['active']?.label || 'Active' }
  return { className: 'bg-slate-50 text-slate-600 border-slate-200', Icon: PowerOff, label: businessStatus['disabled']?.label || 'Disabled' }
}

/** Renders one or more status badges showing configuration state, active/disabled status, and pending change indicator. */
export function GroupStatusBadge({ group, configured, businessStatus }: Readonly<{
  group: AdGroup
  configured: boolean
  businessStatus: Record<string, { label?: string } | undefined>
}>) {
  const config = resolveStatusBadgeConfig(configured, group.isActive, businessStatus)
  return (
    <div className="flex items-center gap-2 flex-wrap">
      <Badge variant="outline" className={config.className}>
        <config.Icon className="h-3 w-3 mr-1" />
        {config.label}
      </Badge>
      {group.pendingChangeIndicator && (
        <Badge variant="outline" className="bg-yellow-50 text-yellow-700 border-yellow-200">
          Pending
        </Badge>
      )}
    </div>
  )
}

/** Renders the enable/disable toggle and configure gear button for a single AD group row. */
export function GroupActionButtons({ group, permissions, configured, canConfigureGroups, onToggleActive, onConfigureGroup }: Readonly<{
  group: AdGroup
  permissions: AdminPermissions
  configured: boolean
  canConfigureGroups: boolean
  onToggleActive: (group: AdGroup) => void
  onConfigureGroup: (group: AdGroup) => void
}>) {
  const groupLabel = group.logicalName || group.groupIdentifier
  return (
    <div className="flex items-center justify-end gap-2 flex-wrap">
      {permissions.canEnableDisableGroups && configured && (
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              variant="outline"
              size="sm"
              onClick={() => onToggleActive(group)}
              className={group.isActive ? 'text-green-600 hover:text-green-700 border-green-200' : 'text-gray-400 hover:text-gray-600 border-gray-200'}
              aria-label={group.isActive ? `Disable ${groupLabel}` : `Enable ${groupLabel}`}
            >
              {group.isActive ? <ToggleRight className="h-4 w-4" /> : <ToggleLeft className="h-4 w-4" />}
            </Button>
          </TooltipTrigger>
          <TooltipContent>
            {group.isActive ? 'Disable Group' : 'Enable Group'}
          </TooltipContent>
        </Tooltip>
      )}
      {canConfigureGroups && (
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              variant="outline"
              size="sm"
              onClick={() => onConfigureGroup(group)}
              aria-label={`Configure ${groupLabel}`}
            >
              <Settings className="h-4 w-4" />
            </Button>
          </TooltipTrigger>
          <TooltipContent>
            Configure AD Group
          </TooltipContent>
        </Tooltip>
      )}
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/ad-groups-filters-bar.tsx
import { Input } from '../../../ui/input'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../../../ui/select'
import { Search, Filter } from 'lucide-react'
import { useBusinessRoles, useBusinessStatus } from '@/hooks/features/use-business-terminology'
import { AdvancedFiltersSheet } from './advanced-filters-sheet'
import type { RegionDto, BusinessUnitDto, CountryDto } from '@/services/api/reference-data.service'

/** Props for the AdGroupsFiltersBar component. */
interface AdGroupsFiltersBarProps {
  /** Current search term for filtering by name or DN */
  searchTerm: string
  /** Callback to update the search term */
  onSearchTermChange: (value: string) => void
  /** Current role filter value ('all' or a specific role code) */
  roleFilter: string
  /** Callback to update the role filter */
  onRoleFilterChange: (value: string) => void
  /** Current status filter value */
  statusFilter: string
  /** Callback to update the status filter */
  onStatusFilterChange: (value: string) => void
  /** Current market filter value */
  marketFilter: string
  /** Callback to update the market filter */
  onMarketFilterChange: (value: string) => void
  /** Current region filter value */
  regionFilter: string
  /** Callback to update the region filter */
  onRegionFilterChange: (value: string) => void
  /** Current country filter value */
  countryFilter: string
  /** Callback to update the country filter */
  onCountryFilterChange: (value: string) => void
  /** Current business unit filter value */
  businessUnitFilter: string
  /** Callback to update the business unit filter */
  onBusinessUnitFilterChange: (value: string) => void
  /** Available regions from reference data API */
  regions: RegionDto[]
  /** Available countries from reference data API */
  countries: CountryDto[]
  /** Available business units from reference data API */
  businessUnits: BusinessUnitDto[]
  /** Whether reference data is currently loading */
  isLoading: boolean
}

/**
 * Filter bar for the AD groups table. Provides a search input, role and status
 * dropdowns, and an advanced filters sheet for region, country, and business unit.
 */
export function AdGroupsFiltersBar({
  searchTerm,
  onSearchTermChange,
  roleFilter,
  onRoleFilterChange,
  statusFilter,
  onStatusFilterChange,
  marketFilter,
  onMarketFilterChange,
  regionFilter,
  onRegionFilterChange,
  countryFilter,
  onCountryFilterChange,
  businessUnitFilter,
  onBusinessUnitFilterChange,
  regions,
  countries,
  businessUnits,
  isLoading
}: Readonly<AdGroupsFiltersBarProps>) {
  const businessRoles = useBusinessRoles()
  const businessStatus = useBusinessStatus()

  const handleClearAdvancedFilters = () => {
    onMarketFilterChange('all')
    onRegionFilterChange('all')
    onCountryFilterChange('all')
    onBusinessUnitFilterChange('all')
  }

  return (
    <div className="flex flex-col space-y-4 md:flex-row md:items-center md:space-y-0 md:space-x-4">
      <div className="relative w-48 focus-within:w-96 flex-shrink-0 transition-all duration-300">
        <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
        <Input
          placeholder="Search team groups..."
          value={searchTerm}
          onChange={(e) => onSearchTermChange(e.target.value)}
          className="pl-8 w-full
                     transition-all duration-300 ease-in-out
                     focus:shadow-lg focus:z-10 focus:border-primary"
        />
      </div>

      <div className="flex items-center space-x-2">
        <Filter className="h-4 w-4 text-muted-foreground" />

        <Select value={roleFilter} onValueChange={onRoleFilterChange}>
          <SelectTrigger className="w-40">
            <SelectValue placeholder="All Roles" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Roles</SelectItem>
            <SelectItem value="voice_agent">{businessRoles['voice_agent']?.displayName || 'Voice Agent'}</SelectItem>
            <SelectItem value="chat_agent">{businessRoles['chat_agent']?.displayName || 'Chat Agent'}</SelectItem>
            <SelectItem value="supervisor">{businessRoles['supervisor']?.displayName || 'Supervisor'}</SelectItem>
            <SelectItem value="admin">{businessRoles['admin']?.displayName || 'Administrator'}</SelectItem>
          </SelectContent>
        </Select>

        <Select value={statusFilter} onValueChange={onStatusFilterChange}>
          <SelectTrigger className="w-40">
            <SelectValue placeholder="All Status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Status</SelectItem>
            <SelectItem value="active">{businessStatus['active']?.label || 'Active'}</SelectItem>
            <SelectItem value="inactive">{businessStatus['disabled']?.label || 'Inactive'}</SelectItem>
            <SelectItem value="needs_setup">{businessStatus['needs_setup']?.label || 'Needs Setup'}</SelectItem>
          </SelectContent>
        </Select>

        <AdvancedFiltersSheet
          marketFilter={marketFilter}
          onMarketFilterChange={onMarketFilterChange}
          regionFilter={regionFilter}
          onRegionFilterChange={onRegionFilterChange}
          countryFilter={countryFilter}
          onCountryFilterChange={onCountryFilterChange}
          businessUnitFilter={businessUnitFilter}
          onBusinessUnitFilterChange={onBusinessUnitFilterChange}
          onClearAll={handleClearAdvancedFilters}
          regions={regions}
          countries={countries}
          businessUnits={businessUnits}
          isLoading={isLoading}
        />
      </div>
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/ad-groups-pagination.tsx
import { Button } from '../../../ui/button'

/** Props for the AdGroupsPagination component. */
interface AdGroupsPaginationProps {
  /** Current 1-based page index */
  currentPage: number
  /** Total number of available pages */
  totalPages: number
  /** 1-based index of the first item on the current page */
  pageStart: number
  /** 1-based index of the last item on the current page */
  pageEnd: number
  /** Total number of groups across all pages */
  totalCount: number
  /** Callback invoked with the new page number when navigating */
  onPageChange: (page: number) => void
}

/**
 * Previous/Next page navigation with a "Showing X-Y of Z" summary.
 * Automatically hides when there is only a single page.
 */
export function AdGroupsPagination({
  currentPage,
  totalPages,
  pageStart,
  pageEnd,
  totalCount,
  onPageChange
}: Readonly<AdGroupsPaginationProps>) {
  if (totalPages <= 1) return null

  return (
    <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
      <span className="text-sm text-muted-foreground">
        {`Showing ${pageStart}-${pageEnd} of ${totalCount} groups`}
      </span>
      <div className="flex items-center gap-2">
        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(Math.max(1, currentPage - 1))}
          disabled={currentPage === 1}
        >
          Previous
        </Button>
        <span className="text-sm text-muted-foreground">
          {`Page ${currentPage} of ${totalPages}`}
        </span>
        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(Math.min(totalPages, currentPage + 1))}
          disabled={currentPage === totalPages}
        >
          Next
        </Button>
      </div>
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/ad-groups-stats-cards.tsx
import { Card, CardContent, CardHeader, CardTitle } from '../../../ui/card'
import { AlertTriangle, CheckCircle, Users } from 'lucide-react'

/** Props for the AdGroupsStatsCards component. */
interface AdGroupsStatsCardsProps {
  /** Number of AD groups that still need configuration */
  unconfiguredCount: number
  /** Number of AD groups that are fully configured and active */
  activeCount: number
  /** Total number of AD groups across all states */
  totalCount: number
}

/** Displays three summary statistic cards for unconfigured, active, and total AD groups. */
export function AdGroupsStatsCards({ unconfiguredCount, activeCount, totalCount }: Readonly<AdGroupsStatsCardsProps>) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle as="div" className="text-sm font-medium">Needs Configuration</CardTitle>
          <AlertTriangle className="h-4 w-4 text-orange-600" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-orange-700">{unconfiguredCount}</div>
          <p className="text-xs text-muted-foreground">Groups requiring setup</p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle as="div" className="text-sm font-medium">Active Groups</CardTitle>
          <CheckCircle className="h-4 w-4 text-emerald-600" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-emerald-700">{activeCount}</div>
          <p className="text-xs text-muted-foreground">Configured and active</p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle as="div" className="text-sm font-medium">Total Groups</CardTitle>
          <Users className="h-4 w-4 text-slate-600" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-slate-700">{totalCount}</div>
          <p className="text-xs text-muted-foreground">All AD groups</p>
        </CardContent>
      </Card>
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/ad-groups-table-helpers.ts
/**
 * AD Groups Table Helpers
 * Pure functions for table selection state and country name resolution.
 */

import type { CountryDto } from '@/services/api/reference-data.service'

/** Builds a Map from country code (uppercase) to country display name. */
export function buildCountryNameMap(countries: CountryDto[]): Map<string, string> {
  const map = new Map<string, string>()
  countries.forEach(country => {
    map.set(country.countryCode.toUpperCase(), country.countryName)
  })
  return map
}

export interface SelectionState {
  allPageSelected: boolean
  partiallySelected: boolean
}

/** Computes whether all/some items on the current page are selected. */
export function computeSelectionState(
  groups: { id: string }[],
  selectedGroups: Set<string>
): SelectionState {
  const pageGroupIds = groups.map(group => group.id)
  const selectedOnPage = pageGroupIds.filter(id => selectedGroups.has(id))
  const allPageSelected = pageGroupIds.length > 0 && selectedOnPage.length === pageGroupIds.length
  const partiallySelected = selectedOnPage.length > 0 && !allPageSelected
  return { allPageSelected, partiallySelected }
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/ad-groups-table.tsx
import { memo, useMemo } from 'react'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '../../../ui/table'
import { Checkbox } from '../../../ui/checkbox'
import { TooltipProvider } from '../../../ui/tooltip'
import { Users, MapPin } from 'lucide-react'
import { cn } from '../../../../lib/utils'
import { useBusinessRoles, useBusinessStatus } from '@/hooks/features/use-business-terminology'
import type { AdGroup } from '../../../../types/features/ad-group-config'
import type { AdminPermissions } from '../../admin-layout'
import type { CountryDto } from '@/services/api/reference-data.service'
import { BrandLoader } from '@/components/common/brand-loader'
import { AccessLevelBadge, GroupStatusBadge, GroupActionButtons } from './ad-group-table-cells'
import { buildCountryNameMap, computeSelectionState } from './ad-groups-table-helpers'

/** Props for the AdGroupsTable component. */
interface AdGroupsTableProps {
  /** Array of AD groups to display in the table */
  groups: AdGroup[]
  /** Set of selected group IDs for bulk operations */
  selectedGroups: Set<string>
  /** Whether the table data is currently loading */
  loading: boolean
  /** ID of the group currently being saved (shows pulse animation) */
  savingGroupId: string | null
  /** Callback invoked when a group's checkbox is toggled */
  onSelectGroup: (groupId: string) => void
  /** Callback to select all visible groups */
  onSelectAll: () => void
  /** Callback to deselect all visible groups */
  onDeselectAll: () => void
  /** Callback invoked when the configure button is clicked for a group */
  onConfigureGroup: (group: AdGroup) => void
  /** Callback invoked when the enable/disable toggle is clicked */
  onToggleActive: (group: AdGroup) => void
  /** Function to check if a group has all required configuration */
  isConfigured: (group: AdGroup) => boolean
  /** Ref to the scrollable table container for scroll position management */
  tableContainerRef: React.RefObject<HTMLDivElement | null>
  /** Admin permissions controlling which columns and actions are visible */
  permissions: AdminPermissions
  /** Country reference data for resolving country codes to display names */
  countries: CountryDto[]
}

/**
 * Paginated table displaying AD groups with selection checkboxes, role, location,
 * access level, member count, status, and action buttons. Supports scroll position
 * preservation across page navigation and configuration saves.
 */
function AdGroupsTableComponent({
  groups,
  selectedGroups,
  loading,
  savingGroupId,
  onSelectGroup,
  onSelectAll,
  onDeselectAll,
  onConfigureGroup,
  onToggleActive,
  isConfigured,
  tableContainerRef,
  permissions,
  countries
}: Readonly<AdGroupsTableProps>) {
  const businessRoles = useBusinessRoles()
  const businessStatus = useBusinessStatus()

  const countryNameMap = useMemo(() => buildCountryNameMap(countries), [countries])

  // Check if user can configure groups (requires at least one edit permission)
  const canConfigureGroups = permissions.canEditBusinessInfo ||
                            permissions.canEditPermissions ||
                            permissions.canEditApplications

  const { allPageSelected, partiallySelected } = computeSelectionState(groups, selectedGroups)

  return (
    <TooltipProvider delayDuration={150}>
      <div ref={tableContainerRef} className="h-[calc(100dvh-22rem)] min-h-[18rem] overflow-hidden rounded-md border shadow-sm sm:min-h-[20rem]">
        <Table className="w-full min-w-[1080px] table-auto xl:table-fixed">
        <TableHeader>
          <TableRow>
            <TableHead className="w-12 py-3 px-4">
              <Checkbox
                checked={allPageSelected || (partiallySelected ? 'indeterminate' as const : false)}
                onCheckedChange={(checked) => { checked ? onSelectAll() : onDeselectAll() }}
                aria-label="Select all AD groups on this page"
              />
            </TableHead>
            <TableHead className="min-w-[280px] py-3 px-4 whitespace-nowrap xl:w-[35%]">Team Group</TableHead>
            <TableHead className="w-36 py-3 px-4 whitespace-nowrap">Role</TableHead>
            <TableHead className="w-44 py-3 px-4 whitespace-nowrap">Location</TableHead>
            <TableHead className="w-36 py-3 px-4 whitespace-nowrap">Access Level</TableHead>
            <TableHead className="w-28 py-3 px-4 text-center whitespace-nowrap">Members</TableHead>
            <TableHead className="w-32 py-3 px-4 whitespace-nowrap">Status</TableHead>
            <TableHead className="w-32 md:w-40 lg:w-44 py-3 px-4 text-right whitespace-nowrap">Manage</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {loading && (
            <TableRow>
              <TableCell colSpan={8} className="h-32">
                <BrandLoader message="Loading team groups..." />
              </TableCell>
            </TableRow>
          )}
          {!loading && groups.length === 0 && (
            <TableRow>
              <TableCell colSpan={8} className="h-24">
                <div className="flex items-center justify-center">
                  <div className="text-sm text-muted-foreground">
                    No team groups found
                  </div>
                </div>
              </TableCell>
            </TableRow>
          )}
          {!loading && groups.length > 0 && (
            groups.map((group) => (
              <TableRow
                key={group.id}
                className={cn(
                  "hover:bg-gray-50 transition-colors [&>td]:align-top",
                  savingGroupId === group.groupIdentifier && "bg-blue-50 animate-pulse"
                )}
              >
                <TableCell className="py-3 px-4">
                  <Checkbox
                    checked={selectedGroups.has(group.id)}
                    onCheckedChange={() => onSelectGroup(group.id)}
                    aria-label={`Select ${group.logicalName || group.groupIdentifier}`}
                  />
                </TableCell>

                <TableCell className="py-3 px-4">
                  <div className="space-y-1.5">
                    <div className="font-medium leading-snug text-gray-900 break-words">
                      {group.logicalName || 'Unconfigured Group'}
                    </div>
                    <div
                      className="max-w-full text-xs text-muted-foreground font-mono break-all sm:break-normal sm:truncate"
                      title={group.groupIdentifier}
                    >
                      {group.groupIdentifier}
                    </div>
                  </div>
                </TableCell>

                <TableCell className="py-3 px-4">
                  {group.roleName ? (
                    <span className="text-sm font-medium text-gray-900 break-words">
                      {businessRoles[group.roleName]?.displayName || group.roleName}
                    </span>
                  ) : (
                    <span className="text-muted-foreground text-sm">Not set</span>
                  )}
                </TableCell>

                <TableCell className="py-3 px-4">
                  {group.country ? (
                    <div className="flex items-center gap-1.5 text-sm text-gray-900">
                      <MapPin className="h-3.5 w-3.5 text-gray-500" />
                      {countryNameMap.get(group.country.toUpperCase()) ?? group.country}
                    </div>
                  ) : (
                    <span className="text-muted-foreground text-sm">Not set</span>
                  )}
                </TableCell>

                <TableCell className="py-3 px-4">
                  {group.accessLevel ? (
                    <AccessLevelBadge accessLevel={group.accessLevel} />
                  ) : (
                    <span className="text-muted-foreground text-sm">Not set</span>
                  )}
                </TableCell>

                <TableCell className="py-3 px-4 text-center">
                  {group.userCount === undefined ? (
                    <span className="text-muted-foreground text-sm">-</span>
                  ) : (
                    <div className="flex items-center justify-center gap-1 text-sm text-gray-900">
                      <Users className="h-3 w-3" />
                      {group.userCount}
                    </div>
                  )}
                </TableCell>

                <TableCell className="py-3 px-4">
                  <GroupStatusBadge
                    group={group}
                    configured={isConfigured(group)}
                    businessStatus={businessStatus}
                  />
                </TableCell>

                <TableCell className="py-3 px-4 text-right">
                  <GroupActionButtons
                    group={group}
                    permissions={permissions}
                    configured={isConfigured(group)}
                    canConfigureGroups={canConfigureGroups}
                    onToggleActive={onToggleActive}
                    onConfigureGroup={onConfigureGroup}
                  />
                </TableCell>
              </TableRow>
            ))
          )}
        </TableBody>
      </Table>
    </div>
    </TooltipProvider>
  )
}

/** Memoized AD groups table component to prevent unnecessary re-renders. */
export const AdGroupsTable = memo(AdGroupsTableComponent)
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/ad-groups-toggle-dialog.tsx
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '../../../ui/dialog'
import { Button } from '../../../ui/button'
import { ShieldOff, CheckCircle } from 'lucide-react'
import type { AdGroup } from '../../../../types/features/ad-group-config'

/** Props for the AdGroupsToggleDialog component. */
interface AdGroupsToggleDialogProps {
  /** The AD group being toggled, or null when the dialog is closed */
  group: AdGroup | null
  /** Controls dialog visibility */
  open: boolean
  /** Callback to open or close the dialog */
  onOpenChange: (open: boolean) => void
  /** Callback invoked when the user confirms the enable/disable action */
  onConfirm: () => void
}

interface ToggleConfig {
  action: string
  Icon: typeof ShieldOff
  iconClass: string
  warningClass: string
  warningText: string
  buttonVariant: 'destructive' | 'default'
  buttonClass: string
}

const DISABLE_CONFIG: ToggleConfig = {
  action: 'Disable Group',
  Icon: ShieldOff,
  iconClass: 'h-5 w-5 text-red-500',
  warningClass: 'block mt-2 text-orange-600',
  warningText: 'This will prevent users in this group from accessing the system.',
  buttonVariant: 'destructive',
  buttonClass: ''
}

const ENABLE_CONFIG: ToggleConfig = {
  action: 'Enable Group',
  Icon: CheckCircle,
  iconClass: 'h-5 w-5 text-green-500',
  warningClass: 'block mt-2 text-green-600',
  warningText: 'This will allow users in this group to access the system.',
  buttonVariant: 'default',
  buttonClass: 'bg-green-600 hover:bg-green-700'
}

/**
 * Confirmation dialog displayed before enabling or disabling an AD group.
 * Dynamically adapts its title, description, and button styling based on
 * whether the group is currently active or inactive.
 */
export function AdGroupsToggleDialog({ group, open, onOpenChange, onConfirm }: Readonly<AdGroupsToggleDialogProps>) {
  if (!group) return null

  const config = group.isActive ? DISABLE_CONFIG : ENABLE_CONFIG
  const verb = group.isActive ? 'disable' : 'enable'
  const groupName = group.logicalName || group.groupIdentifier

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <config.Icon className={config.iconClass} />
            {config.action}
          </DialogTitle>
          <DialogDescription>
            {`Are you sure you want to ${verb} the group ${groupName}?`}
            <span className={config.warningClass}>{config.warningText}</span>
          </DialogDescription>
        </DialogHeader>
        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button onClick={onConfirm} variant={config.buttonVariant} className={config.buttonClass}>
            {config.action}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/advanced-filters-helpers.ts
/**
 * Advanced Filters Helpers
 * Pure functions for computing active filter counts and building filter chip data.
 */

export interface FilterChipData {
  value: string
  label: string
  onClear: () => void
}

/** Counts the number of active (non-"all") filters. */
export function countActiveFilters(
  regionFilter: string,
  countryFilter: string,
  businessUnitFilter: string
): number {
  return [
    regionFilter === 'all' ? 0 : 1,
    countryFilter === 'all' ? 0 : 1,
    businessUnitFilter === 'all' ? 0 : 1
  ].reduce((sum, val) => sum + val, 0)
}

/** Builds chip data for active filters that can be displayed and cleared individually. */
export function buildFilterChips(
  regionFilter: string,
  countryFilter: string,
  businessUnitFilter: string,
  onRegionClear: () => void,
  onCountryClear: () => void,
  onBusinessUnitClear: () => void
): FilterChipData[] {
  return [
    { value: regionFilter, label: 'Region', onClear: onRegionClear },
    { value: countryFilter, label: 'Country', onClear: onCountryClear },
    { value: businessUnitFilter, label: 'Department', onClear: onBusinessUnitClear }
  ].filter(f => f.value !== 'all')
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/components/advanced-filters-sheet.tsx
import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetTrigger, SheetFooter } from '../../../ui/sheet'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../../../ui/select'
import { Button } from '../../../ui/button'
import { Badge } from '../../../ui/badge'
import { SlidersHorizontal, X } from 'lucide-react'
import { getBusinessField } from '@/hooks/features/use-business-terminology'
import type { RegionDto, BusinessUnitDto, CountryDto } from '@/services/api/reference-data.service'
import { countActiveFilters, buildFilterChips } from './advanced-filters-helpers'

/** Placeholder text shown in dropdowns while reference data is loading. */
const PLACEHOLDER_LOADING = 'Loading...'

/** Props for the AdvancedFiltersSheet component. */
interface AdvancedFiltersSheetProps {
  /** Current market filter value or 'all' */
  marketFilter: string
  /** Callback to update the market filter */
  onMarketFilterChange: (value: string) => void
  /** Current region filter code or 'all' */
  regionFilter: string
  /** Callback to update the region filter */
  onRegionFilterChange: (value: string) => void
  /** Current country filter code or 'all' */
  countryFilter: string
  /** Callback to update the country filter */
  onCountryFilterChange: (value: string) => void
  /** Current business unit filter code or 'all' */
  businessUnitFilter: string
  /** Callback to update the business unit filter */
  onBusinessUnitFilterChange: (value: string) => void
  /** Callback to reset all advanced filters to their default 'all' values */
  onClearAll: () => void
  /** Available region reference data for the region dropdown */
  regions: RegionDto[]
  /** Available country reference data for the country dropdown */
  countries: CountryDto[]
  /** Available business unit reference data for the department dropdown */
  businessUnits: BusinessUnitDto[]
  /** Whether reference data is still loading from the API */
  isLoading: boolean
}

/**
 * Slide-out sheet providing advanced filtering options (region, country,
 * department) that complement the main filter bar. Displays active filter
 * count on its trigger button and allows individual or bulk filter clearing.
 */
export function AdvancedFiltersSheet(props: Readonly<AdvancedFiltersSheetProps>) {
  const {
    regionFilter,
    onRegionFilterChange,
    countryFilter,
    onCountryFilterChange,
    businessUnitFilter,
    onBusinessUnitFilterChange,
    onClearAll,
    regions,
    businessUnits,
    countries,
    isLoading
  } = props

  const activeFilterCount = countActiveFilters(regionFilter, countryFilter, businessUnitFilter)

  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button variant="outline" size="sm" className="relative">
          <SlidersHorizontal className="h-4 w-4 mr-2" />
          More Filters
          {activeFilterCount > 0 && (
            <Badge
              variant="default"
              className="ml-2 h-5 min-w-5 rounded-full px-1.5 text-xs"
            >
              {activeFilterCount}
            </Badge>
          )}
        </Button>
      </SheetTrigger>
      <SheetContent side="right" className="w-full sm:max-w-md">
        <SheetHeader>
          <SheetTitle>Advanced Filters</SheetTitle>
        </SheetHeader>

        <div className="mt-6 space-y-4">
          {/* Active Filters Chips */}
          {activeFilterCount > 0 && (
            <div className="pb-4 border-b">
              <p className="text-sm font-medium mb-2">Active Filters</p>
              <div className="flex flex-wrap gap-2">
                {buildFilterChips(
                  regionFilter, countryFilter, businessUnitFilter,
                  () => onRegionFilterChange('all'),
                  () => onCountryFilterChange('all'),
                  () => onBusinessUnitFilterChange('all')
                ).map(f => (
                    <Badge key={f.label} variant="secondary" className="gap-1">
                      {f.label}: {f.value}
                      <button onClick={f.onClear} className="ml-1 hover:text-destructive">
                        <X className="h-3 w-3" />
                      </button>
                    </Badge>
                  ))}
              </div>
            </div>
          )}

          {/* Filter Dropdowns */}
          <div className="space-y-4">
            {/* Market filter hidden - currently redundant with Country
            <div>
              <label className="text-sm font-medium mb-2 block">Market</label>
              <Select value={marketFilter} onValueChange={onMarketFilterChange} disabled={isLoading}>
                <SelectTrigger className="w-full">
                  <SelectValue placeholder={isLoading ? PLACEHOLDER_LOADING : 'All Markets'} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Markets</SelectItem>
                  {countries.map((country) => (
                    <SelectItem key={country.countryCode} value={country.countryName}>
                      {country.countryName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            */}

            <div>
              <label htmlFor="filter-region" className="text-sm font-medium mb-2 block">Region</label>
              <Select value={regionFilter} onValueChange={onRegionFilterChange} disabled={isLoading}>
                <SelectTrigger id="filter-region" className="w-full">
                  <SelectValue placeholder={isLoading ? PLACEHOLDER_LOADING : 'All Regions'} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">{getBusinessField('allRegions')}</SelectItem>
                  {regions.map((region) => (
                    <SelectItem key={region.regionCode} value={region.regionCode}>
                      {region.regionName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div>
              <label htmlFor="filter-country" className="text-sm font-medium mb-2 block">Country</label>
              <Select value={countryFilter} onValueChange={onCountryFilterChange} disabled={isLoading}>
                <SelectTrigger id="filter-country" className="w-full">
                  <SelectValue placeholder={isLoading ? PLACEHOLDER_LOADING : 'All Countries'} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">{getBusinessField('allCountries')}</SelectItem>
                  {countries.map((country) => (
                    <SelectItem key={country.countryCode} value={country.countryCode}>
                      {country.countryName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div>
              <label htmlFor="filter-department" className="text-sm font-medium mb-2 block">Department</label>
              <Select value={businessUnitFilter} onValueChange={onBusinessUnitFilterChange} disabled={isLoading}>
                <SelectTrigger id="filter-department" className="w-full">
                  <SelectValue placeholder={isLoading ? PLACEHOLDER_LOADING : 'All Departments'} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">{getBusinessField('allBusinessUnits')}</SelectItem>
                  {businessUnits.map((unit) => (
                    <SelectItem key={unit.unitCode} value={unit.unitCode}>
                      {unit.unitName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>

        <SheetFooter className="mt-6 pt-6 border-t">
          <Button
            variant="outline"
            onClick={onClearAll}
            disabled={activeFilterCount === 0}
          >
            Clear All
          </Button>
        </SheetFooter>
      </SheetContent>
    </Sheet>
  )
}
===ENDFILE

===FILE: src/components/admin/ad-groups-view/index.ts
export { AdGroupsView } from './ad-groups-view'
===ENDFILE

===FILE: src/components/admin/admin-layout-helpers.ts
/**
 * Admin Layout Helpers
 * Pure functions for admin view resolution and sidebar state management.
 */

import type { AdminPermissions } from './admin-layout'

export type AdminView = 'ad-groups' | 'pending-approvals' | 'notices'

export const ADMIN_VIEW_STORAGE_KEY = 'admin-active-view'
export const ADMIN_SIDEBAR_COLLAPSED_KEY = 'admin-sidebar-collapsed'

const VIEW_PERMISSION_MAP: Array<[AdminView, keyof AdminPermissions]> = [
  ['ad-groups', 'canViewAdGroups'],
  ['pending-approvals', 'canViewPendingApprovals'],
  ['notices', 'canViewNotices']
]

/** Resolves the list of available admin views based on the user's permissions. */
export function resolveAvailableViews(permissions: AdminPermissions): AdminView[] {
  return VIEW_PERMISSION_MAP
    .filter(([, permKey]) => permissions[permKey])
    .map(([view]) => view)
}

/** Resolves the initial view from local storage, falling back to the first available view. */
export function resolveInitialView(saved: AdminView | null, availableViews: AdminView[]): AdminView | null {
  if (saved && availableViews.includes(saved)) {
    return saved
  }
  return availableViews[0] ?? null
}

/** Ensures the active view is still in the available set, falling back to the first available. */
export function resolveActiveView(activeView: AdminView | null, availableViews: AdminView[]): AdminView | null {
  if (activeView && availableViews.includes(activeView)) {
    return activeView
  }
  return availableViews[0] ?? null
}

/** Reads the saved sidebar collapsed state from localStorage. */
export function getSavedSidebarCollapsed(): boolean {
  if (globalThis.window === undefined) return false
  return localStorage.getItem(ADMIN_SIDEBAR_COLLAPSED_KEY) === 'true'
}
===ENDFILE

===FILE: src/components/admin/admin-layout.tsx
import { lazy, Suspense, useEffect, useMemo, useState } from 'react'
import { AdminSidebar } from './admin-sidebar'
import { BrandLoader } from '@/components/common/brand-loader'
import { Button } from '../ui/button'
import { Sheet, SheetContent, SheetDescription, SheetHeader, SheetTitle } from '../ui/sheet'
import { Menu } from 'lucide-react'
import {
  type AdminView,
  ADMIN_VIEW_STORAGE_KEY,
  ADMIN_SIDEBAR_COLLAPSED_KEY,
  resolveAvailableViews,
  resolveInitialView,
  resolveActiveView,
  getSavedSidebarCollapsed
} from './admin-layout-helpers'

export type { AdminView } from './admin-layout-helpers'
export { resolveAvailableViews, resolveInitialView, resolveActiveView } from './admin-layout-helpers'

const AdGroupsView = lazy(() =>
  import('./ad-groups-view').then((m) => ({ default: m.AdGroupsView }))
)
const PendingApprovalsView = lazy(() =>
  import('./pending-approvals-view/pending-approvals-view').then((m) => ({ default: m.PendingApprovalsView }))
)
const NoticeManagementView = lazy(() =>
  import('./views/notice-management-view').then((m) => ({ default: m.NoticeManagementView }))
)

/**
 * Mirrors the host-side admin capability surface so the host app can pass
 * permissions directly via props rather than the MFE fetching them independently.
 */
export interface AdminPermissions {
  /** Whether the user can preview role-based dashboard layouts */
  canPreviewDashboards: boolean
  /** Whether the user can view the role templates section */
  canViewRoleTemplates: boolean
  /** Whether the user can view the AD groups management section */
  canViewAdGroups: boolean
  /** Whether the user can view the pending approvals section */
  canViewPendingApprovals: boolean
  /** Whether the user can approve or reject pending changes */
  canApproveChanges: boolean
  /** Whether the user can edit AD group business information */
  canEditBusinessInfo: boolean
  /** Whether the user can modify AD group permission overrides */
  canEditPermissions: boolean
  /** Whether the user can assign embedded applications to AD groups */
  canEditApplications: boolean
  /** Whether the user can enable or disable AD groups */
  canEnableDisableGroups: boolean
  /** Whether the user can save changes directly without approval (super admin) */
  canDirectSave: boolean
  /** Whether the user can view the system notices section */
  canViewNotices: boolean
  /** Whether the user can create new system notices */
  canCreateNotice: boolean
  /** Whether the user can edit existing draft notices */
  canEditNotice: boolean
  /** Whether the user can publish draft notices to active status */
  canPublishNotice: boolean
  /** Whether the user can archive active notices */
  canArchiveNotice: boolean
  /** Whether the user can save notice drafts */
  canSaveDraft: boolean
}

/** Props for the AdminLayout component. */
interface AdminLayoutProps {
  /** Full set of admin permissions for the current user */
  permissions: AdminPermissions
  /** The current user's role code (e.g., 'admin', 'super_admin') */
  currentRole: string
}

/**
 * Renders the appropriate admin view component based on the selected navigation item.
 * @param view - The currently active admin view
 * @param permissions - Admin permissions passed through to child views
 * @param _currentRole - The current user's role (reserved for future use)
 * @returns The React element for the selected view
 */
function renderAdminView(view: AdminView, permissions: AdminPermissions, _currentRole: string) {
  switch (view) {
    case 'ad-groups':
      return <AdGroupsView permissions={permissions} />
    case 'pending-approvals':
      return <PendingApprovalsView permissions={permissions} />
    case 'notices':
      return <NoticeManagementView permissions={permissions} />
    default:
      return <AdGroupsView permissions={permissions} />
  }
}

/**
 * Root layout for the admin panel. Manages sidebar navigation, view switching,
 * and mobile-responsive navigation via a slide-out sheet.
 */
export function AdminLayout({ permissions, currentRole }: Readonly<AdminLayoutProps>) {
  const availableViews = useMemo(
    () => resolveAvailableViews(permissions),
    [
      permissions.canViewAdGroups,
      permissions.canViewNotices,
      permissions.canViewPendingApprovals
    ]
  )

  const getInitialView = (): AdminView | null => {
    const saved = localStorage.getItem(ADMIN_VIEW_STORAGE_KEY) as AdminView | null
    return resolveInitialView(saved, availableViews)
  }

  const [activeView, setActiveView] = useState<AdminView | null>(getInitialView)
  const [sidebarCollapsed, setSidebarCollapsed] = useState<boolean>(getSavedSidebarCollapsed)
  const [mobileNavOpen, setMobileNavOpen] = useState(false)

  useEffect(() => {
    const nextView = resolveActiveView(activeView, availableViews)
    if (nextView === activeView) {
      return
    }

    setActiveView(nextView)

    if (nextView) {
      localStorage.setItem(ADMIN_VIEW_STORAGE_KEY, nextView)
      return
    }

    localStorage.removeItem(ADMIN_VIEW_STORAGE_KEY)
  }, [activeView, availableViews])

  const handleViewChange = (view: AdminView) => {
    setActiveView(view)
    localStorage.setItem(ADMIN_VIEW_STORAGE_KEY, view)
    setMobileNavOpen(false)
  }

  const handleSidebarToggle = () => {
    setSidebarCollapsed((previous) => {
      const next = !previous
      localStorage.setItem(ADMIN_SIDEBAR_COLLAPSED_KEY, String(next))
      return next
    })
  }

  if (!activeView) {
    return (
      <div className="flex h-screen items-center justify-center bg-background">
        <p className="text-lg text-muted-foreground">No admin access configured for your account</p>
      </div>
    )
  }

  return (
    <div className="flex h-full min-h-0 w-full overflow-hidden bg-background">
      <div className="hidden h-full lg:block">
        <AdminSidebar
          activeView={activeView}
          onViewChange={handleViewChange}
          permissions={permissions}
          collapsed={sidebarCollapsed}
          onToggleCollapse={handleSidebarToggle}
        />
      </div>
      <main className="flex-1 min-h-0 overflow-y-auto bg-background scrollbar-visible">
        <div className="sticky top-0 z-20 border-b bg-background/95 px-4 py-3 backdrop-blur supports-[backdrop-filter]:bg-background/75 lg:hidden">
          <Button
            variant="outline"
            size="sm"
            onClick={() => setMobileNavOpen(true)}
            className="gap-2"
          >
            <Menu className="h-4 w-4" />
            Navigation
          </Button>
        </div>

        <div className="p-4 sm:p-6">
          <Suspense
            fallback={
              <div className="flex min-h-[260px] items-center justify-center">
                <BrandLoader />
              </div>
            }
          >
            {renderAdminView(activeView, permissions, currentRole)}
          </Suspense>
        </div>
      </main>

      <Sheet open={mobileNavOpen} onOpenChange={setMobileNavOpen}>
        <SheetContent side="left" className="w-[300px] overflow-y-auto p-0 scrollbar-visible sm:w-[320px]">
          <SheetHeader className="sr-only">
            <SheetTitle>Navigation</SheetTitle>
            <SheetDescription>
              Switch between admin sections
            </SheetDescription>
          </SheetHeader>
          <AdminSidebar
            activeView={activeView}
            onViewChange={handleViewChange}
            permissions={permissions}
            mobile
          />
        </SheetContent>
      </Sheet>
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/admin-screen.tsx
import { AdminLayout } from './admin-layout'
import type { AdminPermissions } from './admin-layout'

/** Props for the AdminScreen entry-point component. */
interface AdminScreenProps {
  /** Full set of admin permissions for the current user */
  permissions: AdminPermissions
  /** The current user's role code */
  currentRole: string
}

/**
 * Entry-point component that wraps AdminLayout. Serves as the top-level
 * component rendered by the host application for the admin panel.
 */
export function AdminScreen({ permissions, currentRole }: Readonly<AdminScreenProps>) {
  return <AdminLayout permissions={permissions} currentRole={currentRole} />
}
===ENDFILE

===FILE: src/components/admin/admin-sidebar.tsx
import { type ComponentType, useMemo } from 'react'
import { cn } from '../../lib/utils'
import { Button } from '../ui/button'
import { Badge } from '../ui/badge'
import { Bell, ChevronLeft, ChevronRight, ClipboardCheck, Users } from 'lucide-react'
import { usePendingChangesCount } from '../../hooks/admin/use-pending-changes'
import type { AdminPermissions, AdminView } from './admin-layout'

/** Props for the AdminSidebar navigation component. */
interface AdminSidebarProps {
  /** The currently selected admin view */
  activeView: AdminView
  /** Callback invoked when the user clicks a navigation item */
  onViewChange: (view: AdminView) => void
  /** Admin permissions controlling which navigation items are visible */
  permissions: AdminPermissions
  /** Whether the sidebar is in collapsed (icon-only) mode */
  collapsed?: boolean
  /** Callback to toggle the sidebar collapsed state */
  onToggleCollapse?: () => void
  /** Whether the sidebar is rendered inside a mobile sheet */
  mobile?: boolean
}

/** Definition of a single navigation item in the admin sidebar. */
interface NavItem {
  /** Unique view identifier */
  id: AdminView
  /** Display label for the navigation item */
  label: string
  /** Lucide icon component for visual representation */
  icon: ComponentType<{ className?: string }>
  /** Short description text displayed below the label */
  description: string
  /** Optional badge count (e.g., pending approvals) */
  badgeCount?: number
}

/**
 * Returns the appropriate Tailwind width class for the sidebar based on display mode.
 * @param mobile - Whether the sidebar is in mobile mode
 * @param collapsed - Whether the sidebar is collapsed to icon-only
 * @returns Tailwind class string for width and height
 */
function getSidebarWidthClass(mobile: boolean, collapsed: boolean): string {
  if (mobile) return 'h-full w-full'
  return collapsed ? 'h-full w-20' : 'h-full w-72'
}

function formatBadgeCount(count: number): string {
  return count > 99 ? '99+' : String(count)
}

function NavBadge({ count }: Readonly<{ count?: number }>) {
  if (!count || count <= 0) return null
  return (
    <Badge variant="secondary" className="bg-red-100 text-red-700">
      {formatBadgeCount(count)}
    </Badge>
  )
}

function NavButtonLabel({ item, compact }: Readonly<{ item: NavItem; compact: boolean }>) {
  if (compact) return <span className="sr-only">{item.label}</span>
  return (
    <>
      <span className="flex-1">
        <span className="block text-sm font-semibold">{item.label}</span>
        <span className="block text-xs text-muted-foreground">{item.description}</span>
      </span>
      <NavBadge count={item.badgeCount} />
    </>
  )
}

function NavButton({ item, isActive, compact, onViewChange }: Readonly<{
  item: NavItem
  isActive: boolean
  compact: boolean
  onViewChange: (view: AdminView) => void
}>) {
  const Icon = item.icon
  return (
    <Button
      variant="ghost"
      onClick={() => onViewChange(item.id)}
      title={compact ? item.label : undefined}
      aria-label={item.label}
      className={cn(
        'h-auto w-full rounded-lg border border-transparent text-left',
        compact ? 'items-center justify-center px-2 py-3' : 'items-start justify-start gap-3 px-3 py-3',
        isActive && 'border-red-200 bg-red-50 text-red-700'
      )}
    >
      <Icon className={cn('h-4 w-4 shrink-0', compact ? '' : 'mt-0.5')} />
      <NavButtonLabel item={item} compact={compact} />
    </Button>
  )
}

/** Renders the collapse/expand toggle button in the sidebar header. */
function SidebarCollapseToggle({ collapsed, onToggle }: Readonly<{ collapsed: boolean; onToggle: () => void }>) {
  return (
    <div className="flex items-center justify-end">
      <Button
        variant="ghost"
        size="icon"
        onClick={onToggle}
        aria-label={collapsed ? 'Expand navigation' : 'Collapse navigation'}
      >
        {collapsed ? <ChevronRight className="h-4 w-4" /> : <ChevronLeft className="h-4 w-4" />}
      </Button>
    </div>
  )
}

/** Internal sidebar content renderer that builds navigation items from permissions. */
function AdminSidebarContent({
  activeView,
  onViewChange,
  permissions,
  collapsed = false,
  onToggleCollapse,
  mobile = false
}: Readonly<AdminSidebarProps>) {
  const {
    canViewAdGroups,
    canViewPendingApprovals,
    canViewNotices
  } = permissions

  // Get pending changes count for badge
  const { data: pendingCount } = usePendingChangesCount(canViewPendingApprovals)
  const totalPending = pendingCount?.total ?? 0

  const navItems: NavItem[] = useMemo(() => {
    const allItems: Array<NavItem & { visible: boolean }> = [
      { id: 'ad-groups', label: 'AD Groups', icon: Users, description: 'Manage Permissions', visible: canViewAdGroups },
      { id: 'pending-approvals', label: 'Pending Approvals', icon: ClipboardCheck, description: 'Review Changes', badgeCount: totalPending, visible: canViewPendingApprovals },
      { id: 'notices', label: 'System Notices', icon: Bell, description: 'Broadcast Messages', visible: canViewNotices }
    ]
    return allItems.filter(item => item.visible)
  }, [canViewAdGroups, canViewNotices, canViewPendingApprovals, totalPending])

  return (
    <aside
      className={cn(
        'border-r bg-gradient-to-b from-background to-muted/10 transition-[width] duration-200',
        getSidebarWidthClass(mobile, collapsed)
      )}
      aria-label="Admin navigation"
    >
      <div className={cn('border-b p-3', 'min-h-[56px]')}>
        {!mobile && onToggleCollapse && (
          <SidebarCollapseToggle collapsed={collapsed} onToggle={onToggleCollapse} />
        )}
      </div>
      <nav className="space-y-2 overflow-y-auto p-3 scrollbar-visible">
        {navItems.map((item) => (
          <NavButton
            key={item.id}
            item={item}
            isActive={activeView === item.id}
            compact={collapsed && !mobile}
            onViewChange={onViewChange}
          />
        ))}
      </nav>
    </aside>
  )
}

/** Admin sidebar navigation component supporting collapsed and mobile display modes. */
export function AdminSidebar({
  activeView,
  onViewChange,
  permissions,
  collapsed,
  onToggleCollapse,
  mobile
}: Readonly<AdminSidebarProps>) {
  return (
    <AdminSidebarContent
      activeView={activeView}
      onViewChange={onViewChange}
      permissions={permissions}
      collapsed={collapsed}
      onToggleCollapse={onToggleCollapse}
      mobile={mobile}
    />
  )
}
===ENDFILE

===FILE: src/components/admin/app-card.tsx
import { Card, CardContent } from '../ui/card'
import { Badge } from '../ui/badge'
import { CheckCircle, Package } from 'lucide-react'
import { cn } from '../../lib/utils'
import { EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'

/** Props for the AppCard component. */
interface AppCardProps {
  /** The embedded application to display */
  app: EmbeddedAppWithStatus
  /** Whether this card is currently selected */
  selected: boolean
  /** Callback invoked when the card is clicked */
  onClick: () => void
}

/**
 * Displays an embedded application as a selectable card with title, description,
 * category badge, and assignment status indicator.
 */
export function AppCard({ app, selected, onClick }: Readonly<AppCardProps>) {
  return (
    <Card
      className={cn(
        "cursor-pointer transition-all duration-200 hover:shadow-md",
        selected
          ? "border-blue-500 bg-blue-50 ring-2 ring-blue-200 shadow-sm"
          : "border-gray-200 hover:bg-gray-50"
      )}
      onClick={onClick}
    >
      <CardContent className="p-4">
        <div className="flex items-start justify-between">
          <div className="flex items-start gap-3 flex-1">
            <div className={cn(
              "p-2 rounded-lg flex-shrink-0",
              selected ? "bg-blue-100" : "bg-gray-100"
            )}>
              <Package className={cn(
                "h-5 w-5",
                selected ? "text-blue-600" : "text-gray-600"
              )} />
            </div>

            <div className="flex-1 min-w-0">
              <div className="flex items-center gap-2 mb-1">
                <h3 className="font-medium text-sm text-gray-900 truncate">
                  {app.titleText}
                </h3>
                {app.isAssignedIndicator && (
                  <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
                )}
              </div>

              <p className="text-xs text-gray-600 line-clamp-2 mb-2">
                {app.descriptionText}
              </p>

              <div className="flex items-center gap-2">
                <Badge
                  variant="secondary"
                  className="text-xs bg-gray-100 text-gray-700 hover:bg-gray-100"
                >
                  {app.categoryName}
                </Badge>

                {app.isAssignedIndicator && (
                  <Badge
                    variant="secondary"
                    className="text-xs bg-green-100 text-green-700 hover:bg-green-100"
                  >
                    {app.assignedFunctionKeys.length === 1 ? `${app.assignedFunctionKeys.length} feature` : `${app.assignedFunctionKeys.length} features`}
                  </Badge>
                )}
              </div>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
===ENDFILE

===FILE: src/components/admin/bulk-copy-confirmation-dialog.tsx
/**
 * Bulk Copy Confirmation Dialog
 * Confirmation dialog for bulk copy operations showing source, targets,
 * and copy options (sections, workflow mode, mismatch policy).
 */

import { Button } from '../ui/button'
import { Checkbox } from '../ui/checkbox'
import { Label } from '../ui/label'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle
} from '../ui/dialog'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from '../ui/select'
import type { AdGroup } from '../../types/features/ad-group-config'
import type { BulkCopyExecutionOptions } from '../../hooks/admin/use-ad-groups-selection'

/** Renders the source group info card showing the group name and identifier. */
function CopyConfirmationSource({ group }: Readonly<{ group: AdGroup | null }>) {
  if (!group) return null
  return (
    <div className="border rounded-md p-4">
      <p className="text-sm font-semibold text-muted-foreground">Source group</p>
      <p className="mt-1 text-sm font-medium">
        {group.logicalName || group.groupIdentifier || 'Unknown group'}
      </p>
      {group.groupIdentifier && (
        <p className="text-xs text-muted-foreground mt-1 font-mono">
          {group.groupIdentifier}
        </p>
      )}
    </div>
  )
}

/** Renders a scrollable list of target groups that will receive the copied configuration. */
function CopyConfirmationTargets({ targets, count }: Readonly<{ targets: AdGroup[]; count: number }>) {
  return (
    <div className="border rounded-md p-4 max-h-48 overflow-y-auto">
      <p className="text-sm font-semibold text-muted-foreground">
        {`Target groups (${count})`}
      </p>
      <ul className="mt-2 space-y-1 text-sm">
        {targets.length === 0 ? (
          <li className="text-muted-foreground text-xs">No groups selected.</li>
        ) : (
          targets.map(group => (
            <li key={group.id} className="flex flex-col">
              <span className="font-medium">{group.logicalName || 'Unconfigured Group'}</span>
              <span className="text-xs text-muted-foreground font-mono">{group.groupIdentifier}</span>
            </li>
          ))
        )}
      </ul>
    </div>
  )
}

/** Returns true if at least one copy section checkbox is selected. */
function hasAnyCopySection(options: BulkCopyExecutionOptions): boolean {
  return options.copyRoleAndPermissionsFlag
    || options.copyBusinessInfoFlag
    || options.copyApplicationsFlag
}

/** Props for the BulkCopyConfirmationDialog component. */
interface BulkCopyConfirmationDialogProps {
  /** Controls dialog visibility */
  open: boolean
  /** The AD group whose configuration will be copied */
  sourceGroup: AdGroup | null
  /** Array of AD groups that will receive the copied configuration */
  targetGroups: AdGroup[]
  /** Total number of target groups (may differ from array length if paginated) */
  targetCount: number
  /** Current copy option selections (sections, workflow, mismatch policy) */
  copyOptions: BulkCopyExecutionOptions
  /** Callback to update copy options via an updater function */
  onCopyOptionsChange: (updater: (prev: BulkCopyExecutionOptions) => BulkCopyExecutionOptions) => void
  /** Whether the copy operation is currently in progress */
  isProcessing: boolean
  /** Callback to execute the bulk copy operation */
  onConfirm: () => Promise<void>
  /** Callback to close the dialog without copying */
  onCancel: () => void
}

/**
 * Confirmation dialog for bulk copy operations. Shows source and target
 * groups, allows selecting which sections to copy (role/permissions,
 * business info, applications), and configures compliance workflow and
 * function mismatch policy.
 */
export function BulkCopyConfirmationDialog({
  open,
  sourceGroup,
  targetGroups,
  targetCount,
  copyOptions,
  onCopyOptionsChange,
  isProcessing,
  onConfirm,
  onCancel
}: Readonly<BulkCopyConfirmationDialogProps>) {
  const hasAtLeastOneCopySection = hasAnyCopySection(copyOptions)

  return (
    <Dialog open={open} onOpenChange={(isOpen) => {
      if (!isOpen) onCancel()
    }}>
      <DialogContent className="max-w-lg">
        <DialogHeader>
          <DialogTitle>Confirm bulk copy</DialogTitle>
          <DialogDescription>
            Review the source and target groups before copying configuration.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-2">
          <CopyConfirmationSource group={sourceGroup} />
          <CopyConfirmationTargets targets={targetGroups} count={targetCount} />

          <p className="text-xs text-muted-foreground">
            This action copies role, permission, location metadata, and embedded app settings. Existing configurations in the selected groups will be overwritten.
          </p>

          <div className="border rounded-md p-4 space-y-4">
            <p className="text-sm font-semibold text-muted-foreground">
              Copy options
            </p>

            <div className="space-y-2">
              <div className="flex items-center gap-2">
                <Checkbox
                  id="copy-role-permissions"
                  checked={copyOptions.copyRoleAndPermissionsFlag}
                  onCheckedChange={(checked) => onCopyOptionsChange(prev => ({
                    ...prev,
                    copyRoleAndPermissionsFlag: Boolean(checked)
                  }))}
                />
                <Label htmlFor="copy-role-permissions" className="text-sm">
                  Role and permission settings
                </Label>
              </div>

              <div className="flex items-center gap-2">
                <Checkbox
                  id="copy-business-info"
                  checked={copyOptions.copyBusinessInfoFlag}
                  onCheckedChange={(checked) => onCopyOptionsChange(prev => ({
                    ...prev,
                    copyBusinessInfoFlag: Boolean(checked)
                  }))}
                />
                <Label htmlFor="copy-business-info" className="text-sm">
                  Business information
                </Label>
              </div>

              <div className="flex items-center gap-2">
                <Checkbox
                  id="copy-applications"
                  checked={copyOptions.copyApplicationsFlag}
                  onCheckedChange={(checked) => onCopyOptionsChange(prev => ({
                    ...prev,
                    copyApplicationsFlag: Boolean(checked)
                  }))}
                />
                <Label htmlFor="copy-applications" className="text-sm">
                  Applications and functions
                </Label>
              </div>
            </div>

            <div className="space-y-2">
              <Label className="text-sm">Compliance workflow</Label>
              <Select
                value={copyOptions.copyWorkflowModeCode}
                onValueChange={(value: BulkCopyExecutionOptions['copyWorkflowModeCode']) => onCopyOptionsChange(prev => ({
                  ...prev,
                  copyWorkflowModeCode: value
                }))}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="SUBMIT_FOR_APPROVAL">Submit for approval (recommended)</SelectItem>
                  <SelectItem value="DIRECT_SAVE">Direct save (bypass approval)</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label className="text-sm">Cross-market function mismatch</Label>
              <Select
                value={copyOptions.functionMismatchPolicyCode}
                onValueChange={(value: BulkCopyExecutionOptions['functionMismatchPolicyCode']) => onCopyOptionsChange(prev => ({
                  ...prev,
                  functionMismatchPolicyCode: value
                }))}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="FAIL_ON_MISMATCH">Fail if function unavailable</SelectItem>
                  <SelectItem value="SKIP_UNAVAILABLE">Skip unavailable functions</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {!hasAtLeastOneCopySection && (
              <p className="text-xs text-red-600">Select at least one section to copy.</p>
            )}
          </div>
        </div>

        <DialogFooter>
          <Button
            variant="outline"
            onClick={onCancel}
            disabled={isProcessing}
          >
            Cancel
          </Button>
          <Button
            onClick={onConfirm}
            disabled={isProcessing || targetCount === 0 || !hasAtLeastOneCopySection}
          >
            {isProcessing ? 'Copying...' : 'Confirm copy'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE

===FILE: src/components/admin/bulk-operations-helpers.ts
/**
 * Bulk Operations Helpers
 * Pure functions for bulk operation state computations and target group resolution.
 */

import type { AdGroup } from '../../types/features/ad-group-config'
import type { BulkCopyExecutionOptions } from '../../hooks/admin/use-ad-groups-selection'

/** Returns the default execution options for a bulk copy operation. */
export function getDefaultCopyOptions(): BulkCopyExecutionOptions {
  return {
    copyRoleAndPermissionsFlag: true,
    copyBusinessInfoFlag: true,
    copyApplicationsFlag: true,
    copyWorkflowModeCode: 'SUBMIT_FOR_APPROVAL',
    functionMismatchPolicyCode: 'FAIL_ON_MISMATCH'
  }
}

/** Resolves pending target groups from IDs using the available groups lookup. */
export function resolvePendingTargetGroups(
  pendingTargetIds: string[],
  allAdGroups: AdGroup[]
): AdGroup[] {
  if (!pendingTargetIds.length) {
    return []
  }
  const lookup = new Map(allAdGroups.map(group => [group.id, group]))
  return pendingTargetIds
    .map(id => lookup.get(id))
    .filter((group): group is AdGroup => Boolean(group))
}
===ENDFILE

===FILE: src/components/admin/bulk-operations-toolbar.tsx
import { useMemo, useState, memo } from 'react'
import { cn } from '../../lib/utils'
import {
  Copy,
  CheckSquare,
  Square,
  MinusSquare,
  X
} from 'lucide-react'
import { Button } from '../ui/button'
import { Badge } from '../ui/badge'
import { CopySourceSelectionModal } from './copy-source-selection-modal'
import { BulkCopyConfirmationDialog } from './bulk-copy-confirmation-dialog'
import { AdGroup } from '../../types/features/ad-group-config'
import type { BulkCopyExecutionOptions } from '../../hooks/admin/use-ad-groups-selection'
import { getDefaultCopyOptions, resolvePendingTargetGroups } from './bulk-operations-helpers'

/** Renders the appropriate checkbox icon based on the current selection state. */
function SelectionIcon({ isAllSelected, isPartiallySelected }: Readonly<{ isAllSelected: boolean; isPartiallySelected: boolean }>) {
  if (isAllSelected) return <CheckSquare className="h-5 w-5 text-primary" />
  if (isPartiallySelected) return <MinusSquare className="h-5 w-5 text-primary" />
  return <Square className="h-5 w-5" />
}

/** Props for the BulkOperationsToolbar component. */
interface BulkOperationsToolbarProps {
  /** Total number of selected groups across all pages */
  selectedCount: number
  /** Number of selected groups visible on the current page */
  selectedVisibleCount: number
  /** Total number of groups across all pages */
  totalCount: number
  /** Number of groups visible on the current page */
  visibleCount: number
  /** Array of selected group identifiers */
  selectedGroups: string[]
  /** All available AD groups for the copy-from source picker */
  allAdGroups: AdGroup[]
  /** Callback to select all visible groups */
  onSelectAll: () => void
  /** Callback to clear all selections */
  onDeselectAll: () => void
  /** Callback to execute a bulk copy from a source group to target groups */
  onCopyFrom: (
    sourceGroup: AdGroup,
    targetGroupIds: string[],
    options: BulkCopyExecutionOptions
  ) => Promise<void>
  /** Callback to search for AD groups by query string */
  onSearchAdGroups: (query: string) => Promise<AdGroup[]>
  /** Whether the group lookup is currently loading */
  isLookupLoading?: boolean
  /** Optional additional CSS class names */
  className?: string
}

/**
 * Sticky toolbar shown when one or more AD groups are selected.
 * Provides bulk operations like "Copy From Another Group" with a confirmation dialog.
 */
function BulkOperationsToolbarComponent({
  selectedCount,
  selectedVisibleCount,
  totalCount,
  visibleCount,
  selectedGroups,
  allAdGroups,
  onSelectAll,
  onDeselectAll,
  onCopyFrom,
  onSearchAdGroups,
  isLookupLoading = false,
  className
}: Readonly<BulkOperationsToolbarProps>) {
  const [showCopyModal, setShowCopyModal] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)
  const [showConfirmation, setShowConfirmation] = useState(false)
  const [selectedSourceGroup, setSelectedSourceGroup] = useState<AdGroup | null>(null)
  const [pendingTargetIds, setPendingTargetIds] = useState<string[]>([])
  const [copyExecutionOptions, setCopyExecutionOptions] = useState<BulkCopyExecutionOptions>(getDefaultCopyOptions)

  const isPartiallySelected = selectedVisibleCount > 0 && selectedVisibleCount < visibleCount
  const isAllSelected = selectedVisibleCount === visibleCount && visibleCount > 0

  const pendingTargetGroups = useMemo(
    () => resolvePendingTargetGroups(pendingTargetIds, allAdGroups),
    [pendingTargetIds, allAdGroups]
  )

  const handleSelectToggle = () => {
    if (isAllSelected) {
      onDeselectAll()
    } else {
      onSelectAll()
    }
  }

  const resetConfirmationState = () => {
    setShowConfirmation(false)
    setSelectedSourceGroup(null)
    setPendingTargetIds([])
  }

  const handleCopyFromSource = (sourceGroup: AdGroup) => {
    setPendingTargetIds(selectedGroups)
    setSelectedSourceGroup(sourceGroup)
    setShowCopyModal(false)
    setShowConfirmation(true)
  }

  const handleConfirmCopy = async () => {
    if (!selectedSourceGroup || pendingTargetIds.length === 0) {
      resetConfirmationState()
      return
    }

    setIsProcessing(true)
    try {
      await onCopyFrom(selectedSourceGroup, pendingTargetIds, copyExecutionOptions)
    } finally {
      setIsProcessing(false)
      resetConfirmationState()
    }
  }

  const handleCancelConfirmation = () => {
    if (isProcessing) {
      return
    }
    resetConfirmationState()
  }

  if (selectedCount === 0) return null

  return (
    <>
      <div
        className={cn(
          'sticky top-0 z-10 flex items-center justify-between gap-4 p-4 bg-muted/90 backdrop-blur-sm border-y',
          className
        )}
      >
        {/* Selection Info */}
        <div className="flex items-center gap-3">
          <button
            onClick={handleSelectToggle}
            className="p-1 hover:bg-background rounded transition-colors"
          >
            <SelectionIcon isAllSelected={isAllSelected} isPartiallySelected={isPartiallySelected} />
          </button>

          <div className="flex items-center gap-2">
            <Badge variant="secondary" className="font-semibold">
              {`${selectedCount} selected`}
            </Badge>
            <span className="text-sm text-muted-foreground">
              {`of ${visibleCount} visible`}
            </span>
            {totalCount !== visibleCount && (
              <span className="text-xs text-muted-foreground">
                ({`${totalCount} total`})
              </span>
            )}
          </div>

          <Button
            variant="ghost"
            size="sm"
            onClick={onDeselectAll}
            className="text-muted-foreground hover:text-foreground"
          >
            <X className="h-4 w-4 mr-1" />
            Clear selection
          </Button>
        </div>

        {/* Bulk Actions */}
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={() => setShowCopyModal(true)}
          >
            <Copy className="h-4 w-4 mr-2" />
            Copy From Another Group
          </Button>
        </div>
      </div>

      <CopySourceSelectionModal
        open={showCopyModal}
        onOpenChange={setShowCopyModal}
        adGroups={allAdGroups}
        excludeGroupIds={selectedGroups}
        onSelect={handleCopyFromSource}
        isLoading={isProcessing || isLookupLoading}
        onSearch={onSearchAdGroups}
      />

      <BulkCopyConfirmationDialog
        open={showConfirmation}
        sourceGroup={selectedSourceGroup}
        targetGroups={pendingTargetGroups}
        targetCount={pendingTargetIds.length}
        copyOptions={copyExecutionOptions}
        onCopyOptionsChange={setCopyExecutionOptions}
        isProcessing={isProcessing}
        onConfirm={handleConfirmCopy}
        onCancel={handleCancelConfirmation}
      />
    </>
  )
}

export const BulkOperationsToolbar = memo(BulkOperationsToolbarComponent)
===ENDFILE

===FILE: src/components/admin/business-relevant-toggles.ts
/**
 * Business-Relevant Toggle Configuration
 *
 * 2-SECTION STRUCTURE for the Permissions tab:
 * 1. "Access Controls" (capabilities) - What users can DO (columns + micro_frontends)
 * 2. "Workspace & Preferences" (workspacePreferences) - What users can CONFIGURE (settings_options only)
 *
 * MINIMAL TOGGLES (10 total, down from 28):
 * - Only business-meaningful toggles admins configure per market/region/team
 * - Linked keys auto-sync dependent technical keys (hidden from UI)
 * - Settings tabs, basic widgets, and role-structural features are NOT toggleable
 *
 * Admin sections are separate and used by the admin panel views.
 *
 * Hidden/auto-synced keys:
 * - features.search.knowledgeBase (follows columns.kms via linkedKeys)
 * - features.search.embeddedApps (follows columns.embeddedApps via linkedKeys)
 * - micro_frontends.spaceCopilot (follows columns.spaceCopilot via linkedKeys)
 * - widgets.mediaBar.callControls (follows micro_frontends.mediaBar via linkedKeys)
 * - All settings_tabs.* (role-structural, no admin ever toggles these)
 * - All widgets.* (role-structural)
 * - settings_options.notifications.desktop (role-structural)
 */

interface ToggleVisibility {
  visible: boolean;
  businessName: string;
  description?: string;
  warning?: string;
  section?: string;
  parent?: string;
  linkedKeys?: string[];
}

interface CategoryConfig {
  title: string;
  description: string;
  toggles: Record<string, ToggleVisibility>;
}

/** Creates a standard visible toggle configuration. */
function visibleToggle(businessName: string, description: string): ToggleVisibility {
  return { visible: true, businessName, description }
}

const SECTION_DASHBOARD_ACCESS = 'Dashboard Access'

export const businessRelevantToggles: Record<string, CategoryConfig> = {
  // SECTION 1: ACCESS CONTROLS (What users can DO)
  // 5 toggles with linkedKeys for auto-sync
  capabilities: {
    title: 'Access Controls',
    description: 'Platform capabilities, dashboard panels, and applications',
    toggles: {
      'columns.kms': {
        visible: true,
        businessName: 'Knowledge Base',
        description: 'Access to knowledge base features',
        section: SECTION_DASHBOARD_ACCESS,
        linkedKeys: ['features.search.knowledgeBase']
      },
      'columns.embeddedApps': {
        visible: true,
        businessName: 'Banking Applications',
        description: 'Access to banking applications',
        section: SECTION_DASHBOARD_ACCESS,
        linkedKeys: ['features.search.embeddedApps']
      },
      'columns.spaceCopilot': {
        visible: true,
        businessName: 'AI Assistant',
        description: 'Access to AI assistant features',
        section: SECTION_DASHBOARD_ACCESS,
        linkedKeys: ['micro_frontends.spaceCopilot']
      },
      'columns.chat': {
        visible: true,
        businessName: 'Chat Interface',
        description: 'Access to chat conversation features',
        section: SECTION_DASHBOARD_ACCESS
      },
      'micro_frontends.mediaBar': {
        visible: true,
        businessName: 'Media Controls',
        description: 'Voice and video controls',
        section: 'Platform Apps',
        warning: 'Required for voice agents',
        linkedKeys: ['widgets.mediaBar.callControls']
      }
    }
  },

  // SECTION 2: WORKSPACE & PREFERENCES (What users can CONFIGURE)
  // 5 toggles - settings_options only
  workspacePreferences: {
    title: 'Workspace & Preferences',
    description: 'User preferences and workspace configuration',
    toggles: {
      'settings_options.calls.autoAccept': {
        visible: true,
        businessName: 'Auto-Accept Calls',
        description: 'Automatically accept incoming calls',
        section: 'Call Preferences'
      },
      'settings_options.calls.doNotDisturb.duration': {
        visible: true,
        businessName: 'Do Not Disturb',
        description: 'Set break duration',
        section: 'Call Preferences'
      },
      'settings_options.interface.showTranscript': {
        visible: true,
        businessName: 'Show Transcripts',
        description: 'Display call/chat transcripts',
        section: 'Privacy & Display'
      },
      'settings_options.interface.autoCloseKnowledgeOnCallEnd': {
        visible: true,
        businessName: 'Auto-Close Knowledge',
        description: 'Automatically close knowledge panel when call ends',
        section: 'Privacy & Display'
      },
      'settings_options.interface.spaceCopilotMode': {
        visible: true,
        businessName: 'AI Assistant Mode',
        description: 'Choose AI assistance level',
        section: 'AI Preference'
      }
    }
  },

  // ADMIN PANEL SECTIONS
  adminViews: {
    title: 'Admin Panel Views',
    description: 'Main administrative sections and dashboards',
    toggles: {
      'admin.roleTemplatesView': visibleToggle('Role Templates', 'View and preview role-based dashboard configurations'),
      'admin.adGroupsView': visibleToggle('Team Access Management', 'Manage AD group configurations and permissions'),
      'admin.systemNoticesView': visibleToggle('System Notices', 'Create and manage system-wide announcements')
    }
  },

  // AD GROUP MANAGEMENT TABS
  adminAdGroupTabs: {
    title: 'AD Group Configuration Tabs',
    description: 'Tabs available when editing AD group configurations',
    toggles: {
      'admin.tab.businessInfo': visibleToggle('Business Info Tab', 'Edit group name, role, market, region, business unit'),
      'admin.tab.permissions': visibleToggle('Permissions Tab', 'Configure role-based permissions for the group'),
      'admin.tab.applications': visibleToggle('Applications Tab', 'Assign embedded applications and functions')
    }
  },

  // ADMIN ACTIONS
  adminActions: {
    title: 'Administrative Actions',
    description: 'Specific admin capabilities and permissions',
    toggles: {
      'admin.editBusinessInfo': visibleToggle('Edit Business Info', 'Modify AD group business information'),
      'admin.editPermissions': visibleToggle('Edit Permissions', 'Toggle capabilities and widgets for groups'),
      'admin.editApplications': visibleToggle('Manage Applications', 'Assign applications and functions to groups'),
      'admin.enableDisableGroups': visibleToggle('Enable/Disable Groups', 'Activate or deactivate AD groups'),
      'admin.previewDashboards': visibleToggle('Preview Dashboards', 'Preview role and group configurations'),
      'admin.createNotice': visibleToggle('Create Notices', 'Create new system announcements'),
      'admin.publishNotice': visibleToggle('Publish Notices', 'Publish draft notices to active status'),
      'admin.archiveNotice': visibleToggle('Archive Notices', 'Archive active notices'),
      'admin.editNotice': visibleToggle('Edit Notices', 'Modify existing draft notices'),
      'admin.saveDraft': visibleToggle('Save Draft Notices', 'Save notices as drafts for later publishing')
    }
  }
};

/**
 * Check if a specific toggle should be shown in admin UI
 */
export function isToggleBusinessRelevant(category: string, toggleKey: string): boolean {
  const categoryConfig = businessRelevantToggles[category];
  if (!categoryConfig) return false;

  const toggle = categoryConfig.toggles[toggleKey];
  return toggle?.visible === true;
}
===ENDFILE

===FILE: src/components/admin/copy-source-card.tsx
/**
 * Copy Source Card - Individual AD group card for copy source selection.
 */

import { Badge } from '../ui/badge'
import { Copy } from 'lucide-react'
import type { AdGroup } from '../../types/features/ad-group-config'
import { GroupLocationInfo } from './copy-source-sub-components'

/** Renders a selectable card for a single AD group with role badge and location info. */
export function GroupCard({ group, isSelected, businessRole, onSelect }: Readonly<{
  group: AdGroup
  isSelected: boolean
  businessRole: { displayName: string }
  onSelect: (group: AdGroup) => void
}>) {
  return (
    <button
      key={group.id}
      onClick={() => onSelect(group)}
      className={`w-full text-left p-4 rounded-lg border-2 transition-all ${
        isSelected
          ? 'border-red-600 bg-red-50 hover:bg-red-100'
          : 'border-border hover:border-red-500 hover:bg-red-50/50'
      }`}
    >
      <div className="flex items-start justify-between gap-3">
        <div className="flex-1 space-y-1">
          <div className="flex items-center gap-2">
            <p className="font-semibold text-sm">
              {group.logicalName || 'Unconfigured Group'}
            </p>
            <Badge variant="outline" className="text-xs">
              {businessRole.displayName}
            </Badge>
          </div>
          <p className="text-xs text-muted-foreground font-mono truncate">
            {group.groupIdentifier}
          </p>
          <GroupLocationInfo group={group} />
        </div>
        {isSelected && (
          <div className="flex-shrink-0">
            <div className="h-5 w-5 rounded-full bg-primary flex items-center justify-center">
              <Copy className="h-3 w-3 text-primary-foreground" />
            </div>
          </div>
        )}
      </div>
    </button>
  )
}
===ENDFILE

===FILE: src/components/admin/copy-source-filters.tsx
/**
 * Copy Source Filters - Search matching and sorting logic for copy source modal.
 */

import type { AdGroup } from '../../types/features/ad-group-config'
import { isConfiguredGroup } from '../../utils/admin/notice-validators'

/** Returns true if the group's name, identifier, role, market, or region matches the search query. */
export function matchesSearchQuery(group: AdGroup, query: string): boolean {
  return Boolean(
    group.logicalName?.toLowerCase().includes(query) ||
    group.groupIdentifier.toLowerCase().includes(query) ||
    group.roleName?.toLowerCase().includes(query) ||
    group.market?.toLowerCase().includes(query) ||
    group.region?.toLowerCase().includes(query)
  )
}

/** Filters out excluded and unconfigured groups, applies search, and sorts alphabetically by name. */
export function filterAndSortGroups(adGroups: AdGroup[], excludeGroupIds: string[], query: string): AdGroup[] {
  let groups = adGroups.filter(group =>
    !excludeGroupIds.includes(group.id) && isConfiguredGroup({ group })
  )
  if (query) {
    const lowerQuery = query.toLowerCase()
    groups = groups.filter(group => matchesSearchQuery(group, lowerQuery))
  }
  return groups.sort((a, b) =>
    (a.logicalName || a.groupIdentifier).localeCompare(b.logicalName || b.groupIdentifier)
  )
}
===ENDFILE

===FILE: src/components/admin/copy-source-list-helpers.ts
/**
 * Copy Source List Helpers
 * Pure utility functions for the copy source group list rendering.
 * Extracted from copy-source-sub-components.tsx to separate logic from JSX.
 */

import type { AdGroup } from '../../types/features/ad-group-config'

/**
 * Collects non-empty location parts (market, region, country) from an AD group
 * for display in the group card location info.
 */
export function collectLocationParts(group: AdGroup): string[] {
  return [group.market, group.region, group.country].filter((v): v is string => Boolean(v))
}

/**
 * Resolves the display-friendly business role from the roles map,
 * with a fallback for unknown or missing role names.
 */
export function resolveBusinessRole(
  roleName: string | undefined,
  businessRoles: Record<string, { displayName: string; description: string; category: string }>
): { displayName: string; description: string; category: string } {
  const key = roleName || 'voice_agent'
  return businessRoles[key] || { displayName: roleName || 'Unknown', description: '', category: '' }
}
===ENDFILE

===FILE: src/components/admin/copy-source-selection-modal.tsx
import { useDeferredValue, useEffect, useMemo, useRef, useState } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '../ui/dialog'
import { Button } from '../ui/button'
import { Input } from '../ui/input'
import { Search, Copy, X } from 'lucide-react'
import { useBusinessRoles } from '@/hooks/features/use-business-terminology'
import type { AdGroup } from '../../types/features/ad-group-config'
import { filterAndSortGroups, GroupsListContent } from './copy-source-sub-components'

/** Props for the CopySourceSelectionModal component. */
interface CopySourceSelectionModalProps {
  /** Whether the modal is open */
  open: boolean
  /** Callback to control the open state */
  onOpenChange: (open: boolean) => void
  /** Available AD groups to display as copy sources */
  adGroups: AdGroup[]
  /** Group IDs to exclude from the source list (already selected as targets) */
  excludeGroupIds: string[]
  /** Callback invoked when a source group is selected */
  onSelect: (sourceGroup: AdGroup) => void
  /** Whether a copy operation is in progress */
  isLoading?: boolean
  /** Optional async search callback for server-side group filtering */
  onSearch?: (query: string) => Promise<AdGroup[]>
}

/**
 * Modal dialog for selecting a source AD group to copy configuration from.
 * Provides search, filtering, and a scrollable list of eligible source groups.
 */
export function CopySourceSelectionModal({
  open,
  onOpenChange,
  adGroups,
  excludeGroupIds,
  onSelect,
  isLoading = false,
  onSearch
}: Readonly<CopySourceSelectionModalProps>) {
  const businessRoles = useBusinessRoles()
  const [searchQuery, setSearchQuery] = useState('')
  const [selectedGroup, setSelectedGroup] = useState<AdGroup | null>(null)
  const debouncedQuery = useDeferredValue(searchQuery)
  const lastSearchedRef = useRef<string | null>(null)

  useEffect(() => {
    if (!open) {
      lastSearchedRef.current = null
      return
    }

    const shouldSkip = !onSearch
      || (debouncedQuery === '' && adGroups.length > 0)
      || lastSearchedRef.current === debouncedQuery
    if (shouldSkip) return

    lastSearchedRef.current = debouncedQuery
    onSearch(debouncedQuery)
  }, [debouncedQuery, onSearch, open, adGroups.length])

  const filteredGroups = useMemo(() =>
    filterAndSortGroups(adGroups, excludeGroupIds, debouncedQuery),
    [adGroups, excludeGroupIds, debouncedQuery]
  )

  const handleSelect = () => {
    if (!selectedGroup) return
    onSelect(selectedGroup)
    setSelectedGroup(null)
    setSearchQuery('')
  }

  const handleCancel = () => {
    setSelectedGroup(null)
    setSearchQuery('')
    onOpenChange(false)
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl max-h-[85vh] flex flex-col">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Copy className="h-5 w-5" />
            Copy Configuration From Another Group
          </DialogTitle>
          <DialogDescription>
            Select a source AD group to copy configuration from. The role, permissions, and location metadata will be copied.
          </DialogDescription>
        </DialogHeader>

        {/* Search Bar */}
        <div className="flex items-center gap-2 px-1 flex-shrink-0">
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search by name, DN, role, or location..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10 pr-10"
            />
            {searchQuery && (
              <button
                onClick={() => setSearchQuery('')}
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-muted-foreground hover:text-foreground"
              >
                <X className="h-4 w-4" />
              </button>
            )}
          </div>
        </div>

        {/* Groups List */}
        <div className="flex-1 min-h-0 max-h-[400px] overflow-y-scroll pr-2" style={{
          scrollbarWidth: 'thin',
          scrollbarColor: '#9ca3af #f3f4f6'
        }}>
          <GroupsListContent
            isLoading={isLoading}
            filteredGroups={filteredGroups}
            searchQuery={searchQuery}
            selectedGroup={selectedGroup}
            businessRoles={businessRoles}
            onSelect={setSelectedGroup}
          />
        </div>

        {/* Footer */}
        <DialogFooter className="flex-shrink-0">
          <div className="flex items-center justify-between w-full">
            <p className="text-sm text-muted-foreground">
              {filteredGroups.length === 1 ? `${filteredGroups.length} group available` : `${filteredGroups.length} groups available`}
            </p>
            <div className="flex gap-2">
              <Button
                variant="outline"
                onClick={handleCancel}
                disabled={isLoading}
              >
                Cancel
              </Button>
              <Button
                onClick={handleSelect}
                disabled={!selectedGroup || isLoading}
              >
                {isLoading ? 'Copying...' : 'Copy Configuration'}
              </Button>
            </div>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE

===FILE: src/components/admin/copy-source-sub-components.tsx
/**
 * Copy Source Sub-Components
 * Reusable sub-components and utility functions for the copy source selection modal.
 */

import { Search } from 'lucide-react'
import { useBusinessRoles } from '@/hooks/features/use-business-terminology'
import type { AdGroup } from '../../types/features/ad-group-config'
import { BrandLoader } from '@/components/common/brand-loader'
import { GroupCard } from './copy-source-card'
import { collectLocationParts, resolveBusinessRole } from './copy-source-list-helpers'

export { matchesSearchQuery, filterAndSortGroups } from './copy-source-filters'

/** Displays market, region, and country info for a group as a dot-separated inline list. */
export function GroupLocationInfo({ group }: Readonly<{ group: AdGroup }>) {
  const parts = collectLocationParts(group)
  if (parts.length === 0) return null
  return (
    <div className="flex items-center gap-2 text-xs text-muted-foreground mt-1">
      {parts.map((part, i) => (
        <span key={part}>
          {i > 0 && <span className="mr-2">&bull;</span>}
          {part}
        </span>
      ))}
    </div>
  )
}

/** Renders the scrollable list of selectable AD group cards with loading and empty states. */
export function GroupsListContent({ isLoading, filteredGroups, searchQuery, selectedGroup, businessRoles, onSelect }: Readonly<{
  isLoading: boolean
  filteredGroups: AdGroup[]
  searchQuery: string
  selectedGroup: AdGroup | null
  businessRoles: ReturnType<typeof useBusinessRoles>
  onSelect: (group: AdGroup) => void
}>) {
  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-12">
        <BrandLoader message="Loading AD groups..." />
      </div>
    )
  }

  if (filteredGroups.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center py-12 text-center">
        <Search className="h-12 w-12 text-muted-foreground mb-4" />
        <p className="text-sm text-muted-foreground">
          {searchQuery ? 'No matching groups found' : 'No configured groups available'}
        </p>
      </div>
    )
  }

  return (
    <div className="space-y-2">
      {filteredGroups.map((group) => {
        const isSelected = selectedGroup?.id === group.id
        const businessRole = resolveBusinessRole(group.roleName, businessRoles)
        return (
          <GroupCard
            key={group.id}
            group={group}
            isSelected={isSelected}
            businessRole={businessRole}
            onSelect={onSelect}
          />
        )
      })}
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/function-assignment-modal-builders.ts
/**
 * Function Assignment Modal Builders - Builds modal configurations for save confirmation.
 */

import { EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'
import type { SaveDetermination } from './function-assignment-utils'

export const LABEL_UNASSIGN = 'Unassign Application'

export function getOriginalAssignedCount(app: EmbeddedAppWithStatus): number {
  return app.assignedFunctionKeys?.length ?? 0
}

export function getDefaultDisplayName(
  defaultFeatureKey: string | undefined,
  functionDefinitions: Record<string, { displayName?: string }>
): string | undefined {
  if (!defaultFeatureKey) return undefined
  return functionDefinitions[defaultFeatureKey]?.displayName || defaultFeatureKey
}

export function buildDefaultOnlyModal(app: EmbeddedAppWithStatus, defaultDisplayName: string | undefined, defaultFeatureKey: string | undefined, selectedFunctions: string[]): SaveDetermination {
  return {
    modalState: {
      type: 'default',
      title: 'Default feature included',
      description: `${defaultDisplayName} will be assigned automatically so "${app.titleText}" can load its baseline view. Continue with this assignment?`,
      confirmLabel: 'Assign application',
      cancelLabel: 'Cancel'
    },
    pendingSave: { functions: selectedFunctions, defaultFunction: defaultFeatureKey }
  }
}

export function buildEmptySelectionModal(app: EmbeddedAppWithStatus, groupLabel: string, originalAssignedCount: number): SaveDetermination {
  if (originalAssignedCount === 0) {
    return {
      modalState: { type: 'missing', title: 'Select at least one feature', description: 'Choose a capability to assign or cancel to keep the application unassigned.', confirmLabel: 'OK' },
      pendingSave: null
    }
  }
  return {
    modalState: { type: 'removal', title: LABEL_UNASSIGN, description: `Saving without any features will unassign "${app.titleText}" from ${groupLabel}. Continue?`, confirmLabel: LABEL_UNASSIGN, cancelLabel: 'Cancel', context: 'save-removal' },
    pendingSave: { functions: [] }
  }
}

export function buildStandardModal(selectedFunctions: string[], app: EmbeddedAppWithStatus, groupLabel: string): SaveDetermination {
  const featureWord = selectedFunctions.length === 1 ? 'feature' : 'features'
  return {
    modalState: { type: 'standard', title: 'Confirm feature assignment', description: `Apply ${selectedFunctions.length} ${featureWord} to "${app.titleText}" for ${groupLabel}?`, confirmLabel: 'Save Assignment', cancelLabel: 'Cancel' },
    pendingSave: { functions: selectedFunctions }
  }
}
===ENDFILE

===FILE: src/components/admin/function-assignment-panel.tsx
import React, { useState, useEffect } from 'react'
import { useFunctionSelection } from '../../hooks/admin/use-function-selection'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../ui/card'
import { Badge } from '../ui/badge'
import { Label } from '../ui/label'
import { Package, Settings } from 'lucide-react'
import { EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'
import {
  determineSaveModalState,
  getFilteredFunctions,
  countByCategory,
  LABEL_UNASSIGN,
  type PermissionFilter,
  type ModalStateConfig
} from './function-assignment-utils'
import {
  FunctionListItem,
  PanelFooterSection,
  PermissionFilterBar,
  BulkActionsBar,
  FunctionConfirmationDialog
} from './function-panel-sections'

/** Props for the FunctionAssignmentPanel component. */
interface FunctionAssignmentPanelProps {
  /** The embedded application whose functions are being assigned */
  app: EmbeddedAppWithStatus
  /** Display name of the AD group receiving the assignment */
  groupName: string
  /** Callback to persist the function selection to the backend */
  onSave: (functions: string[], defaultFunction?: string) => Promise<void>
  /** Optional callback invoked on every selection change for staging unsaved changes */
  onSelectionChange?: (functions: string[], defaultFunction?: string) => void
  /** Whether a save operation is in progress */
  isLoading?: boolean
  /** Whether the panel is in read-only mode */
  isReadOnly?: boolean
}

/**
 * Panel for selecting which functions of an embedded application should be
 * assigned to an AD group. Supports filtering by permission type, bulk
 * selection, and confirmation dialogs for save and unassign operations.
 */
export function FunctionAssignmentPanel({
  app,
  groupName,
  onSave,
  onSelectionChange,
  isLoading = false,
  isReadOnly = false
}: Readonly<FunctionAssignmentPanelProps>) {
  const {
    selectedFunctions,
    defaultFunction,
    hasChanges,
    handleFunctionToggle,
    handleSelectAllFiltered,
    handleClearSelection,
    handleReset
  } = useFunctionSelection({ app })

  // Report selection changes to parent so modal-level save can include them
  useEffect(() => {
    if (onSelectionChange && hasChanges()) {
      onSelectionChange(selectedFunctions, defaultFunction)
    }
  }, [selectedFunctions, defaultFunction])

  const [permissionFilter, setPermissionFilter] = useState<PermissionFilter>('all')
  const [modalState, setModalState] = useState<ModalStateConfig>({ type: 'none' })
  const [pendingSave, setPendingSave] = useState<{
    functions: string[]
    defaultFunction?: string
  } | null>(null)

  const functionDefinitions = app.functionDefinitionsObject || {}
  const availableFunctions = Object.keys(functionDefinitions)

  const closeModal = () => {
    setModalState({ type: 'none' })
    setPendingSave(null)
  }

  const handleConfirmModal = async () => {
    if (modalState.type === 'missing' || !pendingSave) { closeModal(); return }

    try {
      await onSave(pendingSave.functions, pendingSave.defaultFunction)
      onSelectionChange?.([], undefined)
      closeModal()
    } catch {
      // onSave handles its own notifications; keep dialog open for retry
    }
  }

  const handleSave = async () => {
    const groupLabel = groupName || 'this AD group'
    const determination = determineSaveModalState(selectedFunctions, app, groupLabel, functionDefinitions)

    // Override defaultFunction with the actual tracked value for standard saves
    if (determination.pendingSave && determination.modalState.type === 'standard') {
      determination.pendingSave.defaultFunction = defaultFunction
    }

    setPendingSave(determination.pendingSave)
    setModalState(determination.modalState)
  }

  const filteredFunctions = getFilteredFunctions(availableFunctions, functionDefinitions, permissionFilter)
  const writeCount = countByCategory(availableFunctions, functionDefinitions, 'write')
  const readCount = countByCategory(availableFunctions, functionDefinitions, 'read')

  const handleUnassign = () => {
    if (isLoading || !app.isAssignedIndicator) return

    setPendingSave({ functions: [] })
    setModalState({
      type: 'removal',
      title: LABEL_UNASSIGN,
      description: `Unassigning "${app.titleText}" will remove all access for ${groupName || 'this AD group'}. Continue?`,
      confirmLabel: LABEL_UNASSIGN,
      cancelLabel: 'Cancel',
      context: 'button-removal'
    })
  }

  return (
    <>
      <Card className="h-full">
      <CardHeader className="pb-4">
        <div className="flex items-start justify-between">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-blue-100 rounded-lg">
              <Package className="h-5 w-5 text-blue-600" />
            </div>
            <div>
              <CardTitle className="text-lg">{app.titleText}</CardTitle>
              <CardDescription>{app.descriptionText}</CardDescription>
            </div>
          </div>
          {app.isAssignedIndicator && (
            <Badge variant="secondary" className="bg-green-100 text-green-700">
              Assigned
            </Badge>
          )}
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {/* Function Selection */}
        <div className="space-y-4">
          <div className="flex items-center justify-between flex-wrap gap-3">
            <div className="flex items-center gap-2">
              <Settings className="h-4 w-4 text-gray-500" />
              <Label className="text-sm font-medium">Available Features</Label>
              <Badge variant="outline" className="text-xs">
                {`${selectedFunctions.length} of ${availableFunctions.length} selected`}
              </Badge>
            </div>

            <PermissionFilterBar
              permissionFilter={permissionFilter}
              setPermissionFilter={setPermissionFilter}
              availableFunctions={availableFunctions}
              writeCount={writeCount}
              readCount={readCount}
            />
          </div>

          <BulkActionsBar
            permissionFilter={permissionFilter}
            writeCount={writeCount}
            readCount={readCount}
            filteredFunctions={filteredFunctions}
            onSelectAll={handleSelectAllFiltered}
            onClear={handleClearSelection}
          />

          {filteredFunctions.length > 0 ? (
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-3 max-h-[400px] overflow-y-auto">
              {filteredFunctions.map((functionKey) => (
                <FunctionListItem
                  key={functionKey}
                  functionKey={functionKey}
                  definition={functionDefinitions[functionKey]}
                  defaultFunctionKey={app.defaultFunctionKey}
                  selectedFunctions={selectedFunctions}
                  isReadOnly={isReadOnly}
                  onToggle={handleFunctionToggle}
                />
              ))}
            </div>
          ) : (
            <div className="text-center py-8 text-gray-500 text-sm">
              {permissionFilter === 'all'
                ? 'No features available for this application'
                : `No ${permissionFilter} features available`}
            </div>
          )}
        </div>


        <PanelFooterSection
          isReadOnly={isReadOnly}
          selectedCount={selectedFunctions.length}
          hasChanges={hasChanges()}
          isLoading={isLoading}
          isAssigned={app.isAssignedIndicator}
          onSave={handleSave}
          onReset={handleReset}
          onUnassign={handleUnassign}
        />
      </CardContent>
      </Card>

      <FunctionConfirmationDialog
        modalState={modalState}
        onConfirm={handleConfirmModal}
        onCancel={closeModal}
        isOpen={modalState.type !== 'none'}
      />
    </>
  )
}
===ENDFILE

===FILE: src/components/admin/function-assignment-utils.ts
/**
 * Function Assignment Utilities
 * Types and pure logic for the function assignment panel.
 * Handles save determination, filtering, and styling helpers.
 */

import { EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'
import {
  getOriginalAssignedCount,
  getDefaultDisplayName,
  buildDefaultOnlyModal,
  buildEmptySelectionModal,
  buildStandardModal
} from './function-assignment-modal-builders'

// Re-export for consumers
export { LABEL_UNASSIGN } from './function-assignment-modal-builders'

export type PermissionFilter = 'all' | 'write' | 'read'

export interface ModalStateConfig {
  type: 'none' | 'default' | 'standard' | 'missing' | 'removal'
  title?: string
  description?: string
  confirmLabel?: string
  cancelLabel?: string
  context?: 'save-removal' | 'button-removal'
}

export interface SaveDetermination {
  modalState: ModalStateConfig
  pendingSave: { functions: string[]; defaultFunction?: string } | null
}

/**
 * Determines the correct save confirmation modal type based on the current selection.
 * Handles default-only, empty (removal), missing, and standard selection scenarios.
 */
export function determineSaveModalState(
  selectedFunctions: string[],
  app: EmbeddedAppWithStatus,
  groupLabel: string,
  functionDefinitions: Record<string, { displayName?: string }>
): SaveDetermination {
  const originalAssignedCount = getOriginalAssignedCount(app)
  const defaultFeatureKey = app.defaultFunctionKey
  const defaultDisplayName = getDefaultDisplayName(defaultFeatureKey, functionDefinitions)
  const isDefaultOnlySelection = selectedFunctions.length === 1 && selectedFunctions[0] === defaultFeatureKey

  if (isDefaultOnlySelection && originalAssignedCount === 0) {
    return buildDefaultOnlyModal(app, defaultDisplayName, defaultFeatureKey, selectedFunctions)
  }
  if (selectedFunctions.length === 0) {
    return buildEmptySelectionModal(app, groupLabel, originalAssignedCount)
  }
  return buildStandardModal(selectedFunctions, app, groupLabel)
}

/**
 * Returns the Tailwind CSS class for a function list item based on its selection state.
 */
export function getFunctionItemStyle(isChecked: boolean, isDefaultFeature: boolean): string {
  if (!isChecked) return "border-gray-200 hover:bg-gray-50"
  if (isDefaultFeature) return "border-green-200 bg-green-50"
  return "border-blue-200 bg-blue-50"
}

/**
 * Filters available functions by category (all, read, write).
 */
export function getFilteredFunctions(
  availableFunctions: string[],
  functionDefinitions: Record<string, { categoryText?: string }>,
  permissionFilter: PermissionFilter
): string[] {
  if (permissionFilter === 'all') return availableFunctions
  return availableFunctions.filter(functionKey =>
    functionDefinitions[functionKey]?.categoryText === permissionFilter
  )
}

/**
 * Counts the number of functions in a specific category.
 */
export function countByCategory(
  availableFunctions: string[],
  functionDefinitions: Record<string, { categoryText?: string }>,
  category: string
): number {
  return availableFunctions.filter(fk =>
    functionDefinitions[fk]?.categoryText === category
  ).length
}
===ENDFILE

===FILE: src/components/admin/function-confirmation-dialog.tsx
/**
 * Function Confirmation Dialog
 * Reusable confirmation dialog for function assignment operations.
 */

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle
} from '../ui/alert-dialog'
import type { ModalStateConfig } from './function-assignment-utils'

/** Renders an alert dialog for confirming function assignment operations (assign, unassign, missing). */
export function FunctionConfirmationDialog({ modalState, onConfirm, onCancel, isOpen }: Readonly<{
  modalState: ModalStateConfig
  onConfirm: () => Promise<void>
  onCancel: () => void
  isOpen: boolean
}>) {
  return (
    <AlertDialog open={isOpen} onOpenChange={(open) => { if (!open) onCancel() }}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>{modalState.title}</AlertDialogTitle>
          {modalState.description && (
            <AlertDialogDescription>{modalState.description}</AlertDialogDescription>
          )}
        </AlertDialogHeader>
        <AlertDialogFooter>
          {modalState.type !== 'missing' && modalState.cancelLabel && (
            <AlertDialogCancel
              onClick={(event) => {
                event.preventDefault()
                onCancel()
              }}
            >
              {modalState.cancelLabel}
            </AlertDialogCancel>
          )}
          <AlertDialogAction
            onClick={async (event) => {
              event.preventDefault()
              await onConfirm()
            }}
          >
            {modalState.confirmLabel || 'Continue'}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  )
}
===ENDFILE

===FILE: src/components/admin/function-panel-sections.tsx
/**
 * Function Panel Sections
 * Sub-components for the function assignment panel:
 * list items, footer, filter bar, bulk actions, and confirmation dialog.
 */

import { Checkbox } from '../ui/checkbox'
import { Badge } from '../ui/badge'
import { Button } from '../ui/button'
import { Label } from '../ui/label'
import { Save, X } from 'lucide-react'
import { cn } from '../../lib/utils'
import {
  getFunctionItemStyle,
  LABEL_UNASSIGN,
  type PermissionFilter,
} from './function-assignment-utils'
// Re-export the confirmation dialog from its new home
export { FunctionConfirmationDialog } from './function-confirmation-dialog'

/** Renders the label, description, and category for a function item. */
function FunctionItemDetails({ functionKey, definition, isDefaultFeature, isDisabled }: Readonly<{
  functionKey: string
  definition: { displayName?: string; description?: string; categoryText?: string } | undefined
  isDefaultFeature: boolean
  isDisabled: boolean
}>) {
  return (
    <div className="flex-1 min-w-0">
      <div className="flex items-center gap-2 flex-wrap">
        <Label
          htmlFor={functionKey}
          className={cn("text-sm font-medium", isDisabled ? "cursor-not-allowed text-gray-600" : "cursor-pointer")}
        >
          {definition?.displayName || functionKey}
        </Label>
        {isDefaultFeature && <Badge variant="secondary" className="bg-green-100 text-green-700 text-xs">Required</Badge>}
      </div>
      {definition?.description && <p className="text-xs text-gray-600 mt-1">{definition.description}</p>}
      {definition?.categoryText && <Badge variant="outline" className="text-xs mt-2">{definition.categoryText}</Badge>}
    </div>
  )
}

/** Renders a single function checkbox item with name, description, category badge, and required indicator. */
export function FunctionListItem({ functionKey, definition, defaultFunctionKey, selectedFunctions, isReadOnly, onToggle }: Readonly<{
  functionKey: string
  definition: { displayName?: string; description?: string; categoryText?: string } | undefined
  defaultFunctionKey: string | undefined
  selectedFunctions: string[]
  isReadOnly: boolean
  onToggle: (params: { functionKey: string; checked: boolean }) => void
}>) {
  const isDefaultFeature = defaultFunctionKey === functionKey
  const isChecked = isDefaultFeature || selectedFunctions.includes(functionKey)
  const isDisabled = isReadOnly || isDefaultFeature

  return (
    <div className={cn("flex items-start space-x-3 p-3 border rounded-lg transition-colors", getFunctionItemStyle(isChecked, isDefaultFeature))}>
      <Checkbox
        id={functionKey}
        checked={isChecked}
        disabled={isDisabled}
        onCheckedChange={(checked) => onToggle({ functionKey, checked: checked as boolean })}
        className="mt-0.5 flex-shrink-0"
      />
      <FunctionItemDetails functionKey={functionKey} definition={definition} isDefaultFeature={isDefaultFeature} isDisabled={isDisabled} />
    </div>
  )
}

/** Displays the read-only footer message showing current assignment state. */
function FooterStatusMessage({ selectedCount }: Readonly<{ selectedCount: number }>) {
  return (
    <div className="text-center text-sm py-2 text-gray-500">
      {selectedCount === 0
        ? 'No features assigned to this application'
        : 'Current assignment saved'}
    </div>
  )
}

/** Displays save/reset buttons when changes exist, or a status message when saved. */
function FooterEditStatus({ selectedCount, hasChanges, isLoading, onSave, onReset }: Readonly<{
  selectedCount: number
  hasChanges: boolean
  isLoading: boolean
  onSave: () => void
  onReset: () => void
}>) {
  if (hasChanges) {
    return (
      <div className="flex items-center gap-2">
        <Button onClick={onSave} disabled={isLoading} className="flex-1">
          {isLoading ? 'Saving...' : <><Save className="h-4 w-4 mr-2" />Save Assignment</>}
        </Button>
        <Button variant="outline" onClick={onReset} disabled={isLoading}>
          <X className="h-4 w-4 mr-2" />
          Reset
        </Button>
      </div>
    )
  }

  return (
    <div className={cn('text-center text-sm py-2', selectedCount === 0 ? 'text-gray-500' : 'text-green-600')}>
      {selectedCount === 0 ? 'Select features to assign this application to the AD group' : 'Current assignment saved'}
    </div>
  )
}

/** Composite footer section combining status/save controls and an unassign button for the function panel. */
export function PanelFooterSection({ isReadOnly, selectedCount, hasChanges, isLoading, isAssigned, onSave, onReset, onUnassign }: Readonly<{
  isReadOnly: boolean
  selectedCount: number
  hasChanges: boolean
  isLoading: boolean
  isAssigned: boolean
  onSave: () => void
  onReset: () => void
  onUnassign: () => void
}>) {
  return (
    <div className="pt-4 border-t space-y-3">
      {isReadOnly && <FooterStatusMessage selectedCount={selectedCount} />}
      {!isReadOnly && (
        <FooterEditStatus
          selectedCount={selectedCount}
          hasChanges={hasChanges}
          isLoading={isLoading}
          onSave={onSave}
          onReset={onReset}
        />
      )}

      {!isReadOnly && isAssigned && (
        <Button
          variant="outline"
          onClick={onUnassign}
          disabled={isLoading}
          className="w-full border-red-200 text-red-600 hover:bg-red-50 hover:text-red-700"
        >
          {LABEL_UNASSIGN}
        </Button>
      )}
    </div>
  )
}

/** Renders All/Write/Read toggle buttons for filtering functions by permission category. */
export function PermissionFilterBar({ permissionFilter, setPermissionFilter, availableFunctions, writeCount, readCount }: Readonly<{
  permissionFilter: PermissionFilter
  setPermissionFilter: (v: PermissionFilter) => void
  availableFunctions: string[]
  writeCount: number
  readCount: number
}>) {
  return (
    <div className="flex items-center gap-2">
      <Button
        variant={permissionFilter === 'all' ? 'default' : 'outline'}
        size="sm"
        onClick={() => setPermissionFilter('all')}
        className="h-8"
      >
        {`All (${availableFunctions.length})`}
      </Button>
      <Button
        variant={permissionFilter === 'write' ? 'default' : 'outline'}
        size="sm"
        onClick={() => setPermissionFilter('write')}
        className="h-8"
      >
        {`Write (${writeCount})`}
      </Button>
      <Button
        variant={permissionFilter === 'read' ? 'default' : 'outline'}
        size="sm"
        onClick={() => setPermissionFilter('read')}
        className="h-8"
      >
        {`Read (${readCount})`}
      </Button>
    </div>
  )
}

/** Renders Select All / Clear Selection buttons for the active permission filter category. */
export function BulkActionsBar({ permissionFilter, writeCount, readCount, filteredFunctions, onSelectAll, onClear }: Readonly<{
  permissionFilter: PermissionFilter
  writeCount: number
  readCount: number
  filteredFunctions: string[]
  onSelectAll: (params: { filteredFunctions: string[] }) => void
  onClear: () => void
}>) {
  if (permissionFilter === 'all' || filteredFunctions.length === 0) return null
  const filterLabel = permissionFilter === 'write' ? `Write (${writeCount})` : `Read (${readCount})`
  return (
    <div className="flex items-center gap-3 text-sm px-2">
      <Button
        variant="ghost"
        size="sm"
        onClick={() => onSelectAll({ filteredFunctions })}
        className="h-7 text-xs"
      >
        {`Select All ${filterLabel}`}
      </Button>
      <span className="text-gray-400">&bull;</span>
      <Button
        variant="ghost"
        size="sm"
        onClick={onClear}
        className="h-7 text-xs"
      >
        Clear Selection
      </Button>
    </div>
  )
}

===ENDFILE

===FILE: src/components/admin/iframe-layout-preview.tsx
import { useState, useEffect } from 'react';
import { Card } from '../ui/card';
import { Button } from '../ui/button';
import { Badge } from '../ui/badge';
import { RefreshCw, ExternalLink } from 'lucide-react';
import type { RoleTemplate } from '../../types/system/layout-template';

/** Props for the IframeLayoutPreview component. */
interface IframeLayoutPreviewProps {
  /** The role template to preview, already merged with any AD group overrides */
  role: RoleTemplate;
  /** Optional AD group name for display in the preview header */
  adGroup?: string;
}

/**
 * Renders a sandboxed iframe preview of the dashboard layout for a given role template.
 * Passes the merged template as a base64-encoded URL parameter to the preview endpoint.
 */
export function IframeLayoutPreview({ role, adGroup }: Readonly<IframeLayoutPreviewProps>) {
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);
  const [mergedTemplate, setMergedTemplate] = useState<RoleTemplate>(role);
  const currentRole = 'admin';

  // Note: We don't fetch AD group data here because:
  // 1. The role template is already merged with AD group overrides by the parent component
  // 2. API calls from within iframes may not work due to proxy limitations
  // 3. The preview receives the complete merged template via URL parameters
  useEffect(() => {
    setMergedTemplate(role);
  }, [role]);

  // Build preview URL with merged template JSON
  const previewParams = new URLSearchParams({
    mode: 'preview',
    role: mergedTemplate.roleName,
    currentRole: currentRole, // Pass the current role context to iframe
    template: btoa(JSON.stringify(mergedTemplate)) // Pass merged template JSON as base64 encoded string
  });

  if (adGroup) {
    previewParams.set('adGroup', adGroup);
  }

  const previewUrl = `/dashboard/preview?${previewParams.toString()}`;

  // Handle iframe load events
  const handleIframeLoad = () => {
    setIsLoading(false);
    setHasError(false);
  };

  const handleIframeError = () => {
    setIsLoading(false);
    setHasError(true);
  };

  // Refresh preview
  const refreshPreview = () => {
    setIsLoading(true);
    setHasError(false);
    // Force iframe reload by updating key
    const iframe = document.getElementById('preview-iframe') as HTMLIFrameElement;
    if (iframe) {
      iframe.src = previewUrl;
    }
  };

  // Open in new tab
  const openInNewTab = () => {
    window.open(previewUrl, '_blank');
  };

  return (
    <div className="w-full h-full flex flex-col">
      {/* Preview Header */}
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-3">
          <h3 className="text-lg font-semibold">
            {`${role.displayName} Layout Preview`}
          </h3>
          {adGroup && (
            <Badge variant="outline" className="text-xs">
              {`AD Group: ${adGroup}`}
            </Badge>
          )}
        </div>

        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={refreshPreview}
            disabled={isLoading}
          >
            <RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} />
            Refresh
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={openInNewTab}
          >
            <ExternalLink className="h-4 w-4" />
            Open Full
          </Button>
        </div>
      </div>

      {/* Preview Container */}
      <Card className="relative overflow-hidden flex-1">
        {/* Error State */}
        {hasError && !isLoading && (
          <div className="absolute inset-0 bg-background/80 backdrop-blur-sm z-10 flex items-center justify-center">
            <div className="text-center">
              <p className="text-destructive font-medium mb-2">Failed to load preview</p>
              <Button variant="outline" size="sm" onClick={refreshPreview}>
                <RefreshCw className="h-4 w-4 mr-2" />
                Try Again
              </Button>
            </div>
          </div>
        )}

        {/* Preview iframe */}
        <iframe
          id="preview-iframe"
          src={previewUrl}
          className="w-full h-full border-0 rounded-lg"
          data-panel-iframe="true"
          title={`${role.displayName} Dashboard Preview`}
          sandbox="allow-same-origin allow-scripts allow-forms"
          onLoad={handleIframeLoad}
          onError={handleIframeError}
        />
      </Card>

      {/* Preview Info */}
      <div className="mt-3 text-xs text-muted-foreground">
        <p>
          {(() => {
            const suffix = adGroup ? ` with ${adGroup} AD group overrides applied` : ''
            return `This preview shows the exact dashboard interface that ${role.displayName.toLowerCase()}s see${suffix}.`
          })()}
        </p>
        <p className="mt-1">
           Real components with demo data  Interactive elements disabled  Secure sandbox environment
        </p>
      </div>
    </div>
  );
}
===ENDFILE

===FILE: src/components/admin/layout-preview-modal.tsx
import { useState, useEffect, useRef } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '../ui/dialog';
import { Button } from '../ui/button';
import { Eye } from 'lucide-react';
import { IframeLayoutPreview } from './iframe-layout-preview';
import { AdGroup } from '../../types/features/ad-group-config';
import type { RoleTemplate } from '../../types/system/layout-template';

/** Props for the LayoutPreviewModal component. */
interface LayoutPreviewModalProps {
  /** Pre-loaded role template for immediate preview */
  role?: RoleTemplate;
  /** AD group for which overrides should be applied in the preview */
  adGroup?: AdGroup;
  /** Optional async function to fetch the role template on demand */
  fetchLayout?: () => Promise<RoleTemplate>;
  /** Custom trigger element (defaults to a "Preview Dashboard" button) */
  children?: React.ReactNode;
}

/**
 * Modal dialog that shows a live dashboard preview for a role template.
 * Supports both pre-loaded templates and on-demand lazy fetching.
 */
export function LayoutPreviewModal({ role, adGroup, fetchLayout, children }: Readonly<LayoutPreviewModalProps>) {
  const [open, setOpen] = useState(false);
  const [loadedRole, setLoadedRole] = useState<RoleTemplate | null>(role || null);
  const [loading, setLoading] = useState(false);
  const fetchingRef = useRef(false);

  useEffect(() => {
    if (!open) {
      if (fetchLayout) setLoadedRole(null);
      fetchingRef.current = false;
      return undefined;
    }
    if (!fetchLayout || fetchingRef.current || loadedRole) return undefined;

    let active = true;
    fetchingRef.current = true;
    setLoading(true);

    fetchLayout()
      .then(roleData => { if (active) { setLoadedRole(roleData); setLoading(false) } })
      .catch(() => { if (active) setLoading(false) })
      .finally(() => { if (active) fetchingRef.current = false });

    return () => { active = false };
  }, [open, fetchLayout]);

  const displayRole = loadedRole || role;
  const adGroupName = adGroup?.logicalName || adGroup?.groupIdentifier;

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        {children || (
          <Button variant="outline" size="sm" className="w-full group border-primary/20 hover:border-primary/40 hover:bg-primary/5 transition-all">
            <Eye className="h-4 w-4 mr-2 group-hover:text-primary transition-colors" />
            <span className="group-hover:text-primary transition-colors">Preview Dashboard</span>
          </Button>
        )}
      </DialogTrigger>
      <DialogContent className="w-[90vw] h-[90vh] max-w-[90vw] max-h-[90vh] p-4 sm:p-6 gap-3 flex flex-col">
        <DialogHeader className="space-y-1 sm:text-left">
          <DialogTitle className="text-xl font-bold flex items-center gap-2">
            Dashboard Layout Preview
            {adGroupName && (
              <span className="text-sm font-normal text-muted-foreground">
                 {adGroupName}
              </span>
            )}
          </DialogTitle>
          <DialogDescription className="text-sm text-muted-foreground/90">
            Live preview showing the exact interface this role sees
            {adGroupName && ' with AD group-specific overrides'}
          </DialogDescription>
        </DialogHeader>

        <div className="flex-1 min-h-0">
          {displayRole && (
            <IframeLayoutPreview role={displayRole} adGroup={adGroupName} />
          )}
          {!displayRole && !loading && (
            <div className="flex items-center justify-center h-96">
              <div className="text-muted-foreground">No layout data available</div>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}
===ENDFILE

===FILE: src/components/admin/notices/__tests__/notice-form-modal-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))

vi.mock('../../../ui/input', () => ({
  Input: ({ onChange, value, id, placeholder }: any) => (
    <input data-testid={`input-${id || 'default'}`} onChange={onChange} value={value || ''} placeholder={placeholder} />
  )
}))

vi.mock('../../../ui/label', () => ({
  Label: ({ children, htmlFor }: any) => <label htmlFor={htmlFor}>{children}</label>
}))

vi.mock('../../../ui/textarea', () => ({
  Textarea: ({ onChange, value, id }: any) => (
    <textarea data-testid={`textarea-${id || 'default'}`} onChange={onChange} value={value || ''} />
  )
}))

vi.mock('../../../ui/switch', () => ({
  Switch: ({ id, checked, onCheckedChange }: any) => (
    <input type="checkbox" data-testid={`switch-${id}`} checked={checked}
      onChange={() => onCheckedChange?.(!checked)} />
  )
}))

vi.mock('../../../ui/tabs', () => ({
  Tabs: ({ children, value, onValueChange }: any) => (
    <div data-testid="tabs" data-value={value}>
      <button data-testid="switch-to-targeting" onClick={() => onValueChange('targeting')}>targeting</button>
      <button data-testid="switch-to-details" onClick={() => onValueChange('details')}>details</button>
      {children}
    </div>
  ),
  TabsContent: ({ children, value }: any) => <div data-testid={`tab-${value}`}>{children}</div>,
  TabsList: ({ children }: any) => <div>{children}</div>,
  TabsTrigger: ({ children, value }: any) => <div data-testid={`trigger-${value}`}>{children}</div>
}))

vi.mock('../../../ui/select', () => ({
  Select: ({ children, onValueChange }: any) => <div>{children}<button data-testid="sev-change" onClick={() => onValueChange?.('WARNING')}>change-sev</button></div>,
  SelectContent: ({ children }: any) => <div>{children}</div>,
  SelectItem: ({ children }: any) => <div>{children}</div>,
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: () => <span />
}))

vi.mock('../../../ui/date-time-picker', () => ({
  DateTimePicker: ({ id, label, onChange }: any) => (
    <div data-testid={`datepicker-${id}`}>
      <span>{label}</span>
      <button data-testid={`date-change-${id}`} onClick={() => onChange?.('2026-01-01T00:00:00Z')}>pick</button>
    </div>
  )
}))

const MockIcon = () => <span data-testid="sev-icon" />
vi.mock('@/hooks/features/use-notice-config', () => ({
  useNoticeSeverities: () => [
    { value: 'INFO', label: 'Info', icon: MockIcon },
    { value: 'WARNING', label: 'Warning', icon: MockIcon }
  ],
  useTargetRoles: () => [
    { value: 'voice_agent', label: 'Voice Agent' },
    { value: 'chat_agent', label: 'Chat Agent' }
  ]
}))

const mockSetFormData = vi.fn()
const mockResetForm = vi.fn()
const mockToggleRole = vi.fn()
const mockToggleAdGroup = vi.fn()

vi.mock('../../../../hooks/admin/use-notice-form', () => ({
  useNoticeForm: () => ({
    formData: {
      title: 'Test Notice',
      message: 'Test message content',
      severity: 'INFO',
      requiresAcknowledgement: false,
      broadcastToAll: false,
      targetRoles: [],
      startAt: null,
      endAt: null,
      adGroupIds: []
    },
    setFormData: mockSetFormData,
    minScheduleDate: '2026-01-01T00:00:00Z',
    parsedStartDate: null,
    isEndDateValid: true,
    toggleRole: mockToggleRole,
    isRoleSelected: vi.fn(() => false),
    toggleAdGroup: mockToggleAdGroup,
    isAdGroupSelected: vi.fn(() => false),
    resetForm: mockResetForm
  })
}))

vi.mock('../../../../hooks/admin/use-ad-groups-loader', () => ({
  useAdGroupsLoader: () => ({
    adGroups: [{ groupIdentifier: 'CN=g1', logicalName: 'Group 1' }],
    isLoadingGroups: false
  })
}))

const mockHandleSave = vi.fn()
vi.mock('../../../../hooks/admin/use-notice-save', () => ({
  useNoticeSave: () => ({ isSaving: false, handleSave: mockHandleSave })
}))

vi.mock('../notice-form-sub-components', () => ({
  AdGroupListContent: ({ adGroups, toggleAdGroup }: any) => (
    <div data-testid="ad-group-list">
      {adGroups.map((g: any) => (
        <button key={g.groupIdentifier} data-testid={`toggle-${g.groupIdentifier}`}
          onClick={() => toggleAdGroup({ groupIdentifier: g.groupIdentifier })}>{g.logicalName}</button>
      ))}
    </div>
  ),
  NoticeFormFooter: ({ handleClose, handleSave }: any) => (
    <div data-testid="form-footer">
      <button data-testid="footer-cancel" onClick={handleClose}>Cancel</button>
      <button data-testid="footer-save" onClick={() => handleSave({ asDraft: false })}>Save</button>
    </div>
  )
}))

vi.mock('../notice-form-helpers', () => ({
  getDialogTitle: (isEdit: boolean) => isEdit ? 'Edit Notice' : 'Create System Notice',
  getDialogDescription: (isEdit: boolean) => isEdit ? 'Update notice' : 'Create a new notice'
}))

import { NoticeFormModal } from '../notice-form-modal'

describe('NoticeFormModal - extra coverage', () => {
  const baseProps = {
    open: true,
    onClose: vi.fn(),
    onSave: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders title input with value', () => {
    render(<NoticeFormModal {...baseProps} />)
    const input = screen.getByTestId('input-title') as HTMLInputElement
    expect(input.value).toBe('Test Notice')
  })

  it('renders message textarea with value', () => {
    render(<NoticeFormModal {...baseProps} />)
    const textarea = screen.getByTestId('textarea-message') as HTMLTextAreaElement
    expect(textarea.value).toBe('Test message content')
  })

  it('calls setFormData when title changes', () => {
    render(<NoticeFormModal {...baseProps} />)
    fireEvent.change(screen.getByTestId('input-title'), { target: { value: 'Updated' } })
    expect(mockSetFormData).toHaveBeenCalled()
  })

  it('calls setFormData when message changes', () => {
    render(<NoticeFormModal {...baseProps} />)
    fireEvent.change(screen.getByTestId('textarea-message'), { target: { value: 'Updated msg' } })
    expect(mockSetFormData).toHaveBeenCalled()
  })

  it('renders severity select', () => {
    render(<NoticeFormModal {...baseProps} />)
    expect(screen.getByText('Info')).toBeInTheDocument()
    expect(screen.getByText('Warning')).toBeInTheDocument()
  })

  it('renders requires acknowledgement switch', () => {
    render(<NoticeFormModal {...baseProps} />)
    expect(screen.getByText('Requires acknowledgement')).toBeInTheDocument()
    expect(screen.getByTestId('switch-requires-ack')).toBeInTheDocument()
  })

  it('renders targeting tab content', () => {
    render(<NoticeFormModal {...baseProps} />)
    expect(screen.getByText('Broadcast to all users')).toBeInTheDocument()
  })

  it('renders role targeting when not broadcast', () => {
    render(<NoticeFormModal {...baseProps} />)
    expect(screen.getByText('Voice Agent')).toBeInTheDocument()
    expect(screen.getByText('Chat Agent')).toBeInTheDocument()
  })

  it('renders AD group list', () => {
    render(<NoticeFormModal {...baseProps} />)
    expect(screen.getByTestId('ad-group-list')).toBeInTheDocument()
    expect(screen.getByText('Group 1')).toBeInTheDocument()
  })

  it('renders date pickers', () => {
    render(<NoticeFormModal {...baseProps} />)
    expect(screen.getByTestId('datepicker-start-date')).toBeInTheDocument()
    expect(screen.getByTestId('datepicker-end-date')).toBeInTheDocument()
  })

  it('renders form footer', () => {
    render(<NoticeFormModal {...baseProps} />)
    expect(screen.getByTestId('form-footer')).toBeInTheDocument()
  })

  it('calls onClose via footer cancel', () => {
    render(<NoticeFormModal {...baseProps} />)
    fireEvent.click(screen.getByTestId('footer-cancel'))
    expect(mockResetForm).toHaveBeenCalled()
    expect(baseProps.onClose).toHaveBeenCalled()
  })

  it('shows character counts', () => {
    render(<NoticeFormModal {...baseProps} />)
    expect(screen.getByText('11/200 characters')).toBeInTheDocument()
    expect(screen.getByText('20/2000 characters')).toBeInTheDocument()
  })

  it('renders create title for new notice', () => {
    render(<NoticeFormModal {...baseProps} />)
    expect(screen.getByText('Create System Notice')).toBeInTheDocument()
  })

  it('renders edit title for existing notice', () => {
    render(<NoticeFormModal {...baseProps} editNotice={{ id: '1' } as any} />)
    expect(screen.getByText('Edit Notice')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/notices/__tests__/notice-form-modal.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))
vi.mock('../../../ui/button', () => ({ Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button> }))
vi.mock('../../../ui/input', () => ({ Input: (p: any) => <input data-testid="input" {...p} /> }))
vi.mock('../../../ui/label', () => ({ Label: ({ children }: any) => <label>{children}</label> }))
vi.mock('../../../ui/textarea', () => ({ Textarea: (p: any) => <textarea data-testid="textarea" {...p} /> }))
vi.mock('../../../ui/switch', () => ({ Switch: (p: any) => <input type="checkbox" data-testid="switch" {...p} /> }))
vi.mock('../../../ui/tabs', () => ({
  Tabs: ({ children }: any) => <div>{children}</div>,
  TabsContent: ({ children }: any) => <div>{children}</div>,
  TabsList: ({ children }: any) => <div>{children}</div>,
  TabsTrigger: ({ children }: any) => <div>{children}</div>
}))
vi.mock('../../../ui/select', () => ({
  Select: ({ children }: any) => <div>{children}</div>,
  SelectContent: ({ children }: any) => <div>{children}</div>,
  SelectItem: ({ children }: any) => <div>{children}</div>,
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: () => <span />
}))
vi.mock('../../../ui/date-time-picker', () => ({
  DateTimePicker: (p: any) => <input data-testid="date-picker" {...p} />
}))
vi.mock('lucide-react', () => ({
  Loader2: (p: any) => <span data-testid="loader" {...p} />
}))
const MockIcon = (p: any) => <span data-testid="icon" {...p} />
vi.mock('@/hooks/features/use-notice-config', () => ({
  useNoticeSeverities: () => [{ value: 'INFO', label: 'Info', icon: MockIcon }, { value: 'WARNING', label: 'Warning', icon: MockIcon }],
  useTargetRoles: () => [{ value: 'all', label: 'All' }]
}))
vi.mock('../../../../lib/utils', () => ({ cn: (...a: unknown[]) => a.filter(Boolean).join(' ') }))
vi.mock('../../../../hooks/admin/use-notice-form', () => ({
  useNoticeForm: () => ({
    formData: { title: '', message: '', severity: 'INFO', targetRoles: ['all'], isActive: true, scheduledStartAt: null, scheduledEndAt: null, adGroupIds: [] },
    setFormData: vi.fn(),
    minScheduleDate: new Date().toISOString(),
    parsedStartDate: null,
    isEndDateValid: true,
    toggleRole: vi.fn(),
    isRoleSelected: vi.fn(() => false),
    toggleAdGroup: vi.fn(),
    isAdGroupSelected: vi.fn(() => false),
    resetForm: vi.fn(),
  })
}))
vi.mock('../../../../hooks/admin/use-ad-groups-loader', () => ({
  useAdGroupsLoader: () => ({ adGroups: [], isLoadingGroups: false })
}))
vi.mock('../../../../hooks/admin/use-notice-save', () => ({
  useNoticeSave: () => ({ isSaving: false, handleSave: vi.fn() })
}))

import { NoticeFormModal } from '../notice-form-modal'

describe('NoticeFormModal', () => {
  it('renders nothing when closed', () => {
    const { container } = render(
      <NoticeFormModal open={false} onClose={vi.fn()} onSave={vi.fn()} />
    )
    expect(container.querySelector('[data-testid="dialog"]')).toBeNull()
  })

  it('renders form when open', () => {
    render(<NoticeFormModal open={true} onClose={vi.fn()} onSave={vi.fn()} />)
    expect(screen.getByTestId('dialog')).toBeInTheDocument()
  })

  it('shows create title for new notice', () => {
    render(<NoticeFormModal open={true} onClose={vi.fn()} onSave={vi.fn()} />)
    expect(screen.getByText('Create System Notice')).toBeInTheDocument()
  })

  it('shows edit title for existing notice', () => {
    const existing = { id: '1', title: 'Test', message: 'Hello', severity: 'INFO', targetRoles: ['all'], isActive: true }
    render(<NoticeFormModal open={true} onClose={vi.fn()} onSave={vi.fn()} editNotice={existing as any} />)
    expect(screen.getByText('Edit Notice')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/notices/__tests__/notice-form-sub-components.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../ui/button', () => ({
  Button: ({ children, onClick, disabled, variant }: any) => (
    <button onClick={onClick} disabled={disabled} data-variant={variant}>{children}</button>
  )
}))

vi.mock('../../../ui/label', () => ({
  Label: ({ children, htmlFor, className }: any) => <label htmlFor={htmlFor} className={className}>{children}</label>
}))

vi.mock('../../../ui/switch', () => ({
  Switch: ({ id, checked, onCheckedChange }: any) => (
    <input type="checkbox" data-testid={`switch-${id}`} checked={checked} onChange={() => onCheckedChange?.(!checked)} />
  )
}))

vi.mock('../../../ui/dialog', () => ({
  DialogFooter: ({ children }: any) => <div data-testid="dialog-footer">{children}</div>
}))

vi.mock('lucide-react', () => ({
  Loader2: ({ className }: any) => <span data-testid="loader" className={className} />
}))

import { AdGroupListContent, NoticeFormFooter } from '../notice-form-sub-components'

describe('AdGroupListContent', () => {
  it('shows loading spinner when loading', () => {
    render(<AdGroupListContent isLoading={true} adGroups={[]} isAdGroupSelected={() => false} toggleAdGroup={vi.fn()} />)
    expect(screen.getByTestId('loader')).toBeInTheDocument()
  })

  it('shows empty message when no groups', () => {
    render(<AdGroupListContent isLoading={false} adGroups={[]} isAdGroupSelected={() => false} toggleAdGroup={vi.fn()} />)
    expect(screen.getByText('No AD groups match your search.')).toBeInTheDocument()
  })

  it('renders group list', () => {
    const groups = [
      { groupIdentifier: 'CN=group-1', logicalName: 'UK Retail' },
      { groupIdentifier: 'CN=group-2', logicalName: 'APAC Chat' }
    ]
    render(<AdGroupListContent isLoading={false} adGroups={groups} isAdGroupSelected={() => false} toggleAdGroup={vi.fn()} />)
    expect(screen.getByText('UK Retail')).toBeInTheDocument()
    expect(screen.getByText('APAC Chat')).toBeInTheDocument()
  })

  it('calls toggleAdGroup when switch toggled', () => {
    const toggle = vi.fn()
    const groups = [{ groupIdentifier: 'CN=group-1', logicalName: 'Group 1' }]
    render(<AdGroupListContent isLoading={false} adGroups={groups} isAdGroupSelected={() => false} toggleAdGroup={toggle} />)
    fireEvent.click(screen.getByTestId('switch-adgroup-CN=group-1'))
    expect(toggle).toHaveBeenCalledWith({ groupIdentifier: 'CN=group-1' })
  })

  it('shows checked state when group is selected', () => {
    const groups = [{ groupIdentifier: 'CN=group-1', logicalName: 'Group 1' }]
    render(
      <AdGroupListContent
        isLoading={false}
        adGroups={groups}
        isAdGroupSelected={({ groupIdentifier }) => groupIdentifier === 'CN=group-1'}
        toggleAdGroup={vi.fn()}
      />
    )
    const checkbox = screen.getByTestId('switch-adgroup-CN=group-1') as HTMLInputElement
    expect(checkbox.checked).toBe(true)
  })
})

describe('NoticeFormFooter', () => {
  const baseProps = {
    editNotice: null as any,
    isSaving: false,
    isEndDateValid: true,
    handleSave: vi.fn(),
    handleClose: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders cancel button', () => {
    render(<NoticeFormFooter {...baseProps} />)
    expect(screen.getByText('Cancel')).toBeInTheDocument()
  })

  it('calls handleClose when cancel clicked', () => {
    render(<NoticeFormFooter {...baseProps} />)
    fireEvent.click(screen.getByText('Cancel'))
    expect(baseProps.handleClose).toHaveBeenCalled()
  })

  it('renders Save Draft and Publish Now for new notice', () => {
    render(<NoticeFormFooter {...baseProps} />)
    expect(screen.getByText('Save Draft')).toBeInTheDocument()
    expect(screen.getByText('Publish Now')).toBeInTheDocument()
  })

  it('renders Update Notice for edit mode', () => {
    render(<NoticeFormFooter {...baseProps} editNotice={{ id: '1' } as any} />)
    expect(screen.getByText('Update Notice')).toBeInTheDocument()
    expect(screen.queryByText('Save Draft')).not.toBeInTheDocument()
    expect(screen.queryByText('Publish Now')).not.toBeInTheDocument()
  })

  it('calls handleSave with asDraft=true for Save Draft', () => {
    render(<NoticeFormFooter {...baseProps} />)
    fireEvent.click(screen.getByText('Save Draft'))
    expect(baseProps.handleSave).toHaveBeenCalledWith({ asDraft: true })
  })

  it('calls handleSave with asDraft=false for Publish Now', () => {
    render(<NoticeFormFooter {...baseProps} />)
    fireEvent.click(screen.getByText('Publish Now'))
    expect(baseProps.handleSave).toHaveBeenCalledWith({ asDraft: false })
  })

  it('disables buttons when saving', () => {
    render(<NoticeFormFooter {...baseProps} isSaving={true} />)
    expect(screen.getByText('Cancel')).toBeDisabled()
    expect(screen.getByText('Save Draft')).toBeDisabled()
    expect(screen.getByText('Publish Now')).toBeDisabled()
  })

  it('disables buttons when end date is invalid', () => {
    render(<NoticeFormFooter {...baseProps} isEndDateValid={false} />)
    expect(screen.getByText('Save Draft')).toBeDisabled()
    expect(screen.getByText('Publish Now')).toBeDisabled()
  })
})
===ENDFILE

===FILE: src/components/admin/notices/__tests__/notice-row.test.tsx
import { describe, expect, it, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'

const mockUpdateNoticeStatus = vi.fn()

vi.mock('@/hooks/features/use-notice-config', () => ({
  useNoticeSeverities: () => [
    { value: 'INFO', label: 'Information', icon: () => <span data-testid="info-icon" /> },
    { value: 'WARNING', label: 'Warning', icon: () => <span data-testid="warning-icon" /> },
    { value: 'CRITICAL', label: 'Critical', icon: () => <span data-testid="critical-icon" /> }
  ]
}))

vi.mock('../../../../services/api/admin.service', () => ({
  adminService: {
    updateNoticeStatus: (...args: unknown[]) => mockUpdateNoticeStatus(...args)
  }
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}

vi.mock('../../../../hooks/features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

vi.mock('../../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

vi.mock('lucide-react', () => ({
  Archive: () => <span data-testid="archive-icon" />,
  Play: () => <span data-testid="play-icon" />,
  Pencil: () => <span data-testid="pencil-icon" />
}))

vi.mock('../../../ui/badge', () => ({
  Badge: ({ children, ...rest }: Record<string, unknown>) => (
    <span data-testid="badge" {...rest}>{children as React.ReactNode}</span>
  )
}))

vi.mock('../../../ui/button', () => ({
  Button: ({ children, onClick, disabled, ...rest }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} disabled={disabled as boolean} {...rest}>
      {children as React.ReactNode}
    </button>
  )
}))

vi.mock('../../../ui/table', () => ({
  TableRow: ({ children, className }: { children: React.ReactNode; className?: string }) => (
    <tr className={className}>{children}</tr>
  ),
  TableCell: ({ children, ...rest }: Record<string, unknown>) => <td {...rest}>{children as React.ReactNode}</td>
}))

import { NoticeRow } from '../notice-row'
import type { AdminPermissions } from '../../admin-layout'

const allPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

const baseNotice = {
  id: 'n1',
  title: 'Test Notice',
  message: 'This is a test notice message',
  severity: 'INFO',
  status: 'ACTIVE' as const,
  createdAt: '2025-01-15T10:00:00Z',
  broadcastToAll: false,
  targetRoles: [],
  targetAdGroups: []
}

describe('NoticeRow', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders notice title and message', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('Test Notice')).toBeInTheDocument()
    expect(screen.getByText('This is a test notice message')).toBeInTheDocument()
  })

  it('renders severity badge', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('Information')).toBeInTheDocument()
  })

  it('displays "All Users" for broadcast notices', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={{ ...baseNotice, broadcastToAll: true } as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('All Users')).toBeInTheDocument()
  })

  it('displays role count for targeted notices', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={{ ...baseNotice, targetRoles: ['voice_agent', 'chat_agent'] } as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('2 role(s)')).toBeInTheDocument()
  })

  it('displays AD group count', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={{ ...baseNotice, targetAdGroups: ['g1'] } as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('1 AD group(s)')).toBeInTheDocument()
  })

  it('displays "No targets" when empty', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('No targets')).toBeInTheDocument()
  })

  it('formats date', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('Jan 15, 2025')).toBeInTheDocument()
  })

  it('shows N/A for missing date', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={{ ...baseNotice, createdAt: undefined } as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('N/A')).toBeInTheDocument()
  })

  it('shows archive button for active notices', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByTestId('archive-icon')).toBeInTheDocument()
  })

  it('shows publish and edit buttons for draft notices', () => {
    const draftNotice = { ...baseNotice, status: 'DRAFT' }
    render(
      <table><tbody>
        <NoticeRow
          notice={draftNotice as any}
          onUpdate={vi.fn()}
          onEdit={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByTestId('play-icon')).toBeInTheDocument()
    expect(screen.getByTestId('pencil-icon')).toBeInTheDocument()
  })

  it('hides archive button without permission', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={{ ...allPermissions, canArchiveNotice: false }}
        />
      </tbody></table>
    )
    expect(screen.queryByTestId('archive-icon')).not.toBeInTheDocument()
  })

  it('calls handleArchive on archive click', async () => {
    mockUpdateNoticeStatus.mockResolvedValue({ ...baseNotice, status: 'ARCHIVED' })
    const onUpdate = vi.fn()

    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={onUpdate}
          permissions={allPermissions}
        />
      </tbody></table>
    )

    fireEvent.click(screen.getByText('Archive'))

    await waitFor(() => {
      expect(mockUpdateNoticeStatus).toHaveBeenCalledWith('n1', 'ARCHIVED')
      expect(mockNotifications.success).toHaveBeenCalled()
    })
  })

  it('handles archive error', async () => {
    mockUpdateNoticeStatus.mockRejectedValue(new Error('Failed'))

    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )

    fireEvent.click(screen.getByText('Archive'))

    await waitFor(() => {
      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })

  it('calls handlePublish on publish click', async () => {
    mockUpdateNoticeStatus.mockResolvedValue({ ...baseNotice, status: 'ACTIVE' })
    const draftNotice = { ...baseNotice, status: 'DRAFT' }

    render(
      <table><tbody>
        <NoticeRow
          notice={draftNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )

    fireEvent.click(screen.getByText('Publish'))

    await waitFor(() => {
      expect(mockUpdateNoticeStatus).toHaveBeenCalledWith('n1', 'ACTIVE')
      expect(mockNotifications.success).toHaveBeenCalled()
    })
  })

  it('calls onEdit when edit button clicked', () => {
    const onEdit = vi.fn()
    const draftNotice = { ...baseNotice, status: 'DRAFT' }

    render(
      <table><tbody>
        <NoticeRow
          notice={draftNotice as any}
          onUpdate={vi.fn()}
          onEdit={onEdit}
          permissions={allPermissions}
        />
      </tbody></table>
    )

    fireEvent.click(screen.getByText('Edit'))
    expect(onEdit).toHaveBeenCalledWith(draftNotice)
  })
})
===ENDFILE

===FILE: src/components/admin/notices/notice-action-buttons.tsx
/**
 * Notice Action Buttons - Edit, Publish, and Archive buttons for notice rows.
 */

import { Button } from '../../ui/button'
import { Archive, Play, Pencil } from 'lucide-react'
import type { AdminNoticeResponse } from '../../../services/api/admin.service'
import type { AdminPermissions } from '../admin-layout'

/** Renders the action buttons (Edit, Publish, Archive) for a notice row based on permissions. */
export function NoticeActionButtons({ notice, permissions, onEdit, onPublish, onArchive, isUpdating }: Readonly<{
  notice: AdminNoticeResponse
  permissions: AdminPermissions
  onEdit?: (notice: AdminNoticeResponse) => void
  onPublish: () => void
  onArchive: () => void
  isUpdating: boolean
}>) {
  return (
    <div className="flex items-center justify-end gap-2">
      {notice.status === 'DRAFT' && (
        <>
          {permissions.canEditNotice && onEdit && (
            <Button
              type="button"
              size="sm"
              variant="outline"
              onClick={() => onEdit(notice)}
              disabled={isUpdating}
            >
              <Pencil className="h-3 w-3 mr-1" />
              Edit
            </Button>
          )}
          {permissions.canPublishNotice && (
            <Button
              type="button"
              size="sm"
              variant="outline"
              onClick={onPublish}
              disabled={isUpdating}
            >
              <Play className="h-3 w-3 mr-1" />
              Publish
            </Button>
          )}
        </>
      )}
      {notice.status === 'ACTIVE' && permissions.canArchiveNotice && (
        <Button
          type="button"
          size="sm"
          variant="outline"
          onClick={onArchive}
          disabled={isUpdating}
        >
          <Archive className="h-3 w-3 mr-1" />
          Archive
        </Button>
      )}
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/notices/notice-form-helpers.ts
/**
 * Notice Form Helpers
 * Pure functions for notice form state management and dialog title resolution.
 */

/** Returns the dialog title based on whether editing an existing notice or creating new. */
export function getDialogTitle(isEditing: boolean): string {
  return isEditing ? 'Edit Notice' : 'Create System Notice'
}

/** Returns the dialog description based on whether editing or creating. */
export function getDialogDescription(isEditing: boolean): string {
  return isEditing
    ? 'Update the notice details and save your changes.'
    : 'Create a new system notice to broadcast to users. You can save as a draft or publish immediately.'
}
===ENDFILE

===FILE: src/components/admin/notices/notice-form-modal.tsx
import React, { useState } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle
} from '../../ui/dialog'
import { Input } from '../../ui/input'
import { Label } from '../../ui/label'
import { Textarea } from '../../ui/textarea'
import { Switch } from '../../ui/switch'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../../ui/tabs'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from '../../ui/select'
import { useNoticeSeverities, useTargetRoles } from '@/hooks/features/use-notice-config'
import type { AdminNoticeResponse } from '../../../services/api/admin.service'
import { DateTimePicker } from '../../ui/date-time-picker'
import { useAdGroupsLoader } from '../../../hooks/admin/use-ad-groups-loader'
import { useNoticeForm } from '../../../hooks/admin/use-notice-form'
import { useNoticeSave } from '../../../hooks/admin/use-notice-save'
import { AdGroupListContent, NoticeFormFooter } from './notice-form-sub-components'
import { getDialogTitle, getDialogDescription } from './notice-form-helpers'

/** Re-export sub-components for backward compatibility */
export { AdGroupListContent, NoticeFormFooter } from './notice-form-sub-components'
export { getDialogTitle, getDialogDescription } from './notice-form-helpers'

/** Props for the NoticeFormModal component. */
interface NoticeFormModalProps {
  /** Whether the modal is open */
  open: boolean
  /** Callback invoked when the modal is closed */
  onClose: () => void
  /** Callback invoked after a successful save */
  onSave: () => void
  /** When provided, the form opens in edit mode for this existing notice */
  editNotice?: AdminNoticeResponse | null
}

/**
 * Modal form for creating or editing system notices. Provides two tabs:
 * "Details" for title, message, severity, and acknowledgement settings, and
 * "Targeting & Schedule" for role/AD group targeting and date scheduling.
 */
export function NoticeFormModal({ open, onClose, onSave, editNotice = null }: Readonly<NoticeFormModalProps>) {
  const NOTICE_SEVERITIES = useNoticeSeverities()
  const TARGET_ROLES = useTargetRoles()
  const [activeTab, setActiveTab] = useState('details')
  const [adGroupSearch, setAdGroupSearch] = useState('')

  const {
    formData,
    setFormData,
    minScheduleDate,
    parsedStartDate,
    isEndDateValid,
    toggleRole,
    isRoleSelected,
    toggleAdGroup,
    isAdGroupSelected,
    resetForm
  } = useNoticeForm({ open, editNotice })

  const { adGroups, isLoadingGroups } = useAdGroupsLoader({
    open,
    searchTerm: adGroupSearch
  })

  const { isSaving, handleSave } = useNoticeSave({
    formData,
    editNotice,
    isEndDateValid,
    onSuccess: () => {
      handleClose()
      onSave()
    }
  })

  const handleClose = () => {
    resetForm()
    setActiveTab('details')
    setAdGroupSearch('')
    onClose()
  }

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>{getDialogTitle(!!editNotice)}</DialogTitle>
          <DialogDescription>
            {getDialogDescription(!!editNotice)}
          </DialogDescription>
        </DialogHeader>

        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="details">Details</TabsTrigger>
            <TabsTrigger value="targeting">Targeting & Schedule</TabsTrigger>
          </TabsList>

          <TabsContent value="details" className="space-y-4 mt-4">
            <div className="space-y-2">
              <Label htmlFor="title">Title *</Label>
              <Input
                id="title"
                placeholder="Enter notice title..."
                maxLength={200}
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
              />
              <p className="text-xs text-muted-foreground">
                {`${formData.title?.length || 0}/200 characters`}
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="message">Message *</Label>
              <Textarea
                id="message"
                placeholder="Enter notice message..."
                rows={4}
                maxLength={2000}
                value={formData.message}
                onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => setFormData({ ...formData, message: e.target.value })}
              />
              <p className="text-xs text-muted-foreground">
                {`${formData.message?.length || 0}/2000 characters`}
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="severity">Severity</Label>
              <Select
                value={formData.severity}
                onValueChange={(value: string) => setFormData({ ...formData, severity: value })}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {NOTICE_SEVERITIES.map(sev => {
                    const Icon = sev.icon
                    return (
                      <SelectItem key={sev.value} value={sev.value}>
                        <div className="flex items-center gap-2">
                          <Icon className="h-4 w-4" />
                          {sev.label}
                        </div>
                      </SelectItem>
                    )
                  })}
                </SelectContent>
              </Select>
            </div>

            <div className="flex items-center space-x-2">
              <Switch
                id="requires-ack"
                checked={formData.requiresAcknowledgement}
                onCheckedChange={(checked) =>
                  setFormData({ ...formData, requiresAcknowledgement: checked })
                }
              />
              <Label htmlFor="requires-ack" className="cursor-pointer">
                Requires acknowledgement
              </Label>
            </div>
          </TabsContent>

          <TabsContent value="targeting" className="space-y-4 mt-4">
            <div className="flex items-center space-x-2">
              <Switch
                id="broadcast-all"
                checked={formData.broadcastToAll}
                onCheckedChange={(checked) =>
                  setFormData({ ...formData, broadcastToAll: checked })
                }
              />
              <Label htmlFor="broadcast-all" className="cursor-pointer">
                Broadcast to all users
              </Label>
            </div>

            {!formData.broadcastToAll && (
              <>
                <div className="space-y-2">
                  <Label>Target specific roles</Label>
                  <div className="grid grid-cols-2 gap-2">
                    {TARGET_ROLES.map(role => (
                      <div key={role.value} className="flex items-center space-x-2">
                        <Switch
                          id={`role-${role.value}`}
                          checked={isRoleSelected({ roleValue: role.value })}
                          onCheckedChange={() => toggleRole({ roleValue: role.value })}
                        />
                        <Label
                          htmlFor={`role-${role.value}`}
                          className="cursor-pointer text-sm"
                        >
                          {role.label}
                        </Label>
                      </div>
                    ))}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Target specific AD groups</Label>
                  <Input
                    placeholder="Search AD groups by name, DN, role, or location..."
                    value={adGroupSearch}
                    onChange={(event) => setAdGroupSearch(event.target.value)}
                  />
                  <div className="max-h-48 overflow-y-auto border rounded-md p-3 space-y-2">
                    <AdGroupListContent
                      isLoading={isLoadingGroups}
                      adGroups={adGroups}
                      isAdGroupSelected={isAdGroupSelected}
                      toggleAdGroup={toggleAdGroup}
                    />
                  </div>
                </div>
              </>
            )}

            <DateTimePicker
              id="start-date"
              label="Start Date (optional)"
              value={formData.startAt}
              onChange={(value) => setFormData({ ...formData, startAt: value })}
              minDate={minScheduleDate}
            />

            <div className="space-y-2">
              <DateTimePicker
                id="end-date"
                label="End Date (optional)"
                value={formData.endAt}
                onChange={(value) => setFormData({ ...formData, endAt: value })}
                minDate={parsedStartDate ?? minScheduleDate}
                placeholder="Pick an end date and time"
              />
              {!isEndDateValid && (
                <p className="text-sm text-destructive">
                  End date and time must be after start date and time
                </p>
              )}
            </div>
          </TabsContent>
        </Tabs>

        <NoticeFormFooter
          editNotice={editNotice}
          isSaving={isSaving}
          isEndDateValid={isEndDateValid}
          handleSave={handleSave}
          handleClose={handleClose}
        />
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE

===FILE: src/components/admin/notices/notice-form-sub-components.tsx
/**
 * Notice Form Sub-Components
 * Extracted presentational components used by the NoticeFormModal.
 */

import { Button } from '../../ui/button'
import { Label } from '../../ui/label'
import { Switch } from '../../ui/switch'
import { DialogFooter } from '../../ui/dialog'
import { Loader2 } from 'lucide-react'
import type { AdminNoticeResponse } from '../../../services/api/admin.service'

/** Renders the scrollable list of AD groups with toggle switches for notice targeting. */
export function AdGroupListContent({ isLoading, adGroups, isAdGroupSelected, toggleAdGroup }: Readonly<{
  isLoading: boolean
  adGroups: Array<{ groupIdentifier: string; logicalName?: string }>
  isAdGroupSelected: (args: { groupIdentifier: string }) => boolean
  toggleAdGroup: (args: { groupIdentifier: string }) => void
}>) {
  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-8">
        <Loader2 className="h-5 w-5 animate-spin text-primary" />
      </div>
    )
  }
  if (adGroups.length === 0) {
    return <p className="text-sm text-muted-foreground">No AD groups match your search.</p>
  }
  return (
    <>
      {adGroups.map(group => (
        <div key={group.groupIdentifier} className="flex items-center space-x-2">
          <Switch
            id={`adgroup-${group.groupIdentifier}`}
            checked={isAdGroupSelected({ groupIdentifier: group.groupIdentifier })}
            onCheckedChange={() => toggleAdGroup({ groupIdentifier: group.groupIdentifier })}
          />
          <Label
            htmlFor={`adgroup-${group.groupIdentifier}`}
            className="cursor-pointer text-sm"
          >
            {group.logicalName}
          </Label>
        </div>
      ))}
    </>
  )
}

/** Renders the footer action buttons for the notice form dialog. */
export function NoticeFormFooter({ editNotice, isSaving, isEndDateValid, handleSave, handleClose }: Readonly<{
  editNotice: AdminNoticeResponse | null | undefined
  isSaving: boolean
  isEndDateValid: boolean
  handleSave: (opts: { asDraft: boolean }) => void
  handleClose: () => void
}>) {
  return (
    <DialogFooter>
      <Button variant="outline" onClick={handleClose} disabled={isSaving}>
        Cancel
      </Button>
      {editNotice ? (
        <Button onClick={() => handleSave({ asDraft: true })} disabled={isSaving || !isEndDateValid}>
          {isSaving && <Loader2 className="h-4 w-4 mr-2 animate-spin text-primary" />}
          Update Notice
        </Button>
      ) : (
        <>
          <Button
            variant="outline"
            onClick={() => handleSave({ asDraft: true })}
            disabled={isSaving || !isEndDateValid}
          >
            {isSaving && <Loader2 className="h-4 w-4 mr-2 animate-spin text-primary" />}
            Save Draft
          </Button>
          <Button onClick={() => handleSave({ asDraft: false })} disabled={isSaving || !isEndDateValid}>
            {isSaving && <Loader2 className="h-4 w-4 mr-2 animate-spin text-primary" />}
            Publish Now
          </Button>
        </>
      )}
    </DialogFooter>
  )
}
===ENDFILE

===FILE: src/components/admin/notices/notice-row-helpers.ts
/**
 * Notice Row Helpers - Pure formatting functions for notice display.
 */

import type { AdminNoticeResponse } from '../../../services/api/admin.service'

function countLabel(items: unknown[] | undefined, singular: string): string | null {
  return items && items.length > 0 ? `${items.length} ${singular}(s)` : null
}

/**
 * Formats the targeting information for a notice as a display string.
 * @param notice - The notice to get target display for
 * @returns Human-readable targeting summary
 */
export function getTargetsDisplay(notice: AdminNoticeResponse): string {
  if (notice.broadcastToAll) return 'All Users'
  return countLabel(notice.targetRoles, 'role') ?? countLabel(notice.targetAdGroups, 'AD group') ?? 'No targets'
}

/**
 * Formats a date string into a short localized date (e.g., "Jan 15, 2026").
 * @param dateString - ISO date string or undefined
 * @returns Formatted date string, or 'N/A' if no date provided
 */
export function formatNoticeDate(dateString?: string): string {
  if (!dateString) return 'N/A'
  return new Date(dateString).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  })
}

/** Maps severity codes to their Tailwind CSS class names for badge, dot, and icon styling. */
export const SEVERITY_STYLES: Record<string, { badge: string; dot: string; icon: string }> = {
  INFO: { badge: 'bg-white border-slate-300 text-slate-700', dot: 'bg-slate-500', icon: 'text-slate-500' },
  SUCCESS: { badge: 'bg-white border-emerald-300 text-emerald-700', dot: 'bg-emerald-500', icon: 'text-emerald-500' },
  WARNING: { badge: 'bg-white border-amber-300 text-amber-700', dot: 'bg-amber-500', icon: 'text-amber-500' },
  ERROR: { badge: 'bg-white border-orange-300 text-orange-700', dot: 'bg-orange-500', icon: 'text-orange-500' },
  CRITICAL: { badge: 'bg-white border-red-300 text-red-700', dot: 'bg-red-500', icon: 'text-red-500' }
}
===ENDFILE

===FILE: src/components/admin/notices/notice-row.tsx
import { Badge } from '../../ui/badge'
import { TableCell, TableRow } from '../../ui/table'
import { useNoticeSeverities } from '@/hooks/features/use-notice-config'
import { adminService, type AdminNoticeResponse } from '../../../services/api/admin.service'
import { useState } from 'react'
import { useNotifications } from '../../../hooks/features/use-notifications'
import type { AdminPermissions } from '../admin-layout'
import { cn } from '../../../lib/utils'
import { getTargetsDisplay, formatNoticeDate, SEVERITY_STYLES } from './notice-row-helpers'
import { NoticeActionButtons } from './notice-action-buttons'

/** Props for the NoticeRow component. */
interface NoticeRowProps {
  /** The notice data to render */
  notice: AdminNoticeResponse
  /** Callback invoked when a notice is updated (e.g., published or archived) */
  onUpdate: (updatedNotice: AdminNoticeResponse) => void
  /** Callback invoked when the edit button is clicked */
  onEdit?: (notice: AdminNoticeResponse) => void
  /** Admin permissions controlling which action buttons are visible */
  permissions: AdminPermissions
}

/**
 * Renders a single row in the notices table with severity badge, target display,
 * creation date, and context-aware action buttons. Supports fade-out animation on status change.
 */
export function NoticeRow({ notice, onUpdate, onEdit, permissions }: Readonly<NoticeRowProps>) {
  const NOTICE_SEVERITIES = useNoticeSeverities()
  const [isUpdating, setIsUpdating] = useState(false)
  const [isRemoving, setIsRemoving] = useState(false)
  const notifications = useNotifications()

  const severityConfig = NOTICE_SEVERITIES.find(s => s.value === notice.severity)
  const SeverityIcon = severityConfig?.icon

  const severityStyles = SEVERITY_STYLES

  const handleStatusChange = async (targetStatus: string, successTitle: string, successDescription: string, failTitle: string) => {
    setIsUpdating(true)
    setIsRemoving(true)
    try {
      const updatedNotice = await adminService.updateNoticeStatus(notice.id, targetStatus)
      notifications.success({ title: successTitle, description: successDescription })
      setTimeout(() => { onUpdate(updatedNotice) }, 300)
    } catch (error) {
      setIsRemoving(false)
      notifications.error({ title: failTitle, description: error instanceof Error ? error.message : 'An error occurred' })
    } finally {
      setIsUpdating(false)
    }
  }

  const handleArchive = () => handleStatusChange('ARCHIVED', 'Notice archived', `"${notice.title}" has been archived`, 'Failed to archive')
  const handlePublish = () => handleStatusChange('ACTIVE', 'Notice published', `"${notice.title}" is now active`, 'Failed to publish')

  return (
    <TableRow className={`transition-opacity duration-300 ${isRemoving ? 'opacity-0' : 'opacity-100'}`}>
      <TableCell className="font-medium">
        <div className="flex flex-col">
          <span className="font-semibold">{notice.title}</span>
          <span className="text-xs text-muted-foreground line-clamp-1">
            {notice.message}
          </span>
        </div>
      </TableCell>
      <TableCell>
        <Badge
          variant="outline"
          className={cn(
            'flex items-center gap-2 w-fit px-3 py-1 rounded-full border bg-white shadow-sm text-sm font-medium',
            severityStyles[notice.severity]?.badge ?? 'border-slate-200 text-slate-700'
          )}
        >
          <span
            className={cn(
              'h-2 w-2 rounded-full',
              severityStyles[notice.severity]?.dot ?? 'bg-slate-400'
            )}
          />
          {SeverityIcon && (
            <SeverityIcon
              className={cn(
                'h-4 w-4',
                severityStyles[notice.severity]?.icon ?? 'text-slate-500'
              )}
              aria-hidden
            />
          )}
          <span>{severityConfig?.label}</span>
        </Badge>
      </TableCell>
      <TableCell className="text-sm text-muted-foreground">
        {getTargetsDisplay(notice)}
      </TableCell>
      <TableCell className="text-sm text-muted-foreground">
        {formatNoticeDate(notice.createdAt)}
      </TableCell>
      <TableCell className="text-right">
        <NoticeActionButtons
          notice={notice}
          permissions={permissions}
          onEdit={onEdit}
          onPublish={handlePublish}
          onArchive={handleArchive}
          isUpdating={isUpdating}
        />
      </TableCell>
    </TableRow>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/__tests__/pending-approvals-helpers.test.ts
import { describe, it, expect, vi } from 'vitest'
import { handleTabValueChange, getActivityTotalCount, STATUS_FILTERS } from '../pending-approvals-helpers'

describe('handleTabValueChange', () => {
  it('sets active tab', () => {
    const setActiveTab = vi.fn()
    const setSubmissionFilter = vi.fn()
    const setActivityFilter = vi.fn()

    handleTabValueChange('level-one', setActiveTab, setSubmissionFilter, setActivityFilter)

    expect(setActiveTab).toHaveBeenCalledWith('level-one')
  })

  it('resets submission filter when not on my-submissions tab', () => {
    const setActiveTab = vi.fn()
    const setSubmissionFilter = vi.fn()
    const setActivityFilter = vi.fn()

    handleTabValueChange('level-one', setActiveTab, setSubmissionFilter, setActivityFilter)

    expect(setSubmissionFilter).toHaveBeenCalledWith('all')
  })

  it('does not reset submission filter when on my-submissions tab', () => {
    const setActiveTab = vi.fn()
    const setSubmissionFilter = vi.fn()
    const setActivityFilter = vi.fn()

    handleTabValueChange('my-submissions', setActiveTab, setSubmissionFilter, setActivityFilter)

    expect(setSubmissionFilter).not.toHaveBeenCalled()
  })

  it('resets activity filter when not on my-activity tab', () => {
    const setActiveTab = vi.fn()
    const setSubmissionFilter = vi.fn()
    const setActivityFilter = vi.fn()

    handleTabValueChange('level-one', setActiveTab, setSubmissionFilter, setActivityFilter)

    expect(setActivityFilter).toHaveBeenCalledWith('all')
  })

  it('does not reset activity filter when on my-activity tab', () => {
    const setActiveTab = vi.fn()
    const setSubmissionFilter = vi.fn()
    const setActivityFilter = vi.fn()

    handleTabValueChange('my-activity', setActiveTab, setSubmissionFilter, setActivityFilter)

    expect(setActivityFilter).not.toHaveBeenCalled()
  })
})

describe('getActivityTotalCount', () => {
  it('returns dataCount when filter is all', () => {
    expect(getActivityTotalCount('all', 42, 10)).toBe(42)
  })

  it('returns filteredCount when filter is all and dataCount is undefined', () => {
    expect(getActivityTotalCount('all', undefined, 10)).toBe(10)
  })

  it('returns filteredCount when filter is not all', () => {
    expect(getActivityTotalCount('approvals', 42, 5)).toBe(5)
  })
})

describe('STATUS_FILTERS', () => {
  it('has all filter with empty array', () => {
    expect(STATUS_FILTERS.all).toEqual([])
  })

  it('has pending filter with two statuses', () => {
    expect(STATUS_FILTERS.pending).toHaveLength(2)
  })

  it('has approved filter', () => {
    expect(STATUS_FILTERS.approved).toContain('APPROVED')
  })

  it('has rejected filter', () => {
    expect(STATUS_FILTERS.rejected).toContain('REJECTED')
  })

  it('has cancelled filter', () => {
    expect(STATUS_FILTERS.cancelled).toContain('CANCELLED')
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/__tests__/pending-approvals-sub-components.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('../../../ui/card', () => ({
  Card: ({ children }: any) => <div data-testid="card">{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>
}))

vi.mock('../../../ui/button', () => ({
  Button: ({ children, onClick, variant }: any) => (
    <button onClick={onClick} data-variant={variant}>{children}</button>
  )
}))

vi.mock('lucide-react', () => ({
  AlertCircle: () => <span data-testid="alert-circle" />,
  RefreshCw: () => <span data-testid="refresh-icon" />
}))

import { TabBadge, ErrorCard, TabContentWithError } from '../pending-approvals-sub-components'

describe('TabBadge', () => {
  it('renders badge with count when visible and count > 0', () => {
    render(<TabBadge count={5} className="bg-yellow-100" />)
    expect(screen.getByText('5')).toBeInTheDocument()
  })

  it('returns null when count is 0', () => {
    const { container } = render(<TabBadge count={0} className="bg-yellow-100" />)
    expect(container.innerHTML).toBe('')
  })

  it('returns null when count is negative', () => {
    const { container } = render(<TabBadge count={-1} className="bg-yellow-100" />)
    expect(container.innerHTML).toBe('')
  })

  it('returns null when visible is false', () => {
    const { container } = render(<TabBadge count={5} className="bg-yellow-100" visible={false} />)
    expect(container.innerHTML).toBe('')
  })

  it('renders when visible is explicitly true', () => {
    render(<TabBadge count={3} className="bg-blue-100" visible={true} />)
    expect(screen.getByText('3')).toBeInTheDocument()
  })
})

describe('ErrorCard', () => {
  it('renders error message and retry button', () => {
    render(<ErrorCard onRetry={vi.fn()} />)
    expect(screen.getByText('Unable to Load')).toBeInTheDocument()
    expect(screen.getByText('There was a problem loading the data. Please try again.')).toBeInTheDocument()
    expect(screen.getByText('Retry')).toBeInTheDocument()
  })

  it('calls onRetry when retry button is clicked', () => {
    const onRetry = vi.fn()
    render(<ErrorCard onRetry={onRetry} />)
    fireEvent.click(screen.getByText('Retry'))
    expect(onRetry).toHaveBeenCalledTimes(1)
  })
})

describe('TabContentWithError', () => {
  it('renders children when isError is false', () => {
    render(
      <TabContentWithError isError={false} onRetry={vi.fn()}>
        <div data-testid="child-content">Content</div>
      </TabContentWithError>
    )
    expect(screen.getByTestId('child-content')).toBeInTheDocument()
  })

  it('renders ErrorCard when isError is true', () => {
    render(
      <TabContentWithError isError={true} onRetry={vi.fn()}>
        <div data-testid="child-content">Content</div>
      </TabContentWithError>
    )
    expect(screen.queryByTestId('child-content')).not.toBeInTheDocument()
    expect(screen.getByText('Unable to Load')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/__tests__/pending-approvals-view-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../ui/tabs', () => ({
  Tabs: ({ children, value, onValueChange }: any) => (
    <div data-testid="tabs" data-value={value}>
      <button data-testid="change-tab-my-submissions" onClick={() => onValueChange('my-submissions')}>switch-submissions</button>
      <button data-testid="change-tab-my-activity" onClick={() => onValueChange('my-activity')}>switch-activity</button>
      <button data-testid="change-tab-level-one" onClick={() => onValueChange('level-one')}>switch-level-one</button>
      <button data-testid="change-tab-level-two" onClick={() => onValueChange('level-two')}>switch-level-two</button>
      {children}
    </div>
  ),
  TabsContent: ({ children, value }: any) => <div data-testid={`tab-content-${value}`}>{children}</div>,
  TabsList: ({ children }: any) => <div>{children}</div>,
  TabsTrigger: ({ children, value }: any) => <div data-testid={`tab-trigger-${value}`}>{children}</div>
}))

vi.mock('../../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: any) => <button onClick={onClick} disabled={disabled}>{children}</button>
}))

vi.mock('lucide-react', () => ({
  RefreshCw: ({ className }: any) => <span data-testid="refresh-icon" className={className} />
}))

const mockRefetch = vi.fn()
const mockRefetchActivity = vi.fn()

vi.mock('../../../../hooks/admin/use-pending-changes', () => ({
  usePendingChanges: () => ({
    data: {
      items: [
        { id: '1', status: 'PENDING_LEVEL_ONE', targetGroupName: 'Group A', submittedBy: { displayName: 'User A' } },
        { id: '2', status: 'PENDING_LEVEL_ONE', targetGroupName: 'Group B', submittedBy: { displayName: 'User B' } }
      ],
      counts: { pendingLevelOne: 2, pendingLevelTwo: 1, mySubmissions: 3 }
    },
    isLoading: false,
    isError: false,
    refetch: mockRefetch
  }),
  useMyActivity: () => ({
    data: { items: [], totalCount: 0 },
    isLoading: false,
    isError: false,
    refetch: mockRefetchActivity
  })
}))

vi.mock('../components/approval-request-list', () => ({
  ApprovalRequestList: ({ changes, emptyMessage }: any) => (
    <div data-testid="request-list">
      <span>{emptyMessage}</span>
      {changes?.map((c: any) => <div key={c.id}>{c.targetGroupName}</div>)}
    </div>
  )
}))

vi.mock('../components/activity-history-list', () => ({
  ActivityHistoryList: () => <div data-testid="activity-list" />
}))

vi.mock('../components/approval-stats-cards', () => ({
  ApprovalStatsCards: ({ totalPending, levelOnePending, levelTwoPending }: any) => (
    <div data-testid="stats-cards">Total: {totalPending}, L1: {levelOnePending}, L2: {levelTwoPending}</div>
  )
}))

vi.mock('../components/approval-filter-toggles', () => ({
  SubmissionFilterToggle: ({ value, onChange }: any) => (
    <button data-testid="submission-filter" onClick={() => onChange('pending')}>Filter: {value}</button>
  ),
  ActivityActionFilterToggle: ({ value, onChange }: any) => (
    <button data-testid="activity-filter" onClick={() => onChange('approvals')}>Activity: {value}</button>
  ),
  ActivityTimeRangeToggle: ({ value, onChange }: any) => (
    <button data-testid="time-filter" onClick={() => onChange('7d')}>Time: {value}</button>
  )
}))

vi.mock('../pending-approvals-sub-components', () => ({
  TabBadge: ({ count, className }: any) => <span data-testid="tab-badge" className={className}>{count}</span>,
  ErrorCard: ({ children, onRetry }: any) => <div data-testid="error-card">{children}<button onClick={onRetry}>Retry</button></div>,
  TabContentWithError: ({ children, isError, onRetry }: any) => isError ? <div data-testid="error-wrapper">Error<button onClick={onRetry}>Retry</button></div> : <div>{children}</div>
}))

import { PendingApprovalsView } from '../pending-approvals-view'

describe('PendingApprovalsView - extra coverage', () => {
  const permissions = { canApproveChanges: true } as any

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders page title and description', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    expect(screen.getByText('Pending Approvals')).toBeInTheDocument()
    expect(screen.getByText('Review and approve configuration changes')).toBeInTheDocument()
  })

  it('renders refresh button', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    expect(screen.getByText('Refresh')).toBeInTheDocument()
  })

  it('calls refetch when refresh clicked', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    fireEvent.click(screen.getByText('Refresh'))
    expect(mockRefetch).toHaveBeenCalled()
  })

  it('renders stats cards with correct counts', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    expect(screen.getByText('Total: 3, L1: 2, L2: 1')).toBeInTheDocument()
  })

  it('renders tab badges with counts', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    const badges = screen.getAllByTestId('tab-badge')
    expect(badges.length).toBeGreaterThanOrEqual(2)
  })

  it('renders request list in level-one tab', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    const lists = screen.getAllByTestId('request-list')
    expect(lists.length).toBeGreaterThan(0)
  })

  it('renders my-submissions tab content', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    expect(screen.getByTestId('tab-content-my-submissions')).toBeInTheDocument()
  })

  it('renders my-activity tab content', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    expect(screen.getByTestId('tab-content-my-activity')).toBeInTheDocument()
  })

  it('switches to my-submissions tab', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    fireEvent.click(screen.getByTestId('change-tab-my-submissions'))
    // submission filter toggle should be visible
    expect(screen.getByTestId('submission-filter')).toBeInTheDocument()
  })

  it('switches to my-activity tab', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    fireEvent.click(screen.getByTestId('change-tab-my-activity'))
    expect(screen.getByTestId('activity-filter')).toBeInTheDocument()
    expect(screen.getByTestId('time-filter')).toBeInTheDocument()
  })

  it('renders activity list', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    expect(screen.getByTestId('activity-list')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/__tests__/pending-approvals-view.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../ui/tabs', () => ({
  Tabs: ({ children }: any) => <div data-testid="tabs">{children}</div>,
  TabsContent: ({ children }: any) => <div>{children}</div>,
  TabsList: ({ children }: any) => <div>{children}</div>,
  TabsTrigger: ({ children }: any) => <div data-testid="tab-trigger">{children}</div>
}))
vi.mock('../../../ui/badge', () => ({ Badge: ({ children }: any) => <span>{children}</span> }))
vi.mock('../../../ui/card', () => ({
  Card: ({ children }: any) => <div>{children}</div>,
  CardContent: ({ children }: any) => <div>{children}</div>,
  CardDescription: ({ children }: any) => <div>{children}</div>,
  CardHeader: ({ children }: any) => <div>{children}</div>
}))
vi.mock('../../../ui/toggle-group', () => ({
  ToggleGroup: ({ children }: any) => <div>{children}</div>,
  ToggleGroupItem: ({ children }: any) => <div>{children}</div>
}))
vi.mock('../../../ui/button', () => ({ Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button> }))
vi.mock('lucide-react', () => ({
  AlertCircle: (p: any) => <span {...p} />,
  Clock: (p: any) => <span {...p} />,
  RefreshCw: (p: any) => <span {...p} />
}))
vi.mock('../../../../hooks/admin/use-pending-changes', () => ({
  usePendingChanges: () => ({ data: { changes: [] }, isLoading: false, isError: false, refetch: vi.fn() }),
  useMyActivity: () => ({ data: null, isLoading: false, isError: false, refetch: vi.fn() })
}))
vi.mock('../components/approval-request-list', () => ({
  ApprovalRequestList: () => <div data-testid="request-list" />
}))
vi.mock('../components/activity-history-list', () => ({
  ActivityHistoryList: () => <div data-testid="activity-list" />
}))

import { PendingApprovalsView } from '../pending-approvals-view'

describe('PendingApprovalsView', () => {
  const permissions = { canApprove: true, canMakeChanges: true, canManageNotices: true } as any

  it('renders tabs', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    expect(screen.getByTestId('tabs')).toBeInTheDocument()
  })

  it('renders awaiting review tab trigger', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    expect(screen.getAllByText('Awaiting Review').length).toBeGreaterThan(0)
  })

  it('renders request lists', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    expect(screen.getAllByTestId('request-list').length).toBeGreaterThan(0)
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/__tests__/activity-history-card.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('date-fns', () => ({
  formatDistanceToNow: () => '2 hours ago',
  format: () => 'Jan 1, 2026 12:00 PM'
}))

vi.mock('lucide-react', () => ({
  AlertTriangle: (p: any) => <span data-testid="alert-triangle" {...p} />,
  CheckCircle2: (p: any) => <span data-testid="check-circle" {...p} />,
  MinusCircle: (p: any) => <span data-testid="minus-circle" {...p} />,
  Pencil: (p: any) => <span data-testid="pencil" {...p} />,
  Save: (p: any) => <span data-testid="save" {...p} />,
  XCircle: (p: any) => <span data-testid="x-circle" {...p} />
}))

vi.mock('../../../../ui/card', () => ({
  Card: ({ children }: any) => <div data-testid="card">{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>
}))

vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children }: any) => <span data-testid="badge">{children}</span>
}))

import { ActivityHistoryCard } from '../activity-history-card'

describe('ActivityHistoryCard', () => {
  const baseActivity = {
    id: '1',
    action: 'SUBMIT' as const,
    changeType: 'CONFIG_UPDATE',
    targetGroupName: 'Test Group',
    performedAt: '2026-01-01T12:00:00Z',
    criticalIndicator: false,
    performedBy: 'user1'
  }

  it('renders activity with SUBMIT action', () => {
    render(<ActivityHistoryCard activity={baseActivity as any} />)
    expect(screen.getByText('You submitted')).toBeInTheDocument()
    expect(screen.getByText('Test Group')).toBeInTheDocument()
  })

  it('renders relative time', () => {
    render(<ActivityHistoryCard activity={baseActivity as any} />)
    expect(screen.getByText('2 hours ago')).toBeInTheDocument()
  })

  it('shows Config badge for CONFIG_UPDATE', () => {
    render(<ActivityHistoryCard activity={baseActivity as any} />)
    expect(screen.getByText('Config')).toBeInTheDocument()
  })

  it('shows App badge for APP_UPDATE', () => {
    const appActivity = { ...baseActivity, changeType: 'APP_UPDATE' }
    render(<ActivityHistoryCard activity={appActivity as any} />)
    expect(screen.getByText('App')).toBeInTheDocument()
  })

  it('shows critical indicator when set', () => {
    const critical = { ...baseActivity, criticalIndicator: true }
    render(<ActivityHistoryCard activity={critical as any} />)
    expect(screen.getByText('Critical')).toBeInTheDocument()
    expect(screen.getByTestId('alert-triangle')).toBeInTheDocument()
  })

  it('does not show critical when not set', () => {
    render(<ActivityHistoryCard activity={baseActivity as any} />)
    expect(screen.queryByText('Critical')).not.toBeInTheDocument()
  })

  it('renders L1_APPROVE action', () => {
    const approved = { ...baseActivity, action: 'L1_APPROVE' as const }
    render(<ActivityHistoryCard activity={approved as any} />)
    expect(screen.getByText('You approved (L1)')).toBeInTheDocument()
  })

  it('renders REJECT action', () => {
    const rejected = { ...baseActivity, action: 'REJECT' as const }
    render(<ActivityHistoryCard activity={rejected as any} />)
    expect(screen.getByText('You rejected')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/__tests__/activity-history-list.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  Inbox: (p: any) => <span data-testid="inbox" {...p} />
}))

vi.mock('../../../../ui/skeleton', () => ({
  Skeleton: ({ className }: any) => <div data-testid="skeleton" className={className} />
}))

vi.mock('../../../../ui/card', () => ({
  Card: ({ children }: any) => <div data-testid="card">{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>
}))

vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: any) => <button onClick={onClick} disabled={disabled}>{children}</button>
}))

vi.mock('../activity-history-card', () => ({
  ActivityHistoryCard: ({ activity }: any) => <div data-testid="activity-card">{activity.id}</div>
}))

import { ActivityHistoryList } from '../activity-history-list'

describe('ActivityHistoryList', () => {
  const activities = [
    { id: '1', action: 'SUBMIT', changeType: 'CONFIG_UPDATE', targetGroupName: 'G1', performedAt: '2026-01-01T12:00:00Z', criticalIndicator: false },
    { id: '2', action: 'L1_APPROVE', changeType: 'APP_UPDATE', targetGroupName: 'G2', performedAt: '2026-01-02T12:00:00Z', criticalIndicator: false },
  ]

  it('shows loading skeletons when loading with no data', () => {
    render(<ActivityHistoryList activities={[]} isLoading={true} totalCount={0} page={0} onLoadMore={vi.fn()} />)
    const skeletons = screen.getAllByTestId('skeleton')
    expect(skeletons.length).toBeGreaterThan(0)
  })

  it('shows empty state when no activities', () => {
    render(<ActivityHistoryList activities={[]} isLoading={false} totalCount={0} page={0} onLoadMore={vi.fn()} />)
    expect(screen.getByText('No Activity Yet')).toBeInTheDocument()
  })

  it('renders activity cards', () => {
    render(<ActivityHistoryList activities={activities as any} isLoading={false} totalCount={2} page={0} onLoadMore={vi.fn()} />)
    const cards = screen.getAllByTestId('activity-card')
    expect(cards).toHaveLength(2)
  })

  it('shows load more button when hasMore', () => {
    render(<ActivityHistoryList activities={activities as any} isLoading={false} totalCount={10} page={0} onLoadMore={vi.fn()} />)
    expect(screen.getByText('Load more')).toBeInTheDocument()
  })

  it('does not show load more when all loaded', () => {
    render(<ActivityHistoryList activities={activities as any} isLoading={false} totalCount={2} page={0} onLoadMore={vi.fn()} />)
    expect(screen.queryByText('Load more')).not.toBeInTheDocument()
  })

  it('calls onLoadMore when button clicked', () => {
    const onLoadMore = vi.fn()
    render(<ActivityHistoryList activities={activities as any} isLoading={false} totalCount={10} page={0} onLoadMore={onLoadMore} />)
    fireEvent.click(screen.getByText('Load more'))
    expect(onLoadMore).toHaveBeenCalled()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/__tests__/approval-card-sub-components.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('date-fns', () => ({ formatDistanceToNow: () => '3 hours ago' }))
vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))
vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, className }: any) => <button onClick={onClick} className={className}>{children}</button>
}))
vi.mock('lucide-react', () => ({
  CheckCircle2: (p: any) => <span data-testid="icon-check" {...p} />,
  Clock: (p: any) => <span data-testid="icon-clock" {...p} />,
  XCircle: (p: any) => <span data-testid="icon-x" {...p} />,
  MinusCircle: (p: any) => <span data-testid="icon-minus" {...p} />
}))

import {
  StatusBadge,
  isExpiringSoon,
  ApprovalInfo,
  ResolutionInfo,
  CardActionButtons,
  SeniorReviewSection,
  COMPLETED_STATUSES
} from '../approval-card-sub-components'

describe('StatusBadge', () => {
  it('renders approved badge', () => {
    render(<StatusBadge status="APPROVED" />)
    expect(screen.getByText('Approved')).toBeInTheDocument()
    expect(screen.getByTestId('icon-check')).toBeInTheDocument()
  })

  it('renders rejected badge', () => {
    render(<StatusBadge status="REJECTED" />)
    expect(screen.getByText('Rejected')).toBeInTheDocument()
    expect(screen.getByTestId('icon-x')).toBeInTheDocument()
  })

  it('renders cancelled badge', () => {
    render(<StatusBadge status="CANCELLED" />)
    expect(screen.getByText('Cancelled')).toBeInTheDocument()
    expect(screen.getByTestId('icon-minus')).toBeInTheDocument()
  })

  it('renders expired badge', () => {
    render(<StatusBadge status="EXPIRED" />)
    expect(screen.getByText('Expired')).toBeInTheDocument()
  })

  it('renders pending level one badge', () => {
    render(<StatusBadge status="PENDING_LEVEL_ONE" />)
    expect(screen.getByText('Awaiting Review')).toBeInTheDocument()
  })

  it('renders pending level two badge', () => {
    render(<StatusBadge status="PENDING_LEVEL_TWO" />)
    expect(screen.getByText('Awaiting Sr. Review')).toBeInTheDocument()
  })

  it('returns null for unknown status', () => {
    const { container } = render(<StatusBadge status="UNKNOWN" />)
    expect(container.innerHTML).toBe('')
  })
})

describe('isExpiringSoon', () => {
  it('returns true when expiration is within 24 hours', () => {
    const soon = new Date(Date.now() + 12 * 60 * 60 * 1000).toISOString()
    expect(isExpiringSoon(soon)).toBe(true)
  })

  it('returns false when expiration is more than 24 hours away', () => {
    const later = new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString()
    expect(isExpiringSoon(later)).toBe(false)
  })
})

describe('ApprovalInfo', () => {
  it('renders null when approval is null', () => {
    const { container } = render(<ApprovalInfo approval={null} label="L1" />)
    expect(container.innerHTML).toBe('')
  })

  it('renders approver name and label', () => {
    render(<ApprovalInfo approval={{ approverName: 'Jane Doe' }} label="L1" />)
    expect(screen.getByText(/L1 Approved by Jane Doe/)).toBeInTheDocument()
  })

  it('renders approval date time when provided', () => {
    const approval = {
      approverName: 'Jane Doe',
      approvalDateTime: new Date().toISOString()
    }
    render(<ApprovalInfo approval={approval} label="L2" />)
    expect(screen.getByText(/3 hours ago/)).toBeInTheDocument()
  })

  it('renders without date when approvalDateTime is absent', () => {
    render(<ApprovalInfo approval={{ approverName: 'Bob' }} label="L1" />)
    expect(screen.getByText(/L1 Approved by Bob/)).toBeInTheDocument()
    expect(screen.queryByText(/ago/)).toBeNull()
  })
})

describe('ResolutionInfo', () => {
  it('returns null for non-completed status', () => {
    const change = { status: 'PENDING_LEVEL_ONE' } as any
    const { container } = render(<ResolutionInfo change={change} />)
    expect(container.innerHTML).toBe('')
  })

  it('renders approval info for approved status', () => {
    const change = {
      status: 'APPROVED',
      levelOneApproval: { approverName: 'Alice', approvalDateTime: new Date().toISOString() },
      levelTwoApproval: null,
      matchedRules: []
    } as any
    render(<ResolutionInfo change={change} />)
    expect(screen.getByText(/L1 Approved by Alice/)).toBeInTheDocument()
  })

  it('renders both L1 and L2 approvals when present', () => {
    const change = {
      status: 'APPROVED',
      levelOneApproval: { approverName: 'Alice', approvalDateTime: new Date().toISOString() },
      levelTwoApproval: { approverName: 'Bob', approvalDateTime: new Date().toISOString() },
      matchedRules: []
    } as any
    render(<ResolutionInfo change={change} />)
    expect(screen.getByText(/L1 Approved by Alice/)).toBeInTheDocument()
    expect(screen.getByText(/L2 Approved by Bob/)).toBeInTheDocument()
  })

  it('renders rejection info', () => {
    const change = {
      status: 'REJECTED',
      rejectedBy: { displayName: 'Charlie' },
      rejectedDateTime: new Date().toISOString(),
      rejectionReason: 'Does not meet policy requirements',
      matchedRules: []
    } as any
    render(<ResolutionInfo change={change} />)
    expect(screen.getByText(/Rejected by Charlie/)).toBeInTheDocument()
    expect(screen.getByText(/Does not meet policy requirements/)).toBeInTheDocument()
  })

  it('renders rejection with unknown when rejectedBy is null', () => {
    const change = {
      status: 'REJECTED',
      rejectedBy: null,
      rejectedDateTime: null,
      rejectionReason: null,
      matchedRules: []
    } as any
    render(<ResolutionInfo change={change} />)
    expect(screen.getByText(/Rejected by Unknown/)).toBeInTheDocument()
  })

  it('renders cancelled status', () => {
    const change = { status: 'CANCELLED', matchedRules: [] } as any
    render(<ResolutionInfo change={change} />)
    expect(screen.getByText('Withdrawn by you')).toBeInTheDocument()
  })
})

describe('CardActionButtons', () => {
  it('returns null for completed statuses', () => {
    const change = { status: 'APPROVED', criticalIndicator: false, matchedRules: [] } as any
    const { container } = render(
      <CardActionButtons change={change} onShowApprove={vi.fn()} onShowDecline={vi.fn()} onShowCancel={vi.fn()} />
    )
    expect(container.innerHTML).toBe('')
  })

  it('renders approve button when canApproveIndicator is true', () => {
    const change = {
      status: 'PENDING_LEVEL_ONE',
      criticalIndicator: false,
      canApproveIndicator: true,
      canRejectIndicator: false,
      canCancelIndicator: false,
      matchedRules: []
    } as any
    render(<CardActionButtons change={change} onShowApprove={vi.fn()} onShowDecline={vi.fn()} onShowCancel={vi.fn()} />)
    expect(screen.getByText('Approve')).toBeInTheDocument()
  })

  it('renders Approve (Escalate) for critical level-one', () => {
    const change = {
      status: 'PENDING_LEVEL_ONE',
      criticalIndicator: true,
      canApproveIndicator: true,
      canRejectIndicator: false,
      canCancelIndicator: false,
      matchedRules: []
    } as any
    render(<CardActionButtons change={change} onShowApprove={vi.fn()} onShowDecline={vi.fn()} onShowCancel={vi.fn()} />)
    expect(screen.getByText('Approve (Escalate)')).toBeInTheDocument()
  })

  it('renders Approve for critical level-two (not escalate)', () => {
    const change = {
      status: 'PENDING_LEVEL_TWO',
      criticalIndicator: true,
      canApproveIndicator: true,
      canRejectIndicator: false,
      canCancelIndicator: false,
      matchedRules: []
    } as any
    render(<CardActionButtons change={change} onShowApprove={vi.fn()} onShowDecline={vi.fn()} onShowCancel={vi.fn()} />)
    expect(screen.getByText('Approve')).toBeInTheDocument()
  })

  it('renders decline button when canRejectIndicator is true', () => {
    const change = {
      status: 'PENDING_LEVEL_ONE',
      criticalIndicator: false,
      canApproveIndicator: false,
      canRejectIndicator: true,
      canCancelIndicator: false,
      matchedRules: []
    } as any
    render(<CardActionButtons change={change} onShowApprove={vi.fn()} onShowDecline={vi.fn()} onShowCancel={vi.fn()} />)
    expect(screen.getByText('Decline')).toBeInTheDocument()
  })

  it('renders withdraw button when canCancelIndicator is true', () => {
    const change = {
      status: 'PENDING_LEVEL_ONE',
      criticalIndicator: false,
      canApproveIndicator: false,
      canRejectIndicator: false,
      canCancelIndicator: true,
      matchedRules: []
    } as any
    render(<CardActionButtons change={change} onShowApprove={vi.fn()} onShowDecline={vi.fn()} onShowCancel={vi.fn()} />)
    expect(screen.getByText('Withdraw Request')).toBeInTheDocument()
  })

  it('calls onShowApprove when approve clicked', () => {
    const onShowApprove = vi.fn()
    const change = {
      status: 'PENDING_LEVEL_ONE',
      criticalIndicator: false,
      canApproveIndicator: true,
      canRejectIndicator: false,
      canCancelIndicator: false,
      matchedRules: []
    } as any
    render(<CardActionButtons change={change} onShowApprove={onShowApprove} onShowDecline={vi.fn()} onShowCancel={vi.fn()} />)
    screen.getByText('Approve').click()
    expect(onShowApprove).toHaveBeenCalled()
  })

  it('calls onShowDecline when decline clicked', () => {
    const onShowDecline = vi.fn()
    const change = {
      status: 'PENDING_LEVEL_ONE',
      criticalIndicator: false,
      canApproveIndicator: false,
      canRejectIndicator: true,
      canCancelIndicator: false,
      matchedRules: []
    } as any
    render(<CardActionButtons change={change} onShowApprove={vi.fn()} onShowDecline={onShowDecline} onShowCancel={vi.fn()} />)
    screen.getByText('Decline').click()
    expect(onShowDecline).toHaveBeenCalled()
  })

  it('calls onShowCancel when withdraw clicked', () => {
    const onShowCancel = vi.fn()
    const change = {
      status: 'PENDING_LEVEL_ONE',
      criticalIndicator: false,
      canApproveIndicator: false,
      canRejectIndicator: false,
      canCancelIndicator: true,
      matchedRules: []
    } as any
    render(<CardActionButtons change={change} onShowApprove={vi.fn()} onShowDecline={vi.fn()} onShowCancel={onShowCancel} />)
    screen.getByText('Withdraw Request').click()
    expect(onShowCancel).toHaveBeenCalled()
  })

  it('renders all action buttons when all indicators are true', () => {
    const change = {
      status: 'PENDING_LEVEL_ONE',
      criticalIndicator: false,
      canApproveIndicator: true,
      canRejectIndicator: true,
      canCancelIndicator: true,
      matchedRules: []
    } as any
    render(<CardActionButtons change={change} onShowApprove={vi.fn()} onShowDecline={vi.fn()} onShowCancel={vi.fn()} />)
    expect(screen.getByText('Approve')).toBeInTheDocument()
    expect(screen.getByText('Decline')).toBeInTheDocument()
    expect(screen.getByText('Withdraw Request')).toBeInTheDocument()
  })
})

describe('SeniorReviewSection', () => {
  it('returns null when not critical', () => {
    const change = { criticalIndicator: false, matchedRules: [] } as any
    const { container } = render(<SeniorReviewSection change={change} />)
    expect(container.innerHTML).toBe('')
  })

  it('returns null when critical but no matched rules', () => {
    const change = { criticalIndicator: true, matchedRules: [] } as any
    const { container } = render(<SeniorReviewSection change={change} />)
    expect(container.innerHTML).toBe('')
  })

  it('renders matched rules when critical with rules', () => {
    const change = {
      criticalIndicator: true,
      matchedRules: [
        { entityType: 'permission', entityKey: 'admin_access', reason: 'Admin-level permission change' },
        { entityType: 'app', entityKey: 'banking', reason: 'Critical banking app modification' }
      ]
    } as any
    render(<SeniorReviewSection change={change} />)
    expect(screen.getByText('Why Senior Review Required:')).toBeInTheDocument()
    expect(screen.getByText('Admin-level permission change')).toBeInTheDocument()
    expect(screen.getByText('Critical banking app modification')).toBeInTheDocument()
  })
})

describe('COMPLETED_STATUSES', () => {
  it('contains expected statuses', () => {
    expect(COMPLETED_STATUSES.has('APPROVED')).toBe(true)
    expect(COMPLETED_STATUSES.has('REJECTED')).toBe(true)
    expect(COMPLETED_STATUSES.has('CANCELLED')).toBe(true)
    expect(COMPLETED_STATUSES.has('EXPIRED')).toBe(true)
  })

  it('does not contain pending statuses', () => {
    expect(COMPLETED_STATUSES.has('PENDING_LEVEL_ONE')).toBe(false)
    expect(COMPLETED_STATUSES.has('PENDING_LEVEL_TWO')).toBe(false)
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/__tests__/approval-filter-toggles-extra.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../../ui/toggle-group', () => ({
  ToggleGroup: ({ children, onValueChange, value }: any) => (
    <div data-testid="toggle-group" data-value={value}>
      {typeof children === 'function' ? children : children}
      <input data-testid="toggle-change" onChange={(e: any) => onValueChange?.(e.target.value)} />
    </div>
  ),
  ToggleGroupItem: ({ children, value, ...props }: any) => (
    <button data-testid={`toggle-item-${value}`} data-value={value} {...props}>{children}</button>
  )
}))

import {
  SubmissionFilterToggle,
  ActivityActionFilterToggle,
  ActivityTimeRangeToggle
} from '../../components/approval-filter-toggles'

describe('SubmissionFilterToggle', () => {
  it('renders all submission filter options', () => {
    const onChange = vi.fn()
    render(<SubmissionFilterToggle value="all" onChange={onChange} />)
    expect(screen.getByText('All')).toBeInTheDocument()
    expect(screen.getByText('Pending')).toBeInTheDocument()
    expect(screen.getByText('Approved')).toBeInTheDocument()
    expect(screen.getByText('Rejected')).toBeInTheDocument()
    expect(screen.getByText('Cancelled')).toBeInTheDocument()
  })

  it('calls onChange when toggle value changes', () => {
    const onChange = vi.fn()
    render(<SubmissionFilterToggle value="all" onChange={onChange} />)
    const input = screen.getByTestId('toggle-change')
    fireEvent.change(input, { target: { value: 'pending' } })
    expect(onChange).toHaveBeenCalledWith('pending')
  })

  it('does not call onChange when empty value is provided', () => {
    const onChange = vi.fn()
    render(<SubmissionFilterToggle value="all" onChange={onChange} />)
    const input = screen.getByTestId('toggle-change')
    fireEvent.change(input, { target: { value: '' } })
    // Empty string should not propagate
    expect(onChange).not.toHaveBeenCalled()
  })
})

describe('ActivityActionFilterToggle', () => {
  it('renders all activity action filter options', () => {
    const onChange = vi.fn()
    render(<ActivityActionFilterToggle value="all" onChange={onChange} />)
    expect(screen.getByText('All')).toBeInTheDocument()
    expect(screen.getByText('Approvals')).toBeInTheDocument()
    expect(screen.getByText('Rejections')).toBeInTheDocument()
    expect(screen.getByText('Submissions')).toBeInTheDocument()
    expect(screen.getByText('Direct Saves')).toBeInTheDocument()
  })

  it('calls onChange when value changes', () => {
    const onChange = vi.fn()
    render(<ActivityActionFilterToggle value="all" onChange={onChange} />)
    const input = screen.getByTestId('toggle-change')
    fireEvent.change(input, { target: { value: 'approvals' } })
    expect(onChange).toHaveBeenCalledWith('approvals')
  })
})

describe('ActivityTimeRangeToggle', () => {
  it('renders all time range options', () => {
    const onChange = vi.fn()
    render(<ActivityTimeRangeToggle value="all" onChange={onChange} />)
    expect(screen.getByText('All Time')).toBeInTheDocument()
    expect(screen.getByText('Today')).toBeInTheDocument()
    expect(screen.getByText('This Week')).toBeInTheDocument()
    expect(screen.getByText('This Month')).toBeInTheDocument()
  })

  it('calls onChange when value changes', () => {
    const onChange = vi.fn()
    render(<ActivityTimeRangeToggle value="all" onChange={onChange} />)
    const input = screen.getByTestId('toggle-change')
    fireEvent.change(input, { target: { value: 'today' } })
    expect(onChange).toHaveBeenCalledWith('today')
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/__tests__/approval-filter-toggles.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../../ui/toggle-group', () => ({
  ToggleGroup: ({ children, onValueChange, ...props }: Record<string, unknown>) => (
    <div data-testid="toggle-group" data-value={props.value as string}
      onClick={() => (onValueChange as (v: string) => void)?.('pending')}>
      {children as React.ReactNode}
    </div>
  ),
  ToggleGroupItem: ({ children, value, ...props }: Record<string, unknown>) => (
    <button data-value={value as string} aria-label={props['aria-label'] as string}>
      {children as React.ReactNode}
    </button>
  )
}))

import { SubmissionFilterToggle, ActivityActionFilterToggle, ActivityTimeRangeToggle } from '../approval-filter-toggles'

describe('SubmissionFilterToggle', () => {
  it('renders all submission filter options', () => {
    render(<SubmissionFilterToggle value="all" onChange={vi.fn()} />)
    expect(screen.getByText('All')).toBeInTheDocument()
    expect(screen.getByText('Pending')).toBeInTheDocument()
    expect(screen.getByText('Approved')).toBeInTheDocument()
    expect(screen.getByText('Rejected')).toBeInTheDocument()
    expect(screen.getByText('Cancelled')).toBeInTheDocument()
  })

  it('has aria labels for accessibility', () => {
    render(<SubmissionFilterToggle value="all" onChange={vi.fn()} />)
    expect(screen.getByLabelText('All submissions')).toBeInTheDocument()
    expect(screen.getByLabelText('Pending submissions')).toBeInTheDocument()
  })
})

describe('ActivityActionFilterToggle', () => {
  it('renders all action filter options', () => {
    render(<ActivityActionFilterToggle value="all" onChange={vi.fn()} />)
    expect(screen.getByText('All')).toBeInTheDocument()
    expect(screen.getByText('Approvals')).toBeInTheDocument()
    expect(screen.getByText('Rejections')).toBeInTheDocument()
    expect(screen.getByText('Submissions')).toBeInTheDocument()
    expect(screen.getByText('Direct Saves')).toBeInTheDocument()
  })
})

describe('ActivityTimeRangeToggle', () => {
  it('renders all time range options', () => {
    render(<ActivityTimeRangeToggle value="all" onChange={vi.fn()} />)
    expect(screen.getByText('All Time')).toBeInTheDocument()
    expect(screen.getByText('Today')).toBeInTheDocument()
    expect(screen.getByText('This Week')).toBeInTheDocument()
    expect(screen.getByText('This Month')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/__tests__/approval-request-card.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('date-fns', () => ({ formatDistanceToNow: () => '2 hours ago' }))
vi.mock('../../../../ui/card', () => ({
  Card: ({ children }: any) => <div data-testid="card">{children}</div>,
  CardContent: ({ children }: any) => <div>{children}</div>,
  CardHeader: ({ children }: any) => <div>{children}</div>
}))
vi.mock('../../../../ui/badge', () => ({ Badge: ({ children }: any) => <span data-testid="badge">{children}</span> }))
vi.mock('../../../../ui/button', () => ({ Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button> }))
vi.mock('../../../../ui/collapsible', () => ({
  Collapsible: ({ children }: any) => <div>{children}</div>,
  CollapsibleContent: ({ children }: any) => <div>{children}</div>,
  CollapsibleTrigger: ({ children }: any) => <div>{children}</div>
}))
vi.mock('lucide-react', () => ({
  AlertTriangle: (p: any) => <span {...p} />,
  CheckCircle2: (p: any) => <span {...p} />,
  ChevronDown: (p: any) => <span {...p} />,
  ChevronUp: (p: any) => <span {...p} />,
  Clock: (p: any) => <span {...p} />,
  User: (p: any) => <span {...p} />,
  XCircle: (p: any) => <span {...p} />,
  MinusCircle: (p: any) => <span {...p} />
}))
vi.mock('../what-changed-diff', () => ({
  WhatChangedDiff: () => <div data-testid="what-changed" />
}))
vi.mock('../../dialogs/approval-dialog', () => ({
  ApprovalDialog: () => <div data-testid="approval-dialog" />
}))
vi.mock('../../dialogs/decline-dialog', () => ({
  DeclineDialog: () => <div data-testid="decline-dialog" />
}))
vi.mock('../../dialogs/cancel-dialog', () => ({
  CancelDialog: () => <div data-testid="cancel-dialog" />
}))

import { ApprovalRequestCard } from '../approval-request-card'

const mockChange = {
  id: '1',
  targetGroupName: 'Voice Agent Group',
  status: 'PENDING_LEVEL_ONE',
  criticalIndicator: false,
  submittedBy: { displayName: 'Alice', userId: 'alice' },
  submittedDateTime: new Date().toISOString(),
  expiresDateTime: new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString(),
  matchedRules: [],
  currentState: {},
  proposedState: {},
  appsChanges: [],
  canApprove: true,
  canCancel: false,
  activityLog: []
} as any

describe('ApprovalRequestCard', () => {
  it('renders group name', () => {
    render(<ApprovalRequestCard change={mockChange} onActionComplete={vi.fn()} />)
    expect(screen.getByText('Voice Agent Group')).toBeInTheDocument()
  })

  it('renders status badge', () => {
    render(<ApprovalRequestCard change={mockChange} onActionComplete={vi.fn()} />)
    expect(screen.getAllByText('Awaiting Review').length).toBeGreaterThan(0)
  })

  it('shows critical badge when critical', () => {
    const critical = { ...mockChange, criticalIndicator: true }
    render(<ApprovalRequestCard change={critical} onActionComplete={vi.fn()} />)
    expect(screen.getByText('Requires Sr. Review')).toBeInTheDocument()
  })

  it('renders submitted time', () => {
    render(<ApprovalRequestCard change={mockChange} onActionComplete={vi.fn()} />)
    expect(screen.getByText('2 hours ago')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/__tests__/approval-request-list.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../ui/skeleton', () => ({ Skeleton: ({ className }: any) => <div data-testid="skeleton" className={className} /> }))
vi.mock('../../../../ui/card', () => ({
  Card: ({ children }: any) => <div data-testid="card">{children}</div>,
  CardContent: ({ children }: any) => <div>{children}</div>
}))
vi.mock('lucide-react', () => ({
  Inbox: (p: any) => <span data-testid="inbox-icon" {...p} />
}))
vi.mock('../approval-request-card', () => ({
  ApprovalRequestCard: ({ change }: any) => <div data-testid="request-card">{change.targetGroupName}</div>
}))

import { ApprovalRequestList } from '../approval-request-list'

describe('ApprovalRequestList', () => {
  it('shows skeletons when loading', () => {
    render(<ApprovalRequestList changes={[]} isLoading={true} emptyMessage="No items" onRefresh={vi.fn()} />)
    expect(screen.getAllByTestId('skeleton').length).toBeGreaterThan(0)
  })

  it('shows empty message when no changes', () => {
    render(<ApprovalRequestList changes={[]} isLoading={false} emptyMessage="Nothing here" onRefresh={vi.fn()} />)
    expect(screen.getByText('Nothing here')).toBeInTheDocument()
  })

  it('renders change cards', () => {
    const changes = [
      { id: '1', targetGroupName: 'Group A' },
      { id: '2', targetGroupName: 'Group B' }
    ] as any
    render(<ApprovalRequestList changes={changes} isLoading={false} emptyMessage="" onRefresh={vi.fn()} />)
    expect(screen.getAllByTestId('request-card')).toHaveLength(2)
    expect(screen.getByText('Group A')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/__tests__/approval-stats-cards.test.tsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'

import { vi } from 'vitest'

vi.mock('lucide-react', () => ({
  Clock: () => <span data-testid="clock-icon" />
}))

vi.mock('../../../../ui/card', () => ({
  Card: ({ children }: { children: React.ReactNode }) => <div data-testid="card">{children}</div>,
  CardHeader: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  CardDescription: ({ children }: { children: React.ReactNode }) => <p>{children}</p>,
  CardContent: ({ children }: { children: React.ReactNode }) => <div>{children}</div>
}))

vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children }: { children: React.ReactNode }) => <span data-testid="badge">{children}</span>
}))

import { ApprovalStatsCards } from '../approval-stats-cards'

describe('ApprovalStatsCards', () => {
  it('renders three stat cards', () => {
    render(<ApprovalStatsCards totalPending={10} levelOnePending={6} levelTwoPending={4} />)
    expect(screen.getAllByTestId('card')).toHaveLength(3)
  })

  it('displays total pending count', () => {
    render(<ApprovalStatsCards totalPending={15} levelOnePending={0} levelTwoPending={0} />)
    expect(screen.getByText('15')).toBeInTheDocument()
  })

  it('displays level one pending count', () => {
    render(<ApprovalStatsCards totalPending={0} levelOnePending={8} levelTwoPending={0} />)
    expect(screen.getByText('8')).toBeInTheDocument()
  })

  it('displays level two pending count', () => {
    render(<ApprovalStatsCards totalPending={0} levelOnePending={0} levelTwoPending={3} />)
    expect(screen.getByText('3')).toBeInTheDocument()
  })

  it('renders card descriptions', () => {
    render(<ApprovalStatsCards totalPending={0} levelOnePending={0} levelTwoPending={0} />)
    expect(screen.getByText('Total Pending')).toBeInTheDocument()
    expect(screen.getByText('Awaiting Review')).toBeInTheDocument()
    expect(screen.getByText('Awaiting Senior Review')).toBeInTheDocument()
  })

  it('renders approval level labels', () => {
    render(<ApprovalStatsCards totalPending={0} levelOnePending={0} levelTwoPending={0} />)
    expect(screen.getByText('Level 1 approvals')).toBeInTheDocument()
    expect(screen.getByText('Level 2 approvals')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/__tests__/change-list-sections.test.tsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import { vi } from 'vitest'

vi.mock('lucide-react', () => ({
  Plus: () => <span data-testid="plus-icon" />,
  Minus: () => <span data-testid="minus-icon" />,
  Check: () => <span data-testid="check-icon" />
}))

vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children }: { children: React.ReactNode }) => <span data-testid="badge">{children}</span>
}))

vi.mock('../../../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

import { AppsChangesSection, FunctionsChangesSection } from '../change-list-sections'

describe('AppsChangesSection', () => {
  it('renders Application Changes heading', () => {
    render(<AppsChangesSection appsChanges={{ added: [], removed: [], unchanged: [] }} />)
    expect(screen.getByText('Application Changes')).toBeInTheDocument()
  })

  it('renders added apps as badges', () => {
    render(<AppsChangesSection appsChanges={{ added: ['credit-card'], removed: [], unchanged: [] }} />)
    expect(screen.getByText('Credit Card')).toBeInTheDocument()
  })

  it('renders removed apps as badges', () => {
    render(<AppsChangesSection appsChanges={{ added: [], removed: ['money-transfer'], unchanged: [] }} />)
    expect(screen.getByText('Money Transfer')).toBeInTheDocument()
  })

  it('renders unchanged apps as badges', () => {
    render(<AppsChangesSection appsChanges={{ added: [], removed: [], unchanged: ['payments'] }} />)
    expect(screen.getByText('Payments')).toBeInTheDocument()
  })

  it('renders section labels', () => {
    render(<AppsChangesSection appsChanges={{ added: ['a'], removed: ['b'], unchanged: ['c'] }} />)
    expect(screen.getByText('Added:')).toBeInTheDocument()
    expect(screen.getByText('Removed:')).toBeInTheDocument()
    expect(screen.getByText('Unchanged:')).toBeInTheDocument()
  })

  it('hides empty sections', () => {
    render(<AppsChangesSection appsChanges={{ added: ['a'], removed: [], unchanged: [] }} />)
    expect(screen.getByText('Added:')).toBeInTheDocument()
    expect(screen.queryByText('Removed:')).not.toBeInTheDocument()
    expect(screen.queryByText('Unchanged:')).not.toBeInTheDocument()
  })
})

describe('FunctionsChangesSection', () => {
  it('renders Function Changes heading', () => {
    render(<FunctionsChangesSection functionsChanges={{ added: [], removed: [], unchanged: [] }} />)
    expect(screen.getByText('Function Changes')).toBeInTheDocument()
  })

  it('renders added functions with app:function format', () => {
    render(
      <FunctionsChangesSection functionsChanges={{
        added: [{ app: 'credit-card', function: 'balance-check' }],
        removed: [],
        unchanged: []
      }} />
    )
    expect(screen.getByText(/Credit Card/)).toBeInTheDocument()
    expect(screen.getByText(/Balance Check/)).toBeInTheDocument()
  })

  it('renders removed functions', () => {
    render(
      <FunctionsChangesSection functionsChanges={{
        added: [],
        removed: [{ app: 'money-transfer', function: 'send' }],
        unchanged: []
      }} />
    )
    expect(screen.getByText(/Money Transfer/)).toBeInTheDocument()
    expect(screen.getByText(/Send/)).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/__tests__/diff-computation.test.ts
import { describe, it, expect } from 'vitest'
import { computeDiff, buildSummaryParts, computeChangeSummary } from '../diff-computation'
import type { DiffEntry } from '../diff-computation'

describe('diff-computation', () => {
  describe('computeDiff', () => {
    it('returns empty array when states are identical', () => {
      const state = { logicalName: 'Test Group', roleName: 'voice_agent' }
      expect(computeDiff(state, state)).toEqual([])
    })

    it('detects business field changes', () => {
      const current = { logicalName: 'Old Name', roleName: 'voice_agent' }
      const proposed = { logicalName: 'New Name', roleName: 'voice_agent' }
      const diffs = computeDiff(current, proposed)
      expect(diffs).toHaveLength(1)
      expect(diffs[0].settingName).toBe('Group Name')
      expect(diffs[0].before).toBe('Old Name')
      expect(diffs[0].after).toBe('New Name')
      expect(diffs[0].category).toBe('business')
    })

    it('detects permission changes', () => {
      const current = { permissions: { columns: { chat: { enabledIndicator: true } } } }
      const proposed = { permissions: { columns: { chat: { enabledIndicator: false } } } }
      const diffs = computeDiff(current, proposed)
      expect(diffs.length).toBeGreaterThanOrEqual(1)
      expect(diffs.some(d => d.category === 'permission')).toBe(true)
    })

    it('skips hidden fields', () => {
      const current = { id: '1', createdAt: '2024-01-01', logicalName: 'Test' }
      const proposed = { id: '2', createdAt: '2024-02-01', logicalName: 'Test' }
      const diffs = computeDiff(current, proposed)
      expect(diffs).toHaveLength(0)
    })

    it('handles null/undefined states', () => {
      expect(computeDiff(null as unknown as Record<string, unknown>, {})).toEqual([])
      expect(computeDiff({}, null as unknown as Record<string, unknown>)).toEqual([])
    })

    it('sorts diffs by category: business, permission, application', () => {
      const current = {
        logicalName: 'Old',
        permissions: { columns: { chat: { enabledIndicator: true } } },
        embeddedApps: { 'credit-card': { enabled: true } }
      }
      const proposed = {
        logicalName: 'New',
        permissions: { columns: { chat: { enabledIndicator: false } } },
        embeddedApps: { 'credit-card': { enabled: false } }
      }
      const diffs = computeDiff(current, proposed)
      if (diffs.length >= 2) {
        const categories = diffs.map(d => d.category)
        const businessIdx = categories.indexOf('business')
        const permIdx = categories.indexOf('permission')
        if (businessIdx >= 0 && permIdx >= 0) {
          expect(businessIdx).toBeLessThan(permIdx)
        }
      }
    })
  })

  describe('buildSummaryParts', () => {
    it('returns empty array when no changes', () => {
      expect(buildSummaryParts(0, false, false)).toEqual([])
    })

    it('reports single setting change', () => {
      const parts = buildSummaryParts(1, false, false)
      expect(parts).toEqual(['1 setting will be modified'])
    })

    it('reports multiple setting changes', () => {
      const parts = buildSummaryParts(3, false, false)
      expect(parts).toEqual(['3 settings will be modified'])
    })

    it('includes app changes', () => {
      const parts = buildSummaryParts(0, true, false)
      expect(parts).toContain('Application changes detected')
    })

    it('includes function changes', () => {
      const parts = buildSummaryParts(0, false, true)
      expect(parts).toContain('Function changes detected')
    })

    it('combines all change types', () => {
      const parts = buildSummaryParts(2, true, true)
      expect(parts).toHaveLength(3)
    })

    it('handles null/undefined for boolean params', () => {
      const parts = buildSummaryParts(1, null, undefined)
      expect(parts).toEqual(['1 setting will be modified'])
    })
  })

  describe('computeChangeSummary', () => {
    const makeDiffs = (count: number): DiffEntry[] =>
      Array.from({ length: count }, (_, i) => ({
        settingName: `Setting ${i}`,
        before: 'old',
        after: 'new',
        category: 'business' as const
      }))

    it('returns correct total with no app/function changes', () => {
      const result = computeChangeSummary(makeDiffs(3), null, null)
      expect(result.totalChanges).toBe(3)
      expect(result.hasAppsChanges).toBe(false)
      expect(result.hasFunctionsChanges).toBe(false)
    })

    it('includes app changes in total', () => {
      const appsChanges = { added: ['credit-card'], removed: [], unchanged: [] }
      const result = computeChangeSummary(makeDiffs(2), appsChanges, null)
      expect(result.hasAppsChanges).toBe(true)
      expect(result.totalChanges).toBe(3)
    })

    it('includes function changes in total', () => {
      const functionsChanges = { added: [{ app: 'app', function: 'fn' }], removed: [], unchanged: [] }
      const result = computeChangeSummary(makeDiffs(1), null, functionsChanges)
      expect(result.hasFunctionsChanges).toBe(true)
      expect(result.totalChanges).toBe(2)
    })

    it('filters out Apps diff when appsChanges present', () => {
      const diffs: DiffEntry[] = [
        { settingName: 'Apps', before: 'old', after: 'new', category: 'application' },
        { settingName: 'Region', before: 'APAC', after: 'EMEA', category: 'business' }
      ]
      const appsChanges = { added: ['app1'], removed: [], unchanged: [] }
      const result = computeChangeSummary(diffs, appsChanges, null)
      expect(result.filteredDiffs).toHaveLength(1)
      expect(result.filteredDiffs[0].settingName).toBe('Region')
    })
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/__tests__/diff-format-utils.test.ts
import { describe, it, expect } from 'vitest'
import {
  HIDDEN_FIELDS,
  FIELD_DISPLAY_NAMES,
  formatAppName,
  formatFunctionName,
  formatFieldName,
  formatValue,
  getSettingDisplayName,
  shouldHideField
} from '../diff-format-utils'

describe('diff-format-utils', () => {
  describe('HIDDEN_FIELDS', () => {
    it('contains system metadata fields', () => {
      expect(HIDDEN_FIELDS.has('id')).toBe(true)
      expect(HIDDEN_FIELDS.has('createdAt')).toBe(true)
      expect(HIDDEN_FIELDS.has('updatedAt')).toBe(true)
      expect(HIDDEN_FIELDS.has('userCount')).toBe(true)
    })

    it('does not contain business fields', () => {
      expect(HIDDEN_FIELDS.has('logicalName')).toBe(false)
      expect(HIDDEN_FIELDS.has('roleName')).toBe(false)
    })
  })

  describe('FIELD_DISPLAY_NAMES', () => {
    it('maps business info fields', () => {
      expect(FIELD_DISPLAY_NAMES['logicalName']).toBe('Group Name')
      expect(FIELD_DISPLAY_NAMES['roleName']).toBe('Role Template')
      expect(FIELD_DISPLAY_NAMES['isActive']).toBe('Status')
    })

    it('maps permission fields', () => {
      expect(FIELD_DISPLAY_NAMES['permissions.columns.chat.enabledIndicator']).toBe('Chat Column')
    })
  })

  describe('formatAppName / formatFunctionName', () => {
    it('converts hyphenated names to title case', () => {
      expect(formatAppName('credit-card')).toBe('Credit Card')
      expect(formatFunctionName('money-transfer')).toBe('Money Transfer')
    })

    it('converts underscore names to title case', () => {
      expect(formatAppName('embedded_banking')).toBe('Embedded Banking')
    })

    it('handles single word', () => {
      expect(formatAppName('payments')).toBe('Payments')
    })
  })

  describe('formatFieldName', () => {
    it('strips common prefixes and suffixes', () => {
      expect(formatFieldName('permissions.columns.chat.enabledIndicator')).toBe('Columns.chat')
    })

    it('converts camelCase to title case', () => {
      expect(formatFieldName('businessUnit')).toBe('Business Unit')
    })

    it('handles simple field names', () => {
      expect(formatFieldName('region')).toBe('Region')
    })
  })

  describe('formatValue', () => {
    it('returns dash for null and undefined', () => {
      expect(formatValue(null)).toBe('-')
      expect(formatValue(undefined)).toBe('-')
    })

    it('formats booleans as Enabled/Disabled', () => {
      expect(formatValue(true)).toBe('Enabled')
      expect(formatValue(false)).toBe('Disabled')
    })

    it('formats status strings', () => {
      expect(formatValue('enabled')).toBe('Enabled')
      expect(formatValue('disabled')).toBe('Disabled')
      expect(formatValue('active')).toBe('Enabled')
      expect(formatValue('inactive')).toBe('Disabled')
    })

    it('passes through regular strings', () => {
      expect(formatValue('APAC')).toBe('APAC')
    })

    it('formats numbers as strings', () => {
      expect(formatValue(42)).toBe('42')
    })

    it('returns None for empty array', () => {
      expect(formatValue([])).toBe('None')
    })

    it('joins simple arrays', () => {
      expect(formatValue(['a', 'b'])).toBe('a, b')
    })

    it('formats app assignment objects', () => {
      const obj = { appKey: 'credit-card', functionKeys: ['balance-check'], assignedIndicator: true }
      expect(formatValue(obj)).toBe('Credit Card: Balance Check')
    })

    it('shows Removed for unassigned app objects', () => {
      const obj = { appKey: 'credit-card', functionKeys: [], assignedIndicator: false }
      expect(formatValue(obj)).toBe('Credit Card: Removed')
    })

    it('formats application arrays', () => {
      const apps = [
        { appKey: 'credit-card', functionKeys: ['view'], assignedIndicator: true }
      ]
      expect(formatValue(apps)).toContain('Credit Card: View')
    })

    it('skips unassigned apps in arrays', () => {
      const apps = [
        { appKey: 'credit-card', functionKeys: [], assignedIndicator: false }
      ]
      expect(formatValue(apps)).toBe('None')
    })

    it('handles generic objects by formatting key-value pairs', () => {
      const obj = { region: 'APAC', country: 'HK' }
      const result = formatValue(obj)
      expect(result).toContain('Region')
      expect(result).toContain('APAC')
    })
  })

  describe('getSettingDisplayName', () => {
    it('returns direct mapping when available', () => {
      expect(getSettingDisplayName('logicalName')).toBe('Group Name')
      expect(getSettingDisplayName('roleName')).toBe('Role Template')
    })

    it('handles embedded app paths', () => {
      expect(getSettingDisplayName('embeddedApps.credit-card')).toBe('Credit Card Application')
      expect(getSettingDisplayName('embeddedApps.credit-card.enabled')).toBe('Credit Card Application')
    })

    it('handles function paths', () => {
      expect(getSettingDisplayName('app.functions.balance-check')).toBe('Balance Check Feature')
    })

    it('handles column assignment paths', () => {
      expect(getSettingDisplayName('columnAssignments.chat.state')).toBe('Chat Panel')
    })

    it('falls back to formatted field name', () => {
      const result = getSettingDisplayName('someUnknownField')
      expect(result).toBe('Some Unknown Field')
    })
  })

  describe('shouldHideField', () => {
    it('hides root hidden fields', () => {
      expect(shouldHideField('id')).toBe(true)
      expect(shouldHideField('createdAt')).toBe(true)
      expect(shouldHideField('userCount')).toBe(true)
    })

    it('hides nested paths ending with hidden keys', () => {
      expect(shouldHideField('some.nested.id')).toBe(true)
      expect(shouldHideField('deep.path.updatedAt')).toBe(true)
    })

    it('does not hide business fields', () => {
      expect(shouldHideField('logicalName')).toBe(false)
      expect(shouldHideField('roleName')).toBe(false)
      expect(shouldHideField('region')).toBe(false)
    })
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/__tests__/what-changed-diff.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../../lib/utils', () => ({
  cn: (...a: unknown[]) => a.filter(Boolean).join(' ')
}))

vi.mock('../../../../ui/table', () => ({
  Table: ({ children }: any) => <table data-testid="diff-table">{children}</table>,
  TableBody: ({ children }: any) => <tbody>{children}</tbody>,
  TableCell: ({ children, className }: any) => <td className={className}>{children}</td>,
  TableHead: ({ children, className }: any) => <th className={className}>{children}</th>,
  TableHeader: ({ children }: any) => <thead>{children}</thead>,
  TableRow: ({ children }: any) => <tr>{children}</tr>
}))

vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('lucide-react', () => ({
  Plus: (p: any) => <span data-testid="plus-icon" {...p} />,
  Minus: (p: any) => <span data-testid="minus-icon" {...p} />,
  Check: (p: any) => <span data-testid="check-icon" {...p} />
}))

import { WhatChangedDiff } from '../what-changed-diff'

describe('WhatChangedDiff', () => {
  it('shows no changes message when states are identical', () => {
    const state = { logicalName: 'Group A', roleName: 'voice_agent' }
    render(<WhatChangedDiff currentState={state} proposedState={state} />)
    expect(screen.getByText('No changes detected')).toBeInTheDocument()
  })

  it('renders diff table when business fields differ', () => {
    const current = { logicalName: 'Old Name', roleName: 'voice_agent' }
    const proposed = { logicalName: 'New Name', roleName: 'voice_agent' }
    render(<WhatChangedDiff currentState={current} proposedState={proposed} />)
    expect(screen.getByText('What Changed')).toBeInTheDocument()
    expect(screen.getByText('Old Name')).toBeInTheDocument()
    expect(screen.getByText('New Name')).toBeInTheDocument()
  })

  it('renders app changes section when appsChanges provided', () => {
    const current = { logicalName: 'Group' }
    const proposed = { logicalName: 'Group' }
    const appsChanges = {
      added: ['banking-app'],
      removed: ['old-app'],
      unchanged: ['stable-app']
    }
    render(
      <WhatChangedDiff
        currentState={current}
        proposedState={proposed}
        appsChanges={appsChanges}
      />
    )
    expect(screen.getByText('Application Changes')).toBeInTheDocument()
    expect(screen.getByText('Banking App')).toBeInTheDocument()
    expect(screen.getByText('Old App')).toBeInTheDocument()
  })

  it('renders function changes section when functionsChanges provided', () => {
    const current = { logicalName: 'Group' }
    const proposed = { logicalName: 'Group' }
    const functionsChanges = {
      added: [{ app: 'banking-app', function: 'view-balance' }],
      removed: [{ app: 'banking-app', function: 'edit-profile' }],
      unchanged: []
    }
    render(
      <WhatChangedDiff
        currentState={current}
        proposedState={proposed}
        functionsChanges={functionsChanges}
      />
    )
    expect(screen.getByText('Function Changes')).toBeInTheDocument()
  })

  it('shows boolean changes as Enabled/Disabled', () => {
    const current = { isActive: true }
    const proposed = { isActive: false }
    render(<WhatChangedDiff currentState={current} proposedState={proposed} />)
    expect(screen.getByText('Enabled')).toBeInTheDocument()
    expect(screen.getByText('Disabled')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/activity-history-card.tsx
import { formatDistanceToNow, format } from 'date-fns'
import { Card, CardContent } from '../../../ui/card'
import { Badge } from '../../../ui/badge'
import {
  AlertTriangle,
  CheckCircle2,
  MinusCircle,
  Pencil,
  Save,
  XCircle
} from 'lucide-react'
import type { ActivityLogDto, AuditAction } from '../../../../types/features/approval-workflow.types'

/** Props for the ActivityHistoryCard component. */
interface ActivityHistoryCardProps {
  /** The activity log entry to render */
  activity: ActivityLogDto
}

/** Maps each audit action type to its display icon, colour, and human-readable label. */
const ACTION_CONFIG: Record<AuditAction, { icon: typeof CheckCircle2; colorClass: string; label: string }> = {
  L1_APPROVE: { icon: CheckCircle2, colorClass: 'text-green-600', label: 'You approved (L1)' },
  L2_APPROVE: { icon: CheckCircle2, colorClass: 'text-green-700', label: 'You approved (L2)' },
  REJECT: { icon: XCircle, colorClass: 'text-red-600', label: 'You rejected' },
  SUBMIT: { icon: Pencil, colorClass: 'text-blue-600', label: 'You submitted' },
  CANCEL: { icon: MinusCircle, colorClass: 'text-gray-500', label: 'You withdrew' },
  DIRECT_SAVE: { icon: Save, colorClass: 'text-purple-600', label: 'You saved directly' }
}

/**
 * Renders a single activity log entry as a card showing the action icon,
 * label, target group name, criticality badge, and relative timestamp.
 */
export function ActivityHistoryCard({ activity }: Readonly<ActivityHistoryCardProps>) {
  const config = ACTION_CONFIG[activity.action] ?? ACTION_CONFIG.SUBMIT
  const Icon = config.icon

  const relativeTime = formatDistanceToNow(new Date(activity.performedAt), { addSuffix: true })
  const absoluteTime = format(new Date(activity.performedAt), 'PPpp')

  return (
    <Card>
      <CardContent className="flex items-start gap-3 p-4">
        <div className={`mt-0.5 shrink-0 ${config.colorClass}`}>
          <Icon className="h-5 w-5" />
        </div>
        <div className="flex-1 min-w-0 space-y-1">
          <div className="flex items-center gap-2 flex-wrap">
            <span className="font-medium text-sm">{config.label}</span>
            <Badge variant="outline" className="text-xs">
              {activity.changeType === 'APP_UPDATE' ? 'App' : 'Config'}
            </Badge>
            {activity.criticalIndicator && (
              <Badge variant="outline" className="bg-orange-50 text-orange-700 border-orange-200 text-xs">
                <AlertTriangle className="h-3 w-3 mr-1" />
                Critical
              </Badge>
            )}
          </div>
          <p className="text-sm text-muted-foreground truncate">
            {activity.targetGroupName}
          </p>
          <p className="text-xs text-muted-foreground" title={absoluteTime}>
            {relativeTime}
          </p>
        </div>
      </CardContent>
    </Card>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/activity-history-list.tsx
import { Skeleton } from '../../../ui/skeleton'
import { Card, CardContent } from '../../../ui/card'
import { Button } from '../../../ui/button'
import { Inbox } from 'lucide-react'
import { ActivityHistoryCard } from './activity-history-card'
import type { ActivityLogDto } from '../../../../types/features/approval-workflow.types'

/** Props for the ActivityHistoryList component. */
interface ActivityHistoryListProps {
  /** Array of activity log entries to display */
  activities: ActivityLogDto[]
  /** Whether the activity data is currently being fetched */
  isLoading: boolean
  /** Total number of activity entries available on the server */
  totalCount: number
  /** Current pagination page number */
  page: number
  /** Callback to load the next page of activity entries */
  onLoadMore: () => void
}

/**
 * Renders a paginated list of activity history cards with skeleton loading
 * state, empty state, and a "Load more" button for incremental pagination.
 */
export function ActivityHistoryList({
  activities,
  isLoading,
  totalCount,
  page: _page,
  onLoadMore
}: Readonly<ActivityHistoryListProps>) {
  if (isLoading && activities.length === 0) {
    return (
      <div className="space-y-3">
        {['s1', 's2', 's3', 's4'].map(id => (
          <Card key={id}>
            <CardContent className="p-4">
              <div className="flex items-start gap-3">
                <Skeleton className="h-5 w-5 rounded-full shrink-0" />
                <div className="space-y-2 flex-1">
                  <Skeleton className="h-4 w-40" />
                  <Skeleton className="h-3 w-56" />
                  <Skeleton className="h-3 w-24" />
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    )
  }

  if (activities.length === 0) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-16">
          <Inbox className="h-16 w-16 text-muted-foreground/50 mb-4" />
          <p className="text-lg font-medium text-muted-foreground">
            No Activity Yet
          </p>
          <p className="text-sm text-muted-foreground/70 mt-1">
            Your approval and review activity will appear here.
          </p>
        </CardContent>
      </Card>
    )
  }

  const hasMore = activities.length < totalCount

  return (
    <div className="space-y-3">
      {activities.map((activity) => (
        <ActivityHistoryCard key={activity.id} activity={activity} />
      ))}

      {hasMore && (
        <div className="flex justify-center pt-2">
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={onLoadMore}
            disabled={isLoading}
          >
            {isLoading ? 'Refresh' : 'Load more'}
          </Button>
        </div>
      )}
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/approval-card-sub-components.tsx
/**
 * Approval Card Sub-Components - Status badges, info displays, and action buttons
 * for the approval request card.
 */

import React from 'react'
import { formatDistanceToNow } from 'date-fns'
import { Badge } from '../../../ui/badge'
import { Button } from '../../../ui/button'
import {
  CheckCircle2,
  Clock,
  XCircle,
  MinusCircle
} from 'lucide-react'
import type { PendingChangeDto } from '../../../../types/features/approval-workflow.types'

/** Maps approval statuses to their badge styling, icon, and display label. */
const STATUS_BADGE_CONFIG: Record<string, { className: string; icon: React.ComponentType<{ className?: string }>; label: string }> = {
  APPROVED: { className: 'bg-green-50 text-green-700 border-green-200', icon: CheckCircle2, label: 'Approved' },
  REJECTED: { className: 'bg-red-50 text-red-700 border-red-200', icon: XCircle, label: 'Rejected' },
  CANCELLED: { className: 'bg-gray-50 text-gray-600 border-gray-200', icon: MinusCircle, label: 'Cancelled' },
  EXPIRED: { className: 'bg-gray-50 text-gray-500 border-gray-200', icon: Clock, label: 'Expired' },
  PENDING_LEVEL_ONE: { className: 'bg-yellow-50 text-yellow-700 border-yellow-200', icon: Clock, label: 'Awaiting Review' },
  PENDING_LEVEL_TWO: { className: 'bg-orange-50 text-orange-700 border-orange-200', icon: Clock, label: 'Awaiting Sr. Review' }
}

/** Set of terminal statuses where no further actions can be taken. */
export const COMPLETED_STATUSES = new Set(['APPROVED', 'REJECTED', 'CANCELLED', 'EXPIRED'])

/** Renders a colored badge with icon for the given approval status. */
export function StatusBadge({ status }: Readonly<{ status: string }>) {
  const config = STATUS_BADGE_CONFIG[status]
  if (!config) return null
  const Icon = config.icon
  return (
    <Badge variant="outline" className={config.className}>
      <Icon className="h-3 w-3 mr-1" />
      {config.label}
    </Badge>
  )
}

/** Returns true if the expiration time is less than 24 hours away. */
export function isExpiringSoon(expiresDateTime: string): boolean {
  const hoursRemaining = (new Date(expiresDateTime).getTime() - Date.now()) / (1000 * 60 * 60)
  return hoursRemaining < 24
}

/** Displays approval metadata (approver name and timestamp) for a completed approval level. */
export function ApprovalInfo({ approval, label }: Readonly<{
  approval: { approverName: string; approvalDateTime?: string } | null | undefined
  label: string
}>) {
  if (!approval) return null
  return (
    <p className="text-green-700">
      {`${label} Approved by ${approval.approverName}`}
      {approval.approvalDateTime && (
        <span className="text-muted-foreground ml-1">
          ({formatDistanceToNow(new Date(approval.approvalDateTime), { addSuffix: true })})
        </span>
      )}
    </p>
  )
}

/** Renders the resolution details for completed changes (approved, rejected, or cancelled). */
export function ResolutionInfo({ change }: Readonly<{ change: PendingChangeDto }>) {
  if (!COMPLETED_STATUSES.has(change.status)) return null
  return (
    <div className="rounded-md border p-3 text-sm space-y-1.5">
      {change.status === 'APPROVED' && (
        <>
          <ApprovalInfo approval={change.levelOneApproval} label="L1" />
          <ApprovalInfo approval={change.levelTwoApproval} label="L2" />
        </>
      )}
      {change.status === 'REJECTED' && (
        <>
          <p className="text-red-700">
            {`Rejected by ${change.rejectedBy?.displayName ?? 'Unknown'}`}
            {change.rejectedDateTime && (
              <span className="text-muted-foreground ml-1">
                ({formatDistanceToNow(new Date(change.rejectedDateTime), { addSuffix: true })})
              </span>
            )}
          </p>
          {change.rejectionReason && (
            <p className="text-muted-foreground">
              {`Reason: ${change.rejectionReason}`}
            </p>
          )}
        </>
      )}
      {change.status === 'CANCELLED' && (
        <p className="text-gray-600">Withdrawn by you</p>
      )}
    </div>
  )
}

/** Renders the Approve, Decline, and Withdraw buttons based on the change's permission flags. */
export function CardActionButtons({ change, onShowApprove, onShowDecline, onShowCancel }: Readonly<{
  change: PendingChangeDto
  onShowApprove: () => void
  onShowDecline: () => void
  onShowCancel: () => void
}>) {
  if (COMPLETED_STATUSES.has(change.status)) return null
  const isCritical = change.criticalIndicator
  const isLevelTwo = change.status === 'PENDING_LEVEL_TWO'
  const approveLabel = isCritical && !isLevelTwo ? 'Approve (Escalate)' : 'Approve'
  return (
    <div className="flex justify-end gap-2 pt-2 border-t">
      {change.canCancelIndicator && (
        <Button
          type="button"
          variant="outline"
          className="text-destructive border-destructive hover:bg-destructive/10"
          onClick={onShowCancel}
        >
          Withdraw Request
        </Button>
      )}
      {change.canRejectIndicator && (
        <Button type="button" variant="outline" onClick={onShowDecline}>
          Decline
        </Button>
      )}
      {change.canApproveIndicator && (
        <Button type="button" onClick={onShowApprove}>{approveLabel}</Button>
      )}
    </div>
  )
}

/** Displays the list of rules that triggered senior (L2) review requirement. */
export function SeniorReviewSection({ change }: Readonly<{ change: PendingChangeDto }>) {
  if (!change.criticalIndicator || change.matchedRules.length === 0) return null
  return (
    <div className="mt-4 p-3 bg-orange-50 border border-orange-200 rounded-md">
      <h4 className="font-medium text-orange-800 mb-2">
        Why Senior Review Required:
      </h4>
      <ul className="text-sm text-orange-700 space-y-1">
        {change.matchedRules.map((rule) => (
          <li key={`${rule.entityType}-${rule.entityKey}`} className="flex items-start gap-2">
            <span className="text-orange-500">*</span>
            <span>{rule.reason}</span>
          </li>
        ))}
      </ul>
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/approval-filter-toggles.tsx
/**
 * Approval Filter Toggles
 * Toggle group components for filtering submissions and activity history.
 */

import { ToggleGroup, ToggleGroupItem } from '../../../ui/toggle-group'
import type { ActivityActionFilter, ActivityTimeRange } from '../../../../types/features/approval-workflow.types'

/** Filter options for the user's own submissions tab. */
type SubmissionFilter = 'all' | 'pending' | 'approved' | 'rejected' | 'cancelled'

/** Toggle group allowing the user to filter their submissions by status (all, pending, approved, rejected, cancelled). */
export function SubmissionFilterToggle({ value, onChange }: Readonly<{
  value: SubmissionFilter
  onChange: (v: SubmissionFilter) => void
}>) {
  return (
    <ToggleGroup
      type="single"
      value={value}
      onValueChange={(v) => {
        if (v) onChange(v as SubmissionFilter)
      }}
      className="justify-start"
    >
      <ToggleGroupItem value="all" aria-label="All submissions" className="text-xs px-3">
        All
      </ToggleGroupItem>
      <ToggleGroupItem value="pending" aria-label="Pending submissions" className="text-xs px-3">
        Pending
      </ToggleGroupItem>
      <ToggleGroupItem value="approved" aria-label="Approved submissions" className="text-xs px-3">
        Approved
      </ToggleGroupItem>
      <ToggleGroupItem value="rejected" aria-label="Rejected submissions" className="text-xs px-3">
        Rejected
      </ToggleGroupItem>
      <ToggleGroupItem value="cancelled" aria-label="Cancelled submissions" className="text-xs px-3">
        Cancelled
      </ToggleGroupItem>
    </ToggleGroup>
  )
}

/** Toggle group for filtering activity history by action type (approvals, rejections, submissions, direct saves). */
export function ActivityActionFilterToggle({ value, onChange }: Readonly<{
  value: ActivityActionFilter
  onChange: (v: ActivityActionFilter) => void
}>) {
  return (
    <ToggleGroup
      type="single"
      value={value}
      onValueChange={(v) => {
        if (v) onChange(v as ActivityActionFilter)
      }}
      className="justify-start"
    >
      <ToggleGroupItem value="all" className="text-xs px-3">
        All
      </ToggleGroupItem>
      <ToggleGroupItem value="approvals" className="text-xs px-3">
        Approvals
      </ToggleGroupItem>
      <ToggleGroupItem value="rejections" className="text-xs px-3">
        Rejections
      </ToggleGroupItem>
      <ToggleGroupItem value="submissions" className="text-xs px-3">
        Submissions
      </ToggleGroupItem>
      <ToggleGroupItem value="direct_saves" className="text-xs px-3">
        Direct Saves
      </ToggleGroupItem>
    </ToggleGroup>
  )
}

/** Toggle group for filtering activity history by time range (all time, today, this week, this month). */
export function ActivityTimeRangeToggle({ value, onChange }: Readonly<{
  value: ActivityTimeRange
  onChange: (v: ActivityTimeRange) => void
}>) {
  return (
    <ToggleGroup
      type="single"
      value={value}
      onValueChange={(v) => {
        if (v) onChange(v as ActivityTimeRange)
      }}
      className="justify-start"
    >
      <ToggleGroupItem value="all" className="text-xs px-3">
        All Time
      </ToggleGroupItem>
      <ToggleGroupItem value="today" className="text-xs px-3">
        Today
      </ToggleGroupItem>
      <ToggleGroupItem value="week" className="text-xs px-3">
        This Week
      </ToggleGroupItem>
      <ToggleGroupItem value="month" className="text-xs px-3">
        This Month
      </ToggleGroupItem>
    </ToggleGroup>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/approval-request-card.tsx
/**
 * Approval Request Card
 * Displays a single pending change with actions
 */

import { useState } from 'react'
import { formatDistanceToNow } from 'date-fns'
import { Card, CardContent, CardHeader } from '../../../ui/card'
import { Badge } from '../../../ui/badge'
import { Button } from '../../../ui/button'
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger
} from '../../../ui/collapsible'
import {
  AlertTriangle,
  ChevronDown,
  ChevronUp,
  Clock,
  User,
} from 'lucide-react'
import { WhatChangedDiff } from './what-changed-diff'
import { ApprovalDialog } from '../dialogs/approval-dialog'
import { DeclineDialog } from '../dialogs/decline-dialog'
import { CancelDialog } from '../dialogs/cancel-dialog'
import type { PendingChangeDto } from '../../../../types/features/approval-workflow.types'
import {
  StatusBadge,
  isExpiringSoon,
  ResolutionInfo,
  CardActionButtons,
  SeniorReviewSection
} from './approval-card-sub-components'

/** Props for the ApprovalRequestCard component. */
interface ApprovalRequestCardProps {
  /** The pending change data to display */
  change: PendingChangeDto
  /** Callback invoked after an approval action completes (approve, decline, cancel) */
  onActionComplete: () => void
}

/**
 * Card component displaying a single pending configuration change with collapsible
 * diff details, resolution info, and action buttons for approve, decline, and cancel.
 */
export function ApprovalRequestCard({
  change,
  onActionComplete
}: Readonly<ApprovalRequestCardProps>) {
  const [isExpanded, setIsExpanded] = useState(false)
  const [showApproveDialog, setShowApproveDialog] = useState(false)
  const [showDeclineDialog, setShowDeclineDialog] = useState(false)
  const [showCancelDialog, setShowCancelDialog] = useState(false)

  const submittedAgo = formatDistanceToNow(new Date(change.submittedDateTime), {
    addSuffix: true
  })

  const isCritical = change.criticalIndicator

  return (
    <>
      <Card className="overflow-hidden">
        <CardHeader className="pb-3">
          <div className="flex items-start justify-between">
            <div className="space-y-1">
              <div className="flex items-center gap-2 flex-wrap">
                <h3 className="font-semibold text-lg">
                  {change.targetGroupName}
                </h3>
                <StatusBadge status={change.status} />
                {isCritical && (
                  <Badge
                    variant="outline"
                    className="bg-orange-50 text-orange-700 border-orange-200"
                  >
                    <AlertTriangle className="h-3 w-3 mr-1" />
                    Requires Sr. Review
                  </Badge>
                )}
              </div>
              <div className="flex items-center gap-4 text-sm text-muted-foreground">
                <span className="flex items-center gap-1">
                  <User className="h-3.5 w-3.5" />
                  {`Submitted by ${change.submittedBy.displayName}`}
                </span>
                <span className="flex items-center gap-1">
                  <Clock className="h-3.5 w-3.5" />
                  {submittedAgo}
                </span>
              </div>
            </div>
            {isExpiringSoon(change.expiresDateTime) && (
              <Badge variant="destructive" className="shrink-0">
                Expires soon
              </Badge>
            )}
          </div>
        </CardHeader>

        <CardContent className="space-y-4">
          {/* Collapsible Change Details */}
          <Collapsible open={isExpanded} onOpenChange={setIsExpanded}>
            <CollapsibleTrigger asChild>
              <Button
                variant="ghost"
                size="sm"
                className="w-full justify-between hover:bg-muted/50"
              >
                <span>
                  {isExpanded
                    ? 'Hide Changes'
                    : 'View Changes'}
                </span>
                {isExpanded ? (
                  <ChevronUp className="h-4 w-4" />
                ) : (
                  <ChevronDown className="h-4 w-4" />
                )}
              </Button>
            </CollapsibleTrigger>
            <CollapsibleContent className="mt-4">
              <WhatChangedDiff
                currentState={change.currentState}
                proposedState={change.proposedState}
                appsChanges={change.appsChanges}
                functionsChanges={change.functionsChanges}
              />

              <SeniorReviewSection change={change} />
            </CollapsibleContent>
          </Collapsible>

          {/* Resolution Info (for completed items) */}
          <ResolutionInfo change={change} />

          {/* Action Buttons (hidden for completed items) */}
          <CardActionButtons
            change={change}
            onShowApprove={() => setShowApproveDialog(true)}
            onShowDecline={() => setShowDeclineDialog(true)}
            onShowCancel={() => setShowCancelDialog(true)}
          />
        </CardContent>
      </Card>

      {/* Dialogs */}
      <ApprovalDialog
        open={showApproveDialog}
        onOpenChange={setShowApproveDialog}
        change={change}
        onSuccess={onActionComplete}
      />
      <DeclineDialog
        open={showDeclineDialog}
        onOpenChange={setShowDeclineDialog}
        change={change}
        onSuccess={onActionComplete}
      />
      <CancelDialog
        open={showCancelDialog}
        onOpenChange={setShowCancelDialog}
        change={change}
        onSuccess={onActionComplete}
      />
    </>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/approval-request-list.tsx
/**
 * Approval Request List
 * Displays a list of pending change cards
 */

import { Skeleton } from '../../../ui/skeleton'
import { Card, CardContent } from '../../../ui/card'
import { Inbox } from 'lucide-react'
import { ApprovalRequestCard } from './approval-request-card'
import type { PendingChangeDto } from '../../../../types/features/approval-workflow.types'

/** Props for the ApprovalRequestList component. */
interface ApprovalRequestListProps {
  /** Array of pending changes to render as approval cards */
  changes: PendingChangeDto[]
  /** Whether the list data is being fetched from the API */
  isLoading: boolean
  /** Heading text displayed when the list is empty */
  emptyMessage: string
  /** Optional descriptive text displayed below the empty heading */
  emptyDescription?: string
  /** Callback invoked after an approval action to refresh the list */
  onRefresh: () => void
}

/**
 * Renders a vertical list of ApprovalRequestCard components with skeleton
 * loading placeholders and a configurable empty state message.
 */
export function ApprovalRequestList({
  changes,
  isLoading,
  emptyMessage,
  emptyDescription,
  onRefresh
}: Readonly<ApprovalRequestListProps>) {
  if (isLoading) {
    return (
      <div className="space-y-4">
        {['s1', 's2', 's3'].map(id => (
          <Card key={id}>
            <CardContent className="p-6">
              <div className="space-y-3">
                <Skeleton className="h-5 w-48" />
                <Skeleton className="h-4 w-64" />
                <div className="flex gap-2 mt-4">
                  <Skeleton className="h-9 w-24" />
                  <Skeleton className="h-9 w-24" />
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    )
  }

  if (changes.length === 0) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-16">
          <Inbox className="h-16 w-16 text-muted-foreground/50 mb-4" />
          <p className="text-lg font-medium text-muted-foreground">
            {emptyMessage}
          </p>
          <p className="text-sm text-muted-foreground/70 mt-1">
            {emptyDescription || 'Changes submitted for review will appear here'}
          </p>
        </CardContent>
      </Card>
    )
  }

  return (
    <div className="space-y-4">
      {changes.map((change) => (
        <ApprovalRequestCard
          key={change.id}
          change={change}
          onActionComplete={onRefresh}
        />
      ))}
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/approval-stats-cards.tsx
/**
 * Approval Stats Cards
 * Summary statistics cards for the pending approvals view header.
 */

import { Card, CardContent, CardDescription, CardHeader } from '../../../ui/card'
import { Badge } from '../../../ui/badge'
import { Clock } from 'lucide-react'

/** Props for the ApprovalStatsCards component. */
interface ApprovalStatsCardsProps {
  /** Total number of pending changes awaiting any level of approval */
  totalPending: number
  /** Number of changes awaiting initial (Level 1) review */
  levelOnePending: number
  /** Number of critical changes awaiting senior (Level 2) review */
  levelTwoPending: number
}

/** Renders three summary statistic cards showing total, L1, and L2 pending approval counts. */
export function ApprovalStatsCards({ totalPending, levelOnePending, levelTwoPending }: Readonly<ApprovalStatsCardsProps>) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      <Card>
        <CardHeader className="pb-2">
          <CardDescription>Total Pending</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex items-center gap-2">
            <Clock className="h-5 w-5 text-muted-foreground" />
            <span className="text-2xl font-bold">{totalPending}</span>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader className="pb-2">
          <CardDescription>Awaiting Review</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex items-center gap-2">
            <Badge variant="secondary" className="bg-yellow-100 text-yellow-800">
              {levelOnePending}
            </Badge>
            <span className="text-sm text-muted-foreground">
              Level 1 approvals
            </span>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader className="pb-2">
          <CardDescription>Awaiting Senior Review</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex items-center gap-2">
            <Badge variant="secondary" className="bg-orange-100 text-orange-800">
              {levelTwoPending}
            </Badge>
            <span className="text-sm text-muted-foreground">
              Level 2 approvals
            </span>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/change-list-sections.tsx
/**
 * Change List Sections
 * Sub-components for rendering structured app and function change lists
 * in the What Changed Diff view.
 */

import { Badge } from '../../../ui/badge'
import { cn } from '../../../../lib/utils'
import { Plus, Minus, Check } from 'lucide-react'
import { formatAppName, formatFunctionName } from './diff-format-utils'
import type {
  AppsChangeDetail,
  FunctionsChangeDetail
} from '../../../../types/features/approval-workflow.types'

/** Renders a labelled list of change items with a coloured icon prefix. Returns null when items is empty. */
function ChangeListSection({ icon: Icon, label, iconColor, items, renderItem }: Readonly<{
  icon: React.ComponentType<{ className?: string }>
  label: string
  iconColor: string
  items: unknown[]
  renderItem: (item: unknown, idx: number) => React.ReactNode
}>) {
  if (items.length === 0) return null
  return (
    <div className="flex items-start gap-2">
      <Icon className={cn("h-4 w-4 mt-0.5 shrink-0", iconColor)} />
      <div>
        <span className={cn("text-sm font-medium", iconColor)}>{label}</span>
        <div className="flex flex-wrap gap-1.5 mt-1">
          {items.map((item, idx) => renderItem(item, idx))}
        </div>
      </div>
    </div>
  )
}

/** Displays a card listing added, removed, and unchanged application assignments in the diff view. */
export function AppsChangesSection({ appsChanges }: Readonly<{ appsChanges: AppsChangeDetail }>) {
  return (
    <div className="rounded-md border">
      <div className="p-3 border-b bg-muted/30">
        <h4 className="font-medium">Application Changes</h4>
      </div>
      <div className="p-4 space-y-3">
        <ChangeListSection
          icon={Plus} label="Added:" iconColor="text-green-600"
          items={appsChanges.added}
          renderItem={(app) => (
            <Badge key={app as string} variant="outline" className="bg-green-50 text-green-700 border-green-200">
              {formatAppName(app as string)}
            </Badge>
          )}
        />
        <ChangeListSection
          icon={Minus} label="Removed:" iconColor="text-red-600"
          items={appsChanges.removed}
          renderItem={(app) => (
            <Badge key={app as string} variant="outline" className="bg-red-50 text-red-700 border-red-200">
              {formatAppName(app as string)}
            </Badge>
          )}
        />
        <ChangeListSection
          icon={Check} label="Unchanged:" iconColor="text-muted-foreground"
          items={appsChanges.unchanged}
          renderItem={(app) => (
            <Badge key={app as string} variant="outline" className="text-muted-foreground">
              {formatAppName(app as string)}
            </Badge>
          )}
        />
      </div>
    </div>
  )
}

/** Displays a card listing added and removed function-level assignments in the diff view. */
export function FunctionsChangesSection({ functionsChanges }: Readonly<{ functionsChanges: FunctionsChangeDetail }>) {
  return (
    <div className="rounded-md border">
      <div className="p-3 border-b bg-muted/30">
        <h4 className="font-medium">Function Changes</h4>
      </div>
      <div className="p-4 space-y-3">
        <ChangeListSection
          icon={Plus} label="Added:" iconColor="text-green-600"
          items={functionsChanges.added}
          renderItem={(fn) => {
            const entry = fn as { app: string; function: string }
            return (
              <Badge key={`${entry.app}-${entry.function}`} variant="outline" className="bg-green-50 text-green-700 border-green-200">
                {formatAppName(entry.app)}: {formatFunctionName(entry.function)}
              </Badge>
            )
          }}
        />
        <ChangeListSection
          icon={Minus} label="Removed:" iconColor="text-red-600"
          items={functionsChanges.removed}
          renderItem={(fn) => {
            const entry = fn as { app: string; function: string }
            return (
              <Badge key={`${entry.app}-${entry.function}`} variant="outline" className="bg-red-50 text-red-700 border-red-200">
                {formatAppName(entry.app)}: {formatFunctionName(entry.function)}
              </Badge>
            )
          }}
        />
      </div>
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/diff-computation.ts
/**
 * Diff Computation
 * Logic for computing and categorizing configuration diffs
 * between current and proposed AD group states.
 */

import { formatValue } from './diff-value-formatters'
import { getSettingDisplayName } from './diff-field-resolver'
import { flattenObject, collectRelevantKeys, getFieldCategory } from './diff-object-flattener'
import type {
  AppsChangeDetail,
  FunctionsChangeDetail
} from '../../../../types/features/approval-workflow.types'

/** A single field-level difference between current and proposed AD group state. */
export interface DiffEntry {
  /** Business-friendly field name for display */
  settingName: string
  /** Formatted value before the change */
  before: string
  /** Formatted value after the change */
  after: string
  /** Category for grouping and sorting in the diff view */
  category: 'business' | 'permission' | 'application'
}

// Re-export for consumers
export { flattenObject, collectRelevantKeys, getFieldCategory } from './diff-object-flattener'

const CATEGORY_ORDER: Record<string, number> = { business: 0, permission: 1, application: 2 }

/**
 * Computes a list of field-level differences between current and proposed AD group states.
 * Flattens nested objects, filters to business-relevant fields, and sorts by category.
 * @param currentState - The current AD group configuration
 * @param proposedState - The proposed (new) configuration
 * @returns Sorted array of diff entries grouped by business/permission/application category
 */
function isValueChanged(currentVal: unknown, proposedVal: unknown): boolean {
  return JSON.stringify(currentVal) !== JSON.stringify(proposedVal)
}

function buildDiffEntry(key: string, currentVal: unknown, proposedVal: unknown): DiffEntry | null {
  if (!isValueChanged(currentVal, proposedVal)) return null
  const beforeStr = formatValue(currentVal)
  const afterStr = formatValue(proposedVal)
  if (beforeStr === '-' && afterStr === '-') return null
  return { settingName: getSettingDisplayName(key), before: beforeStr, after: afterStr, category: getFieldCategory(key) }
}

export function computeDiff(
  currentState: Record<string, unknown>,
  proposedState: Record<string, unknown>
): DiffEntry[] {
  const flatCurrent = flattenObject(currentState ?? {})
  const flatProposed = flattenObject(proposedState ?? {})
  const relevantKeys = collectRelevantKeys(flatCurrent, flatProposed)

  const diffs = [...relevantKeys]
    .map(key => buildDiffEntry(key, flatCurrent[key], flatProposed[key]))
    .filter((entry): entry is DiffEntry => entry !== null)

  diffs.sort((a, b) => CATEGORY_ORDER[a.category] - CATEGORY_ORDER[b.category])
  return diffs
}

/**
 * Builds human-readable summary lines for the change overview banner.
 * @returns Array of summary strings (e.g., '3 settings will be modified', 'Application changes detected')
 */
function formatSettingCount(count: number): string {
  return count === 1 ? '1 setting will be modified' : `${count} settings will be modified`
}

export function buildSummaryParts(
  diffCount: number,
  hasAppsChanges: boolean | null | undefined,
  hasFunctionsChanges: boolean | null | undefined
): string[] {
  return [
    diffCount > 0 ? formatSettingCount(diffCount) : '',
    hasAppsChanges ? 'Application changes detected' : '',
    hasFunctionsChanges ? 'Function changes detected' : ''
  ].filter(Boolean)
}

/**
 * Computes a comprehensive change summary combining field diffs with app and function changes.
 * Filters out the generic 'Apps' diff entry when dedicated app change data is available.
 */
function hasAddedOrRemoved(changes: { added: unknown[]; removed: unknown[] } | null | undefined): boolean {
  return Boolean(changes && (changes.added.length > 0 || changes.removed.length > 0))
}

export function computeChangeSummary(
  diffs: DiffEntry[],
  appsChanges: AppsChangeDetail | null | undefined,
  functionsChanges: FunctionsChangeDetail | null | undefined
) {
  const filteredDiffs = appsChanges ? diffs.filter(d => d.settingName !== 'Apps') : diffs
  const hasAppsChanges = hasAddedOrRemoved(appsChanges)
  const hasFunctionsChanges = hasAddedOrRemoved(functionsChanges)
  const totalChanges = filteredDiffs.length + (hasAppsChanges ? 1 : 0) + (hasFunctionsChanges ? 1 : 0)
  return { filteredDiffs, hasAppsChanges, hasFunctionsChanges, totalChanges }
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/diff-field-resolver.ts
/**
 * Diff Field Resolver
 * Functions for resolving display names and visibility of diff field paths.
 */

import {
  HIDDEN_FIELDS,
  FIELD_DISPLAY_NAMES,
  SUFFIX_ENABLED,
  SUFFIX_ASSIGNED,
  PREFIX_EMBEDDED_APPS,
  SEPARATOR_FUNCTIONS
} from './diff-format-constants'
import { formatAppName, formatFunctionName, formatFieldName } from './diff-value-formatters'

/** Removes trailing '.enabled' and '.assignedIndicator' suffixes from a field path segment. */
function stripSuffixes(value: string): string {
  return value.replace(SUFFIX_ENABLED, '').replace(SUFFIX_ASSIGNED, '')
}

/**
 * Resolves a dot-notation field path to a business-friendly display name.
 * Checks direct mappings first, then handles embedded apps, functions, and column paths.
 * @param path - Dot-notation field path (e.g., 'embeddedApps.credit-card.enabled')
 * @returns Human-readable label for the diff table
 */
function resolveSpecialPath(path: string): string | null {
  if (path.startsWith(PREFIX_EMBEDDED_APPS)) return `${formatAppName(stripSuffixes(path.replace(PREFIX_EMBEDDED_APPS, '')))} Application`
  if (path.includes(SEPARATOR_FUNCTIONS)) return `${formatFunctionName(stripSuffixes(path.split(SEPARATOR_FUNCTIONS)[1] ?? path))} Feature`
  if (path.startsWith('columnAssignments.')) return `${formatFieldName(path.split('.')[1])} Panel`
  return null
}

export function getSettingDisplayName(path: string): string {
  return FIELD_DISPLAY_NAMES[path] ?? resolveSpecialPath(path) ?? formatFieldName(path)
}

/**
 * Determines whether a field path should be excluded from the diff display.
 * Checks both the root key and the terminal key against the hidden fields set.
 */
export function shouldHideField(path: string): boolean {
  const parts = path.split('.')
  const rootKey = parts[0]
  const lastKey = parts.at(-1)!
  return HIDDEN_FIELDS.has(rootKey) || HIDDEN_FIELDS.has(lastKey)
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/diff-format-constants.ts
/**
 * Diff Format Constants
 * Hidden fields and display name mappings for the What Changed Diff display.
 */

/**
 * System and metadata fields excluded from the approval diff display.
 * These are internal identifiers, timestamps, or complex nested objects
 * that are either not meaningful to reviewers or rendered in dedicated sections.
 */
export const HIDDEN_FIELDS = new Set([
  'id',
  'createdAt',
  'updatedAt',
  'lastModified',
  'lastModifiedBy',
  'groupIdentifier',
  'adminGroupIdentifier',
  'superAdminGroupIdentifier',
  'userCount',
  'widgetAssignments',
  'featureAssignments',
  'settingsTabAssignments',
  'settingsOptionAssignments',
  'microFrontendAssignments',
  // These are complex nested objects - handle separately if needed
  'columnAssignments',
  // App/function changes are rendered in dedicated sections below the table
  'applicationChanges',
  'appFunctionChanges',
])

/**
 * Maps dot-notation config paths to business-friendly display labels.
 * Used by getSettingDisplayName as the first-priority lookup before pattern-based resolution.
 */
export const FIELD_DISPLAY_NAMES: Record<string, string> = {
  // Business Info fields
  'logicalName': 'Group Name',
  'roleName': 'Role Template',
  'region': 'Region',
  'country': 'Country',
  'market': 'Market',
  'channel': 'Channel',
  'businessUnit': 'Business Unit',
  'isActive': 'Status',
  'activeIndicator': 'Status',

  // Permission fields - columns
  'permissions.widgets.kms.articleViewer.enabledIndicator': 'Knowledge Base Access',
  'permissions.columns.kms.enabledIndicator': 'Knowledge Column',
  'permissions.columns.customer.enabledIndicator': 'Customer Column',
  'permissions.columns.transcript.enabledIndicator': 'Transcript Column',
  'permissions.columns.embeddedApps.enabledIndicator': 'Embedded Apps Column',
  'permissions.columns.chat.enabledIndicator': 'Chat Column',

  // Column state shortcuts
  'columnAssignments.chat.state': 'Chat Panel',
  'columnAssignments.kms.state': 'Knowledge Panel',
  'columnAssignments.customer.state': 'Customer Panel',
  'columnAssignments.transcript.state': 'Transcript Panel',
  'columnAssignments.embeddedApps.state': 'Banking Apps Panel',

  // Application assignments
  'embeddedApps': 'Assigned Applications',
  'applications': 'Assigned Applications',
  'appAssignments': 'Application Access',
}

export const SUFFIX_ENABLED = '.enabled'
export const SUFFIX_ASSIGNED = '.assignedIndicator'
export const PREFIX_EMBEDDED_APPS = 'embeddedApps.'
export const SEPARATOR_FUNCTIONS = '.functions.'
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/diff-format-utils.ts
/**
 * Diff Format Utilities
 * Re-exports from split modules for backward compatibility.
 */

// Constants
export { HIDDEN_FIELDS, FIELD_DISPLAY_NAMES } from './diff-format-constants'

// Value formatters
export { formatAppName, formatFunctionName, formatFieldName, formatValue } from './diff-value-formatters'

// Field resolvers
export { getSettingDisplayName, shouldHideField } from './diff-field-resolver'
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/diff-object-flattener.ts
/**
 * Diff Object Flattener
 * Utilities for flattening nested objects into dot-notation paths for diff comparison.
 */

import { shouldHideField } from './diff-field-resolver'
import { FIELD_DISPLAY_NAMES } from './diff-format-constants'

const BUSINESS_RELEVANT_FIELDS = new Set([
  'logicalName', 'roleName', 'region', 'country', 'businessUnit', 'market', 'isActive'
])

const PREFIX_EMBEDDED_APPS = 'embeddedApps.'
const SEPARATOR_FUNCTIONS = '.functions.'

/**
 * Recursively flattens a nested object into dot-notation key-value pairs.
 * Skips hidden fields and preserves arrays as leaf values.
 * @param obj - Nested object to flatten
 * @param prefix - Accumulated dot-notation prefix for recursion
 * @returns Flat map where keys are dot-notation paths (e.g., 'permissions.columns.chat')
 */
function isNestedObject(value: unknown): value is Record<string, unknown> {
  return value !== null && typeof value === 'object' && !Array.isArray(value)
}

function buildKey(prefix: string, key: string): string {
  return prefix ? `${prefix}.${key}` : key
}

function flattenEntry(result: Record<string, unknown>, key: string, value: unknown): void {
  if (isNestedObject(value)) {
    Object.assign(result, flattenObject(value, key))
    return
  }
  result[key] = value
}

export function flattenObject(
  obj: Record<string, unknown>,
  prefix = ''
): Record<string, unknown> {
  const result: Record<string, unknown> = {}

  for (const [key, value] of Object.entries(obj)) {
    const newKey = buildKey(prefix, key)
    if (!shouldHideField(newKey)) flattenEntry(result, newKey, value)
  }

  return result
}

/** Checks whether a flattened key represents a business-relevant field that should appear in the diff. */
export function isBusinessRelevantKey(key: string): boolean {
  return Boolean(FIELD_DISPLAY_NAMES[key]) ||
    BUSINESS_RELEVANT_FIELDS.has(key) ||
    key.startsWith(PREFIX_EMBEDDED_APPS) ||
    key.includes(SEPARATOR_FUNCTIONS)
}

/**
 * Gathers the union of keys from current and proposed states, keeping only business-relevant ones.
 * All current-state keys are included; proposed keys are filtered by isBusinessRelevantKey.
 */
export function collectRelevantKeys(
  flatCurrent: Record<string, unknown>,
  flatProposed: Record<string, unknown>
): Set<string> {
  const keys = new Set<string>(Object.keys(flatCurrent))
  for (const key of Object.keys(flatProposed)) {
    if (isBusinessRelevantKey(key)) {
      keys.add(key)
    }
  }
  return keys
}

/**
 * Categorizes a field path for grouping in the diff view.
 * Application fields (embeddedApps, functions) sort last; permission fields sort middle; business fields sort first.
 */
const APPLICATION_PATTERNS = ['embeddedApps', 'App', 'function']
const PERMISSION_PREFIXES = ['permissions', 'columnAssignments']

export function getFieldCategory(path: string): 'business' | 'permission' | 'application' {
  if (APPLICATION_PATTERNS.some(p => path.includes(p))) return 'application'
  if (PERMISSION_PREFIXES.some(p => path.startsWith(p))) return 'permission'
  return 'business'
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/diff-value-format-helpers.ts
/**
 * Diff Value Format Helpers - Low-level formatting functions for diff display values.
 */

import { HIDDEN_FIELDS } from './diff-format-constants'

/** Normalizes 'enabled'/'active' strings to title-case display labels. */
export function formatStatusString(value: string): string {
  if (value === 'enabled' || value === 'active') return 'Enabled'
  if (value === 'disabled' || value === 'inactive') return 'Disabled'
  return value
}

/**
 * Converts a kebab-case or snake_case identifier into Title Case for display.
 * Used to render app keys and function keys as human-readable names.
 */
export function formatIdentifierName(key: string): string {
  return key
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ')
}

export const formatAppName = formatIdentifierName
export const formatFunctionName = formatIdentifierName

/**
 * Strips common dot-notation prefixes and converts camelCase field paths
 * into Title Case labels for display in the diff table.
 */
export function formatFieldName(key: string): string {
  const cleanKey = key
    .replace(/^(permissions\.|businessInfo\.|columnAssignments\.|widgetAssignments\.)/, '')
    .replace(/\.(enabledIndicator|state|enabled)$/, '')

  return cleanKey
    .replaceAll(/([A-Z])/g, ' $1')
    .replace(/^./, str => str.toUpperCase())
    .trim()
}

export function formatFunctionList(functions: string[] | undefined): string {
  return functions?.length ? functions.map(f => formatFunctionName(f)).join(', ') : 'All functions'
}

export function isAppObject(app: unknown): app is Record<string, unknown> {
  return typeof app === 'object' && app !== null
}

export function formatSingleAppEntry(app: unknown): string | null {
  if (!isAppObject(app)) return String(app)
  if (app.assignedIndicator === false) return null
  return `${formatAppName((app.appKey as string) || 'Unknown')}: ${formatFunctionList(app.functionKeys as string[])}`
}

/** Renders an array of app assignment objects as a multi-line summary, skipping unassigned apps. */
export function formatApplicationsArray(apps: unknown[]): string {
  const formatted = apps.map(formatSingleAppEntry).filter(Boolean)
  return formatted.length > 0 ? formatted.join('\n') : 'None'
}

export function isAppAssignmentObject(obj: Record<string, unknown>): boolean {
  return 'appKey' in obj && 'functionKeys' in obj
}

export function formatAppAssignment(obj: Record<string, unknown>): string {
  const appKey = obj.appKey as string
  if (!obj.assignedIndicator) return `${formatAppName(appKey)}: Removed`
  return `${formatAppName(appKey)}: ${formatFunctionList(obj.functionKeys as string[])}`
}

/** Formats a nested object as a display string, with special handling for app assignment shapes. */
export function formatObjectValue(obj: Record<string, unknown>, formatValue: (value: unknown) => string): string {
  if (isAppAssignmentObject(obj)) return formatAppAssignment(obj)

  const entries = Object.entries(obj)
    .filter(([key]) => !HIDDEN_FIELDS.has(key))
    .map(([key, val]) => `${formatFieldName(key)}: ${formatValue(val)}`)

  return entries.length > 0 ? entries.join(', ') : '-'
}

/** Routes array formatting based on element type: objects use app formatting, primitives join with commas. */
export function formatArrayValue(value: unknown[]): string {
  if (value.length === 0) return 'None'
  if (typeof value[0] === 'object') return formatApplicationsArray(value)
  return value.join(', ')
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/diff-value-formatters.ts
/**
 * Diff Value Formatters
 * Pure formatting functions for converting raw field values
 * into business-friendly display strings.
 */

import {
  formatStatusString,
  formatArrayValue,
  formatObjectValue
} from './diff-value-format-helpers'

// Re-export all helpers for consumers
export {
  formatIdentifierName,
  formatAppName,
  formatFunctionName,
  formatFieldName,
  formatFunctionList,
  formatSingleAppEntry,
  formatApplicationsArray,
  formatAppAssignment
} from './diff-value-format-helpers'

const TYPE_FORMATTERS: Record<string, (v: unknown) => string> = {
  boolean: (v) => (v as boolean) ? 'Enabled' : 'Disabled',
  string: (v) => formatStatusString(v as string),
  number: String,
  bigint: String
}

function formatByType(value: unknown): string | null {
  if (Array.isArray(value)) return formatArrayValue(value)
  const formatter = TYPE_FORMATTERS[typeof value]
  if (formatter) return formatter(value)
  if (typeof value === 'object') return formatObjectValue(value as Record<string, unknown>, formatValue)
  return null
}

/**
 * Converts any raw config value into a human-readable string for diff display.
 * Handles null, boolean, array, object, string, and number types with business-friendly labels.
 */
export function formatValue(value: unknown): string {
  if (value === null || value === undefined) return '-'
  return formatByType(value) ?? '-'
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/components/what-changed-diff.tsx
/**
 * What Changed Diff
 * Displays a comparison table of before/after configuration changes
 * Uses business-friendly labels and filters out system/metadata fields
 */

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow
} from '../../../ui/table'
import { cn } from '../../../../lib/utils'
import type {
  AppsChangeDetail,
  FunctionsChangeDetail
} from '../../../../types/features/approval-workflow.types'
import { computeDiff, computeChangeSummary, buildSummaryParts } from './diff-computation'
import { AppsChangesSection, FunctionsChangesSection } from './change-list-sections'
import type { DiffEntry } from './diff-computation'

/** Props for the WhatChangedDiff component. */
interface WhatChangedDiffProps {
  /** Current AD group configuration snapshot */
  currentState: Record<string, unknown>
  /** Proposed new configuration to compare against current */
  proposedState: Record<string, unknown>
  /** Optional structured application assignment changes (added/removed/unchanged) */
  appsChanges?: AppsChangeDetail | null
  /** Optional structured function-level assignment changes (added/removed) */
  functionsChanges?: FunctionsChangeDetail | null
}

/** Renders a single row in the settings diff table with before/after colour coding. */
function DiffTableRow({ diff }: Readonly<{ diff: DiffEntry }>) {
  return (
    <TableRow key={diff.settingName}>
      <TableCell className="font-medium align-top break-words">{diff.settingName}</TableCell>
      <TableCell className="align-top">
        <span
          className={cn(
            'inline-block max-w-full whitespace-pre-wrap break-words rounded px-2 py-0.5 text-sm leading-relaxed',
            diff.before !== '-' && 'bg-red-50 text-red-700'
          )}
        >
          {diff.before}
        </span>
      </TableCell>
      <TableCell className="align-top">
        <span
          className={cn(
            'inline-block max-w-full whitespace-pre-wrap break-words rounded px-2 py-0.5 text-sm leading-relaxed',
            diff.after !== '-' && 'bg-green-50 text-green-700'
          )}
        >
          {diff.after}
        </span>
      </TableCell>
    </TableRow>
  )
}

/** Renders the three-column (Setting, Before, After) comparison table for changed settings. */
function SettingsDiffTable({ diffs }: Readonly<{ diffs: DiffEntry[] }>) {
  if (diffs.length === 0) return null
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead className="w-[40%] whitespace-nowrap">Setting</TableHead>
          <TableHead className="w-[30%] whitespace-nowrap">Before</TableHead>
          <TableHead className="w-[30%] whitespace-nowrap">After</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {diffs.map((diff) => (
          <DiffTableRow key={diff.settingName} diff={diff} />
        ))}
      </TableBody>
    </Table>
  )
}

/**
 * Composite diff view that combines a settings comparison table with
 * dedicated app and function change sections. Computes diffs from raw
 * current/proposed state objects and renders a human-readable summary.
 */
export function WhatChangedDiff({
  currentState,
  proposedState,
  appsChanges,
  functionsChanges
}: Readonly<WhatChangedDiffProps>) {
  const diffs = computeDiff(currentState, proposedState)
  const { filteredDiffs, hasAppsChanges, hasFunctionsChanges, totalChanges } = computeChangeSummary(diffs, appsChanges, functionsChanges)

  if (totalChanges === 0) {
    return (
      <div className="text-center py-4 text-muted-foreground">
        No changes detected
      </div>
    )
  }

  const summaryParts = buildSummaryParts(filteredDiffs.length, hasAppsChanges, hasFunctionsChanges)

  return (
    <div className="space-y-4">
      <div className="rounded-md border">
        <div className="p-3 border-b bg-muted/30">
          <h4 className="font-medium">What Changed</h4>
          <p className="text-sm text-muted-foreground mt-0.5">
            {summaryParts.join('  ')}
          </p>
        </div>
        <SettingsDiffTable diffs={filteredDiffs} />
      </div>

      {hasAppsChanges && appsChanges && (
        <AppsChangesSection appsChanges={appsChanges} />
      )}

      {hasFunctionsChanges && functionsChanges && (
        <FunctionsChangesSection functionsChanges={functionsChanges} />
      )}
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/dialogs/__tests__/approval-dialog-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'

const mockMutateAsync = vi.fn()
vi.mock('../../../../../hooks/admin/use-pending-changes', () => ({
  useApproveChange: () => ({
    mutateAsync: mockMutateAsync,
    isPending: false
  })
}))

const mockNotify = vi.fn()
vi.mock('../../../../../hooks/common/use-toast', () => ({
  useToast: () => ({ notify: mockNotify })
}))

vi.mock('../../../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))

vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: any) => (
    <button onClick={onClick} disabled={disabled}>{children}</button>
  )
}))

vi.mock('../../../../ui/textarea', () => ({
  Textarea: ({ id, value, onChange, placeholder }: any) => (
    <textarea data-testid={id} value={value} onChange={onChange} placeholder={placeholder} />
  )
}))

vi.mock('../../../../ui/label', () => ({
  Label: ({ children }: any) => <label>{children}</label>
}))

vi.mock('../../../../ui/alert', () => ({
  Alert: ({ children }: any) => <div data-testid="alert">{children}</div>,
  AlertDescription: ({ children }: any) => <div>{children}</div>
}))

vi.mock('lucide-react', () => ({
  AlertTriangle: () => <span data-testid="alert-triangle" />,
  Loader2: () => <span data-testid="loader" />
}))

vi.mock('../change-info-section', () => ({
  ChangeInfoSection: ({ change }: any) => <div data-testid="change-info">{change.targetGroupName}</div>
}))

import { ApprovalDialog } from '../approval-dialog'

const mockChange = {
  id: 'change-1',
  targetGroupName: 'Test Group',
  status: 'PENDING_LEVEL_ONE' as const,
  criticalIndicator: false,
  matchedRules: [],
  submittedBy: { displayName: 'John Doe' },
  submittedDateTime: '2025-01-15T10:00:00Z',
  expiresDateTime: '2025-02-15T10:00:00Z',
  currentState: {},
  proposedState: {},
  canApproveIndicator: true,
  canRejectIndicator: true,
  canCancelIndicator: false,
  levelOneApproval: null,
  levelTwoApproval: null,
  rejectedBy: null,
  rejectedDateTime: null,
  rejectionReason: null,
  appsChanges: [],
  functionsChanges: []
}

describe('ApprovalDialog', () => {
  const defaultProps = {
    open: true,
    onOpenChange: vi.fn(),
    change: mockChange as any,
    onSuccess: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders dialog when open', () => {
    render(<ApprovalDialog {...defaultProps} />)
    expect(screen.getAllByText('Confirm Approval').length).toBeGreaterThanOrEqual(1)
  })

  it('does not render when closed', () => {
    render(<ApprovalDialog {...defaultProps} open={false} />)
    expect(screen.queryByText('Confirm Approval')).not.toBeInTheDocument()
  })

  it('shows escalation title for critical non-L2 changes', () => {
    const criticalChange = { ...mockChange, criticalIndicator: true }
    render(<ApprovalDialog {...defaultProps} change={criticalChange as any} />)
    expect(screen.getAllByText('Approve and Escalate').length).toBeGreaterThanOrEqual(1)
  })

  it('shows escalation warning for critical changes', () => {
    const criticalChange = {
      ...mockChange,
      criticalIndicator: true,
      matchedRules: [{ entityType: 'PERMISSION', entityKey: 'key1', reason: 'Critical permission change' }]
    }
    render(<ApprovalDialog {...defaultProps} change={criticalChange as any} />)
    expect(screen.getByTestId('alert')).toBeInTheDocument()
  })

  it('shows confirm approval title for regular L2 changes', () => {
    const l2Change = { ...mockChange, status: 'PENDING_LEVEL_TWO', criticalIndicator: true }
    render(<ApprovalDialog {...defaultProps} change={l2Change as any} />)
    expect(screen.getAllByText('Confirm Approval').length).toBeGreaterThanOrEqual(1)
  })

  it('allows entering a comment', () => {
    render(<ApprovalDialog {...defaultProps} />)
    const textarea = screen.getByTestId('comment')
    fireEvent.change(textarea, { target: { value: 'Looks good' } })
    expect(textarea).toHaveValue('Looks good')
  })

  it('calls approve mutation on confirm', async () => {
    mockMutateAsync.mockResolvedValue({ newStatus: 'APPROVED' })
    render(<ApprovalDialog {...defaultProps} />)

    const confirmButton = screen.getAllByText('Confirm Approval')[1]
    fireEvent.click(confirmButton)

    await waitFor(() => {
      expect(mockMutateAsync).toHaveBeenCalledWith({
        changeId: 'change-1',
        request: undefined
      })
    })
  })

  it('sends comment when provided', async () => {
    mockMutateAsync.mockResolvedValue({ newStatus: 'APPROVED' })
    render(<ApprovalDialog {...defaultProps} />)

    const textarea = screen.getByTestId('comment')
    fireEvent.change(textarea, { target: { value: 'Approved with notes' } })

    const confirmButton = screen.getAllByText('Confirm Approval')[1]
    fireEvent.click(confirmButton)

    await waitFor(() => {
      expect(mockMutateAsync).toHaveBeenCalledWith({
        changeId: 'change-1',
        request: { comment: 'Approved with notes' }
      })
    })
  })

  it('shows escalation notification for PENDING_LEVEL_TWO result', async () => {
    mockMutateAsync.mockResolvedValue({ newStatus: 'PENDING_LEVEL_TWO' })
    render(<ApprovalDialog {...defaultProps} />)

    fireEvent.click(screen.getAllByText('Confirm Approval')[1])

    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(
        expect.objectContaining({ title: 'Changes Escalated' })
      )
    })
  })

  it('shows success notification for approved result', async () => {
    mockMutateAsync.mockResolvedValue({ newStatus: 'APPROVED' })
    render(<ApprovalDialog {...defaultProps} />)

    fireEvent.click(screen.getAllByText('Confirm Approval')[1])

    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(
        expect.objectContaining({ title: 'Changes Approved' })
      )
    })
  })

  it('shows self-approval error when rejection contains self-approval', async () => {
    mockMutateAsync.mockRejectedValue(new Error('Self-approval is not allowed'))
    render(<ApprovalDialog {...defaultProps} />)

    fireEvent.click(screen.getAllByText('Confirm Approval')[1])

    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(
        expect.objectContaining({ title: 'Cannot Approve' })
      )
    })
  })

  it('shows generic error on non-self-approval failure', async () => {
    mockMutateAsync.mockRejectedValue(new Error('Server error'))
    render(<ApprovalDialog {...defaultProps} />)

    fireEvent.click(screen.getAllByText('Confirm Approval')[1])

    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(
        expect.objectContaining({ title: 'Error', description: 'Server error' })
      )
    })
  })

  it('handles non-Error rejection', async () => {
    mockMutateAsync.mockRejectedValue('Unknown error string')
    render(<ApprovalDialog {...defaultProps} />)

    fireEvent.click(screen.getAllByText('Confirm Approval')[1])

    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(
        expect.objectContaining({ title: 'Error' })
      )
    })
  })

  it('renders cancel button', () => {
    render(<ApprovalDialog {...defaultProps} />)
    expect(screen.getByText('Cancel')).toBeInTheDocument()
  })

  it('calls onOpenChange when cancel is clicked', () => {
    render(<ApprovalDialog {...defaultProps} />)
    fireEvent.click(screen.getByText('Cancel'))
    expect(defaultProps.onOpenChange).toHaveBeenCalledWith(false)
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/dialogs/__tests__/approval-dialog.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react'

const mockMutateAsync = vi.fn()
const mockNotify = vi.fn()
let mockIsPending = false

vi.mock('../../../../ui/dialog', () => ({
  Dialog: ({ children, open, onOpenChange }: any) => open ? <div data-testid="dialog"><button data-testid="dialog-close" onClick={() => onOpenChange(false)}>X</button>{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))
vi.mock('../../../../ui/button', () => ({ Button: ({ children, onClick, disabled }: any) => <button onClick={onClick} disabled={disabled}>{children}</button> }))
vi.mock('../../../../ui/textarea', () => ({ Textarea: ({ value, onChange, id }: any) => <textarea data-testid="textarea" value={value} onChange={onChange} id={id} /> }))
vi.mock('../../../../ui/label', () => ({ Label: ({ children }: any) => <label>{children}</label> }))
vi.mock('../../../../ui/alert', () => ({
  Alert: ({ children }: any) => <div data-testid="alert">{children}</div>,
  AlertDescription: ({ children }: any) => <div>{children}</div>
}))
vi.mock('lucide-react', () => ({
  AlertTriangle: (p: any) => <span {...p} />,
  Loader2: (p: any) => <span data-testid="loader" {...p} />
}))
vi.mock('../change-info-section', () => ({
  ChangeInfoSection: ({ change }: any) => <div data-testid="change-info">{change.targetGroupName}</div>
}))
vi.mock('../../../../../hooks/admin/use-pending-changes', () => ({
  useApproveChange: () => ({ mutateAsync: mockMutateAsync, isPending: mockIsPending })
}))
vi.mock('../../../../../hooks/common/use-toast', () => ({
  useToast: () => ({ notify: mockNotify })
}))

import { ApprovalDialog } from '../approval-dialog'

const mockChange = {
  id: '1',
  targetGroupName: 'Test Group',
  criticalIndicator: false,
  status: 'PENDING_LEVEL_ONE',
  submittedBy: { displayName: 'John Doe' },
  matchedRules: []
} as any

describe('ApprovalDialog', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockIsPending = false
  })

  it('renders nothing when closed', () => {
    const { container } = render(
      <ApprovalDialog open={false} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />
    )
    expect(container.querySelector('[data-testid="dialog"]')).toBeNull()
  })

  it('renders dialog when open', () => {
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByTestId('dialog')).toBeInTheDocument()
    expect(screen.getByRole('heading', { name: 'Confirm Approval' })).toBeInTheDocument()
  })

  it('shows change info section', () => {
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByTestId('change-info')).toBeInTheDocument()
  })

  it('shows escalation title for critical changes', () => {
    const critical = { ...mockChange, criticalIndicator: true }
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={critical} onSuccess={vi.fn()} />)
    expect(screen.getByRole('heading', { name: 'Approve and Escalate' })).toBeInTheDocument()
  })

  it('shows escalation description for critical level-one changes', () => {
    const critical = { ...mockChange, criticalIndicator: true }
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={critical} onSuccess={vi.fn()} />)
    expect(screen.getByText(/Senior Reviewer approval/)).toBeInTheDocument()
  })

  it('shows confirm approval title for level-two critical changes', () => {
    const levelTwo = { ...mockChange, criticalIndicator: true, status: 'PENDING_LEVEL_TWO' }
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={levelTwo} onSuccess={vi.fn()} />)
    expect(screen.getByRole('heading', { name: 'Confirm Approval' })).toBeInTheDocument()
  })

  it('shows escalation warning with matched rules', () => {
    const criticalWithRules = {
      ...mockChange,
      criticalIndicator: true,
      matchedRules: [
        { entityType: 'permission', entityKey: 'admin', reason: 'Admin-level permission change' }
      ]
    }
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={criticalWithRules} onSuccess={vi.fn()} />)
    expect(screen.getByText(/Admin-level permission change/)).toBeInTheDocument()
    expect(screen.getByText(/Senior Review required/)).toBeInTheDocument()
  })

  it('successfully approves without comment', async () => {
    mockMutateAsync.mockResolvedValue({ newStatus: 'APPROVED' })
    const onOpenChange = vi.fn()
    const onSuccess = vi.fn()
    render(<ApprovalDialog open={true} onOpenChange={onOpenChange} change={mockChange} onSuccess={onSuccess} />)
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Confirm Approval' }))
    })
    await waitFor(() => {
      expect(mockMutateAsync).toHaveBeenCalledWith({
        changeId: '1',
        request: undefined
      })
      expect(mockNotify).toHaveBeenCalledWith(expect.objectContaining({
        title: 'Changes Approved',
        variant: 'success'
      }))
      expect(onOpenChange).toHaveBeenCalledWith(false)
      expect(onSuccess).toHaveBeenCalled()
    })
  })

  it('successfully approves with comment', async () => {
    mockMutateAsync.mockResolvedValue({ newStatus: 'APPROVED' })
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    fireEvent.change(screen.getByTestId('textarea'), { target: { value: 'Looks good' } })
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Confirm Approval' }))
    })
    await waitFor(() => {
      expect(mockMutateAsync).toHaveBeenCalledWith({
        changeId: '1',
        request: { comment: 'Looks good' }
      })
    })
  })

  it('shows escalation notification when result is PENDING_LEVEL_TWO', async () => {
    mockMutateAsync.mockResolvedValue({ newStatus: 'PENDING_LEVEL_TWO' })
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Confirm Approval' }))
    })
    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(expect.objectContaining({
        title: 'Changes Escalated',
        description: 'The changes have been forwarded to a Senior Reviewer for final approval.'
      }))
    })
  })

  it('shows error on self-approval', async () => {
    mockMutateAsync.mockRejectedValue(new Error('Self-approval not permitted'))
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Confirm Approval' }))
    })
    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(expect.objectContaining({
        title: 'Cannot Approve',
        description: 'You cannot approve changes you submitted. Another reviewer must approve this request.'
      }))
    })
  })

  it('shows generic error on non-Error failure', async () => {
    mockMutateAsync.mockRejectedValue('unknown')
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Confirm Approval' }))
    })
    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(expect.objectContaining({
        title: 'Error',
        description: 'An unexpected error occurred. Please try again.'
      }))
    })
  })

  it('shows regular error on other errors', async () => {
    mockMutateAsync.mockRejectedValue(new Error('Network timeout'))
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Confirm Approval' }))
    })
    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(expect.objectContaining({
        title: 'Error',
        description: 'Network timeout'
      }))
    })
  })

  it('handles close and resets comment', () => {
    const onOpenChange = vi.fn()
    render(<ApprovalDialog open={true} onOpenChange={onOpenChange} change={mockChange} onSuccess={vi.fn()} />)
    fireEvent.click(screen.getByText('Cancel'))
    expect(onOpenChange).toHaveBeenCalledWith(false)
  })

  it('prevents close when mutation is pending', () => {
    mockIsPending = true
    const onOpenChange = vi.fn()
    render(<ApprovalDialog open={true} onOpenChange={onOpenChange} change={mockChange} onSuccess={vi.fn()} />)
    fireEvent.click(screen.getByTestId('dialog-close'))
    expect(onOpenChange).not.toHaveBeenCalledWith(false)
  })

  it('shows non-escalation description for non-critical changes', () => {
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByText(/take effect immediately/)).toBeInTheDocument()
  })

  it('renders comment label', () => {
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByText('Add a note (optional)')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/dialogs/__tests__/cancel-dialog-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'

const mockMutateAsync = vi.fn()
vi.mock('../../../../../hooks/admin/use-pending-changes', () => ({
  useCancelChange: () => ({
    mutateAsync: mockMutateAsync,
    isPending: false
  })
}))

const mockNotify = vi.fn()
vi.mock('../../../../../hooks/common/use-toast', () => ({
  useToast: () => ({ notify: mockNotify })
}))

vi.mock('../../../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))

vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, disabled, variant }: any) => (
    <button onClick={onClick} disabled={disabled} data-variant={variant}>{children}</button>
  )
}))

vi.mock('lucide-react', () => ({
  AlertTriangle: () => <span data-testid="alert-triangle" />,
  Loader2: () => <span data-testid="loader" />
}))

import { CancelDialog } from '../cancel-dialog'

const mockChange = {
  id: 'change-1',
  targetGroupName: 'Test Group',
  status: 'PENDING_LEVEL_ONE',
  submittedBy: { displayName: 'Jane Doe' },
  submittedDateTime: '2025-01-15T10:00:00Z',
  expiresDateTime: '2025-02-15T10:00:00Z',
  currentState: {},
  proposedState: {},
  matchedRules: [],
  criticalIndicator: false,
  canApproveIndicator: false,
  canRejectIndicator: false,
  canCancelIndicator: true,
  levelOneApproval: null,
  levelTwoApproval: null,
  rejectedBy: null,
  rejectedDateTime: null,
  rejectionReason: null,
  appsChanges: [],
  functionsChanges: []
}

describe('CancelDialog', () => {
  const defaultProps = {
    open: true,
    onOpenChange: vi.fn(),
    change: mockChange as any,
    onSuccess: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders dialog when open', () => {
    render(<CancelDialog {...defaultProps} />)
    expect(screen.getAllByText('Withdraw Request').length).toBeGreaterThanOrEqual(1)
  })

  it('does not render when closed', () => {
    render(<CancelDialog {...defaultProps} open={false} />)
    expect(screen.queryByText('Withdraw Request')).not.toBeInTheDocument()
  })

  it('displays group name', () => {
    render(<CancelDialog {...defaultProps} />)
    expect(screen.getByText('Test Group')).toBeInTheDocument()
  })

  it('displays submitted by name', () => {
    render(<CancelDialog {...defaultProps} />)
    expect(screen.getByText('Jane Doe')).toBeInTheDocument()
  })

  it('shows warning message', () => {
    render(<CancelDialog {...defaultProps} />)
    expect(screen.getByText(/This will remove the change from the approval queue/)).toBeInTheDocument()
  })

  it('calls cancel mutation when withdraw is clicked', async () => {
    mockMutateAsync.mockResolvedValue(undefined)
    render(<CancelDialog {...defaultProps} />)

    const buttons = screen.getAllByText('Withdraw Request')
    fireEvent.click(buttons[buttons.length - 1])

    await waitFor(() => {
      expect(mockMutateAsync).toHaveBeenCalledWith('change-1')
    })
  })

  it('shows success notification on successful withdrawal', async () => {
    mockMutateAsync.mockResolvedValue(undefined)
    render(<CancelDialog {...defaultProps} />)

    const buttons = screen.getAllByText('Withdraw Request')
    fireEvent.click(buttons[buttons.length - 1])

    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(
        expect.objectContaining({ title: 'Request Withdrawn' })
      )
    })
  })

  it('shows error notification on failure', async () => {
    mockMutateAsync.mockRejectedValue(new Error('Server error'))
    render(<CancelDialog {...defaultProps} />)

    const buttons = screen.getAllByText('Withdraw Request')
    fireEvent.click(buttons[buttons.length - 1])

    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(
        expect.objectContaining({ title: 'Error', description: 'Server error' })
      )
    })
  })

  it('handles non-Error rejection', async () => {
    mockMutateAsync.mockRejectedValue('Unknown error')
    render(<CancelDialog {...defaultProps} />)

    const buttons = screen.getAllByText('Withdraw Request')
    fireEvent.click(buttons[buttons.length - 1])

    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(
        expect.objectContaining({ title: 'Error' })
      )
    })
  })

  it('calls onOpenChange when cancel button is clicked', () => {
    render(<CancelDialog {...defaultProps} />)
    fireEvent.click(screen.getByText('Cancel'))
    expect(defaultProps.onOpenChange).toHaveBeenCalledWith(false)
  })

  it('calls onSuccess after successful withdrawal', async () => {
    mockMutateAsync.mockResolvedValue(undefined)
    render(<CancelDialog {...defaultProps} />)

    const buttons = screen.getAllByText('Withdraw Request')
    fireEvent.click(buttons[buttons.length - 1])

    await waitFor(() => {
      expect(defaultProps.onSuccess).toHaveBeenCalled()
    })
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/dialogs/__tests__/cancel-dialog.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react'

const mockMutateAsync = vi.fn()
const mockNotify = vi.fn()
let mockIsPending = false

vi.mock('../../../../ui/dialog', () => ({
  Dialog: ({ children, open, onOpenChange }: any) => open ? <div data-testid="dialog"><button data-testid="dialog-close" onClick={() => onOpenChange(false)}>X</button>{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))
vi.mock('../../../../ui/button', () => ({ Button: ({ children, onClick, disabled }: any) => <button onClick={onClick} disabled={disabled}>{children}</button> }))
vi.mock('lucide-react', () => ({
  AlertTriangle: (p: any) => <span {...p} />,
  Loader2: (p: any) => <span data-testid="loader" {...p} />
}))
vi.mock('../../../../../hooks/admin/use-pending-changes', () => ({
  useCancelChange: () => ({ mutateAsync: mockMutateAsync, isPending: mockIsPending })
}))
vi.mock('../../../../../hooks/common/use-toast', () => ({
  useToast: () => ({ notify: mockNotify })
}))

import { CancelDialog } from '../cancel-dialog'

const mockChange = {
  id: '1',
  targetGroupName: 'Test Group',
  submittedBy: { displayName: 'Bob Smith' }
} as any

describe('CancelDialog', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockIsPending = false
  })

  it('renders nothing when closed', () => {
    const { container } = render(
      <CancelDialog open={false} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />
    )
    expect(container.querySelector('[data-testid="dialog"]')).toBeNull()
  })

  it('renders dialog when open', () => {
    render(<CancelDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByTestId('dialog')).toBeInTheDocument()
    expect(screen.getByRole('heading', { name: 'Withdraw Request' })).toBeInTheDocument()
  })

  it('shows group name', () => {
    render(<CancelDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByText('Test Group')).toBeInTheDocument()
  })

  it('shows submitter name', () => {
    render(<CancelDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByText('Bob Smith')).toBeInTheDocument()
  })

  it('shows warning message about irreversible action', () => {
    render(<CancelDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByText(/This will remove the change from the approval queue/)).toBeInTheDocument()
  })

  it('successfully withdraws request', async () => {
    mockMutateAsync.mockResolvedValue(undefined)
    const onOpenChange = vi.fn()
    const onSuccess = vi.fn()
    render(<CancelDialog open={true} onOpenChange={onOpenChange} change={mockChange} onSuccess={onSuccess} />)
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Withdraw Request' }))
    })
    await waitFor(() => {
      expect(mockMutateAsync).toHaveBeenCalledWith('1')
      expect(mockNotify).toHaveBeenCalledWith(expect.objectContaining({
        title: 'Request Withdrawn',
        variant: 'success'
      }))
      expect(onOpenChange).toHaveBeenCalledWith(false)
      expect(onSuccess).toHaveBeenCalled()
    })
  })

  it('shows error notification on failure with Error object', async () => {
    mockMutateAsync.mockRejectedValue(new Error('Network error'))
    const onSuccess = vi.fn()
    render(<CancelDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={onSuccess} />)
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Withdraw Request' }))
    })
    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(expect.objectContaining({
        title: 'Error',
        description: 'Network error',
        variant: 'error'
      }))
      expect(onSuccess).not.toHaveBeenCalled()
    })
  })

  it('shows generic error notification on non-Error failure', async () => {
    mockMutateAsync.mockRejectedValue('unknown error')
    render(<CancelDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Withdraw Request' }))
    })
    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(expect.objectContaining({
        description: 'An unexpected error occurred. Please try again.'
      }))
    })
  })

  it('handles close via cancel button', () => {
    const onOpenChange = vi.fn()
    render(<CancelDialog open={true} onOpenChange={onOpenChange} change={mockChange} onSuccess={vi.fn()} />)
    fireEvent.click(screen.getByText('Cancel'))
    expect(onOpenChange).toHaveBeenCalledWith(false)
  })

  it('prevents close when mutation is pending', () => {
    mockIsPending = true
    const onOpenChange = vi.fn()
    render(<CancelDialog open={true} onOpenChange={onOpenChange} change={mockChange} onSuccess={vi.fn()} />)
    fireEvent.click(screen.getByTestId('dialog-close'))
    expect(onOpenChange).not.toHaveBeenCalledWith(false)
  })

  it('shows dialog description text', () => {
    render(<CancelDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByText(/Are you sure you want to withdraw/)).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/dialogs/__tests__/change-info-section.test.tsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import { ChangeInfoSection } from '../change-info-section'

describe('ChangeInfoSection', () => {
  const baseMockChange = {
    targetGroupName: 'UK Retail Voice Agents',
    submittedBy: { displayName: 'John Smith', userId: 'user1' }
  } as any

  it('renders group name', () => {
    render(<ChangeInfoSection change={baseMockChange} />)
    expect(screen.getByText('UK Retail Voice Agents')).toBeInTheDocument()
  })

  it('renders submitter name', () => {
    render(<ChangeInfoSection change={baseMockChange} />)
    expect(screen.getByText('John Smith')).toBeInTheDocument()
  })

  it('renders Group label', () => {
    render(<ChangeInfoSection change={baseMockChange} />)
    expect(screen.getByText('Group:')).toBeInTheDocument()
  })

  it('renders Submitted by label', () => {
    render(<ChangeInfoSection change={baseMockChange} />)
    expect(screen.getByText('Submitted by:')).toBeInTheDocument()
  })

  it('renders different group and submitter names', () => {
    const change = {
      targetGroupName: 'APAC Chat Support',
      submittedBy: { displayName: 'Jane Doe', userId: 'user2' }
    } as any
    render(<ChangeInfoSection change={change} />)
    expect(screen.getByText('APAC Chat Support')).toBeInTheDocument()
    expect(screen.getByText('Jane Doe')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/dialogs/__tests__/decline-dialog-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'

const mockMutateAsync = vi.fn()
vi.mock('../../../../../hooks/admin/use-pending-changes', () => ({
  useRejectChange: () => ({
    mutateAsync: mockMutateAsync,
    isPending: false
  })
}))

const mockNotify = vi.fn()
vi.mock('../../../../../hooks/common/use-toast', () => ({
  useToast: () => ({ notify: mockNotify })
}))

vi.mock('../../../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))

vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, disabled, variant }: any) => (
    <button onClick={onClick} disabled={disabled} data-variant={variant}>{children}</button>
  )
}))

vi.mock('../../../../ui/textarea', () => ({
  Textarea: ({ id, value, onChange, placeholder, className }: any) => (
    <textarea data-testid={id} value={value} onChange={onChange} placeholder={placeholder} className={className} />
  )
}))

vi.mock('../../../../ui/label', () => ({
  Label: ({ children }: any) => <label>{children}</label>
}))

vi.mock('lucide-react', () => ({
  Loader2: () => <span data-testid="loader" />
}))

vi.mock('../change-info-section', () => ({
  ChangeInfoSection: ({ change }: any) => <div data-testid="change-info">{change.targetGroupName}</div>
}))

import { DeclineDialog } from '../decline-dialog'

const mockChange = {
  id: 'change-1',
  targetGroupName: 'Test Group',
  status: 'PENDING_LEVEL_ONE',
  submittedBy: { displayName: 'John Doe' },
  submittedDateTime: '2025-01-15T10:00:00Z',
  expiresDateTime: '2025-02-15T10:00:00Z',
  currentState: {},
  proposedState: {},
  matchedRules: [],
  criticalIndicator: false,
  canApproveIndicator: true,
  canRejectIndicator: true,
  canCancelIndicator: false,
  levelOneApproval: null,
  levelTwoApproval: null,
  rejectedBy: null,
  rejectedDateTime: null,
  rejectionReason: null,
  appsChanges: [],
  functionsChanges: []
}

describe('DeclineDialog', () => {
  const defaultProps = {
    open: true,
    onOpenChange: vi.fn(),
    change: mockChange as any,
    onSuccess: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders dialog when open', () => {
    render(<DeclineDialog {...defaultProps} />)
    expect(screen.getAllByText('Decline Request').length).toBeGreaterThanOrEqual(1)
  })

  it('does not render when closed', () => {
    render(<DeclineDialog {...defaultProps} open={false} />)
    expect(screen.queryByText('Decline Request')).not.toBeInTheDocument()
  })

  it('renders reason textarea', () => {
    render(<DeclineDialog {...defaultProps} />)
    expect(screen.getByTestId('reason')).toBeInTheDocument()
  })

  it('shows feedback message with submitter name', () => {
    render(<DeclineDialog {...defaultProps} />)
    expect(screen.getByText('Your feedback will be shared with John Doe')).toBeInTheDocument()
  })

  it('disables decline button when reason is too short', async () => {
    render(<DeclineDialog {...defaultProps} />)
    const textarea = screen.getByTestId('reason')
    fireEvent.change(textarea, { target: { value: 'Short' } })

    const buttons = screen.getAllByText('Decline Request')
    const declineButton = buttons[buttons.length - 1]
    expect(declineButton).toBeDisabled()
  })

  it('calls reject mutation with valid reason', async () => {
    mockMutateAsync.mockResolvedValue(undefined)
    render(<DeclineDialog {...defaultProps} />)

    const textarea = screen.getByTestId('reason')
    fireEvent.change(textarea, { target: { value: 'This needs more review and rework please' } })

    const buttons = screen.getAllByText('Decline Request')
    fireEvent.click(buttons[buttons.length - 1])

    await waitFor(() => {
      expect(mockMutateAsync).toHaveBeenCalledWith({
        changeId: 'change-1',
        request: { rejectionReason: 'This needs more review and rework please' }
      })
    })
  })

  it('shows success notification on successful decline', async () => {
    mockMutateAsync.mockResolvedValue(undefined)
    render(<DeclineDialog {...defaultProps} />)

    const textarea = screen.getByTestId('reason')
    fireEvent.change(textarea, { target: { value: 'Detailed reason for declining this request' } })

    const btns = screen.getAllByText('Decline Request')
    fireEvent.click(btns[btns.length - 1])

    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(
        expect.objectContaining({ title: 'Request Declined' })
      )
    })
  })

  it('shows error notification on failure', async () => {
    mockMutateAsync.mockRejectedValue(new Error('Server error'))
    render(<DeclineDialog {...defaultProps} />)

    const textarea = screen.getByTestId('reason')
    fireEvent.change(textarea, { target: { value: 'Valid reason for decline here' } })

    const btns2 = screen.getAllByText('Decline Request')
    fireEvent.click(btns2[btns2.length - 1])

    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(
        expect.objectContaining({ title: 'Error', description: 'Server error' })
      )
    })
  })

  it('handles non-Error rejection', async () => {
    mockMutateAsync.mockRejectedValue('Unknown')
    render(<DeclineDialog {...defaultProps} />)

    const textarea = screen.getByTestId('reason')
    fireEvent.change(textarea, { target: { value: 'A long enough reason text' } })

    const btns3 = screen.getAllByText('Decline Request')
    fireEvent.click(btns3[btns3.length - 1])

    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(
        expect.objectContaining({ title: 'Error' })
      )
    })
  })

  it('enables decline button when reason becomes valid', () => {
    render(<DeclineDialog {...defaultProps} />)
    const textarea = screen.getByTestId('reason')

    fireEvent.change(textarea, { target: { value: 'Short' } })
    const btns4 = screen.getAllByText('Decline Request')
    expect(btns4[btns4.length - 1]).toBeDisabled()

    fireEvent.change(textarea, { target: { value: 'This is now a valid reason text' } })
    const btns5 = screen.getAllByText('Decline Request')
    expect(btns5[btns5.length - 1]).not.toBeDisabled()
  })

  it('calls onOpenChange when cancel is clicked', () => {
    render(<DeclineDialog {...defaultProps} />)
    fireEvent.click(screen.getByText('Cancel'))
    expect(defaultProps.onOpenChange).toHaveBeenCalledWith(false)
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/dialogs/__tests__/decline-dialog.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react'

const mockMutateAsync = vi.fn()
const mockNotify = vi.fn()
let mockIsPending = false

vi.mock('../../../../ui/dialog', () => ({
  Dialog: ({ children, open, onOpenChange }: any) => open ? <div data-testid="dialog"><button data-testid="dialog-close" onClick={() => onOpenChange(false)}>X</button>{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))
vi.mock('../../../../ui/button', () => ({ Button: ({ children, onClick, disabled }: any) => <button onClick={onClick} disabled={disabled}>{children}</button> }))
vi.mock('../../../../ui/textarea', () => ({ Textarea: ({ value, onChange, id, className, ...rest }: any) => <textarea data-testid="textarea" value={value} onChange={onChange} id={id} className={className} /> }))
vi.mock('../../../../ui/label', () => ({ Label: ({ children }: any) => <label>{children}</label> }))
vi.mock('lucide-react', () => ({ Loader2: (p: any) => <span data-testid="loader" {...p} /> }))
vi.mock('../change-info-section', () => ({
  ChangeInfoSection: ({ change }: any) => <div data-testid="change-info">{change.targetGroupName} - {change.submittedBy.displayName}</div>
}))
vi.mock('../../../../../hooks/admin/use-pending-changes', () => ({
  useRejectChange: () => ({ mutateAsync: mockMutateAsync, isPending: mockIsPending })
}))
vi.mock('../../../../../hooks/common/use-toast', () => ({
  useToast: () => ({ notify: mockNotify })
}))

import { DeclineDialog } from '../decline-dialog'

const mockChange = {
  id: '1',
  targetGroupName: 'Test Group',
  submittedBy: { displayName: 'Jane Doe' }
} as any

describe('DeclineDialog', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockIsPending = false
  })

  it('renders nothing when closed', () => {
    const { container } = render(
      <DeclineDialog open={false} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />
    )
    expect(container.querySelector('[data-testid="dialog"]')).toBeNull()
  })

  it('renders dialog when open', () => {
    render(<DeclineDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByTestId('dialog')).toBeInTheDocument()
    expect(screen.getByRole('heading', { name: 'Decline Request' })).toBeInTheDocument()
  })

  it('shows change info section', () => {
    render(<DeclineDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByTestId('change-info')).toBeInTheDocument()
    expect(screen.getByText(/Test Group/)).toBeInTheDocument()
  })

  it('shows feedback hint text', () => {
    render(<DeclineDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByText(/Your feedback will be shared with Jane Doe/)).toBeInTheDocument()
  })

  it('disables decline button when reason is too short', () => {
    render(<DeclineDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    const textarea = screen.getByTestId('textarea')
    fireEvent.change(textarea, { target: { value: 'short' } })
    expect(screen.getByRole('button', { name: 'Decline Request' })).toBeDisabled()
  })

  it('enables decline button when reason becomes valid', () => {
    render(<DeclineDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    const textarea = screen.getByTestId('textarea')
    fireEvent.change(textarea, { target: { value: 'short' } })
    expect(screen.getByRole('button', { name: 'Decline Request' })).toBeDisabled()
    // Now type enough characters
    fireEvent.change(textarea, { target: { value: 'This is a valid reason with more than 10 chars' } })
    expect(screen.getByRole('button', { name: 'Decline Request' })).not.toBeDisabled()
  })

  it('successfully declines with valid reason', async () => {
    mockMutateAsync.mockResolvedValue(undefined)
    const onOpenChange = vi.fn()
    const onSuccess = vi.fn()
    render(<DeclineDialog open={true} onOpenChange={onOpenChange} change={mockChange} onSuccess={onSuccess} />)
    const textarea = screen.getByTestId('textarea')
    fireEvent.change(textarea, { target: { value: 'This change has issues with the configuration.' } })
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Decline Request' }))
    })
    await waitFor(() => {
      expect(mockMutateAsync).toHaveBeenCalledWith({
        changeId: '1',
        request: { rejectionReason: 'This change has issues with the configuration.' }
      })
      expect(mockNotify).toHaveBeenCalledWith(expect.objectContaining({
        title: 'Request Declined',
        variant: 'success'
      }))
      expect(onOpenChange).toHaveBeenCalledWith(false)
      expect(onSuccess).toHaveBeenCalled()
    })
  })

  it('shows error notification on failure with Error object', async () => {
    mockMutateAsync.mockRejectedValue(new Error('Server error'))
    render(<DeclineDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    fireEvent.change(screen.getByTestId('textarea'), { target: { value: 'A valid rejection reason text' } })
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Decline Request' }))
    })
    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(expect.objectContaining({
        title: 'Error',
        description: 'Server error',
        variant: 'error'
      }))
    })
  })

  it('shows generic error notification on non-Error failure', async () => {
    mockMutateAsync.mockRejectedValue('string error')
    render(<DeclineDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    fireEvent.change(screen.getByTestId('textarea'), { target: { value: 'A valid rejection reason text' } })
    await act(async () => {
      fireEvent.click(screen.getByRole('button', { name: 'Decline Request' }))
    })
    await waitFor(() => {
      expect(mockNotify).toHaveBeenCalledWith(expect.objectContaining({
        description: 'An unexpected error occurred. Please try again.'
      }))
    })
  })

  it('handles close and resets state', () => {
    const onOpenChange = vi.fn()
    render(<DeclineDialog open={true} onOpenChange={onOpenChange} change={mockChange} onSuccess={vi.fn()} />)
    fireEvent.click(screen.getByText('Cancel'))
    expect(onOpenChange).toHaveBeenCalledWith(false)
  })

  it('prevents close when mutation is pending', () => {
    mockIsPending = true
    const onOpenChange = vi.fn()
    render(<DeclineDialog open={true} onOpenChange={onOpenChange} change={mockChange} onSuccess={vi.fn()} />)
    fireEvent.click(screen.getByTestId('dialog-close'))
    expect(onOpenChange).not.toHaveBeenCalledWith(false)
  })

  it('shows description text', () => {
    render(<DeclineDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByText(/Please provide feedback for declining/)).toBeInTheDocument()
  })

  it('renders reason label', () => {
    render(<DeclineDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByText('Reason for declining *')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/dialogs/approval-dialog.tsx
/**
 * Approval Dialog
 * Confirmation dialog for approving a pending change
 */

import { useState } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle
} from '../../../ui/dialog'
import { Button } from '../../../ui/button'
import { Textarea } from '../../../ui/textarea'
import { Label } from '../../../ui/label'
import { AlertTriangle, Loader2 } from 'lucide-react'
import { Alert, AlertDescription } from '../../../ui/alert'
import { useApproveChange } from '../../../../hooks/admin/use-pending-changes'
import { useToast } from '../../../../hooks/common/use-toast'
import type { PendingChangeDto } from '../../../../types/features/approval-workflow.types'
import { ChangeInfoSection } from './change-info-section'

/** Props for the ApprovalDialog component. */
interface ApprovalDialogProps {
  /** Controls dialog visibility */
  open: boolean
  /** Callback to open or close the dialog */
  onOpenChange: (open: boolean) => void
  /** The pending change being approved */
  change: PendingChangeDto
  /** Callback invoked after a successful approval to refresh the parent list */
  onSuccess: () => void
}

/**
 * Confirmation dialog for approving a pending configuration change.
 * For critical changes at Level 1, displays escalation warnings and
 * forwards the change to a Senior Reviewer instead of applying immediately.
 */
export function ApprovalDialog({
  open,
  onOpenChange,
  change,
  onSuccess
}: Readonly<ApprovalDialogProps>) {
  const { notify } = useToast()
  const [comment, setComment] = useState('')

  const approveMutation = useApproveChange()

  const isCritical = change.criticalIndicator
  const isLevelTwo = change.status === 'PENDING_LEVEL_TWO'
  const willEscalate = isCritical && !isLevelTwo

  const notifyApprovalResult = (newStatus: string) => {
    const escalated = newStatus === 'PENDING_LEVEL_TWO'
    notify({
      title: escalated ? 'Changes Escalated' : 'Changes Approved',
      description: escalated
        ? 'The changes have been forwarded to a Senior Reviewer for final approval.'
        : 'The configuration changes have been applied successfully.',
      variant: 'success'
    })
  }

  const notifyApprovalError = (error: unknown) => {
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred. Please try again.'
    const isSelfApproval = errorMessage.toLowerCase().includes('self-approval')
    const title = isSelfApproval ? 'Cannot Approve' : 'Error'
    const description = isSelfApproval
      ? 'You cannot approve changes you submitted. Another reviewer must approve this request.'
      : errorMessage
    notify({ title, description, variant: 'error' })
  }

  const handleApprove = async () => {
    try {
      const result = await approveMutation.mutateAsync({
        changeId: change.id,
        request: comment.trim() ? { comment: comment.trim() } : undefined
      })
      notifyApprovalResult(result.newStatus)
      onOpenChange(false)
      setComment('')
      onSuccess()
    } catch (error) {
      notifyApprovalError(error)
    }
  }

  const handleClose = () => {
    if (!approveMutation.isPending) {
      onOpenChange(false)
      setComment('')
    }
  }

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>
            {willEscalate
              ? 'Approve and Escalate'
              : 'Confirm Approval'}
          </DialogTitle>
          <DialogDescription>
            {willEscalate
              ? 'This change requires Senior Reviewer approval. Your approval will forward this to a Senior Reviewer for final review.'
              : 'You are about to approve configuration changes. These changes will take effect immediately after approval.'}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* Change Info */}
          <ChangeInfoSection change={change} />

          {/* Escalation Warning */}
          {willEscalate && (
            <Alert className="bg-orange-50 border-orange-200">
              <AlertTriangle className="h-4 w-4 text-orange-600" />
              <AlertDescription className="text-orange-800">
                Senior Review required because:
                {change.matchedRules.length > 0 && (
                  <ul className="mt-2 text-sm space-y-1">
                    {change.matchedRules.map((rule) => (
                      <li key={`${rule.entityType}-${rule.entityKey}`}>* {rule.reason}</li>
                    ))}
                  </ul>
                )}
              </AlertDescription>
            </Alert>
          )}

          {/* Comment */}
          <div className="space-y-2">
            <Label htmlFor="comment">
              Add a note (optional)
            </Label>
            <Textarea
              id="comment"
              placeholder="Reviewed and approved. Changes align with team requirements."
              value={comment}
              onChange={(e) => setComment(e.target.value)}
              rows={3}
            />
          </div>
        </div>

        <DialogFooter>
          <Button
            variant="outline"
            onClick={handleClose}
            disabled={approveMutation.isPending}
          >
            Cancel
          </Button>
          <Button
            onClick={handleApprove}
            disabled={approveMutation.isPending}
          >
            {approveMutation.isPending && (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            )}
            {willEscalate
              ? 'Approve and Escalate'
              : 'Confirm Approval'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/dialogs/cancel-dialog.tsx
/**
 * Cancel Dialog
 * Confirmation dialog for makers to withdraw their own pending submissions
 */

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle
} from '../../../ui/dialog'
import { Button } from '../../../ui/button'
import { AlertTriangle, Loader2 } from 'lucide-react'
import { useCancelChange } from '../../../../hooks/admin/use-pending-changes'
import { useToast } from '../../../../hooks/common/use-toast'
import type { PendingChangeDto } from '../../../../types/features/approval-workflow.types'

/** Props for the CancelDialog component. */
interface CancelDialogProps {
  /** Controls dialog visibility */
  open: boolean
  /** Callback to open or close the dialog */
  onOpenChange: (open: boolean) => void
  /** The pending change being withdrawn */
  change: PendingChangeDto
  /** Callback invoked after a successful withdrawal to refresh the parent list */
  onSuccess: () => void
}

/**
 * Confirmation dialog allowing a maker to withdraw their own pending
 * submission from the approval queue. Displays a warning that the
 * action is irreversible.
 */
export function CancelDialog({
  open,
  onOpenChange,
  change,
  onSuccess
}: Readonly<CancelDialogProps>) {
  const { notify } = useToast()

  const cancelMutation = useCancelChange()

  const handleCancel = async () => {
    try {
      await cancelMutation.mutateAsync(change.id)

      notify({
        title: 'Request Withdrawn',
        description: 'Your pending change has been withdrawn.',
        variant: 'success'
      })

      onOpenChange(false)
      onSuccess()
    } catch (err) {
      const errorMessage =
        err instanceof Error ? err.message : 'An unexpected error occurred. Please try again.'
      notify({
        title: 'Error',
        description: errorMessage,
        variant: 'error'
      })
    }
  }

  const handleClose = () => {
    if (!cancelMutation.isPending) {
      onOpenChange(false)
    }
  }

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Withdraw Request</DialogTitle>
          <DialogDescription>
            Are you sure you want to withdraw this pending change?
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          <div className="text-sm space-y-1">
            <div>
              <span className="text-muted-foreground">
                Group:
              </span>{' '}
              <span className="font-medium">{change.targetGroupName}</span>
            </div>
            <div>
              <span className="text-muted-foreground">
                Submitted by:
              </span>{' '}
              <span className="font-medium">
                {change.submittedBy.displayName}
              </span>
            </div>
          </div>

          <div className="flex items-start gap-2 p-3 bg-amber-50 border border-amber-200 rounded-md">
            <AlertTriangle className="h-4 w-4 text-amber-600 mt-0.5 shrink-0" />
            <p className="text-sm text-amber-800">
              This will remove the change from the approval queue. This cannot be undone.
            </p>
          </div>
        </div>

        <DialogFooter>
          <Button
            type="button"
            variant="outline"
            onClick={handleClose}
            disabled={cancelMutation.isPending}
          >
            Cancel
          </Button>
          <Button
            type="button"
            variant="destructive"
            onClick={handleCancel}
            disabled={cancelMutation.isPending}
          >
            {cancelMutation.isPending && (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            )}
            Withdraw Request
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/dialogs/change-info-section.tsx
/**
 * Change Info Section
 * Shared component displaying change metadata (group name, submitter)
 * Used by both ApprovalDialog and DeclineDialog to avoid duplication
 */

import type { PendingChangeDto } from '../../../../types/features/approval-workflow.types'

/** Props for the ChangeInfoSection component */
interface ChangeInfoSectionProps {
  /** The pending change containing group name and submitter info */
  change: PendingChangeDto
}

/**
 * Displays the group name and submitter of a pending change.
 * Renders a compact info block used in approval workflow dialogs.
 */
export function ChangeInfoSection({ change }: Readonly<ChangeInfoSectionProps>) {
  return (
    <div className="text-sm space-y-1">
      <div>
        <span className="text-muted-foreground">
          Group:
        </span>{' '}
        <span className="font-medium">{change.targetGroupName}</span>
      </div>
      <div>
        <span className="text-muted-foreground">
          Submitted by:
        </span>{' '}
        <span className="font-medium">
          {change.submittedBy.displayName}
        </span>
      </div>
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/dialogs/decline-dialog.tsx
/**
 * Decline Dialog
 * Confirmation dialog for declining a pending change
 */

import { useState } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle
} from '../../../ui/dialog'
import { Button } from '../../../ui/button'
import { Textarea } from '../../../ui/textarea'
import { Label } from '../../../ui/label'
import { Loader2 } from 'lucide-react'
import { useRejectChange } from '../../../../hooks/admin/use-pending-changes'
import { useToast } from '../../../../hooks/common/use-toast'
import type { PendingChangeDto } from '../../../../types/features/approval-workflow.types'
import { ChangeInfoSection } from './change-info-section'

/** Props for the DeclineDialog component. */
interface DeclineDialogProps {
  /** Controls dialog visibility */
  open: boolean
  /** Callback to open or close the dialog */
  onOpenChange: (open: boolean) => void
  /** The pending change being declined */
  change: PendingChangeDto
  /** Callback invoked after a successful rejection to refresh the parent list */
  onSuccess: () => void
}

/**
 * Dialog for declining a pending configuration change. Requires a mandatory
 * rejection reason (minimum 10 characters) that is shared with the submitter
 * as feedback.
 */
export function DeclineDialog({
  open,
  onOpenChange,
  change,
  onSuccess
}: Readonly<DeclineDialogProps>) {
  const { notify } = useToast()
  const [reason, setReason] = useState('')
  const [error, setError] = useState('')

  const rejectMutation = useRejectChange()

  const isReasonValid = reason.trim().length >= 10

  const handleDecline = async () => {
    if (!isReasonValid) {
      setError('Please provide a reason (minimum 10 characters)')
      return
    }

    setError('')

    try {
      await rejectMutation.mutateAsync({
        changeId: change.id,
        request: { rejectionReason: reason.trim() }
      })

      notify({
        title: 'Request Declined',
        description: `Your feedback has been sent to ${change.submittedBy.displayName}.`,
        variant: 'success'
      })

      onOpenChange(false)
      setReason('')
      onSuccess()
    } catch (err) {
      const errorMessage =
        err instanceof Error ? err.message : 'An unexpected error occurred. Please try again.'
      notify({
        title: 'Error',
        description: errorMessage,
        variant: 'error'
      })
    }
  }

  const handleClose = () => {
    if (!rejectMutation.isPending) {
      onOpenChange(false)
      setReason('')
      setError('')
    }
  }

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Decline Request</DialogTitle>
          <DialogDescription>
            Please provide feedback for declining this change request.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* Change Info */}
          <ChangeInfoSection change={change} />

          {/* Reason */}
          <div className="space-y-2">
            <Label htmlFor="reason">
              Reason for declining *
            </Label>
            <Textarea
              id="reason"
              placeholder="Please explain why this change cannot be approved..."
              value={reason}
              onChange={(e) => {
                setReason(e.target.value)
                const shouldClearError = error && e.target.value.trim().length >= 10
                if (shouldClearError) setError('')
              }}
              rows={4}
              className={error ? 'border-destructive' : ''}
            />
            {error && (
              <p className="text-sm text-destructive">{error}</p>
            )}
            <p className="text-xs text-muted-foreground">
              {`Your feedback will be shared with ${change.submittedBy.displayName}`}
            </p>
          </div>
        </div>

        <DialogFooter>
          <Button
            variant="outline"
            onClick={handleClose}
            disabled={rejectMutation.isPending}
          >
            Cancel
          </Button>
          <Button
            variant="destructive"
            onClick={handleDecline}
            disabled={rejectMutation.isPending || !isReasonValid}
          >
            {rejectMutation.isPending && (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            )}
            Decline Request
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/index.ts
export { PendingApprovalsView } from './pending-approvals-view'
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/pending-approvals-filter-logic.ts
/**
 * Pending Approvals Filter Logic
 * Pure functions for filtering and computing derived data in the pending approvals view.
 * Extracted from pending-approvals-view.tsx to reduce per-file complexity.
 */

import type {
  ActivityActionFilter,
  ActivityLogDto,
  PendingChangeDto
} from '../../../types/features/approval-workflow.types'
import { STATUS_FILTERS, TAB_MY_SUBMISSIONS, type SubmissionFilter } from './pending-approvals-helpers'

/** Maps tab values to their corresponding PAPI status codes for data fetching. */
export const TAB_STATUS_MAP: Record<string, string[]> = {
  'level-one': ['PENDING_LEVEL_ONE'],
  'level-two': ['PENDING_LEVEL_TWO'],
  'my-submissions': ['MY_SUBMISSIONS']
}

/** Maps activity action filter values to the PAPI action codes they include. */
export const ACTIVITY_ACTION_FILTERS: Record<Exclude<ActivityActionFilter, 'all'>, Array<ActivityLogDto['action']>> = {
  approvals: ['L1_APPROVE', 'L2_APPROVE'],
  rejections: ['REJECT'],
  submissions: ['SUBMIT', 'CANCEL'],
  direct_saves: ['DIRECT_SAVE']
}

/**
 * Filters pending submissions based on the selected submission filter tab.
 * Returns all items when on a non-submission tab or when filter is 'all'.
 */
export function filterSubmissions(
  items: PendingChangeDto[],
  activeTab: string,
  submissionFilter: SubmissionFilter
): PendingChangeDto[] {
  if (activeTab !== TAB_MY_SUBMISSIONS || submissionFilter === 'all') {
    return items
  }
  const allowedStatuses = STATUS_FILTERS[submissionFilter]
  return items.filter(item => allowedStatuses.includes(item.status))
}

/**
 * Filters activity log items based on the selected action filter.
 * Returns all items when filter is 'all'.
 */
export function filterActivities(
  activityItems: ActivityLogDto[],
  activityFilter: ActivityActionFilter
): ActivityLogDto[] {
  if (activityFilter === 'all') {
    return activityItems
  }
  return activityItems.filter(
    (activity) => ACTIVITY_ACTION_FILTERS[activityFilter].includes(activity.action)
  )
}

/**
 * Merges new activity data into the existing items list, deduplicating by ID.
 * On page 1, replaces the entire list. On subsequent pages, appends new items.
 */
export function mergeActivityItems(
  previousItems: ActivityLogDto[],
  newItems: ActivityLogDto[],
  page: number
): ActivityLogDto[] {
  if (page === 1) {
    return newItems
  }
  const existingIds = new Set(previousItems.map((item) => item.id))
  const nextItems = newItems.filter((item) => !existingIds.has(item.id))
  return [...previousItems, ...nextItems]
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/pending-approvals-helpers.ts
/**
 * Pending Approvals Helpers
 * Types, constants, and pure functions for the pending approvals view.
 */

import type { ActivityActionFilter } from '../../../types/features/approval-workflow.types'

export type TabValue = 'level-one' | 'level-two' | 'my-submissions' | 'my-activity'
export const TAB_MY_SUBMISSIONS: TabValue = 'my-submissions'
export const TAB_MY_ACTIVITY: TabValue = 'my-activity'
export const TAB_LEVEL_ONE: TabValue = 'level-one'
export type SubmissionFilter = 'all' | 'pending' | 'approved' | 'rejected' | 'cancelled'

export function handleTabValueChange(
  value: string,
  setActiveTab: (v: TabValue) => void,
  setSubmissionFilter: (v: SubmissionFilter) => void,
  setActivityFilter: (v: ActivityActionFilter) => void
) {
  setActiveTab(value as TabValue)
  if (value !== 'my-submissions') setSubmissionFilter('all')
  if (value !== 'my-activity') setActivityFilter('all')
}

export function getActivityTotalCount(filter: ActivityActionFilter, dataCount: number | undefined, filteredCount: number): number {
  if (filter === 'all') return dataCount ?? filteredCount
  return filteredCount
}

export const STATUS_FILTERS: Record<SubmissionFilter, string[]> = {
  all: [],
  pending: ['PENDING_LEVEL_ONE', 'PENDING_LEVEL_TWO'],
  approved: ['APPROVED'],
  rejected: ['REJECTED'],
  cancelled: ['CANCELLED']
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/pending-approvals-sub-components.tsx
/**
 * Pending Approvals Sub-Components
 * Small presentational components used by the PendingApprovalsView.
 */

import { Badge } from '../../ui/badge'
import { Card, CardContent } from '../../ui/card'
import { AlertCircle, RefreshCw } from 'lucide-react'
import { Button } from '../../ui/button'

/** Renders a count badge next to a tab label, hidden when count is 0 or not visible. */
export function TabBadge({ count, className, visible = true }: Readonly<{ count: number; className: string; visible?: boolean }>) {
  if (!visible || count <= 0) return null
  return (
    <Badge variant="secondary" className={`${className} ml-1`}>
      {count}
    </Badge>
  )
}

/** Renders an error card with a retry button when data fails to load. */
export function ErrorCard({ onRetry }: Readonly<{ onRetry: () => void }>) {
  return (
    <Card>
      <CardContent className="flex flex-col items-center justify-center py-8">
        <AlertCircle className="h-12 w-12 text-red-500 mb-4" />
        <h3 className="text-lg font-medium mb-2">Unable to Load</h3>
        <p className="text-muted-foreground text-center mb-4">
          There was a problem loading the data. Please try again.
        </p>
        <Button variant="outline" onClick={onRetry}>
          <RefreshCw className="h-4 w-4 mr-2" />
          Retry
        </Button>
      </CardContent>
    </Card>
  )
}

/** Wraps children with an error fallback, showing ErrorCard when isError is true. */
export function TabContentWithError({ isError, onRetry, children }: Readonly<{ isError: boolean; onRetry: () => void; children: React.ReactNode }>) {
  if (isError) return <ErrorCard onRetry={onRetry} />
  return <>{children}</>
}
===ENDFILE

===FILE: src/components/admin/pending-approvals-view/pending-approvals-view.tsx
/**
 * Pending Approvals View
 * Main view for reviewing and approving configuration changes
 */

import { useEffect, useMemo, useState } from 'react'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../../ui/tabs'
import { RefreshCw } from 'lucide-react'
import { Button } from '../../ui/button'
import { useMyActivity, usePendingChanges } from '../../../hooks/admin/use-pending-changes'
import { ApprovalRequestList } from './components/approval-request-list'
import { ActivityHistoryList } from './components/activity-history-list'
import { ApprovalStatsCards } from './components/approval-stats-cards'
import { SubmissionFilterToggle, ActivityActionFilterToggle, ActivityTimeRangeToggle } from './components/approval-filter-toggles'
import type { AdminPermissions } from '../admin-layout'
import type {
  ActivityActionFilter,
  ActivityLogDto,
  ActivityTimeRange,
  PendingChangeStatus
} from '../../../types/features/approval-workflow.types'
import {
  TAB_MY_SUBMISSIONS,
  TAB_MY_ACTIVITY,
  TAB_LEVEL_ONE,
  handleTabValueChange,
  getActivityTotalCount,
  type TabValue,
  type SubmissionFilter
} from './pending-approvals-helpers'
import { TabBadge, TabContentWithError } from './pending-approvals-sub-components'
import {
  TAB_STATUS_MAP,
  filterSubmissions,
  filterActivities,
  mergeActivityItems
} from './pending-approvals-filter-logic'

/** Re-export sub-components for backward compatibility */
export { TabBadge, ErrorCard, TabContentWithError } from './pending-approvals-sub-components'

/** Props for the PendingApprovalsView component. */
interface PendingApprovalsViewProps {
  /** Admin permissions controlling which approval actions are available */
  permissions: AdminPermissions
}

/**
 * Main view for the maker/checker approval workflow. Displays tabs for
 * level-one review, senior review, personal submissions, and activity history.
 */
export function PendingApprovalsView({ permissions: _permissions }: Readonly<PendingApprovalsViewProps>) {
  const [activeTab, setActiveTab] = useState<TabValue>(TAB_LEVEL_ONE)
  const [submissionFilter, setSubmissionFilter] = useState<SubmissionFilter>('all')
  const [activityFilter, setActivityFilter] = useState<ActivityActionFilter>('all')
  const [activityTimeRange, setActivityTimeRange] = useState<ActivityTimeRange>('all')
  const [activityPage, setActivityPage] = useState(1)
  const [activityItems, setActivityItems] = useState<ActivityLogDto[]>([])

  const {
    data: pendingData,
    isLoading,
    isError,
    refetch
  } = usePendingChanges({ status: (TAB_STATUS_MAP[activeTab] ?? TAB_STATUS_MAP[TAB_LEVEL_ONE]) as PendingChangeStatus[], limit: 50 })

  const {
    data: activityData,
    isLoading: isActivityLoading,
    isError: isActivityError,
    refetch: refetchActivity
  } = useMyActivity(activityPage, activityTimeRange, activeTab === TAB_MY_ACTIVITY)

  useEffect(() => {
    if (activeTab !== TAB_MY_ACTIVITY || !activityData) {
      return
    }
    setActivityItems((previousItems) =>
      mergeActivityItems(previousItems, activityData.items, activityPage)
    )
  }, [activityData, activityPage, activeTab])

  useEffect(() => {
    setActivityPage(1)
    setActivityItems([])
  }, [activityTimeRange])

  const levelOnePending = pendingData?.counts?.pendingLevelOne ?? 0
  const levelTwoPending = pendingData?.counts?.pendingLevelTwo ?? 0
  const mySubmissionsCount = pendingData?.counts?.mySubmissions ?? pendingData?.items?.length ?? 0
  const totalPending = levelOnePending + levelTwoPending

  const filteredSubmissions = useMemo(
    () => filterSubmissions(pendingData?.items ?? [], activeTab, submissionFilter),
    [pendingData?.items, activeTab, submissionFilter]
  )

  const filteredActivities = useMemo(
    () => filterActivities(activityItems, activityFilter),
    [activityFilter, activityItems]
  )

  const canLoadMoreActivity = activityItems.length < (activityData?.totalCount ?? 0)

  const handleLoadMoreActivity = () => {
    if (!canLoadMoreActivity || isActivityLoading) {
      return
    }
    setActivityPage((currentPage) => currentPage + 1)
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-start justify-between">
        <div>
          <h1 className="text-2xl font-semibold tracking-tight">
            Pending Approvals
          </h1>
          <p className="text-muted-foreground mt-1">
            Review and approve configuration changes
          </p>
        </div>
        <Button
          variant="outline"
        size="sm"
        onClick={() => refetch()}
        disabled={isLoading}
      >
          <RefreshCw className={`h-4 w-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} />
          Refresh
        </Button>
      </div>

      <ApprovalStatsCards
        totalPending={totalPending}
        levelOnePending={levelOnePending}
        levelTwoPending={levelTwoPending}
      />

      {/* Tabs */}
      <Tabs
        value={activeTab}
        onValueChange={(v) => handleTabValueChange(v, setActiveTab, setSubmissionFilter, setActivityFilter)}
      >
        <TabsList className="grid w-full grid-cols-4 max-w-4xl">
          <TabsTrigger value="level-one" className="flex items-center gap-2">
            Awaiting Review
            <TabBadge count={levelOnePending} className="bg-yellow-100 text-yellow-800" />
          </TabsTrigger>
          <TabsTrigger value="level-two" className="flex items-center gap-2">
            Awaiting Sr. Review
            <TabBadge count={levelTwoPending} className="bg-orange-100 text-orange-800" />
          </TabsTrigger>
          <TabsTrigger value="my-submissions" className="flex items-center gap-2">
            My Submissions
            <TabBadge count={mySubmissionsCount} className="bg-blue-100 text-blue-800" visible={activeTab === TAB_MY_SUBMISSIONS} />
          </TabsTrigger>
          <TabsTrigger value="my-activity" className="flex items-center gap-2">
            My Activity
          </TabsTrigger>
        </TabsList>

        <TabsContent value="level-one" className="mt-6">
          <TabContentWithError isError={isError} onRetry={() => refetch()}>
            <ApprovalRequestList
              changes={pendingData?.items ?? []}
              isLoading={isLoading}
              emptyMessage="No changes awaiting review"
              onRefresh={() => refetch()}
            />
          </TabContentWithError>
        </TabsContent>

        <TabsContent value="level-two" className="mt-6">
          <TabContentWithError isError={isError} onRetry={() => refetch()}>
            <ApprovalRequestList
              changes={pendingData?.items ?? []}
              isLoading={isLoading}
              emptyMessage="No changes awaiting senior review"
              onRefresh={() => refetch()}
            />
          </TabContentWithError>
        </TabsContent>

        <TabsContent value="my-submissions" className="mt-6">
          <TabContentWithError isError={isError} onRetry={() => refetch()}>
            <div className="space-y-4">
              <SubmissionFilterToggle value={submissionFilter} onChange={setSubmissionFilter} />
              <ApprovalRequestList
                changes={filteredSubmissions}
                isLoading={isLoading}
                emptyMessage="No Pending Submissions"
                emptyDescription="You have no pending change requests."
                onRefresh={() => refetch()}
              />
            </div>
          </TabContentWithError>
        </TabsContent>

        <TabsContent value="my-activity" className="mt-6">
          <div className="space-y-4">
            <div className="flex flex-wrap items-center gap-3">
              <ActivityActionFilterToggle value={activityFilter} onChange={setActivityFilter} />
              <ActivityTimeRangeToggle value={activityTimeRange} onChange={setActivityTimeRange} />
            </div>

            <TabContentWithError isError={isActivityError} onRetry={() => refetchActivity()}>
              <ActivityHistoryList
                activities={filteredActivities}
                isLoading={isActivityLoading}
                totalCount={getActivityTotalCount(activityFilter, activityData?.totalCount, filteredActivities.length)}
                page={activityPage}
                onLoadMore={handleLoadMoreActivity}
              />
            </TabContentWithError>
          </div>
        </TabsContent>

      </Tabs>
    </div>
  )
}

export default PendingApprovalsView
===ENDFILE

===FILE: src/components/admin/tabs/__tests__/applications-tab-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  Search: (p: any) => <span {...p} />, Package: (p: any) => <span {...p} />, Filter: (p: any) => <span {...p} />
}))
vi.mock('../../../ui/card', () => ({
  Card: ({ children, className }: any) => <div className={className}>{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>
}))
vi.mock('../../../ui/input', () => ({ Input: ({ onChange, value, placeholder }: any) => <input onChange={onChange} value={value} placeholder={placeholder} data-testid="search-input" /> }))
vi.mock('../../../ui/label', () => ({ Label: ({ children }: any) => <label>{children}</label> }))
vi.mock('../../../ui/badge', () => ({ Badge: ({ children }: any) => <span>{children}</span> }))
vi.mock('../../../ui/switch', () => ({
  Switch: ({ id, checked, onCheckedChange }: any) => <input type="checkbox" data-testid={`switch-${id}`} checked={checked} onChange={() => onCheckedChange?.(!checked)} />
}))
vi.mock('../../../ui/select', () => ({
  Select: ({ children, onValueChange, value }: any) => <div data-testid="select" data-value={value}>{children}</div>,
  SelectContent: ({ children }: any) => <div>{children}</div>,
  SelectItem: ({ children, value }: any) => <div data-value={value} onClick={() => {}}>{children}</div>,
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: ({ placeholder }: any) => <span>{placeholder}</span>
}))
vi.mock('../../app-card', () => ({
  AppCard: ({ app, onClick, selected }: any) => (
    <div data-testid="app-card" data-selected={selected} onClick={onClick}>{app.titleText}</div>
  )
}))
vi.mock('../../function-assignment-panel', () => ({
  FunctionAssignmentPanel: ({ onSelectionChange }: any) => {
    if (onSelectionChange) onSelectionChange(['fn1'], 'fn1')
    return <div data-testid="fn-panel" />
  }
}))

import { ApplicationsTab } from '../applications-tab'

const mockApps = [
  { appIdentifier: 'a1', titleText: 'Banking App', descriptionText: 'Banking description', categoryName: 'Finance', isAssignedIndicator: false, assignedFunctionKeys: [] },
  { appIdentifier: 'a2', titleText: 'Trading App', descriptionText: 'Trading description', categoryName: 'Markets', isAssignedIndicator: true, assignedFunctionKeys: ['f1'] },
  { appIdentifier: 'a3', titleText: 'Wealth App', descriptionText: 'Wealth description', categoryName: 'Finance', isAssignedIndicator: true, assignedFunctionKeys: ['f2'] }
]

describe('ApplicationsTab - extra coverage', () => {
  const baseProps = {
    availableApps: mockApps as any[],
    selectedApp: null,
    appSearchTerm: '',
    groupDisplayName: 'Test Group',
    isLoadingApps: false,
    isSavingAppAssignment: false,
    onAppSearchTermChange: vi.fn(),
    onAppSelect: vi.fn(),
    onAppSave: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('shows assigned count badge', () => {
    render(<ApplicationsTab {...baseProps} />)
    expect(screen.getByText('2 assigned')).toBeInTheDocument()
  })

  it('shows select app placeholder when no app selected', () => {
    render(<ApplicationsTab {...baseProps} />)
    expect(screen.getByText('Select an Application')).toBeInTheDocument()
    expect(screen.getByText(/Choose an application from the list/)).toBeInTheDocument()
  })

  it('shows loading skeletons when loading', () => {
    render(<ApplicationsTab {...baseProps} isLoadingApps={true} />)
    expect(screen.queryByTestId('app-card')).not.toBeInTheDocument()
  })

  it('shows no results message for search with no matches', () => {
    render(<ApplicationsTab {...baseProps} appSearchTerm="nonexistent" />)
    expect(screen.getByText('No applications found matching your search')).toBeInTheDocument()
  })

  it('filters apps by search term', () => {
    render(<ApplicationsTab {...baseProps} appSearchTerm="banking" />)
    const cards = screen.getAllByTestId('app-card')
    expect(cards).toHaveLength(1)
    expect(cards[0]).toHaveTextContent('Banking App')
  })

  it('fires onAppSearchTermChange when typing in search', () => {
    render(<ApplicationsTab {...baseProps} />)
    const input = screen.getByTestId('search-input')
    fireEvent.change(input, { target: { value: 'test' } })
    expect(baseProps.onAppSearchTermChange).toHaveBeenCalledWith('test')
  })

  it('calls onAppSelect when app card is clicked', () => {
    render(<ApplicationsTab {...baseProps} />)
    fireEvent.click(screen.getByText('Banking App'))
    expect(baseProps.onAppSelect).toHaveBeenCalledWith(mockApps[0])
  })

  it('renders function panel when app is selected', () => {
    render(<ApplicationsTab {...baseProps} selectedApp={mockApps[0] as any} />)
    expect(screen.getByTestId('fn-panel')).toBeInTheDocument()
  })

  it('passes onFunctionSelectionChange through to panel', () => {
    const onFunctionSelectionChange = vi.fn()
    render(<ApplicationsTab {...baseProps} selectedApp={mockApps[0] as any} onFunctionSelectionChange={onFunctionSelectionChange} />)
    expect(onFunctionSelectionChange).toHaveBeenCalledWith('a1', 'Banking App', ['fn1'], 'fn1')
  })

  it('toggles assigned only filter', () => {
    render(<ApplicationsTab {...baseProps} />)
    const toggle = screen.getByTestId('switch-assigned-filter')
    fireEvent.click(toggle)
    // After toggling, only assigned apps should remain
    const cards = screen.getAllByTestId('app-card')
    expect(cards).toHaveLength(2) // a2 and a3 are assigned
  })

  it('shows Assigned only label', () => {
    render(<ApplicationsTab {...baseProps} />)
    expect(screen.getByText('Assigned only')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/tabs/__tests__/applications-tab.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  Search: (p: any) => <span {...p} />, Package: (p: any) => <span {...p} />, Filter: (p: any) => <span {...p} />
}))
vi.mock('../../../ui/card', () => ({ Card: ({ children }: any) => <div>{children}</div>, CardContent: ({ children }: any) => <div>{children}</div> }))
vi.mock('../../../ui/input', () => ({ Input: (p: any) => <input {...p} /> }))
vi.mock('../../../ui/label', () => ({ Label: ({ children }: any) => <label>{children}</label> }))
vi.mock('../../../ui/badge', () => ({ Badge: ({ children }: any) => <span>{children}</span> }))
vi.mock('../../../ui/switch', () => ({ Switch: (p: any) => <input type="checkbox" data-testid="switch" {...p} /> }))
vi.mock('../../../ui/select', () => ({
  Select: ({ children }: any) => <div>{children}</div>,
  SelectContent: ({ children }: any) => <div>{children}</div>,
  SelectItem: ({ children }: any) => <div>{children}</div>,
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: () => <span />
}))
vi.mock('../../app-card', () => ({ AppCard: ({ app }: any) => <div data-testid="app-card">{app.titleText}</div> }))
vi.mock('../../function-assignment-panel', () => ({
  FunctionAssignmentPanel: () => <div data-testid="fn-panel" />
}))
vi.mock('../../../../lib/utils', () => ({ cn: (...a: unknown[]) => a.filter(Boolean).join(' ') }))

import { ApplicationsTab } from '../applications-tab'

const mockApps = [
  { appIdentifier: 'a1', titleText: 'App One', descriptionText: 'Desc', categoryName: 'Cat', isAssignedIndicator: false, assignedFunctionKeys: [] },
  { appIdentifier: 'a2', titleText: 'App Two', descriptionText: 'Desc', categoryName: 'Cat', isAssignedIndicator: true, assignedFunctionKeys: ['f1'] },
]

describe('ApplicationsTab', () => {
  const baseProps = {
    availableApps: mockApps as any[],
    selectedApp: null,
    appSearchTerm: '',
    groupDisplayName: 'Test Group',
    isLoadingApps: false,
    isSavingAppAssignment: false,
    onAppSearchTermChange: vi.fn(),
    onAppSelect: vi.fn(),
    onAppSave: vi.fn(),
  }

  it('renders app cards', () => {
    render(<ApplicationsTab {...baseProps} />)
    expect(screen.getAllByTestId('app-card')).toHaveLength(2)
  })

  it('shows no apps message when empty', () => {
    render(<ApplicationsTab {...baseProps} availableApps={[]} />)
    expect(screen.getByText('No applications available')).toBeInTheDocument()
  })

  it('shows function panel when app selected', () => {
    render(<ApplicationsTab {...baseProps} selectedApp={mockApps[0] as any} />)
    expect(screen.getByTestId('fn-panel')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/tabs/__tests__/business-info-helpers.test.ts
import { describe, it, expect, vi } from 'vitest'

vi.mock('../../../../utils/core/debug', () => ({
  createLogger: () => ({
    trace: vi.fn(), debug: vi.fn(), info: vi.fn(), warn: vi.fn(), error: vi.fn()
  })
}))

const {
  getMarketPlaceholder,
  getCountryPlaceholder,
  getLoadingPlaceholder,
  getFormValue,
  isMarketSelectedWithNoCountries,
  loadDependentOptions
} = await import('../business-info-helpers')

describe('getMarketPlaceholder', () => {
  it('returns "Select region first..." when no region', () => {
    expect(getMarketPlaceholder(undefined, false)).toBe('Select region first...')
  })

  it('returns "Loading markets..." when loading', () => {
    expect(getMarketPlaceholder('AMER', true)).toBe('Loading markets...')
  })

  it('returns "Select market..." when region selected and not loading', () => {
    expect(getMarketPlaceholder('AMER', false)).toBe('Select market...')
  })
})

describe('getCountryPlaceholder', () => {
  it('returns "Select market first..." when no market', () => {
    expect(getCountryPlaceholder(undefined, false)).toBe('Select market first...')
  })

  it('returns "Loading countries..." when loading', () => {
    expect(getCountryPlaceholder('US', true)).toBe('Loading countries...')
  })

  it('returns "Select country..." when market selected and not loading', () => {
    expect(getCountryPlaceholder('US', false)).toBe('Select country...')
  })
})

describe('getLoadingPlaceholder', () => {
  it('returns "Loading..." when loading', () => {
    expect(getLoadingPlaceholder(true, 'Select...')).toBe('Loading...')
  })

  it('returns default text when not loading', () => {
    expect(getLoadingPlaceholder(false, 'Select...')).toBe('Select...')
  })
})

describe('getFormValue', () => {
  it('returns value when defined', () => {
    expect(getFormValue('hello')).toBe('hello')
  })

  it('returns empty string when undefined', () => {
    expect(getFormValue(undefined)).toBe('')
  })

  it('returns empty string when null', () => {
    expect(getFormValue(null)).toBe('')
  })

  it('returns empty string when empty', () => {
    expect(getFormValue('')).toBe('')
  })
})

describe('isMarketSelectedWithNoCountries', () => {
  it('returns true when market selected, no countries, not loading', () => {
    expect(isMarketSelectedWithNoCountries('US', [], false)).toBe(true)
  })

  it('returns false when no market', () => {
    expect(isMarketSelectedWithNoCountries(undefined, [], false)).toBe(false)
  })

  it('returns false when countries exist', () => {
    expect(isMarketSelectedWithNoCountries('US', [{ countryCode: 'US' }], false)).toBe(false)
  })

  it('returns false when loading', () => {
    expect(isMarketSelectedWithNoCountries('US', [], true)).toBe(false)
  })

  it('returns false when market is empty string', () => {
    expect(isMarketSelectedWithNoCountries('', [], false)).toBe(false)
  })
})

describe('loadDependentOptions', () => {
  it('returns undefined and clears options when no parent value', () => {
    const setOptions = vi.fn()
    const setLoading = vi.fn()
    const fetcher = vi.fn()

    const cleanup = loadDependentOptions(undefined, fetcher, setOptions, setLoading, 'error')

    expect(cleanup).toBeUndefined()
    expect(setOptions).toHaveBeenCalledWith([])
  })

  it('calls fetcher and sets options on success', async () => {
    const setOptions = vi.fn()
    const setLoading = vi.fn()
    const data = [{ id: '1' }]
    const fetcher = vi.fn().mockResolvedValue(data)

    const cleanup = loadDependentOptions('AMER', fetcher, setOptions, setLoading, 'error')

    expect(cleanup).toBeDefined()
    expect(setLoading).toHaveBeenCalledWith(true)

    await vi.waitFor(() => {
      expect(setOptions).toHaveBeenCalledWith(data)
    })
  })

  it('handles fetch error gracefully', async () => {
    const setOptions = vi.fn()
    const setLoading = vi.fn()
    const fetcher = vi.fn().mockRejectedValue(new Error('fail'))

    loadDependentOptions('AMER', fetcher, setOptions, setLoading, 'load error')

    await vi.waitFor(() => {
      expect(setOptions).toHaveBeenCalledWith([])
    })
  })

  it('cleanup function prevents stale updates', async () => {
    const setOptions = vi.fn()
    const setLoading = vi.fn()
    let resolvePromise: (val: unknown[]) => void = () => {}
    const fetcher = vi.fn().mockReturnValue(new Promise<unknown[]>(res => { resolvePromise = res }))

    const cleanup = loadDependentOptions('AMER', fetcher, setOptions, setLoading, 'error')

    // Call cleanup before promise resolves
    cleanup?.()

    // Now resolve
    resolvePromise([{ id: '1' }])

    // Wait a tick
    await new Promise(r => setTimeout(r, 10))

    // setOptions should not have been called with the data (only the initial [] call from a prior test wouldn't be here)
    // Actually setOptions should have been called with [] initially before we called loadDependentOptions
    // The key is that it should NOT have been called with [{ id: '1' }]
    const calls = setOptions.mock.calls
    const dataCall = calls.find((c: unknown[][]) => Array.isArray(c[0]) && c[0].length > 0)
    expect(dataCall).toBeUndefined()
  })
})
===ENDFILE

===FILE: src/components/admin/tabs/__tests__/business-info-tab-extra.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../ui/card', () => ({
  Card: ({ children }: any) => <div>{children}</div>,
  CardContent: ({ children }: any) => <div>{children}</div>,
  CardDescription: ({ children }: any) => <p>{children}</p>,
  CardHeader: ({ children }: any) => <div>{children}</div>,
  CardTitle: ({ children }: any) => <h3>{children}</h3>
}))

vi.mock('../../../ui/input', () => ({
  Input: ({ onChange, value, disabled, id, placeholder }: any) => (
    <input data-testid={`input-${id}`} onChange={onChange} value={value || ''} disabled={disabled} placeholder={placeholder} />
  )
}))

vi.mock('../../../ui/label', () => ({
  Label: ({ children, htmlFor }: any) => <label htmlFor={htmlFor}>{children}</label>
}))

vi.mock('../../../ui/select', () => ({
  Select: ({ children, onValueChange, disabled, value }: any) => (
    <div data-testid="select" data-disabled={disabled} data-value={value}>
      {children}
      <button data-testid={`select-change-${value || 'empty'}`} onClick={() => onValueChange?.('test-value')}>trigger</button>
    </div>
  ),
  SelectContent: ({ children }: any) => <div>{children}</div>,
  SelectItem: ({ children, value }: any) => <div data-value={value}>{children}</div>,
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: ({ placeholder }: any) => <span>{placeholder}</span>
}))

vi.mock('@/hooks/features/use-dropdown-options', () => ({
  useDropdownOptions: () => ({
    roles: [
      { value: 'voice_agent', label: 'Voice Agent' },
      { value: 'chat_agent', label: 'Chat Agent' }
    ]
  })
}))

const stableGetMarkets = vi.fn(async () => [{ marketCode: 'MKT1', marketName: 'Market One' }])
const stableGetCountries = vi.fn(async () => [{ countryCode: 'GB', countryName: 'United Kingdom' }])

vi.mock('../../../../hooks/api/use-reference-data', () => ({
  useReferenceData: () => ({
    regions: [{ regionCode: 'EMEA', regionName: 'EMEA' }],
    businessUnits: [{ unitCode: 'WPB', unitName: 'WPB' }],
    roleTemplates: [],
    getMarketsForRegion: stableGetMarkets,
    getCountriesForMarket: stableGetCountries,
    isLoading: false,
    error: null
  })
}))

import { BusinessInfoTab } from '../business-info-tab'

describe('BusinessInfoTab - extra coverage', () => {
  const baseFormData = {
    logicalName: 'Test Group',
    groupIdentifier: 'CN=test-group',
    roleName: 'voice_agent',
    region: 'EMEA',
    market: 'MKT1',
    country: 'GB',
    businessUnit: 'WPB'
  } as any

  const basePending = { businessInfo: {}, permissions: {}, apps: {} } as any

  const baseProps = {
    formData: baseFormData,
    pendingChanges: basePending,
    onFormDataChange: vi.fn(),
    onPendingChangesUpdate: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders all form labels', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('Group Name *')).toBeInTheDocument()
    expect(screen.getByText('Role *')).toBeInTheDocument()
    expect(screen.getByText('Region *')).toBeInTheDocument()
    expect(screen.getByText('Market *')).toBeInTheDocument()
    expect(screen.getByText('Business Unit *')).toBeInTheDocument()
    expect(screen.getByText('Country *')).toBeInTheDocument()
  })

  it('calls onFormDataChange when group name input changes', () => {
    render(<BusinessInfoTab {...baseProps} />)
    const input = screen.getByTestId('input-logicalName')
    fireEvent.change(input, { target: { value: 'Updated Name' } })
    expect(baseProps.onFormDataChange).toHaveBeenCalledWith({ logicalName: 'Updated Name' })
  })

  it('calls onPendingChangesUpdate when group name changes', () => {
    render(<BusinessInfoTab {...baseProps} />)
    const input = screen.getByTestId('input-logicalName')
    fireEvent.change(input, { target: { value: 'Updated Name' } })
    expect(baseProps.onPendingChangesUpdate).toHaveBeenCalled()
  })

  it('disables inputs when read-only', () => {
    render(<BusinessInfoTab {...baseProps} isReadOnly={true} />)
    const input = screen.getByTestId('input-logicalName')
    expect(input).toBeDisabled()
  })

  it('renders role dropdown options', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('Voice Agent')).toBeInTheDocument()
    expect(screen.getByText('Chat Agent')).toBeInTheDocument()
  })

  it('renders region dropdown options', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('EMEA')).toBeInTheDocument()
  })

  it('renders business unit dropdown options', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('WPB')).toBeInTheDocument()
  })

  it('renders card description', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText(/Configure the basic business details/)).toBeInTheDocument()
  })

  it('shows populated form values', () => {
    render(<BusinessInfoTab {...baseProps} />)
    const nameInput = screen.getByTestId('input-logicalName') as HTMLInputElement
    expect(nameInput.value).toBe('Test Group')
  })

  it('handles empty form data with defaults', () => {
    const emptyFormData = {
      logicalName: undefined,
      roleName: undefined,
      region: '',
      market: '',
      country: '',
      businessUnit: ''
    } as any
    render(<BusinessInfoTab {...baseProps} formData={emptyFormData} />)
    expect(screen.getByText('Business Information')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/tabs/__tests__/business-info-tab.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

let selectOnValueChangeMap: Record<string, (v: string) => void> = {}

vi.mock('../../../ui/card', () => ({
  Card: ({ children }: any) => <div>{children}</div>,
  CardContent: ({ children }: any) => <div>{children}</div>,
  CardDescription: ({ children }: any) => <div>{children}</div>,
  CardHeader: ({ children }: any) => <div>{children}</div>,
  CardTitle: ({ children }: any) => <div>{children}</div>
}))
vi.mock('../../../ui/input', () => ({
  Input: (p: any) => <input data-testid={`input-${p.id || 'generic'}`} value={p.value} onChange={p.onChange} disabled={p.disabled} />
}))
vi.mock('../../../ui/label', () => ({ Label: ({ children, htmlFor }: any) => <label htmlFor={htmlFor}>{children}</label> }))
vi.mock('../../../ui/select', () => ({
  Select: ({ children, onValueChange, value, disabled }: any) => {
    const id = `select-${Math.random().toString(36).substr(2, 5)}`
    if (onValueChange) {
      const key = children?.toString() || id
      selectOnValueChangeMap[key] = onValueChange
    }
    return <div data-testid="select" data-value={value} data-disabled={disabled}>{children}</div>
  },
  SelectContent: ({ children }: any) => <div data-testid="select-content">{children}</div>,
  SelectItem: ({ children, value }: any) => (
    <div data-testid={`select-item-${value}`} onClick={() => {
      Object.values(selectOnValueChangeMap).forEach(fn => {
        try { fn(value) } catch (_) { /* ignore */ }
      })
    }}>{children}</div>
  ),
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: ({ placeholder }: any) => <span>{placeholder}</span>
}))
vi.mock('@/hooks/features/use-dropdown-options', () => ({
  useDropdownOptions: () => ({
    roles: [
      { value: 'chat_agent', label: 'Chat Agent' },
      { value: 'voice_agent', label: 'Voice Agent' }
    ],
    regions: [],
    markets: [],
    countries: [],
    businessUnits: []
  })
}))
const stableGetMarkets = vi.fn(async () => [])
const stableGetCountries = vi.fn(async () => [])
let mockRefError: string | null = null
vi.mock('../../../../hooks/api/use-reference-data', () => ({
  useReferenceData: () => ({
    regions: [{ regionCode: 'AMER', regionName: 'Americas' }, { regionCode: 'EMEA', regionName: 'Europe' }],
    businessUnits: [{ unitCode: 'WPB', unitName: 'Wealth & Personal Banking' }],
    roleTemplates: [],
    getMarketsForRegion: stableGetMarkets,
    getCountriesForMarket: stableGetCountries,
    isLoading: false,
    error: mockRefError
  })
}))
vi.mock('../../../../utils/core/debug', () => ({
  createLogger: () => ({ info: vi.fn(), warn: vi.fn(), error: vi.fn(), debug: vi.fn() })
}))
vi.mock('../../../../lib/utils', () => ({ cn: (...a: unknown[]) => a.filter(Boolean).join(' ') }))

import { BusinessInfoTab } from '../business-info-tab'

describe('BusinessInfoTab', () => {
  const baseProps = {
    formData: { logicalName: 'Test Group', groupIdentifier: 'CN=test', roleName: '', region: '', market: '', country: '', businessUnit: '' } as any,
    pendingChanges: { businessInfo: {}, permissions: {}, apps: {} } as any,
    onFormDataChange: vi.fn(),
    onPendingChangesUpdate: vi.fn(),
  }

  beforeEach(() => {
    vi.clearAllMocks()
    selectOnValueChangeMap = {}
    mockRefError = null
  })

  it('renders business info form', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('Business Information')).toBeInTheDocument()
  })

  it('renders group name field', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('Group Name *')).toBeInTheDocument()
  })

  it('renders all field labels', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('Role *')).toBeInTheDocument()
    expect(screen.getByText('Region *')).toBeInTheDocument()
    expect(screen.getByText('Market *')).toBeInTheDocument()
    expect(screen.getByText('Business Unit *')).toBeInTheDocument()
    expect(screen.getByText('Country *')).toBeInTheDocument()
  })

  it('renders role options from dropdown options', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('Chat Agent')).toBeInTheDocument()
    expect(screen.getByText('Voice Agent')).toBeInTheDocument()
  })

  it('renders region options from reference data', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('Americas')).toBeInTheDocument()
    expect(screen.getByText('Europe')).toBeInTheDocument()
  })

  it('calls onFormDataChange when group name input changes', () => {
    render(<BusinessInfoTab {...baseProps} />)
    const input = screen.getByTestId('input-logicalName')
    fireEvent.change(input, { target: { value: 'New Name' } })
    expect(baseProps.onFormDataChange).toHaveBeenCalledWith({ logicalName: 'New Name' })
  })

  it('calls onPendingChangesUpdate when field changes', () => {
    render(<BusinessInfoTab {...baseProps} />)
    const input = screen.getByTestId('input-logicalName')
    fireEvent.change(input, { target: { value: 'Updated' } })
    expect(baseProps.onPendingChangesUpdate).toHaveBeenCalledWith(
      expect.objectContaining({
        businessInfo: expect.objectContaining({ logicalName: 'Updated' })
      })
    )
  })

  it('renders card description text', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText(/Configure the basic business details/)).toBeInTheDocument()
  })

  it('renders business unit options from reference data', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('Wealth & Personal Banking')).toBeInTheDocument()
  })

  it('shows error message when reference data has error', () => {
    mockRefError = 'Load failed'
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('Failed to load regions')).toBeInTheDocument()
    expect(screen.getByText('Failed to load business units')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/tabs/__tests__/permissions-tab.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../ui/card', () => ({
  Card: ({ children }: any) => <div data-testid="card">{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>,
  CardDescription: ({ children }: any) => <p>{children}</p>,
  CardHeader: ({ children }: any) => <div>{children}</div>,
  CardTitle: ({ children, className }: any) => <h3 className={className}>{children}</h3>
}))

vi.mock('../../../ui/input', () => ({
  Input: (p: any) => <input data-testid="search-input" {...p} />
}))

vi.mock('../../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('../../../ui/switch', () => ({
  Switch: ({ checked, disabled, onCheckedChange }: any) => (
    <input type="checkbox" data-testid="switch" checked={checked} disabled={disabled} onChange={(e: any) => onCheckedChange?.(e.target.checked)} />
  )
}))

vi.mock('../../../ui/accordion', () => ({
  Accordion: ({ children, className }: any) => <div className={className}>{children}</div>,
  AccordionContent: ({ children, className }: any) => <div className={className}>{children}</div>,
  AccordionItem: ({ children, value }: any) => <div data-testid={`accordion-item-${value}`}>{children}</div>,
  AccordionTrigger: ({ children, className }: any) => <div className={className}>{children}</div>
}))

vi.mock('lucide-react', () => ({
  CheckCircle: (p: any) => <span data-testid="check-circle" {...p} />,
  AlertTriangle: (p: any) => <span data-testid="alert-triangle" {...p} />,
  Search: (p: any) => <span data-testid="search-icon" {...p} />
}))

vi.mock('../../../../lib/utils', () => ({
  cn: (...a: unknown[]) => a.filter(Boolean).join(' ')
}))

vi.mock('../../../../constants/permission-levels', () => ({
  permissionLevels: {
    capabilities: {
      title: 'Access Controls',
      description: 'Core actions',
      icon: (p: any) => <span {...p} />,
      businessNames: {
        'columns.kms': 'Knowledge Base',
        'columns.embeddedApps': 'Banking Applications',
        'columns.spaceCopilot': 'AI Assistant',
        'columns.chat': 'Chat Interface',
        'micro_frontends.mediaBar': 'Media Controls'
      }
    },
    workspacePreferences: {
      title: 'Workspace & Preferences',
      description: 'User preferences',
      icon: (p: any) => <span {...p} />,
      businessNames: {
        'settings_options.calls.autoAccept': 'Auto-Accept Calls',
        'settings_options.calls.doNotDisturb.duration': 'Do Not Disturb',
        'settings_options.interface.showTranscript': 'Show Transcripts',
        'settings_options.interface.autoCloseKnowledgeOnCallEnd': 'Auto-Close Knowledge',
        'settings_options.interface.spaceCopilotMode': 'AI Assistant Mode'
      }
    }
  }
}))

vi.mock('@/hooks/features/use-dropdown-options', () => ({
  useDropdownOptions: () => ({
    roles: [{ value: 'voice_agent', label: 'Voice Agent' }],
    regions: [],
    markets: [],
    countries: [],
    businessUnits: []
  })
}))

vi.mock('../../business-relevant-toggles', () => ({
  businessRelevantToggles: {
    capabilities: {
      title: 'Access Controls',
      description: 'Core actions',
      toggles: {
        'columns.kms': {
          visible: true,
          businessName: 'Knowledge Base',
          description: 'Access to knowledge base features',
          section: 'Dashboard Access',
          linkedKeys: ['features.search.knowledgeBase']
        }
      }
    },
    workspacePreferences: {
      title: 'Workspace & Preferences',
      description: 'User preferences',
      toggles: {
        'settings_options.calls.autoAccept': {
          visible: true,
          businessName: 'Auto-Accept Calls',
          description: 'Automatically accept incoming calls',
          section: 'Call Preferences'
        }
      }
    }
  }
}))

vi.mock('../../../../hooks/admin/use-permission-state', () => ({
  usePermissionState: () => ({
    isPermissionEnabled: () => true,
    hasUnsavedChanges: () => false
  })
}))

vi.mock('../../../../hooks/admin/use-permission-aggregators', () => ({
  usePermissionAggregators: () => ({
    getPermissionCount: () => 1,
    getEnabledPermissions: () => ['columns.kms'],
    getFilteredPermissions: () => ['columns.kms']
  })
}))

vi.mock('../../../../utils/admin/permission-level-resolver', () => ({
  resolvePermissionLevel: ({ level, key }: { level: string; key: string }) => {
    const COMPOUND: Record<string, string[]> = {
      capabilities: ['columns', 'features', 'micro_frontends'],
      workspacePreferences: ['widgets', 'settings_tabs', 'settings_options']
    }
    const prefixes = COMPOUND[level]
    if (!prefixes) return { actualLevel: level, actualKey: key }
    for (const prefix of prefixes) {
      if (key.startsWith(prefix + '.')) {
        return { actualLevel: prefix, actualKey: key.slice(prefix.length + 1) }
      }
    }
    const [p, ...rest] = key.split('.')
    return { actualLevel: p, actualKey: rest.join('.') }
  }
}))

vi.mock('../../../../utils/admin/permission-hierarchy-sorter', () => ({
  sortWithHierarchy: ({ keys }: { keys: string[] }) => keys
}))

import { PermissionsTab } from '../permissions-tab'

describe('PermissionsTab', () => {
  const defaultProps = {
    formData: {
      logicalName: 'Test Group',
      groupIdentifier: 'CN=test',
      roleName: 'voice_agent'
    } as any,
    roleTemplate: {
      name: 'voice_agent',
      capabilities: { 'columns.kms': true }
    } as any,
    permissionOverrides: {},
    pendingChanges: { permissions: {} } as any,
    searchTerm: '',
    loadingPermission: null,
    onSearchTermChange: vi.fn(),
    onTogglePermission: vi.fn()
  }

  it('renders role-inherited card when role and template exist', () => {
    render(<PermissionsTab {...defaultProps} />)
    expect(screen.getByText('Inherited from Voice Agent')).toBeInTheDocument()
    expect(screen.getByText('All permissions below are inherited from the role template. You can toggle features OFF but cannot add new ones.')).toBeInTheDocument()
  })

  it('shows select role message when no role is selected', () => {
    render(
      <PermissionsTab
        {...defaultProps}
        formData={{ ...defaultProps.formData, roleName: '' }}
        roleTemplate={null}
      />
    )
    expect(screen.getByText('Select a Role First')).toBeInTheDocument()
    expect(screen.getByText('Choose a role in the Business Info tab to see inherited permissions')).toBeInTheDocument()
  })

  it('shows loading message when template is being fetched', () => {
    render(
      <PermissionsTab
        {...defaultProps}
        roleTemplate={null}
        isLoadingTemplate
      />
    )
    expect(screen.getByText('Loading role template...')).toBeInTheDocument()
  })

  it('renders search input', () => {
    render(<PermissionsTab {...defaultProps} />)
    expect(screen.getByTestId('search-input')).toBeInTheDocument()
  })

  it('renders both permission level accordion sections', () => {
    render(<PermissionsTab {...defaultProps} />)
    expect(screen.getByText('Access Controls')).toBeInTheDocument()
    expect(screen.getByText('Workspace & Preferences')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/tabs/applications-tab.tsx
import { useState } from 'react'
import { Card, CardContent } from '../../ui/card'
import { Input } from '../../ui/input'
import { Label } from '../../ui/label'
import { Badge } from '../../ui/badge'
import { Switch } from '../../ui/switch'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '../../ui/select'
import { Search, Package, Filter } from 'lucide-react'
import { AppCard } from '../app-card'
import { FunctionAssignmentPanel } from '../function-assignment-panel'
import type { EmbeddedAppWithStatus } from '../../../types/integration/embedded-apps'

/** Props for the ApplicationsTab component. */
interface ApplicationsTabProps {
  /** List of all available embedded applications with assignment status */
  availableApps: EmbeddedAppWithStatus[]
  /** The currently selected application, or null if none selected */
  selectedApp: EmbeddedAppWithStatus | null
  /** Current search term for filtering applications */
  appSearchTerm: string
  /** Display name of the AD group (shown in the function panel) */
  groupDisplayName: string
  /** Whether the applications list is currently loading */
  isLoadingApps: boolean
  /** Whether an app assignment save is in progress */
  isSavingAppAssignment: boolean
  /** Callback invoked when the search term changes */
  onAppSearchTermChange: (term: string) => void
  /** Callback invoked when an application card is selected */
  onAppSelect: (app: EmbeddedAppWithStatus) => void
  /** Callback to save the function assignment for a specific application */
  onAppSave: (appKey: string, appTitle: string, functions: string[], defaultFunction?: string) => Promise<void>
  /** Callback invoked when function selections change (for staging unsaved changes) */
  onFunctionSelectionChange?: (appKey: string, appTitle: string, functions: string[], defaultFunction?: string) => void
  /** Whether the tab is in read-only mode */
  isReadOnly?: boolean
}

/**
 * Tab panel for managing embedded application assignments. Displays a split view
 * with the application catalog on the left and function assignment details on the right.
 */
export function ApplicationsTab({
  availableApps,
  selectedApp,
  appSearchTerm,
  groupDisplayName,
  isLoadingApps,
  isSavingAppAssignment,
  onAppSearchTermChange,
  onAppSelect,
  onAppSave,
  onFunctionSelectionChange,
  isReadOnly = false
}: Readonly<ApplicationsTabProps>) {
  // Filter states
  const [selectedCategory, setSelectedCategory] = useState<string>('all')
  const [showAssignedOnly, setShowAssignedOnly] = useState(false)

  // Extract unique categories from available apps
  const categories = ['all', ...new Set(availableApps.map(app => app.categoryName).filter(Boolean))]

  // Combined filtering logic
  const filteredApps = availableApps.filter(app => {
    // Search term filter
    const matchesSearch = !appSearchTerm ||
      app.titleText.toLowerCase().includes(appSearchTerm.toLowerCase()) ||
      app.descriptionText.toLowerCase().includes(appSearchTerm.toLowerCase()) ||
      app.categoryName.toLowerCase().includes(appSearchTerm.toLowerCase())

    // Category filter
    const matchesCategory = selectedCategory === 'all' || app.categoryName === selectedCategory

    // Assigned filter
    const matchesAssigned = !showAssignedOnly || app.isAssignedIndicator

    return matchesSearch && matchesCategory && matchesAssigned
  })

  return (
    <div className="grid h-full grid-cols-1 gap-6 lg:grid-cols-2">
      {/* Left Panel - Apps List */}
      <div className="h-full space-y-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Package className="h-4 w-4 text-gray-500" />
            <Label className="text-sm font-medium">Available Applications</Label>
            <Badge variant="outline" className="text-xs">
              {`${availableApps.filter(app => app.isAssignedIndicator).length} assigned`}
            </Badge>
          </div>
        </div>

        {/* Filter Controls - All in one line */}
        <div className="flex items-center gap-3">
          {/* Category Filter */}
          <div className="flex items-center gap-2 min-w-0 w-[200px]">
            <Filter className="h-4 w-4 text-gray-400 flex-shrink-0" />
            <Select value={selectedCategory} onValueChange={setSelectedCategory}>
              <SelectTrigger className="w-full">
                <SelectValue placeholder="All Categories" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Categories</SelectItem>
                {categories.filter(cat => cat !== 'all').map(category => (
                  <SelectItem key={category} value={category}>
                    {category}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* Assigned Apps Toggle */}
          <div className="flex items-center gap-2 bg-gray-50 border border-gray-200 rounded-lg px-3 py-1.5 whitespace-nowrap">
            <Label htmlFor="assigned-filter" className="text-sm font-medium cursor-pointer">
              Assigned only
            </Label>
            <Switch
              id="assigned-filter"
              checked={showAssignedOnly}
              onCheckedChange={setShowAssignedOnly}
            />
          </div>

          {/* Search Bar - Takes remaining space */}
          <div className="flex items-center gap-2 flex-1 min-w-0">
            <Search className="h-4 w-4 text-gray-400 flex-shrink-0" />
            <Input
              placeholder="Search applications..."
              value={appSearchTerm}
              onChange={(e) => onAppSearchTermChange(e.target.value)}
              className="flex-1"
            />
          </div>
        </div>

        <div className="space-y-2 max-h-[60vh] overflow-y-auto">
          {isLoadingApps && (
            <div className="space-y-2">
              {['s1', 's2', 's3'].map(id => (
                <Card key={id} className="animate-pulse">
                  <CardContent className="p-4">
                    <div className="flex items-start gap-3">
                      <div className="w-10 h-10 bg-gray-200 rounded-lg"></div>
                      <div className="flex-1">
                        <div className="w-24 h-4 bg-gray-200 rounded mb-2"></div>
                        <div className="w-32 h-3 bg-gray-200 rounded"></div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
          {!isLoadingApps && filteredApps.length > 0 && (
            filteredApps.map(app => (
              <AppCard
                key={app.appIdentifier}
                app={app}
                selected={selectedApp?.appIdentifier === app.appIdentifier}
                onClick={() => onAppSelect(app)}
              />
            ))
          )}
          {!isLoadingApps && filteredApps.length === 0 && (
            <div className="text-center py-8 text-gray-500 text-sm">
              {appSearchTerm ? 'No applications found matching your search' : 'No applications available'}
            </div>
          )}
        </div>
      </div>

      {/* Right Panel - Function Assignment */}
      <div className="space-y-4">
        {selectedApp ? (
          <FunctionAssignmentPanel
            app={selectedApp}
            groupName={groupDisplayName}
            onSave={async (functions, defaultFunction) => {
              await onAppSave(selectedApp.appIdentifier, selectedApp.titleText, functions, defaultFunction)
            }}
            onSelectionChange={onFunctionSelectionChange
              ? (functions, defaultFunction) => onFunctionSelectionChange(selectedApp.appIdentifier, selectedApp.titleText, functions, defaultFunction)
              : undefined
            }
            isLoading={isSavingAppAssignment}
            isReadOnly={isReadOnly}
          />
        ) : (
          <Card className="h-full">
            <CardContent className="flex flex-col items-center justify-center py-12">
              <Package className="h-12 w-12 text-gray-400 mb-4" />
              <h3 className="text-lg font-medium text-gray-900 mb-2">
                Select an Application
              </h3>
              <p className="text-gray-600 text-center max-w-sm">
                Choose an application from the list to configure its functions for this AD group
              </p>
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/tabs/business-info-helpers.ts
/**
 * Business Info Tab Helpers
 * Pure functions for placeholder text, form values, and dependent data loading.
 */

import { createLogger } from '../../../utils/core/debug'

const logger = createLogger('BusinessInfoTab')

/** Returns a placeholder string for the market dropdown based on region selection state. */
export function getMarketPlaceholder(region: string | undefined, loadingMarkets: boolean): string {
  if (!region) return 'Select region first...'
  if (loadingMarkets) return 'Loading markets...'
  return 'Select market...'
}

/** Returns a placeholder string for the country dropdown based on market selection state. */
export function getCountryPlaceholder(market: string | undefined, loadingCountries: boolean): string {
  if (!market) return 'Select market first...'
  if (loadingCountries) return 'Loading countries...'
  return 'Select country...'
}

/** Returns a loading placeholder or the default text. */
export function getLoadingPlaceholder(isLoading: boolean, defaultText: string): string {
  return isLoading ? 'Loading...' : defaultText
}

/** Normalizes a possibly-undefined form value to an empty string. */
export function getFormValue(value: string | undefined | null): string {
  return value || ''
}

/** Checks if a market is selected but has no country options available. */
export function isMarketSelectedWithNoCountries(
  market: string | undefined,
  countries: { countryCode: string }[],
  isLoading: boolean
): boolean {
  return Boolean(market) && market !== '' && countries.length === 0 && !isLoading
}

/**
 * Loads dependent dropdown options (e.g., markets for a region, countries for a market).
 * Returns a cleanup function to prevent stale updates, or undefined if no parent value.
 */
export function loadDependentOptions<T>(
  parentValue: string | undefined,
  fetcher: (value: string) => Promise<T[]>,
  setOptions: (options: T[]) => void,
  setLoading: (loading: boolean) => void,
  errorMessage: string
): (() => void) | undefined {
  if (!parentValue) {
    setOptions([])
    return undefined
  }
  let ignore = false
  setLoading(true)
  fetcher(parentValue)
    .then(results => { if (!ignore) setOptions(results) })
    .catch(err => {
      if (!ignore) {
        logger.error(errorMessage, err)
        setOptions([])
      }
    })
    .finally(() => { if (!ignore) setLoading(false) })
  return () => { ignore = true }
}
===ENDFILE

===FILE: src/components/admin/tabs/business-info-tab.tsx
import { useState, useEffect } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../../ui/card'
import { Input } from '../../ui/input'
import { Label } from '../../ui/label'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '../../ui/select'
import { useDropdownOptions } from '@/hooks/features/use-dropdown-options'
import { useReferenceData } from '../../../hooks/api/use-reference-data'
import type { CountryDto, MarketDto } from '../../../services/api/reference-data.service'
import type { AdGroup, PendingChanges } from '../../../types/features/ad-group-config'
import {
  getMarketPlaceholder,
  getCountryPlaceholder,
  getLoadingPlaceholder,
  getFormValue,
  isMarketSelectedWithNoCountries,
  loadDependentOptions
} from './business-info-helpers'

/** Re-export helpers for backward compatibility */
export {
  getMarketPlaceholder,
  getCountryPlaceholder,
  getLoadingPlaceholder,
  getFormValue,
  isMarketSelectedWithNoCountries,
  loadDependentOptions
} from './business-info-helpers'

/** Props for the BusinessInfoTab component. */
interface BusinessInfoTabProps {
  /** Current AD group form data */
  formData: AdGroup
  /** Pending unsaved changes for tracking modifications */
  pendingChanges: PendingChanges
  /** Callback invoked when a form field value changes */
  onFormDataChange: (data: Partial<AdGroup>) => void
  /** Callback invoked to update the pending changes tracker */
  onPendingChangesUpdate: (changes: PendingChanges) => void
  /** Whether the tab is in read-only mode */
  isReadOnly?: boolean
}

/** Displays an error message for reference data loading failures. */
function ReferenceDataError({ visible, message }: Readonly<{ visible: boolean; message: string }>) {
  if (!visible) return null
  return <p className="text-sm text-red-500">{message}</p>
}

/**
 * Tab panel for editing AD group business information including group name,
 * role, region, market, business unit, and country. Uses cascading dropdowns
 * where market depends on region, and country depends on market.
 */
export function BusinessInfoTab({
  formData,
  pendingChanges,
  onFormDataChange,
  onPendingChangesUpdate,
  isReadOnly = false
}: Readonly<BusinessInfoTabProps>) {
  const { regions, businessUnits, roleTemplates, getMarketsForRegion, getCountriesForMarket, isLoading, error } = useReferenceData()
  const dropdownOptions = useDropdownOptions({ roleTemplates })
  const [filteredMarkets, setFilteredMarkets] = useState<MarketDto[]>([])
  const [filteredCountries, setFilteredCountries] = useState<CountryDto[]>([])
  const [loadingMarkets, setLoadingMarkets] = useState(false)
  const [loadingCountries, setLoadingCountries] = useState(false)

  useEffect(
    () => loadDependentOptions(formData.region, getMarketsForRegion, setFilteredMarkets, setLoadingMarkets, 'Failed to load markets for region'),
    [formData.region, getMarketsForRegion]
  )

  useEffect(
    () => loadDependentOptions(formData.market, getCountriesForMarket, setFilteredCountries, setLoadingCountries, 'Failed to load countries for market'),
    [formData.market, getCountriesForMarket]
  )

  const handleFieldChange = (formUpdates: Partial<AdGroup>, pendingUpdates?: Record<string, string>) => {
    onFormDataChange(formUpdates)
    onPendingChangesUpdate({
      ...pendingChanges,
      businessInfo: {
        ...pendingChanges?.businessInfo,
        ...pendingUpdates ?? formUpdates
      }
    })
  }

  const handleRoleChange = (value: string) => {
    handleFieldChange({ roleName: value })
  }

  const handleRegionChange = (value: string) => {
    handleFieldChange(
      { region: value, market: '', country: '' },
      { region: value, market: '', country: '' }
    )
  }

  const handleMarketChange = (value: string) => {
    handleFieldChange(
      { market: value, country: '' },
      { market: value, country: '' }
    )
  }

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">Business Information</CardTitle>
          <CardDescription>
            Configure the basic business details for this AD group
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="logicalName">Group Name *</Label>
              <Input
                id="logicalName"
                placeholder="e.g., UK Retail Voice Agents"
                value={getFormValue(formData.logicalName)}
                onChange={(e) => handleFieldChange({ logicalName: e.target.value })}
                disabled={isReadOnly}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="role">Role *</Label>
              <Select
                value={getFormValue(formData.roleName)}
                onValueChange={handleRoleChange}
                disabled={isReadOnly}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select role..." />
                </SelectTrigger>
                <SelectContent>
                  {dropdownOptions.roles.map((role) => (
                    <SelectItem key={role.value} value={role.value}>
                      {role.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="region">Region *</Label>
              <Select
                value={getFormValue(formData.region)}
                onValueChange={handleRegionChange}
                disabled={isReadOnly || isLoading}
              >
                <SelectTrigger>
                  <SelectValue placeholder={getLoadingPlaceholder(isLoading, 'Select region...')} />
                </SelectTrigger>
                <SelectContent>
                  {regions.map((region) => (
                    <SelectItem key={region.regionCode} value={region.regionCode}>
                      {region.regionName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <ReferenceDataError visible={Boolean(error)} message="Failed to load regions" />
            </div>

            <div className="space-y-2">
              <Label htmlFor="market">Market *</Label>
              <Select
                value={getFormValue(formData.market)}
                onValueChange={handleMarketChange}
                disabled={isReadOnly || !formData.region || loadingMarkets}
              >
                <SelectTrigger>
                  <SelectValue
                    placeholder={getMarketPlaceholder(formData.region, loadingMarkets)}
                  />
                </SelectTrigger>
                <SelectContent>
                  {filteredMarkets.map((market) => (
                    <SelectItem key={market.marketCode} value={market.marketCode}>
                      {market.marketName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="businessUnit">Business Unit *</Label>
              <Select
                value={getFormValue(formData.businessUnit)}
                onValueChange={(value: string) => handleFieldChange({ businessUnit: value })}
                disabled={isReadOnly || isLoading}
              >
                <SelectTrigger>
                  <SelectValue placeholder={getLoadingPlaceholder(isLoading, 'Select business unit...')} />
                </SelectTrigger>
                <SelectContent>
                  {businessUnits.map((unit) => (
                    <SelectItem key={unit.unitCode} value={unit.unitCode}>
                      {unit.unitName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <ReferenceDataError visible={Boolean(error)} message="Failed to load business units" />
            </div>

            <div className="space-y-2">
              <Label htmlFor="country">Country *</Label>
              <Select
                value={getFormValue(formData.country)}
                onValueChange={(value: string) => handleFieldChange({ country: value })}
                disabled={isReadOnly || !formData.market || loadingCountries}
              >
                <SelectTrigger>
                  <SelectValue
                    placeholder={getCountryPlaceholder(formData.market, loadingCountries)}
                  />
                </SelectTrigger>
                <SelectContent>
                  {filteredCountries.map((country) => (
                    <SelectItem key={country.countryCode} value={country.countryCode}>
                      {country.countryName}
                    </SelectItem>
                  ))}
                  {isMarketSelectedWithNoCountries(formData.market, filteredCountries, loadingCountries) && (
                    <div className="text-sm text-gray-500 px-2 py-1">No countries available</div>
                  )}
                </SelectContent>
              </Select>
              {isMarketSelectedWithNoCountries(formData.market, filteredCountries, loadingCountries) && (
                <p className="text-sm text-red-500">No countries found for selected region</p>
              )}
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/tabs/permission-row.tsx
/**
 * PermissionRow Component
 * Renders a single permission toggle with change indicators and parent dependency handling.
 */

import { Badge } from '../../ui/badge'
import { Switch } from '../../ui/switch'
import { AlertTriangle } from 'lucide-react'
import { cn } from '../../../lib/utils'
import { businessRelevantToggles } from '../business-relevant-toggles'
import { resolvePermissionLevel } from '../../../utils/admin/permission-level-resolver'
import { getPermissionRowStyle, getPermissionSwitchDisabled } from './permissions-tab-helpers'
import type { AdGroup, PermissionOverrides } from '../../../types/features/ad-group-config'

function PermissionDescription({ description, warning, hasChanges, isOverridden, roleName }: Readonly<{
  description?: string
  warning?: string
  hasChanges: boolean
  isOverridden: boolean
  roleName: string
}>) {
  if (description) {
    return (
      <div>
        <div>{description}</div>
        {warning && <div className="text-orange-600 mt-1">{warning}</div>}
      </div>
    )
  }
  if (hasChanges) return <span className="text-blue-600 font-medium">Modified - not saved yet</span>
  if (isOverridden) return <span className="text-orange-600">Modified from role default</span>
  return <>{`Inherited from ${roleName} role`}</>
}

export interface PermissionRowProps {
  levelKey: string
  permissionKey: string
  formData: AdGroup
  permissionOverrides: PermissionOverrides
  loadingPermission: string | null
  isPermissionEnabled: (args: { level: string; key: string }) => boolean
  hasUnsavedChanges: (args: { level: string; key: string }) => boolean
  onTogglePermission: (level: string, key: string, value: boolean) => void
  isReadOnly?: boolean
}

export function PermissionRow({
  levelKey, permissionKey, formData, permissionOverrides,
  loadingPermission, isPermissionEnabled, hasUnsavedChanges, onTogglePermission,
  isReadOnly = false
}: Readonly<PermissionRowProps>) {
  const businessConfig = businessRelevantToggles[levelKey]?.toggles[permissionKey]
  const businessName = businessConfig?.businessName || permissionKey
  const description = businessConfig?.description
  const warning = businessConfig?.warning

  const isEnabled = isPermissionEnabled({ level: levelKey, key: permissionKey })

  const { actualLevel, actualKey } = resolvePermissionLevel({ level: levelKey, key: permissionKey })
  const isOverridden = permissionOverrides[actualLevel]?.[actualKey] !== undefined

  const hasChanges = hasUnsavedChanges({ level: levelKey, key: permissionKey })

  const hasParent = !!businessConfig?.parent
  const parentKey = businessConfig?.parent
  const parentEnabled = parentKey ? isPermissionEnabled({ level: levelKey, key: parentKey }) : true

  return (
    <div
      className={cn(
        "flex items-center justify-between p-3 border rounded-lg transition-colors",
        hasParent && "ml-8",
        !parentEnabled && "opacity-50",
        getPermissionRowStyle(hasChanges, isOverridden)
      )}
    >
      <div className="space-y-1 flex-1">
        <div className="font-medium text-sm flex items-center gap-2">
          {businessName}
          {hasChanges && (
            <Badge variant="secondary" className="text-xs bg-blue-100 text-blue-700">
              Unsaved
            </Badge>
          )}
          {warning && <AlertTriangle className="h-3 w-3 text-orange-500" />}
        </div>
        <div className="text-xs text-muted-foreground">
          <PermissionDescription
            description={description}
            warning={warning}
            hasChanges={hasChanges}
            isOverridden={isOverridden}
            roleName={formData.roleName ?? ''}
          />
        </div>
      </div>
      <Switch
        checked={isEnabled && parentEnabled}
        disabled={getPermissionSwitchDisabled(isReadOnly, parentEnabled, loadingPermission, levelKey, permissionKey)}
        onCheckedChange={(checked) => onTogglePermission(levelKey, permissionKey, checked)}
      />
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/tabs/permissions-tab-helpers.ts
/**
 * Permissions Tab Helpers
 * Pure functions for permission row styling and section grouping.
 */

import { businessRelevantToggles } from '../business-relevant-toggles'

/** Returns the CSS class for a permission row based on its change and override state. */
export function getPermissionRowStyle(hasChanges: boolean, isOverridden: boolean): string {
  if (hasChanges) return "border-blue-300 bg-blue-50 shadow-sm ring-1 ring-blue-200"
  if (isOverridden) return "border-orange-200 bg-orange-50"
  return "border-gray-200"
}

/** Determines whether the permission switch should be disabled. */
export function getPermissionSwitchDisabled(
  isReadOnly: boolean,
  parentEnabled: boolean,
  loadingPermission: string | null,
  levelKey: string,
  permissionKey: string
): boolean {
  return isReadOnly || !parentEnabled || loadingPermission === `${levelKey}.${permissionKey}`
}

/** Groups permission keys by their configured section within a permission level. */
export function groupBySection(keys: string[], levelKey: string): [string, string[]][] {
  const groups: Map<string, string[]> = new Map()

  for (const key of keys) {
    const config = businessRelevantToggles[levelKey]?.toggles[key]
    const section = config?.section || ''
    if (!groups.has(section)) {
      groups.set(section, [])
    }
    groups.get(section)!.push(key)
  }

  return Array.from(groups.entries())
}
===ENDFILE

===FILE: src/components/admin/tabs/permissions-tab.tsx
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../../ui/card'
import { Input } from '../../ui/input'
import { Badge } from '../../ui/badge'
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '../../ui/accordion'
import {
  CheckCircle,
  AlertTriangle,
  Search
} from 'lucide-react'
import { permissionLevels } from '../../../constants/permission-levels'
import { useDropdownOptions } from '@/hooks/features/use-dropdown-options'
import type {
  AdGroup,
  RoleTemplate,
  PermissionOverrides,
  PendingChanges
} from '../../../types/features/ad-group-config'
import { usePermissionState } from '../../../hooks/admin/use-permission-state'
import { usePermissionAggregators } from '../../../hooks/admin/use-permission-aggregators'
import { PermissionRow } from './permission-row'
import { groupBySection } from './permissions-tab-helpers'

/** Re-export for backward compatibility */
export { PermissionRow } from './permission-row'
export { getPermissionRowStyle, getPermissionSwitchDisabled, groupBySection } from './permissions-tab-helpers'

/** Props for the PermissionsTab component. */
interface PermissionsTabProps {
  /** Current AD group form data including the selected role */
  formData: AdGroup
  /** The role template providing inherited permissions */
  roleTemplate: RoleTemplate | null
  /** Whether the role template is currently loading */
  isLoadingTemplate?: boolean
  /** Permission overrides applied on top of the role template */
  permissionOverrides: PermissionOverrides
  /** Pending unsaved permission changes */
  pendingChanges: PendingChanges
  /** Current search term for filtering permissions */
  searchTerm: string
  /** Key of the permission currently being toggled (for loading state) */
  loadingPermission: string | null
  /** Callback invoked when the search term changes */
  onSearchTermChange: (term: string) => void
  /** Callback invoked when a permission toggle is switched */
  onTogglePermission: (level: string, key: string, value: boolean) => void
  /** Whether the tab is in read-only mode */
  isReadOnly?: boolean
}

/**
 * Tab panel displaying all inherited permissions from the role template.
 * Permissions are grouped by level (columns, widgets, features, etc.) and
 * organized into sections. Admins can toggle individual permissions off.
 */
export function PermissionsTab({
  formData,
  roleTemplate,
  isLoadingTemplate = false,
  permissionOverrides,
  pendingChanges,
  searchTerm,
  loadingPermission,
  onSearchTermChange,
  onTogglePermission,
  isReadOnly = false
}: Readonly<PermissionsTabProps>) {
  const dropdownOptions = useDropdownOptions()

  const { isPermissionEnabled, hasUnsavedChanges } = usePermissionState({
    roleTemplate,
    permissionOverrides,
    pendingChanges
  })

  const {
    getPermissionCount,
    getEnabledPermissions,
    getFilteredPermissions
  } = usePermissionAggregators({
    roleTemplate,
    searchTerm,
    isPermissionEnabled
  })

  if (formData.roleName && isLoadingTemplate) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-8">
          <p className="text-muted-foreground">Loading role template...</p>
        </CardContent>
      </Card>
    )
  }

  if (!formData.roleName || !roleTemplate) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-8">
          <AlertTriangle className="h-12 w-12 text-orange-500 mb-4" />
          <h3 className="text-lg font-medium mb-2">Select a Role First</h3>
          <p className="text-muted-foreground text-center">
            Choose a role in the Business Info tab to see inherited permissions
          </p>
        </CardContent>
      </Card>
    )
  }

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <CheckCircle className="h-5 w-5 text-green-500" />
            {`Inherited from ${dropdownOptions.roles.find(r => r.value === formData.roleName)?.label || formData.roleName}`}
          </CardTitle>
          <CardDescription>
            All permissions below are inherited from the role template. You can toggle features OFF but cannot add new ones.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex items-center gap-2 mb-4">
            <Search className="h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search permissions..."
              value={searchTerm}
              onChange={(e) => onSearchTermChange(e.target.value)}
              className="max-w-sm"
            />
          </div>
        </CardContent>
      </Card>

      <Accordion type="multiple" className="space-y-4">
        {Object.entries(permissionLevels).map(([levelKey, levelConfig]) => {
          const Icon = levelConfig.icon
          const enabledCount = getEnabledPermissions({ level: levelKey }).length
          const totalCount = getPermissionCount({ level: levelKey })
          const filteredPermissions = getFilteredPermissions({ level: levelKey })

          const isEmpty = (filteredPermissions.length === 0 && searchTerm) || totalCount === 0
          if (isEmpty) return null

          const sectionGroups = groupBySection(filteredPermissions, levelKey)
          const hasSections = sectionGroups.some(([name]) => name !== '')

          return (
            <Card key={levelKey}>
              <AccordionItem value={levelKey} className="border-none">
                <AccordionTrigger className="px-6 py-4 hover:no-underline">
                  <div className="flex items-center gap-3 text-left">
                    <Icon className="h-5 w-5" />
                    <div>
                      <h3 className="font-semibold">{levelConfig.title}</h3>
                      <p className="text-sm text-muted-foreground">{levelConfig.description}</p>
                      <div className="flex items-center gap-2 mt-1">
                        <Badge variant="outline" className="text-xs">
                          {`${enabledCount} of ${totalCount} enabled`}
                        </Badge>
                      </div>
                    </div>
                  </div>
                </AccordionTrigger>
                <AccordionContent className="px-6 pb-4">
                  <div className="flex flex-col gap-3">
                    {hasSections ? (
                      sectionGroups.map(([sectionName, keys]) => (
                        <div key={sectionName || '_default'}>
                          {sectionName && (
                            <h4 className="text-xs font-semibold text-muted-foreground uppercase tracking-wider mt-4 mb-2 first:mt-0">
                              {sectionName}
                            </h4>
                          )}
                          <div className="flex flex-col gap-3">
                            {keys.map((permissionKey) => (
                              <PermissionRow
                                key={permissionKey}
                                levelKey={levelKey}
                                permissionKey={permissionKey}
                                formData={formData}
                                permissionOverrides={permissionOverrides}
                                loadingPermission={loadingPermission}
                                isPermissionEnabled={isPermissionEnabled}
                                hasUnsavedChanges={hasUnsavedChanges}
                                onTogglePermission={onTogglePermission}
                                isReadOnly={isReadOnly}
                              />
                            ))}
                          </div>
                        </div>
                      ))
                    ) : (
                      filteredPermissions.map((permissionKey) => (
                        <PermissionRow
                          key={permissionKey}
                          levelKey={levelKey}
                          permissionKey={permissionKey}
                          formData={formData}
                          permissionOverrides={permissionOverrides}
                          loadingPermission={loadingPermission}
                          isPermissionEnabled={isPermissionEnabled}
                          hasUnsavedChanges={hasUnsavedChanges}
                          onTogglePermission={onTogglePermission}
                          isReadOnly={isReadOnly}
                        />
                      ))
                    )}
                  </div>
                  {filteredPermissions.length === 0 && !searchTerm && (
                    <div className="text-center py-8 text-muted-foreground">
                      No permissions available for this category in the selected role.
                    </div>
                  )}
                </AccordionContent>
              </AccordionItem>
            </Card>
          )
        })}
      </Accordion>
    </div>
  )
}
===ENDFILE

===FILE: src/components/admin/views/__tests__/notice-management-view-extra.test.tsx
import { describe, expect, it, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'

const mockListNotices = vi.fn()

vi.mock('@/hooks/features/use-notice-config', () => ({
  Bell: () => <span data-testid="bell-icon" />
}))

vi.mock('../../../../services/api/admin.service', () => ({
  adminService: {
    listNotices: (...args: unknown[]) => mockListNotices(...args)
  }
}))

vi.mock('../../notices/notice-form-modal', () => ({
  NoticeFormModal: ({ open, onSave, onClose, editNotice }: any) =>
    open ? (
      <div data-testid="notice-form-modal">
        <span data-testid="editing-notice">{editNotice?.title || 'none'}</span>
        <button data-testid="save-notice" onClick={onSave}>Save</button>
        <button data-testid="close-modal" onClick={onClose}>Close</button>
      </div>
    ) : null
}))

vi.mock('../../notices/notice-row', () => ({
  NoticeRow: ({ notice, onUpdate, onEdit }: any) => (
    <tr data-testid={`notice-row-${notice.id}`}>
      <td>{notice.title}</td>
      <td>
        <button
          data-testid={`edit-${notice.id}`}
          onClick={() => onEdit(notice)}
        >
          Edit
        </button>
        <button
          data-testid={`update-${notice.id}`}
          onClick={() => onUpdate({ ...notice, status: 'ARCHIVED' })}
        >
          Archive
        </button>
      </td>
    </tr>
  )
}))

vi.mock('../../../ui/button', () => ({
  Button: ({ children, onClick, ...rest }: any) => (
    <button onClick={onClick} {...rest}>{children}</button>
  )
}))

vi.mock('../../../ui/card', () => ({
  Card: ({ children, ...rest }: any) => <div data-testid="card" {...rest}>{children}</div>
}))

vi.mock('../../../ui/tabs', () => ({
  Tabs: ({ children, value, onValueChange }: any) => (
    <div data-testid="tabs" data-value={value}>
      {typeof children === 'object' && Array.isArray(children)
        ? children
        : children}
    </div>
  ),
  TabsList: ({ children }: any) => <div data-testid="tabs-list">{children}</div>,
  TabsTrigger: ({ children, value }: any) => (
    <button data-testid={`tab-${value}`}>{children}</button>
  ),
  TabsContent: ({ children, value }: any) => (
    <div data-testid={`tab-content-${value}`}>{children}</div>
  )
}))

vi.mock('../../../ui/table', () => ({
  Table: ({ children }: any) => <table>{children}</table>,
  TableBody: ({ children }: any) => <tbody>{children}</tbody>,
  TableHead: ({ children }: any) => <th>{children}</th>,
  TableHeader: ({ children }: any) => <thead>{children}</thead>,
  TableRow: ({ children }: any) => <tr>{children}</tr>
}))

vi.mock('../../../common/brand-loader', () => ({
  BrandLoader: () => <div data-testid="loader">Loading...</div>
}))

vi.mock('lucide-react', () => ({
  ArrowUpDown: () => <span data-testid="arrow-updown" />,
  ArrowUp: () => <span data-testid="arrow-up" />,
  ArrowDown: () => <span data-testid="arrow-down" />
}))

import { NoticeManagementView } from '../notice-management-view'
import type { AdminPermissions } from '../../admin-layout'

const allPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

const mockNotices = [
  { id: 'n1', title: 'Active Notice 1', status: 'ACTIVE', severity: 'INFO', createdAt: '2025-01-15T10:00:00Z' },
  { id: 'n2', title: 'Active Notice 2', status: 'ACTIVE', severity: 'WARNING', createdAt: '2025-01-16T10:00:00Z' },
  { id: 'n3', title: 'Draft Notice', status: 'DRAFT', severity: 'INFO', createdAt: '2025-01-17T10:00:00Z' },
  { id: 'n4', title: 'Archived Notice', status: 'ARCHIVED', severity: 'ERROR', createdAt: '2025-01-18T10:00:00Z' }
]

describe('NoticeManagementView - extended', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockListNotices.mockResolvedValue(mockNotices)
  })

  it('sorts notices by date in descending order by default', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      const rows = screen.getAllByTestId(/^notice-row-/)
      expect(rows.length).toBeGreaterThan(0)
    })
  })

  it('opens edit modal when edit button is clicked', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByTestId('edit-n1')).toBeInTheDocument()
    })
    fireEvent.click(screen.getByTestId('edit-n1'))
    expect(screen.getByTestId('notice-form-modal')).toBeInTheDocument()
    expect(screen.getByTestId('editing-notice')).toHaveTextContent('Active Notice 1')
  })

  it('optimistically updates notice status', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByTestId('update-n1')).toBeInTheDocument()
    })
    fireEvent.click(screen.getByTestId('update-n1'))
    // The update should reflect in the UI without re-fetching
  })

  it('refreshes notices when modal save is triggered', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.queryByTestId('notice-form-modal')).not.toBeInTheDocument()
    })

    fireEvent.click(screen.getByText('Create Notice'))
    expect(screen.getByTestId('notice-form-modal')).toBeInTheDocument()

    fireEvent.click(screen.getByTestId('save-notice'))
    expect(mockListNotices).toHaveBeenCalledTimes(2) // initial + after save
  })

  it('closes modal and clears editing notice', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByTestId('edit-n1')).toBeInTheDocument()
    })

    fireEvent.click(screen.getByTestId('edit-n1'))
    expect(screen.getByTestId('notice-form-modal')).toBeInTheDocument()

    fireEvent.click(screen.getByTestId('close-modal'))
    expect(screen.queryByTestId('notice-form-modal')).not.toBeInTheDocument()
  })

  it('renders sort button with toggle functionality', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      const sortButtons = screen.getAllByText('Created')
      expect(sortButtons.length).toBeGreaterThan(0)
    })
  })

  it('shows empty message for drafts when no draft notices', async () => {
    mockListNotices.mockResolvedValue([
      { id: 'n1', title: 'Active', status: 'ACTIVE', severity: 'INFO', createdAt: '2025-01-15T10:00:00Z' }
    ])
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByText('No draft notices.')).toBeInTheDocument()
    })
  })

  it('shows empty message for archived when no archived notices', async () => {
    mockListNotices.mockResolvedValue([
      { id: 'n1', title: 'Active', status: 'ACTIVE', severity: 'INFO', createdAt: '2025-01-15T10:00:00Z' }
    ])
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByText('No archived notices.')).toBeInTheDocument()
    })
  })
})
===ENDFILE

===FILE: src/components/admin/views/__tests__/notice-management-view.test.tsx
import { describe, expect, it, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'

const mockListNotices = vi.fn()

vi.mock('@/hooks/features/use-notice-config', () => ({
  Bell: () => <span data-testid="bell-icon" />
}))

vi.mock('../../../../services/api/admin.service', () => ({
  adminService: {
    listNotices: (...args: unknown[]) => mockListNotices(...args)
  }
}))

vi.mock('../../notices/notice-form-modal', () => ({
  NoticeFormModal: ({ open }: { open: boolean }) =>
    open ? <div data-testid="notice-form-modal">Modal</div> : null
}))

vi.mock('../../notices/notice-row', () => ({
  NoticeRow: ({ notice }: { notice: { title: string } }) => (
    <tr data-testid="notice-row"><td>{notice.title}</td></tr>
  )
}))

vi.mock('../../../ui/button', () => ({
  Button: ({ children, onClick, ...rest }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} {...rest}>{children as React.ReactNode}</button>
  )
}))

vi.mock('../../../ui/card', () => ({
  Card: ({ children, ...rest }: Record<string, unknown>) => <div data-testid="card" {...rest}>{children as React.ReactNode}</div>
}))

vi.mock('../../../ui/tabs', () => ({
  Tabs: ({ children }: Record<string, unknown>) => (
    <div data-testid="tabs">{children as React.ReactNode}</div>
  ),
  TabsList: ({ children }: { children: React.ReactNode }) => <div data-testid="tabs-list">{children}</div>,
  TabsTrigger: ({ children, value }: { children: React.ReactNode; value: string }) => (
    <button data-testid={`tab-${value}`}>{children}</button>
  ),
  TabsContent: ({ children, value }: { children: React.ReactNode; value: string }) => (
    <div data-testid={`tab-content-${value}`}>{children}</div>
  )
}))

vi.mock('../../../ui/table', () => ({
  Table: ({ children }: { children: React.ReactNode }) => <table>{children}</table>,
  TableBody: ({ children }: { children: React.ReactNode }) => <tbody>{children}</tbody>,
  TableHead: ({ children }: { children: React.ReactNode }) => <th>{children}</th>,
  TableHeader: ({ children }: { children: React.ReactNode }) => <thead>{children}</thead>,
  TableRow: ({ children }: { children: React.ReactNode }) => <tr>{children}</tr>
}))

vi.mock('../../../common/brand-loader', () => ({
  BrandLoader: () => <div data-testid="loader">Loading...</div>
}))

vi.mock('lucide-react', () => ({
  ArrowUpDown: () => <span data-testid="arrow-updown" />,
  ArrowUp: () => <span data-testid="arrow-up" />,
  ArrowDown: () => <span data-testid="arrow-down" />
}))

import { NoticeManagementView } from '../notice-management-view'
import type { AdminPermissions } from '../../admin-layout'

const allPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

const mockNotices = [
  { id: 'n1', title: 'Active Notice', status: 'ACTIVE', severity: 'INFO', createdAt: '2025-01-15T10:00:00Z' },
  { id: 'n2', title: 'Draft Notice', status: 'DRAFT', severity: 'WARNING', createdAt: '2025-01-16T10:00:00Z' },
  { id: 'n3', title: 'Archived Notice', status: 'ARCHIVED', severity: 'ERROR', createdAt: '2025-01-17T10:00:00Z' }
]

describe('NoticeManagementView', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockListNotices.mockResolvedValue(mockNotices)
  })

  it('renders title and description', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByText('System Notices')).toBeInTheDocument()
      expect(screen.getByText('Create and manage notices for users across the platform')).toBeInTheDocument()
    })
  })

  it('renders create notice button with permission', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByText('Create Notice')).toBeInTheDocument()
    })
  })

  it('hides create notice button without permission', async () => {
    render(<NoticeManagementView permissions={{ ...allPermissions, canCreateNotice: false }} />)
    await waitFor(() => {
      expect(screen.queryByText('Create Notice')).not.toBeInTheDocument()
    })
  })

  it('shows loading state initially', () => {
    mockListNotices.mockReturnValue(new Promise(() => {}))
    render(<NoticeManagementView permissions={allPermissions} />)
    expect(screen.getByTestId('loader')).toBeInTheDocument()
  })

  it('renders tab triggers', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByTestId('tab-active')).toBeInTheDocument()
      expect(screen.getByTestId('tab-draft')).toBeInTheDocument()
      expect(screen.getByTestId('tab-archived')).toBeInTheDocument()
    })
  })

  it('renders notice rows after loading', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      const rows = screen.getAllByTestId('notice-row')
      expect(rows.length).toBeGreaterThan(0)
    })
  })

  it('shows empty state when no active notices', async () => {
    mockListNotices.mockResolvedValue([
      { id: 'n1', title: 'Draft', status: 'DRAFT', severity: 'INFO', createdAt: '2025-01-15T10:00:00Z' }
    ])

    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByText('No active notices. Create one to get started.')).toBeInTheDocument()
    })
  })

  it('handles API error gracefully', async () => {
    mockListNotices.mockRejectedValue(new Error('API error'))

    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByText('No active notices. Create one to get started.')).toBeInTheDocument()
    })
  })

  it('opens create modal on button click', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.queryByTestId('notice-form-modal')).not.toBeInTheDocument()
    })

    fireEvent.click(screen.getByText('Create Notice'))
    expect(screen.getByTestId('notice-form-modal')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/admin/views/notice-management-view.tsx
import { useState, useEffect } from 'react'
import { Button } from '../../ui/button'
import { Card } from '../../ui/card'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../../ui/tabs'
import { Bell } from '@/hooks/features/use-notice-config'
import { adminService, type AdminNoticeResponse } from '../../../services/api/admin.service'
import { NoticeFormModal } from '../notices/notice-form-modal'
import { NoticeRow } from '../notices/notice-row'
import {
  Table,
  TableBody,
  TableHead,
  TableHeader,
  TableRow
} from '../../ui/table'
import { BrandLoader } from '../../common/brand-loader'
import type { AdminPermissions } from '../admin-layout'
import { ArrowUpDown, ArrowUp, ArrowDown } from 'lucide-react'

/** Props for the NoticeManagementView component. */
interface NoticeManagementViewProps {
  /** Admin permissions controlling notice creation, publishing, and archiving */
  permissions: AdminPermissions
}

/** Sort direction for the notices table. Null means no explicit sorting. */
type SortOrder = 'asc' | 'desc' | null

/**
 * Sorts a list of notices by their creation date.
 * @param noticeList - The array of notices to sort
 * @param order - The sort direction, or null for no sorting
 * @returns A new sorted array (original is not mutated)
 */
function sortNoticesByDate(noticeList: AdminNoticeResponse[], order: SortOrder): AdminNoticeResponse[] {
  if (!order) return noticeList
  return [...noticeList].sort((a, b) => {
    const dateA = new Date(a.createdAt).getTime()
    const dateB = new Date(b.createdAt).getTime()
    return order === 'desc' ? dateB - dateA : dateA - dateB
  })
}

/**
 * Cycles through the sort order: null -> desc -> asc -> null.
 * @param current - The current sort order
 * @returns The next sort order in the cycle
 */
function getNextSortOrder(current: SortOrder): SortOrder {
  if (current === null) return 'desc'
  if (current === 'desc') return 'asc'
  return null
}

/** Clickable column header that cycles through ascending, descending, and unsorted states. */
function SortButton({ sortOrder, onToggle }: Readonly<{ sortOrder: SortOrder; onToggle: () => void }>) {
  return (
    <button
      type="button"
      onClick={onToggle}
      className="flex items-center gap-1 hover:text-foreground transition-colors"
    >
      Created
      {sortOrder === null && <ArrowUpDown className="h-4 w-4" />}
      {sortOrder === 'desc' && <ArrowDown className="h-4 w-4" />}
      {sortOrder === 'asc' && <ArrowUp className="h-4 w-4" />}
    </button>
  )
}

/** Props for the internal NoticeTable component. */
interface NoticeTableProps {
  /** The list of notices to display in the table */
  notices: AdminNoticeResponse[]
  /** Message shown when the notices list is empty */
  emptyMessage: string
  /** Current sort direction for the created date column */
  sortOrder: SortOrder
  /** Callback to cycle the sort order */
  onToggleSort: () => void
  /** Callback invoked when a notice is updated (e.g., status change) */
  onUpdate: (notice: AdminNoticeResponse) => void
  /** Callback invoked when the edit button is clicked on a notice */
  onEdit: (notice: AdminNoticeResponse) => void
  /** Admin permissions for controlling available row actions */
  permissions: AdminPermissions
}

/** Renders a table of notices with sortable date column and per-row action buttons. */
function NoticeTable({ notices, emptyMessage, sortOrder, onToggleSort, onUpdate, onEdit, permissions }: Readonly<NoticeTableProps>) {
  if (notices.length === 0) {
    return (
      <div className="p-12 text-center text-muted-foreground">
        {emptyMessage}
      </div>
    )
  }

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Title</TableHead>
          <TableHead>Severity</TableHead>
          <TableHead>Targets</TableHead>
          <TableHead>
            <SortButton sortOrder={sortOrder} onToggle={onToggleSort} />
          </TableHead>
          <TableHead className="text-right">Actions</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {notices.map(notice => (
          <NoticeRow
            key={notice.id}
            notice={notice}
            onUpdate={onUpdate}
            onEdit={onEdit}
            permissions={permissions}
          />
        ))}
      </TableBody>
    </Table>
  )
}

/**
 * System notices management view. Provides tabbed views for active, draft, and archived
 * notices with sortable creation dates. Supports creating, editing, publishing, and archiving.
 */
export function NoticeManagementView({ permissions }: Readonly<NoticeManagementViewProps>) {
  const [activeTab, setActiveTab] = useState<string>('active')
  const [showCreateModal, setShowCreateModal] = useState(false)
  const [editingNotice, setEditingNotice] = useState<AdminNoticeResponse | null>(null)
  const [notices, setNotices] = useState<AdminNoticeResponse[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [sortOrder, setSortOrder] = useState<SortOrder>('desc')

  const loadNotices = async () => {
    setIsLoading(true)
    const data = await adminService.listNotices().catch(() => null)
    setNotices(data ?? [])
    setIsLoading(false)
  }

  useEffect(() => {
    loadNotices()
  }, [])

  const toggleSort = () => {
    setSortOrder(getNextSortOrder)
  }

  const activeNotices = sortNoticesByDate(notices.filter(n => n.status === 'ACTIVE'), sortOrder)
  const draftNotices = sortNoticesByDate(notices.filter(n => n.status === 'DRAFT'), sortOrder)
  const archivedNotices = sortNoticesByDate(notices.filter(n => n.status === 'ARCHIVED'), sortOrder)

  const handleNoticeCreated = () => {
    setShowCreateModal(false)
    setEditingNotice(null)
    loadNotices()
  }

  const handleNoticeUpdated = (updatedNotice: AdminNoticeResponse) => {
    // Optimistically update the local state instead of re-fetching
    setNotices(prevNotices =>
      prevNotices.map(notice =>
        notice.id === updatedNotice.id ? updatedNotice : notice
      )
    )
  }

  const handleEditNotice = (notice: AdminNoticeResponse) => {
    setEditingNotice(notice)
    setShowCreateModal(true)
  }

  const handleCloseModal = () => {
    setShowCreateModal(false)
    setEditingNotice(null)
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold tracking-tight">System Notices</h2>
          <p className="text-muted-foreground mt-1">
            Create and manage notices for users across the platform
          </p>
        </div>
        {permissions.canCreateNotice && (
          <Button onClick={() => setShowCreateModal(true)}>
            <Bell className="h-4 w-4 mr-2" />
            Create Notice
          </Button>
        )}
      </div>

      {/* Tabs */}
      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <TabsList>
          <TabsTrigger value="active">
            {`Active (${activeNotices.length})`}
          </TabsTrigger>
          <TabsTrigger value="draft">
            {`Drafts (${draftNotices.length})`}
          </TabsTrigger>
          <TabsTrigger value="archived">
            {`Archived (${archivedNotices.length})`}
          </TabsTrigger>
        </TabsList>

        {isLoading ? (
          <Card className="p-12">
            <BrandLoader size="lg" message="Loading system notices..." />
          </Card>
        ) : (
          <>
            <TabsContent value="active">
              <Card className="w-full">
                <NoticeTable
                  notices={activeNotices}
                  emptyMessage="No active notices. Create one to get started."
                  sortOrder={sortOrder}
                  onToggleSort={toggleSort}
                  onUpdate={handleNoticeUpdated}
                  onEdit={handleEditNotice}
                  permissions={permissions}
                />
              </Card>
            </TabsContent>

            <TabsContent value="draft">
              <Card className="w-full">
                <NoticeTable
                  notices={draftNotices}
                  emptyMessage="No draft notices."
                  sortOrder={sortOrder}
                  onToggleSort={toggleSort}
                  onUpdate={handleNoticeUpdated}
                  onEdit={handleEditNotice}
                  permissions={permissions}
                />
              </Card>
            </TabsContent>

            <TabsContent value="archived">
              <Card className="w-full">
                <NoticeTable
                  notices={archivedNotices}
                  emptyMessage="No archived notices."
                  sortOrder={sortOrder}
                  onToggleSort={toggleSort}
                  onUpdate={handleNoticeUpdated}
                  onEdit={handleEditNotice}
                  permissions={permissions}
                />
              </Card>
            </TabsContent>
          </>
        )}
      </Tabs>

      {/* Create/Edit Notice Modal */}
      <NoticeFormModal
        open={showCreateModal}
        onClose={handleCloseModal}
        onSave={handleNoticeCreated}
        editNotice={editingNotice}
      />
    </div>
  )
}
===ENDFILE

===FILE: src/components/common/__tests__/brand-loader.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  Loader2: (props: Record<string, unknown>) => <span data-testid="loader-icon" className={props.className as string} />
}))

vi.mock('../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

import { BrandLoader } from '../brand-loader'

describe('BrandLoader', () => {
  it('renders with default message from i18n', () => {
    render(<BrandLoader />)
    expect(screen.getByText('Loading your HSBC workspace\u2026')).toBeInTheDocument()
    expect(screen.getByRole('status')).toBeInTheDocument()
  })

  it('renders with custom message', () => {
    render(<BrandLoader message="Please wait..." />)
    expect(screen.getByText('Please wait...')).toBeInTheDocument()
  })

  it('renders the loader icon', () => {
    render(<BrandLoader />)
    expect(screen.getByTestId('loader-icon')).toBeInTheDocument()
  })

  it('applies size classes', () => {
    const { rerender } = render(<BrandLoader size="sm" />)
    expect(screen.getByRole('status')).toBeInTheDocument()

    rerender(<BrandLoader size="lg" />)
    expect(screen.getByRole('status')).toBeInTheDocument()
  })

  it('renders inline variant', () => {
    render(<BrandLoader inline />)
    const status = screen.getByRole('status')
    expect(status.className).toContain('flex-row')
  })

  it('applies custom className', () => {
    render(<BrandLoader className="my-custom" />)
    const status = screen.getByRole('status')
    expect(status.className).toContain('my-custom')
  })
})
===ENDFILE

===FILE: src/components/common/brand-loader.tsx
import { cn } from '@/lib/utils'
import { Loader2 } from 'lucide-react'

/** Available size variants for the brand loader. */
type LoaderSize = 'sm' | 'md' | 'lg'

/** Props for the BrandLoader component. */
interface BrandLoaderProps {
  /** Custom loading message (defaults to 'Loading your HSBC workspace...') */
  message?: string
  /** Size variant controlling icon and text dimensions */
  size?: LoaderSize
  /** Optional additional CSS class names */
  className?: string
  /** When true, renders the loader inline (horizontal layout) */
  inline?: boolean
}

const ICON_SIZE_CLASSMAP: Record<LoaderSize, string> = {
  sm: 'h-4 w-4',
  md: 'h-6 w-6',
  lg: 'h-8 w-8'
}

const GAP_CLASSMAP: Record<LoaderSize, string> = {
  sm: 'gap-2',
  md: 'gap-3',
  lg: 'gap-4'
}

const TEXT_SIZE_CLASSMAP: Record<LoaderSize, string> = {
  sm: 'text-xs',
  md: 'text-sm',
  lg: 'text-base'
}

/**
 * HSBC branded loader used across all surfaces to maintain consistent experience.
 * Uses Loader2 icon from lucide-react as the standard HSBC spinner.
 * Always displays a message for better user feedback.
 */
export function BrandLoader({
  message,
  size = 'md',
  className,
  inline = false
}: Readonly<BrandLoaderProps>) {
  const containerClasses = cn(
    'flex items-center justify-center text-center',
    inline ? 'flex-row' : 'flex-col',
    inline ? 'gap-2' : GAP_CLASSMAP[size],
    className
  )

  const textClasses = cn(
    'font-medium tracking-wide text-foreground',
    TEXT_SIZE_CLASSMAP[size]
  )

  const displayMessage = message || 'Loading your HSBC workspace\u2026'

  return (
    <output className={containerClasses} aria-live="polite">
      <Loader2
        className={cn(
          'animate-spin text-[#DB0011]',
          ICON_SIZE_CLASSMAP[size]
        )}
        aria-hidden="true"
      />
      <span className={textClasses}>
        {displayMessage}
      </span>
    </output>
  )
}
===ENDFILE

===FILE: src/components/ui/__tests__/calendar-grid.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'
import { CalendarGrid } from '../calendar-grid'
import { startOfDay, addDays, startOfMonth, endOfMonth, startOfWeek, endOfWeek } from 'date-fns'

function buildCalendarDays(month: Date): Date[] {
  const monthStart = startOfMonth(month)
  const rangeStart = startOfWeek(monthStart, { weekStartsOn: 0 })
  const rangeEnd = endOfWeek(endOfMonth(month), { weekStartsOn: 0 })
  const days: Date[] = []
  let cursor = rangeStart
  while (cursor <= rangeEnd) {
    days.push(cursor)
    cursor = addDays(cursor, 1)
  }
  return days
}

describe('CalendarGrid', () => {
  const baseMonth = new Date(2026, 1, 1) // Feb 2026
  const calendarDays = buildCalendarDays(baseMonth)
  const onDateSelect = vi.fn()
  const onMonthChange = vi.fn()
  const onClear = vi.fn()

  const defaultProps = {
    currentMonth: baseMonth,
    calendarDays,
    selectedDate: null,
    normalizedMinDate: undefined,
    onDateSelect,
    onMonthChange,
    onClear,
    canClear: false
  }

  it('renders weekday labels', () => {
    render(<CalendarGrid {...defaultProps} />)
    expect(screen.getByText('Sun')).toBeInTheDocument()
    expect(screen.getByText('Mon')).toBeInTheDocument()
    expect(screen.getByText('Sat')).toBeInTheDocument()
  })

  it('renders month and year', () => {
    render(<CalendarGrid {...defaultProps} />)
    expect(screen.getByText('February 2026')).toBeInTheDocument()
  })

  it('renders navigation buttons', () => {
    render(<CalendarGrid {...defaultProps} />)
    expect(screen.getByLabelText('Previous month')).toBeInTheDocument()
    expect(screen.getByLabelText('Next month')).toBeInTheDocument()
  })

  it('calls onMonthChange with previous month on previous click', () => {
    render(<CalendarGrid {...defaultProps} />)
    fireEvent.click(screen.getByLabelText('Previous month'))
    expect(onMonthChange).toHaveBeenCalled()
  })

  it('calls onMonthChange with next month on next click', () => {
    render(<CalendarGrid {...defaultProps} />)
    fireEvent.click(screen.getByLabelText('Next month'))
    expect(onMonthChange).toHaveBeenCalled()
  })

  it('calls onDateSelect when a day is clicked', () => {
    render(<CalendarGrid {...defaultProps} />)
    // Click on day 15
    const day15 = screen.getByText('15')
    fireEvent.click(day15)
    expect(onDateSelect).toHaveBeenCalled()
  })

  it('disables clear button when canClear is false', () => {
    render(<CalendarGrid {...defaultProps} canClear={false} />)
    const clearBtn = screen.getByText('Clear')
    expect(clearBtn).toBeDisabled()
  })

  it('enables clear button when canClear is true', () => {
    render(<CalendarGrid {...defaultProps} canClear={true} />)
    const clearBtn = screen.getByText('Clear')
    expect(clearBtn).not.toBeDisabled()
  })

  it('calls onClear when clear button is clicked', () => {
    render(<CalendarGrid {...defaultProps} canClear={true} />)
    fireEvent.click(screen.getByText('Clear'))
    expect(onClear).toHaveBeenCalled()
  })

  it('disables jump to date button when no date selected', () => {
    render(<CalendarGrid {...defaultProps} selectedDate={null} />)
    const jumpBtn = screen.getByText('Jump to date')
    expect(jumpBtn).toBeDisabled()
  })

  it('enables jump to date button when date is selected', () => {
    const selected = startOfDay(new Date(2026, 1, 10))
    render(<CalendarGrid {...defaultProps} selectedDate={selected} />)
    const jumpBtn = screen.getByText('Jump to date')
    expect(jumpBtn).not.toBeDisabled()
  })

  it('calls onMonthChange on jump to date click', () => {
    const selected = startOfDay(new Date(2026, 1, 10))
    render(<CalendarGrid {...defaultProps} selectedDate={selected} />)
    fireEvent.click(screen.getByText('Jump to date'))
    expect(onMonthChange).toHaveBeenCalledWith(selected)
  })

  it('disables days before minDate', () => {
    const minDate = startOfDay(new Date(2026, 1, 10))
    render(<CalendarGrid {...defaultProps} normalizedMinDate={minDate} />)
    // Day 5 should be disabled
    const day5 = screen.getByText('5')
    expect(day5).toBeDisabled()
  })

  it('does not disable selected date even if before minDate', () => {
    const minDate = startOfDay(new Date(2026, 1, 15))
    const selected = startOfDay(new Date(2026, 1, 10))
    render(<CalendarGrid {...defaultProps} normalizedMinDate={minDate} selectedDate={selected} />)
    const day10 = screen.getByText('10')
    expect(day10).not.toBeDisabled()
  })
})
===ENDFILE

===FILE: src/components/ui/__tests__/date-time-picker-utils.test.ts
import { describe, it, expect } from 'vitest'
import {
  DEFAULT_TIME_SLOTS,
  WEEKDAY_LABELS,
  toLocalDateTimeValue,
  parseLocalDateTime,
  formatTimeLabel
} from '../date-time-picker-utils'

describe('date-time-picker-utils', () => {
  describe('DEFAULT_TIME_SLOTS', () => {
    it('contains time slots from 09:00 to 23:30', () => {
      expect(DEFAULT_TIME_SLOTS[0].time).toBe('09:00')
      expect(DEFAULT_TIME_SLOTS[DEFAULT_TIME_SLOTS.length - 1].time).toBe('23:30')
    })

    it('has some unavailable slots', () => {
      const unavailable = DEFAULT_TIME_SLOTS.filter(s => !s.available)
      expect(unavailable.length).toBeGreaterThan(0)
    })
  })

  describe('WEEKDAY_LABELS', () => {
    it('contains 7 days starting with Sun', () => {
      expect(WEEKDAY_LABELS).toHaveLength(7)
      expect(WEEKDAY_LABELS[0]).toBe('Sun')
      expect(WEEKDAY_LABELS[6]).toBe('Sat')
    })
  })

  describe('toLocalDateTimeValue', () => {
    it('formats date and time into ISO local datetime', () => {
      const date = new Date(2025, 0, 15) // Jan 15, 2025
      expect(toLocalDateTimeValue(date, '14:30')).toBe('2025-01-15T14:30')
    })

    it('pads single-digit months and days', () => {
      const date = new Date(2025, 2, 5) // Mar 5, 2025
      expect(toLocalDateTimeValue(date, '09:05')).toBe('2025-03-05T09:05')
    })

    it('handles midnight', () => {
      const date = new Date(2025, 11, 31)
      const result = toLocalDateTimeValue(date, '00:00')
      expect(result).toContain('T00:00')
    })
  })

  describe('parseLocalDateTime', () => {
    it('returns nulls for undefined', () => {
      expect(parseLocalDateTime(undefined)).toEqual({ date: null, time: null })
    })

    it('returns nulls for null', () => {
      expect(parseLocalDateTime(null)).toEqual({ date: null, time: null })
    })

    it('returns nulls for empty string', () => {
      expect(parseLocalDateTime('')).toEqual({ date: null, time: null })
    })

    it('returns nulls for invalid date string', () => {
      expect(parseLocalDateTime('not-a-date')).toEqual({ date: null, time: null })
    })

    it('parses ISO datetime with time part', () => {
      const result = parseLocalDateTime('2025-01-15T14:30')
      expect(result.date).toBeInstanceOf(Date)
      expect(result.time).toBe('14:30')
    })

    it('parses date without time part', () => {
      const result = parseLocalDateTime('2025-01-15')
      expect(result.date).toBeInstanceOf(Date)
      expect(result.time).toBeNull()
    })
  })

  describe('formatTimeLabel', () => {
    it('formats 24h time to locale time string', () => {
      const label = formatTimeLabel('14:30')
      // The exact format depends on locale, but it should contain the time
      expect(label).toBeTruthy()
      expect(typeof label).toBe('string')
    })

    it('formats morning time', () => {
      const label = formatTimeLabel('09:00')
      expect(label).toBeTruthy()
    })
  })
})
===ENDFILE

===FILE: src/components/ui/__tests__/date-time-picker.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('@radix-ui/react-popover', () => ({
  Root: ({ children, open }: any) => <div data-testid="popover-root" data-open={open}>{children}</div>,
  Trigger: ({ children, asChild }: any) => <div data-testid="popover-trigger">{children}</div>,
  Portal: ({ children }: any) => <div data-testid="popover-portal">{children}</div>,
  Content: ({ children }: any) => <div data-testid="popover-content">{children}</div>
}))

vi.mock('../button', () => ({
  Button: ({ children, onClick, id, className }: any) => (
    <button onClick={onClick} data-testid={id || 'picker-button'} className={className}>{children}</button>
  )
}))

vi.mock('../label', () => ({
  Label: ({ children, htmlFor }: any) => <label htmlFor={htmlFor}>{children}</label>
}))

vi.mock('../dialog', () => ({
  getDialogPortalContainer: () => null
}))

vi.mock('../date-time-picker-utils', () => ({
  DEFAULT_TIME_SLOTS: ['09:00', '10:00', '11:00'],
  toLocalDateTimeValue: (date: Date, time: string) => `${date.toISOString().split('T')[0]}T${time}`,
  parseLocalDateTime: (value?: string) => {
    if (!value) return { date: null, time: null }
    const [datePart, timePart] = value.split('T')
    return {
      date: datePart ? new Date(datePart) : null,
      time: timePart || null
    }
  },
  formatTimeLabel: (time: string) => time
}))

vi.mock('../calendar-grid', () => ({
  CalendarGrid: ({ onDateSelect, onClear, onMonthChange }: any) => (
    <div data-testid="calendar-grid">
      <button data-testid="select-date" onClick={() => onDateSelect(new Date('2025-03-15'))}>Select Date</button>
      <button data-testid="clear-date" onClick={onClear}>Clear</button>
      <button data-testid="change-month" onClick={() => onMonthChange(new Date('2025-04-01'))}>Change Month</button>
    </div>
  )
}))

vi.mock('../time-slot-panel', () => ({
  TimeSlotPanel: ({ onTimeSelect }: any) => (
    <div data-testid="time-slot-panel">
      <button data-testid="select-time" onClick={() => onTimeSelect('09:00')}>Select Time</button>
    </div>
  )
}))

vi.mock('lucide-react', () => ({
  CalendarIcon: () => <span data-testid="calendar-icon" />
}))

import { DateTimePicker } from '../date-time-picker'

describe('DateTimePicker', () => {
  const defaultProps = {
    id: 'test-picker',
    label: 'Pick Date',
    value: undefined as string | undefined,
    onChange: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders label and trigger button', () => {
    render(<DateTimePicker {...defaultProps} />)
    expect(screen.getByText('Pick Date')).toBeInTheDocument()
  })

  it('displays placeholder when no value is set', () => {
    render(<DateTimePicker {...defaultProps} />)
    expect(screen.getByText('Pick a date and time')).toBeInTheDocument()
  })

  it('displays custom placeholder when provided', () => {
    render(<DateTimePicker {...defaultProps} placeholder="Choose date" />)
    expect(screen.getByText('Choose date')).toBeInTheDocument()
  })

  it('renders calendar grid and time slot panel', () => {
    render(<DateTimePicker {...defaultProps} />)
    expect(screen.getByTestId('calendar-grid')).toBeInTheDocument()
    expect(screen.getByTestId('time-slot-panel')).toBeInTheDocument()
  })

  it('calls onChange with undefined when date is cleared', () => {
    render(<DateTimePicker {...defaultProps} />)
    fireEvent.click(screen.getByTestId('clear-date'))
    expect(defaultProps.onChange).toHaveBeenCalledWith(undefined)
  })

  it('renders with a pre-selected value', () => {
    render(<DateTimePicker {...defaultProps} value="2025-03-15T09:00" />)
    expect(screen.getByTestId('calendar-grid')).toBeInTheDocument()
  })

  it('renders with minDate prop', () => {
    render(<DateTimePicker {...defaultProps} minDate={new Date('2025-01-01')} />)
    expect(screen.getByTestId('calendar-grid')).toBeInTheDocument()
  })

  it('accepts custom time slots', () => {
    render(<DateTimePicker {...defaultProps} timeSlots={['08:00', '12:00', '16:00']} />)
    expect(screen.getByTestId('time-slot-panel')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/ui/__tests__/dialog.test.ts
import { beforeEach, describe, expect, it } from 'vitest'
import { getDialogPortalContainer } from '../dialog'

describe('getDialogPortalContainer', () => {
  beforeEach(() => {
    document.body.innerHTML = ''
  })

  it('returns undefined when admin root is missing', () => {
    expect(getDialogPortalContainer()).toBeUndefined()
  })

  it('returns the admin root element when present', () => {
    const root = document.createElement('div')
    root.className = 'admin-mfe-root'
    document.body.appendChild(root)

    expect(getDialogPortalContainer()).toBe(root)
  })
})
===ENDFILE

===FILE: src/components/ui/__tests__/select.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import React from 'react'

vi.mock('../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

vi.mock('../dialog', () => ({
  getDialogPortalContainer: () => null
}))

vi.mock('lucide-react', () => ({
  Check: (p: any) => <span data-testid="check-icon" {...p} />,
  ChevronDown: (p: any) => <span data-testid="chevron-down" {...p} />,
  ChevronUp: (p: any) => <span data-testid="chevron-up" {...p} />
}))

vi.mock('@radix-ui/react-select', () => {
  const Root = ({ children, ...props }: any) => <div data-testid="select-root" {...props}>{children}</div>
  const Value = React.forwardRef(({ children, ...props }: any, ref: any) => <span data-testid="select-value" ref={ref} {...props}>{children}</span>)
  Value.displayName = 'SelectValue'
  const Trigger = React.forwardRef(({ className, children, ...props }: any, ref: any) => (
    <button data-testid="select-trigger" className={className} ref={ref} {...props}>{children}</button>
  ))
  Trigger.displayName = 'SelectTrigger'
  const Icon = ({ children, asChild, ...props }: any) => <span data-testid="select-icon" {...props}>{children}</span>
  const Portal = ({ children }: any) => <div data-testid="select-portal">{children}</div>
  const Content = React.forwardRef(({ className, children, position, ...props }: any, ref: any) => (
    <div data-testid="select-content" className={className} ref={ref} {...props}>{children}</div>
  ))
  Content.displayName = 'SelectContent'
  const Viewport = ({ className, children }: any) => <div data-testid="select-viewport" className={className}>{children}</div>
  const ScrollUpButton = React.forwardRef(({ className, children, ...props }: any, ref: any) => (
    <div data-testid="scroll-up" className={className} ref={ref} {...props}>{children}</div>
  ))
  ScrollUpButton.displayName = 'ScrollUpButton'
  const ScrollDownButton = React.forwardRef(({ className, children, ...props }: any, ref: any) => (
    <div data-testid="scroll-down" className={className} ref={ref} {...props}>{children}</div>
  ))
  ScrollDownButton.displayName = 'ScrollDownButton'
  const Label = React.forwardRef(({ className, ...props }: any, ref: any) => (
    <span data-testid="select-label" className={className} ref={ref} {...props} />
  ))
  Label.displayName = 'SelectLabel'
  const Item = React.forwardRef(({ className, children, ...props }: any, ref: any) => (
    <div data-testid="select-item" className={className} ref={ref} {...props}>{children}</div>
  ))
  Item.displayName = 'SelectItem'
  const ItemIndicator = ({ children }: any) => <span data-testid="item-indicator">{children}</span>
  const ItemText = ({ children }: any) => <span data-testid="item-text">{children}</span>
  const Separator = React.forwardRef(({ className, ...props }: any, ref: any) => (
    <hr data-testid="select-separator" className={className} ref={ref} {...props} />
  ))
  Separator.displayName = 'SelectSeparator'

  return {
    Root,
    Value,
    Trigger,
    Icon,
    Portal,
    Content,
    Viewport,
    ScrollUpButton,
    ScrollDownButton,
    Label,
    Item,
    ItemIndicator,
    ItemText,
    Separator
  }
})

import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../select'

describe('Select components', () => {
  it('renders Select root', () => {
    render(
      <Select>
        <SelectTrigger>
          <SelectValue placeholder="Choose" />
        </SelectTrigger>
      </Select>
    )
    expect(screen.getByTestId('select-root')).toBeInTheDocument()
  })

  it('renders SelectTrigger with children', () => {
    render(
      <Select>
        <SelectTrigger className="w-40">
          <SelectValue placeholder="Test" />
        </SelectTrigger>
      </Select>
    )
    expect(screen.getByTestId('select-trigger')).toBeInTheDocument()
  })

  it('renders SelectContent with items', () => {
    render(
      <Select>
        <SelectContent>
          <SelectItem value="opt1">Option 1</SelectItem>
          <SelectItem value="opt2">Option 2</SelectItem>
        </SelectContent>
      </Select>
    )
    expect(screen.getAllByTestId('select-item')).toHaveLength(2)
  })

  it('renders SelectValue', () => {
    render(
      <Select>
        <SelectTrigger>
          <SelectValue placeholder="Pick one" />
        </SelectTrigger>
      </Select>
    )
    expect(screen.getByTestId('select-value')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/ui/__tests__/sheet.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('@/lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

vi.mock('../dialog', () => ({
  getDialogPortalContainer: () => null
}))

vi.mock('lucide-react', () => ({
  X: (p: any) => <span data-testid="x-icon" {...p} />
}))

vi.mock('class-variance-authority', () => ({
  cva: () => () => 'sheet-content-class'
}))

vi.mock('@radix-ui/react-dialog', () => {
  const Root = ({ children, open }: any) =>
    open !== false ? <div data-testid="sheet-root">{children}</div> : null
  const Trigger = ({ children }: any) => <div data-testid="sheet-trigger">{children}</div>
  const Portal = ({ children }: any) => <div data-testid="sheet-portal">{children}</div>
  const Overlay = (({ className, ...props }: any, ref: any) => (
    <div data-testid="sheet-overlay" className={className} ref={ref} {...props} />
  ))
  const Content = (({ className, children, ...props }: any, ref: any) => (
    <div data-testid="sheet-content" className={className} ref={ref} {...props}>{children}</div>
  ))
  const Close = ({ children, className }: any) => (
    <button data-testid="sheet-close" className={className}>{children}</button>
  )
  const Title = (({ className, children, ...props }: any, ref: any) => (
    <h2 data-testid="sheet-title" className={className} ref={ref} {...props}>{children}</h2>
  ))
  const Description = (({ className, children, ...props }: any, ref: any) => (
    <p data-testid="sheet-description" className={className} ref={ref} {...props}>{children}</p>
  ))

  return {
    Root,
    Trigger,
    Portal,
    Overlay: Object.assign(
      (props: any, ref: any) => Overlay(props, ref),
      { displayName: 'SheetOverlay' }
    ),
    Content: Object.assign(
      (props: any, ref: any) => Content(props, ref),
      { displayName: 'SheetContent' }
    ),
    Close,
    Title: Object.assign(
      (props: any, ref: any) => Title(props, ref),
      { displayName: 'SheetTitle' }
    ),
    Description: Object.assign(
      (props: any, ref: any) => Description(props, ref),
      { displayName: 'SheetDescription' }
    )
  }
})

import { Sheet, SheetTrigger, SheetContent, SheetHeader, SheetFooter, SheetTitle, SheetDescription } from '../sheet'

describe('Sheet components', () => {
  it('renders Sheet with trigger and content', () => {
    render(
      <Sheet open={true}>
        <SheetTrigger>Open</SheetTrigger>
        <SheetContent>
          <SheetHeader>
            <SheetTitle>Title</SheetTitle>
            <SheetDescription>Description</SheetDescription>
          </SheetHeader>
          <p>Content here</p>
          <SheetFooter>
            <button>Close</button>
          </SheetFooter>
        </SheetContent>
      </Sheet>
    )
    expect(screen.getByTestId('sheet-root')).toBeInTheDocument()
    expect(screen.getByTestId('sheet-content')).toBeInTheDocument()
    expect(screen.getByText('Title')).toBeInTheDocument()
    expect(screen.getByText('Description')).toBeInTheDocument()
    expect(screen.getByText('Content here')).toBeInTheDocument()
  })

  it('renders SheetHeader with className', () => {
    render(
      <SheetHeader className="custom-header">
        <span>Header Content</span>
      </SheetHeader>
    )
    expect(screen.getByText('Header Content')).toBeInTheDocument()
  })

  it('renders SheetFooter with className', () => {
    render(
      <SheetFooter className="custom-footer">
        <button>Footer Button</button>
      </SheetFooter>
    )
    expect(screen.getByText('Footer Button')).toBeInTheDocument()
  })

  it('renders close button inside SheetContent', () => {
    render(
      <Sheet open={true}>
        <SheetContent>
          <p>Test</p>
        </SheetContent>
      </Sheet>
    )
    expect(screen.getByTestId('sheet-close')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/ui/__tests__/time-slot-panel.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'
import { TimeSlotPanel } from '../time-slot-panel'

describe('TimeSlotPanel', () => {
  const timeSlots = [
    { time: '09:00', available: true },
    { time: '10:00', available: true },
    { time: '11:00', available: false }
  ] as const

  const defaultProps = {
    selectedDate: null as Date | null,
    selectedTime: null as string | null,
    timeSlots,
    onTimeSelect: vi.fn()
  }

  it('shows placeholder text when no date is selected', () => {
    render(<TimeSlotPanel {...defaultProps} />)
    expect(screen.getByText('Select a date to view times')).toBeInTheDocument()
  })

  it('shows formatted date when date is selected', () => {
    const date = new Date(2026, 1, 10) // Feb 10, 2026 (Tuesday)
    render(<TimeSlotPanel {...defaultProps} selectedDate={date} />)
    expect(screen.getByText(/Tuesday/)).toBeInTheDocument()
  })

  it('renders time slot buttons', () => {
    render(<TimeSlotPanel {...defaultProps} selectedDate={new Date(2026, 1, 10)} />)
    expect(screen.getByText('9:00 AM')).toBeInTheDocument()
    expect(screen.getByText('10:00 AM')).toBeInTheDocument()
    expect(screen.getByText('11:00 AM')).toBeInTheDocument()
  })

  it('disables time slots when no date is selected', () => {
    render(<TimeSlotPanel {...defaultProps} />)
    const buttons = screen.getAllByRole('button')
    buttons.forEach(btn => {
      expect(btn).toBeDisabled()
    })
  })

  it('disables unavailable time slots', () => {
    render(<TimeSlotPanel {...defaultProps} selectedDate={new Date(2026, 1, 10)} />)
    const btn11 = screen.getByText('11:00 AM')
    expect(btn11.closest('button')).toBeDisabled()
  })

  it('calls onTimeSelect when available slot is clicked', () => {
    const onTimeSelect = vi.fn()
    render(
      <TimeSlotPanel
        {...defaultProps}
        selectedDate={new Date(2026, 1, 10)}
        onTimeSelect={onTimeSelect}
      />
    )
    fireEvent.click(screen.getByText('9:00 AM'))
    expect(onTimeSelect).toHaveBeenCalledWith('09:00')
  })

  it('highlights selected time slot', () => {
    render(
      <TimeSlotPanel
        {...defaultProps}
        selectedDate={new Date(2026, 1, 10)}
        selectedTime="09:00"
      />
    )
    // The selected button should have the default variant
    expect(screen.getByText('9:00 AM')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/components/ui/__tests__/ui-components.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

// Test all UI wrapper components render without crashing
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '../card'
import { Badge } from '../badge'
import { Button } from '../button'
import { Input } from '../input'
import { Label } from '../label'
import { Textarea } from '../textarea'
import { Separator } from '../separator'
import { Skeleton } from '../skeleton'
import { Alert, AlertDescription } from '../alert'
import { Checkbox } from '../checkbox'
import { Switch } from '../switch'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '../table'
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '../tooltip'
import { Toggle } from '../toggle'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../tabs'
import { Accordion, AccordionItem, AccordionTrigger, AccordionContent } from '../accordion'
import { Collapsible, CollapsibleTrigger, CollapsibleContent } from '../collapsible'
import { ToggleGroup, ToggleGroupItem } from '../toggle-group'
import { AlertDialog, AlertDialogContent, AlertDialogHeader, AlertDialogTitle, AlertDialogDescription, AlertDialogFooter, AlertDialogCancel, AlertDialogAction } from '../alert-dialog'
import { Select, SelectValue, SelectTrigger, SelectContent, SelectItem } from '../select'
import { Toast, ToastContainer } from '../toast'

describe('UI Components', () => {
  describe('Card', () => {
    it('renders card with all sub-components', () => {
      render(
        <Card>
          <CardHeader><CardTitle>Title</CardTitle><CardDescription>Desc</CardDescription></CardHeader>
          <CardContent>Content</CardContent>
          <CardFooter>Footer</CardFooter>
        </Card>
      )
      expect(screen.getByText('Title')).toBeInTheDocument()
      expect(screen.getByText('Content')).toBeInTheDocument()
      expect(screen.getByText('Footer')).toBeInTheDocument()
    })
  })

  describe('Badge', () => {
    it('renders badge', () => {
      render(<Badge>Test Badge</Badge>)
      expect(screen.getByText('Test Badge')).toBeInTheDocument()
    })
  })

  describe('Button', () => {
    it('renders button', () => {
      render(<Button>Click Me</Button>)
      expect(screen.getByText('Click Me')).toBeInTheDocument()
    })
  })

  describe('Input', () => {
    it('renders input', () => {
      render(<Input placeholder="Type here" />)
      expect(screen.getByPlaceholderText('Type here')).toBeInTheDocument()
    })
  })

  describe('Label', () => {
    it('renders label', () => {
      render(<Label>My Label</Label>)
      expect(screen.getByText('My Label')).toBeInTheDocument()
    })
  })

  describe('Textarea', () => {
    it('renders textarea', () => {
      render(<Textarea placeholder="Enter text" />)
      expect(screen.getByPlaceholderText('Enter text')).toBeInTheDocument()
    })
  })

  describe('Separator', () => {
    it('renders separator', () => {
      const { container } = render(<Separator />)
      expect(container.firstChild).toBeTruthy()
    })
  })

  describe('Skeleton', () => {
    it('renders skeleton', () => {
      const { container } = render(<Skeleton className="h-4 w-20" />)
      expect(container.firstChild).toBeTruthy()
    })
  })

  describe('Alert', () => {
    it('renders alert with children', () => {
      render(
        <Alert>
          <AlertDescription>Alert Description</AlertDescription>
        </Alert>
      )
      expect(screen.getByText('Alert Description')).toBeInTheDocument()
    })
  })

  describe('Checkbox', () => {
    it('renders checkbox', () => {
      const { container } = render(<Checkbox />)
      expect(container.querySelector('button')).toBeTruthy()
    })
  })

  describe('Switch', () => {
    it('renders switch', () => {
      const { container } = render(<Switch />)
      expect(container.querySelector('button')).toBeTruthy()
    })
  })

  describe('Table', () => {
    it('renders table with rows', () => {
      render(
        <Table>
          <TableHeader>
            <TableRow><TableHead>Name</TableHead></TableRow>
          </TableHeader>
          <TableBody>
            <TableRow><TableCell>John</TableCell></TableRow>
          </TableBody>
        </Table>
      )
      expect(screen.getByText('Name')).toBeInTheDocument()
      expect(screen.getByText('John')).toBeInTheDocument()
    })
  })

  describe('Tooltip', () => {
    it('renders tooltip provider and trigger', () => {
      render(
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger>Hover me</TooltipTrigger>
            <TooltipContent>Tooltip text</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )
      expect(screen.getByText('Hover me')).toBeInTheDocument()
    })
  })

  describe('Toggle', () => {
    it('renders toggle', () => {
      render(<Toggle>Toggle Me</Toggle>)
      expect(screen.getByText('Toggle Me')).toBeInTheDocument()
    })
  })

  describe('Tabs', () => {
    it('renders tabs', () => {
      render(
        <Tabs defaultValue="tab1">
          <TabsList>
            <TabsTrigger value="tab1">Tab 1</TabsTrigger>
            <TabsTrigger value="tab2">Tab 2</TabsTrigger>
          </TabsList>
          <TabsContent value="tab1">Content 1</TabsContent>
          <TabsContent value="tab2">Content 2</TabsContent>
        </Tabs>
      )
      expect(screen.getByText('Tab 1')).toBeInTheDocument()
      expect(screen.getByText('Content 1')).toBeInTheDocument()
    })
  })

  describe('Accordion', () => {
    it('renders accordion with items', () => {
      render(
        <Accordion type="single" collapsible>
          <AccordionItem value="item-1">
            <AccordionTrigger>Section 1</AccordionTrigger>
            <AccordionContent>Content 1</AccordionContent>
          </AccordionItem>
        </Accordion>
      )
      expect(screen.getByText('Section 1')).toBeInTheDocument()
    })

    it('renders multiple accordion items', () => {
      render(
        <Accordion type="single" collapsible>
          <AccordionItem value="item-1">
            <AccordionTrigger>First</AccordionTrigger>
            <AccordionContent>First Content</AccordionContent>
          </AccordionItem>
          <AccordionItem value="item-2">
            <AccordionTrigger>Second</AccordionTrigger>
            <AccordionContent>Second Content</AccordionContent>
          </AccordionItem>
        </Accordion>
      )
      expect(screen.getByText('First')).toBeInTheDocument()
      expect(screen.getByText('Second')).toBeInTheDocument()
    })

    it('accepts custom className on AccordionItem', () => {
      render(
        <Accordion type="single" collapsible>
          <AccordionItem value="item-1" className="custom-class">
            <AccordionTrigger>Trigger</AccordionTrigger>
            <AccordionContent>Body</AccordionContent>
          </AccordionItem>
        </Accordion>
      )
      expect(screen.getByText('Trigger')).toBeInTheDocument()
    })

    it('accepts custom className on AccordionTrigger', () => {
      render(
        <Accordion type="single" collapsible>
          <AccordionItem value="item-1">
            <AccordionTrigger className="trigger-class">Styled Trigger</AccordionTrigger>
            <AccordionContent>Content</AccordionContent>
          </AccordionItem>
        </Accordion>
      )
      expect(screen.getByText('Styled Trigger')).toBeInTheDocument()
    })

    it('accepts custom className on AccordionContent', () => {
      render(
        <Accordion type="single" collapsible defaultValue="item-1">
          <AccordionItem value="item-1">
            <AccordionTrigger>Open</AccordionTrigger>
            <AccordionContent className="content-class">Visible Content</AccordionContent>
          </AccordionItem>
        </Accordion>
      )
      expect(screen.getByText('Visible Content')).toBeInTheDocument()
    })
  })

  describe('Collapsible', () => {
    it('renders collapsible with trigger and content', () => {
      render(
        <Collapsible>
          <CollapsibleTrigger>Toggle</CollapsibleTrigger>
          <CollapsibleContent>Hidden Content</CollapsibleContent>
        </Collapsible>
      )
      expect(screen.getByText('Toggle')).toBeInTheDocument()
    })

    it('renders with open state', () => {
      render(
        <Collapsible open>
          <CollapsibleTrigger>Toggle</CollapsibleTrigger>
          <CollapsibleContent>Visible Content</CollapsibleContent>
        </Collapsible>
      )
      expect(screen.getByText('Toggle')).toBeInTheDocument()
      expect(screen.getByText('Visible Content')).toBeInTheDocument()
    })
  })

  describe('ToggleGroup', () => {
    it('renders toggle group with items', () => {
      render(
        <ToggleGroup type="single">
          <ToggleGroupItem value="a">A</ToggleGroupItem>
          <ToggleGroupItem value="b">B</ToggleGroupItem>
        </ToggleGroup>
      )
      expect(screen.getByText('A')).toBeInTheDocument()
      expect(screen.getByText('B')).toBeInTheDocument()
    })

    it('accepts variant and size props', () => {
      render(
        <ToggleGroup type="single" variant="outline" size="sm">
          <ToggleGroupItem value="x">X</ToggleGroupItem>
        </ToggleGroup>
      )
      expect(screen.getByText('X')).toBeInTheDocument()
    })

    it('accepts custom className on group', () => {
      render(
        <ToggleGroup type="single" className="custom-group">
          <ToggleGroupItem value="item">Item</ToggleGroupItem>
        </ToggleGroup>
      )
      expect(screen.getByText('Item')).toBeInTheDocument()
    })

    it('renders toggle group item with override variant and size', () => {
      render(
        <ToggleGroup type="single">
          <ToggleGroupItem value="item" variant="outline" size="lg" className="custom-item">Item</ToggleGroupItem>
        </ToggleGroup>
      )
      expect(screen.getByText('Item')).toBeInTheDocument()
    })
  })

  describe('AlertDialog', () => {
    it('renders alert dialog when open', () => {
      render(
        <div className="admin-mfe-root">
          <AlertDialog open>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Confirm Action</AlertDialogTitle>
                <AlertDialogDescription>Are you sure?</AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction>Confirm</AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
        </div>
      )
      expect(screen.getByText('Confirm Action')).toBeInTheDocument()
      expect(screen.getByText('Are you sure?')).toBeInTheDocument()
      expect(screen.getByText('Cancel')).toBeInTheDocument()
      expect(screen.getByText('Confirm')).toBeInTheDocument()
    })
  })

  describe('Select', () => {
    it('renders select trigger with placeholder', () => {
      render(
        <Select>
          <SelectTrigger>
            <SelectValue placeholder="Choose..." />
          </SelectTrigger>
        </Select>
      )
      expect(screen.getByText('Choose...')).toBeInTheDocument()
    })

    it('accepts custom className on trigger', () => {
      render(
        <Select>
          <SelectTrigger className="custom-trigger">
            <SelectValue placeholder="Pick one" />
          </SelectTrigger>
        </Select>
      )
      expect(screen.getByText('Pick one')).toBeInTheDocument()
    })
  })

  describe('Toast', () => {
    it('renders toast with title', () => {
      render(<Toast id="t1" title="Success" variant="success" />)
      expect(screen.getByText('Success')).toBeInTheDocument()
    })

    it('renders toast with description', () => {
      render(<Toast id="t2" title="Info" description="Details here" variant="info" />)
      expect(screen.getByText('Details here')).toBeInTheDocument()
    })

    it('renders close button when onClose is provided', () => {
      const onClose = vi.fn()
      render(<Toast id="t3" title="Closeable" onClose={onClose} variant="warning" />)
      const closeBtn = screen.getByLabelText('Dismiss notification')
      expect(closeBtn).toBeInTheDocument()
      fireEvent.click(closeBtn)
      expect(onClose).toHaveBeenCalledTimes(1)
    })

    it('does not render close button without onClose', () => {
      render(<Toast id="t4" title="No Close" variant="error" />)
      expect(screen.queryByLabelText('Dismiss notification')).not.toBeInTheDocument()
    })

    it('renders action when provided', () => {
      render(<Toast id="t5" title="With Action" action={<button>Undo</button>} variant="info" />)
      expect(screen.getByText('Undo')).toBeInTheDocument()
    })

    it('renders error variant with alert role', () => {
      const { container } = render(<Toast id="t6" title="Error" variant="error" />)
      const output = container.querySelector('output')
      expect(output).toHaveAttribute('role', 'alert')
    })

    it('renders critical variant with alert role', () => {
      const { container } = render(<Toast id="t7" title="Critical" variant="critical" />)
      const output = container.querySelector('output')
      expect(output).toHaveAttribute('role', 'alert')
    })

    it('renders info variant with polite aria-live', () => {
      const { container } = render(<Toast id="t8" title="Info" variant="info" />)
      const output = container.querySelector('output')
      expect(output).toHaveAttribute('aria-live', 'polite')
    })

    it('renders success variant', () => {
      render(<Toast id="t9" title="Done" variant="success" />)
      expect(screen.getByText('Done')).toBeInTheDocument()
    })

    it('defaults to info variant', () => {
      const { container } = render(<Toast id="t10" title="Default" />)
      const output = container.querySelector('output')
      expect(output).toHaveAttribute('aria-live', 'polite')
    })
  })

  describe('ToastContainer', () => {
    it('renders children when present', () => {
      render(
        <ToastContainer>
          <div>Toast 1</div>
          <div>Toast 2</div>
        </ToastContainer>
      )
      expect(screen.getByText('Toast 1')).toBeInTheDocument()
      expect(screen.getByText('Toast 2')).toBeInTheDocument()
    })

    it('returns null when no children', () => {
      const { container } = render(<ToastContainer>{[]}</ToastContainer>)
      expect(container.innerHTML).toBe('')
    })
  })
})
===ENDFILE

===FILE: src/components/ui/accordion.tsx
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "../../lib/utils"

const Accordion = AccordionPrimitive.Root

/** Single accordion section with bottom border separator. */
const AccordionItem = React.forwardRef<
  React.ComponentRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

/** Clickable accordion header with animated chevron rotation on expand/collapse. */
const AccordionTrigger = React.forwardRef<
  React.ComponentRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

/** Animated collapsible content section for accordion items. */
const AccordionContent = React.forwardRef<
  React.ComponentRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
===ENDFILE

===FILE: src/components/ui/alert-dialog.tsx
import * as React from "react"
import { Button } from "./button"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "./dialog"

/** Props for the AlertDialog component wrapping Radix Dialog for confirmation patterns. */
interface AlertDialogProps {
  open?: boolean
  onOpenChange?: (open: boolean) => void
  children: React.ReactNode
}

/** Alert dialog component for destructive or confirmation actions requiring user acknowledgment. */
export function AlertDialog({ open, onOpenChange, children }: Readonly<AlertDialogProps>) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      {children}
    </Dialog>
  )
}

export function AlertDialogContent({ children, ...props }: React.ComponentProps<typeof DialogContent>) {
  return <DialogContent {...props}>{children}</DialogContent>
}

export function AlertDialogHeader({ children, ...props }: React.ComponentProps<typeof DialogHeader>) {
  return <DialogHeader {...props}>{children}</DialogHeader>
}

export function AlertDialogTitle({ children, ...props }: React.ComponentProps<typeof DialogTitle>) {
  return <DialogTitle {...props}>{children}</DialogTitle>
}

export function AlertDialogDescription({ children, ...props }: React.ComponentProps<typeof DialogDescription>) {
  return <DialogDescription {...props}>{children}</DialogDescription>
}

export function AlertDialogFooter({ children, ...props }: React.ComponentProps<typeof DialogFooter>) {
  return <DialogFooter {...props}>{children}</DialogFooter>
}

export function AlertDialogCancel({ children, ...props }: React.ComponentProps<typeof Button>) {
  return <Button variant="outline" {...props}>{children}</Button>
}

export function AlertDialogAction({ children, ...props }: React.ComponentProps<typeof Button>) {
  return <Button {...props}>{children}</Button>
}
===ENDFILE

===FILE: src/components/ui/alert.tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "../../lib/utils"

/** Alert style variants for information and destructive severity levels. */
const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

/** Alert container with role="alert" for accessibility and variant-based styling. */
const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, children, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  >{children}</h5>
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertDescription }
===ENDFILE

===FILE: src/components/ui/badge.tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

/** Badge style variants using class-variance-authority for consistent status/label styling. */
const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

/** Props for the Badge component combining HTML div attributes with variant options. */
interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

/** Inline badge component for displaying labels, statuses, and counts. */
function Badge({ className, variant, ...props }: Readonly<BadgeProps>) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge }
===ENDFILE

===FILE: src/components/ui/button.tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

/** Button style variants using class-variance-authority for consistent action styling. */
const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors will-change-[background-color,color] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

/** Props for the Button component combining HTML button attributes with variant and size options. */
interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {}

/** Memoized button component supporting multiple visual variants and sizes. */
const Button = React.memo(
  React.forwardRef<HTMLButtonElement, ButtonProps>(
    ({ className, variant, size, ...props }, ref) => {
      return (
        <button
          className={cn(buttonVariants({ variant, size, className }))}
          ref={ref}
          {...props}
        />
      )
    }
  )
)
Button.displayName = "Button"

export { Button }
===ENDFILE

===FILE: src/components/ui/calendar-grid.tsx
import {
  format,
  isBefore,
  isSameDay,
  isSameMonth,
  isToday,
  startOfDay,
  addMonths
} from 'date-fns'
import { ChevronLeft, ChevronRight } from 'lucide-react'
import { Button } from './button'
import { cn } from '../../lib/utils'
import { WEEKDAY_LABELS } from './date-time-picker-utils'

/** Props for the CalendarGrid component. */
interface CalendarGridProps {
  /** The month currently displayed in the calendar */
  currentMonth: Date
  /** Array of Date objects representing each day cell in the grid */
  calendarDays: Date[]
  /** Currently selected date or null if no date is selected */
  selectedDate: Date | null
  /** Earliest selectable date (dates before this are disabled) */
  normalizedMinDate: Date | undefined
  /** Callback invoked when a day cell is clicked */
  onDateSelect: (day: Date) => void
  /** Callback invoked when navigating to a different month */
  onMonthChange: (newMonth: Date) => void
  /** Callback to clear the current date selection */
  onClear: () => void
  /** Whether the clear button should be enabled */
  canClear: boolean
}

/** Returns true if the given day should be disabled based on the minimum date constraint. */
function isDateDisabled(day: Date, normalizedMinDate: Date | undefined, selectedDate: Date | null): boolean {
  if (!normalizedMinDate) return false
  const dayStart = startOfDay(day)
  const isSelectedDay = selectedDate !== null && isSameDay(dayStart, selectedDate)
  return !isSelectedDay && isBefore(dayStart, normalizedMinDate)
}

/** Props for the DayCell sub-component. */
interface DayCellProps {
  day: Date
  currentMonth: Date
  selectedDate: Date | null
  normalizedMinDate: Date | undefined
  onDateSelect: (day: Date) => void
}

/** Renders a single selectable day cell inside the calendar grid. */
function DayCell({ day, currentMonth, selectedDate, normalizedMinDate, onDateSelect }: Readonly<DayCellProps>) {
  const dayStart = startOfDay(day)
  const disabled = isDateDisabled(dayStart, normalizedMinDate, selectedDate)
  const selected = selectedDate ? isSameDay(dayStart, selectedDate) : false
  const outsideMonth = !isSameMonth(dayStart, currentMonth)
  const today = isToday(dayStart)

  return (
    <button
      key={dayStart.getTime()}
      type="button"
      onClick={() => onDateSelect(dayStart)}
      disabled={disabled}
      className={cn(
        'flex h-9 w-9 items-center justify-center rounded-md text-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background',
        disabled && 'cursor-not-allowed opacity-40',
        selected && 'bg-primary text-primary-foreground hover:bg-primary/90',
        !selected && today && 'border border-primary/50 text-primary',
        !selected && !today && 'hover:bg-accent hover:text-accent-foreground',
        outsideMonth && !selected && 'text-muted-foreground/50'
      )}
    >
      {format(dayStart, 'd')}
    </button>
  )
}

/**
 * Renders a month-view calendar grid with selectable day cells, previous/next
 * month navigation, and clear/jump-to-date controls.
 */
export function CalendarGrid({
  currentMonth,
  calendarDays,
  selectedDate,
  normalizedMinDate,
  onDateSelect,
  onMonthChange,
  onClear,
  canClear
}: Readonly<CalendarGridProps>) {
  return (
    <div className="p-4 sm:pr-5">
      <div className="flex items-center justify-between pb-4">
        <Button
          type="button"
          variant="ghost"
          size="icon"
          aria-label="Previous month"
          onClick={() => onMonthChange(addMonths(currentMonth, -1))}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>
        <span className="text-sm font-semibold">{format(currentMonth, 'MMMM yyyy')}</span>
        <Button
          type="button"
          variant="ghost"
          size="icon"
          aria-label="Next month"
          onClick={() => onMonthChange(addMonths(currentMonth, 1))}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>
      </div>
      <div className="grid grid-cols-7 gap-1 text-center text-xs text-muted-foreground">
        {WEEKDAY_LABELS.map(dayLabel => (
          <span key={dayLabel} className="rounded-md py-1">
            {dayLabel}
          </span>
        ))}
      </div>
      <div className="grid grid-cols-7 gap-1 pt-1">
        {calendarDays.map(day => (
          <DayCell
            key={startOfDay(day).getTime()}
            day={day}
            currentMonth={currentMonth}
            selectedDate={selectedDate}
            normalizedMinDate={normalizedMinDate}
            onDateSelect={onDateSelect}
          />
        ))}
      </div>
      <div className="mt-3 flex justify-between">
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={onClear}
          disabled={!canClear}
        >
          Clear
        </Button>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={() => selectedDate && onMonthChange(selectedDate)}
          disabled={!selectedDate}
        >
          Jump to date
        </Button>
      </div>
    </div>
  )
}
===ENDFILE

===FILE: src/components/ui/card.tsx
import * as React from "react"

import { cn } from "../../lib/utils"

/** Container card component with rounded borders and shadow. */
const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

/** Card header section with vertical spacing and padding. */
const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

/** Props for CardTitle allowing a custom heading level via the 'as' prop. */
interface CardTitleProps extends React.HTMLAttributes<HTMLHeadingElement> {
  as?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'div'
}

/** Card title component rendering a heading element (configurable via 'as' prop). */
const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  CardTitleProps
>(({ className, as: Component = 'h3', ...props }, ref) => (
  <Component
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

/** Muted-foreground description text for card headers. */
const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

/** Memoized card body section with standard padding. */
const CardContent = React.memo(
  React.forwardRef<
    HTMLDivElement,
    React.HTMLAttributes<HTMLDivElement>
  >(({ className, ...props }, ref) => (
    <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
  ))
)
CardContent.displayName = "CardContent"

/** Card footer section with horizontal flex layout. */
const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
===ENDFILE

===FILE: src/components/ui/checkbox.tsx
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { cn } from "../../lib/utils"
import { CheckIcon } from "@radix-ui/react-icons"

/** Accessible checkbox component built on Radix UI Checkbox primitive with check icon indicator. */
const Checkbox = React.forwardRef<
  React.ComponentRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <CheckIcon className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
===ENDFILE

===FILE: src/components/ui/collapsible.tsx
import * as CollapsiblePrimitive from '@radix-ui/react-collapsible'

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
===ENDFILE

===FILE: src/components/ui/date-time-picker-utils.ts
/**
 * Date Time Picker Utilities - Time slot definitions, date/time formatting,
 * and parsing helpers for the notice scheduling date-time picker component.
 */

import { format } from 'date-fns'

/** Available time slots for scheduling, with availability flags for business hours. */
export const DEFAULT_TIME_SLOTS = [
  { time: '09:00', available: false },
  { time: '09:30', available: false },
  { time: '10:00', available: true },
  { time: '10:30', available: true },
  { time: '11:00', available: true },
  { time: '11:30', available: true },
  { time: '12:00', available: false },
  { time: '12:30', available: true },
  { time: '13:00', available: true },
  { time: '13:30', available: true },
  { time: '14:00', available: true },
  { time: '14:30', available: false },
  { time: '15:00', available: false },
  { time: '15:30', available: true },
  { time: '16:00', available: true },
  { time: '16:30', available: true },
  { time: '17:00', available: true },
  { time: '17:30', available: true },
  { time: '18:00', available: true },
  { time: '18:30', available: true },
  { time: '19:00', available: true },
  { time: '19:30', available: true },
  { time: '20:00', available: true },
  { time: '20:30', available: true },
  { time: '21:00', available: true },
  { time: '21:30', available: true },
  { time: '22:00', available: true },
  { time: '22:30', available: true },
  { time: '23:00', available: true },
  { time: '23:30', available: true }
] as const

export const WEEKDAY_LABELS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] as const

/**
 * Combines a Date object and a time string (HH:MM) into a local ISO datetime string.
 * @param date - The selected calendar date
 * @param time - Time in HH:MM format
 * @returns ISO datetime string without timezone (e.g., '2026-03-15T14:30')
 */
export const toLocalDateTimeValue = (date: Date, time: string) => {
  const [hours, minutes] = time.split(':').map(Number)
  const withTime = new Date(date)
  withTime.setHours(hours, minutes, 0, 0)
  const year = withTime.getFullYear()
  const month = String(withTime.getMonth() + 1).padStart(2, '0')
  const day = String(withTime.getDate()).padStart(2, '0')
  const hour = String(withTime.getHours()).padStart(2, '0')
  const minute = String(withTime.getMinutes()).padStart(2, '0')
  return `${year}-${month}-${day}T${hour}:${minute}`
}

/**
 * Parses a local ISO datetime string into separate date and time components.
 * Returns null values if the input is missing or invalid.
 * @param value - ISO datetime string (e.g., '2026-03-15T14:30')
 * @returns Object with parsed Date and time string, or nulls on failure
 */
export const parseLocalDateTime = (value?: string | null) => {
  if (!value) {
    return { date: null, time: null }
  }

  const parsed = new Date(value)
  if (Number.isNaN(parsed.getTime())) {
    return { date: null, time: null }
  }

  const timePart = value.includes('T') ? value.split('T')[1]?.slice(0, 5) ?? null : null
  return {
    date: parsed,
    time: timePart
  }
}

/**
 * Formats a 24-hour time string (HH:MM) into a locale-appropriate time label.
 * @param time - Time in HH:MM format
 * @returns Formatted time string (e.g., '2:30 PM')
 */
export const formatTimeLabel = (time: string) => {
  const [hours, minutes] = time.split(':').map(Number)
  const base = new Date()
  base.setHours(hours, minutes, 0, 0)
  return format(base, 'p')
}

/** Props for the DateTimePicker component used in notice scheduling. */
export interface DateTimePickerProps {
  id: string
  label: string
  value?: string
  onChange: (value: string | undefined) => void
  minDate?: Date
  placeholder?: string
  timeSlots?: readonly { time: string; available: boolean }[]
}
===ENDFILE

===FILE: src/components/ui/date-time-picker.tsx
'use client'

import { useEffect, useMemo, useState } from 'react'
import * as PopoverPrimitive from '@radix-ui/react-popover'
import { CalendarIcon } from 'lucide-react'
import {
  addDays,
  endOfMonth,
  endOfWeek,
  format,
  isSameDay,
  startOfDay,
  startOfMonth,
  startOfWeek
} from 'date-fns'

import { Button } from './button'
import { Label } from './label'
import { getDialogPortalContainer } from './dialog'
import {
  DEFAULT_TIME_SLOTS,
  toLocalDateTimeValue,
  parseLocalDateTime,
  formatTimeLabel
} from './date-time-picker-utils'
import type { DateTimePickerProps } from './date-time-picker-utils'
import { CalendarGrid } from './calendar-grid'
import { TimeSlotPanel } from './time-slot-panel'

/**
 * Composite date-time picker component combining a calendar grid with
 * time slot selection in a popover. Supports minimum date constraints
 * and custom time slot configurations.
 */
export function DateTimePicker({
  id,
  label,
  value,
  onChange,
  minDate,
  placeholder,
  timeSlots = DEFAULT_TIME_SLOTS
}: Readonly<DateTimePickerProps>) {
  const normalizedMinDate = useMemo(() => (minDate ? startOfDay(minDate) : undefined), [minDate])
  const [open, setOpen] = useState(false)
  const [selectedDate, setSelectedDate] = useState<Date | null>(null)
  const [selectedTime, setSelectedTime] = useState<string | null>(null)
  const [currentMonth, setCurrentMonth] = useState<Date>(() => normalizedMinDate ?? startOfDay(new Date()))

  useEffect(() => {
    const { date, time } = parseLocalDateTime(value)
    setSelectedDate(date)
    setSelectedTime(time)
    if (date) {
      setCurrentMonth(date)
    } else if (normalizedMinDate) {
      setCurrentMonth(normalizedMinDate)
    }
  }, [value, normalizedMinDate])

  const calendarDays = useMemo(() => {
    const monthStart = startOfMonth(currentMonth)
    const rangeStart = startOfWeek(monthStart, { weekStartsOn: 0 })
    const rangeEnd = endOfWeek(endOfMonth(currentMonth), { weekStartsOn: 0 })
    const days: Date[] = []
    let cursor = rangeStart

    while (cursor <= rangeEnd) {
      days.push(cursor)
      cursor = addDays(cursor, 1)
    }

    return days
  }, [currentMonth])

  const handleDateSelect = (day: Date) => {
    const dayStart = startOfDay(day)
    const isSameAsCurrent = selectedDate ? isSameDay(dayStart, selectedDate) : false
    setSelectedDate(dayStart)
    setCurrentMonth(dayStart)

    if (!isSameAsCurrent && selectedTime) {
      setSelectedTime(null)
      onChange(undefined)
    }
  }

  const handleTimeSelect = (timeValue: string) => {
    if (!selectedDate) return
    setSelectedTime(timeValue)
    onChange(toLocalDateTimeValue(selectedDate, timeValue))
    setOpen(false)
  }

  const handleClear = () => {
    setSelectedDate(null)
    setSelectedTime(null)
    onChange(undefined)
    setCurrentMonth(normalizedMinDate ?? startOfDay(new Date()))
    setOpen(false)
  }

  const timeLabel = selectedTime ? `  ${formatTimeLabel(selectedTime)}` : ''
  const formattedDate = selectedDate ? `${format(selectedDate, 'PPP')}${timeLabel}` : null
  const displayText = formattedDate ?? placeholder ?? 'Pick a date and time'

  return (
    <div className="space-y-2">
      <Label htmlFor={id}>{label}</Label>
      <PopoverPrimitive.Root open={open} onOpenChange={setOpen}>
        <PopoverPrimitive.Trigger asChild>
          <Button
            id={id}
            type="button"
            variant="outline"
            className="w-full justify-between gap-2 text-left font-normal"
          >
            <span className="flex items-center gap-2">
              <CalendarIcon className="h-4 w-4 text-primary" />
              <span className={selectedDate ? 'text-foreground' : 'text-muted-foreground'}>
                {displayText}
              </span>
            </span>
          </Button>
        </PopoverPrimitive.Trigger>
        <PopoverPrimitive.Portal container={getDialogPortalContainer()}>
          <PopoverPrimitive.Content
            align="start"
            sideOffset={8}
            collisionPadding={16}
            className="z-50 w-auto max-w-[calc(100vw-2rem)] rounded-md border bg-popover p-0 text-popover-foreground shadow-lg outline-none"
          >
            <div className="flex flex-col sm:flex-row">
              <CalendarGrid
                currentMonth={currentMonth}
                calendarDays={calendarDays}
                selectedDate={selectedDate}
                normalizedMinDate={normalizedMinDate}
                onDateSelect={handleDateSelect}
                onMonthChange={setCurrentMonth}
                onClear={handleClear}
                canClear={Boolean(selectedDate || selectedTime)}
              />
              <TimeSlotPanel
                selectedDate={selectedDate}
                selectedTime={selectedTime}
                timeSlots={timeSlots}
                onTimeSelect={handleTimeSelect}
              />
            </div>
          </PopoverPrimitive.Content>
        </PopoverPrimitive.Portal>
      </PopoverPrimitive.Root>
    </div>
  )
}
===ENDFILE

===FILE: src/components/ui/dialog.tsx
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { Cross2Icon } from "@radix-ui/react-icons"

import { cn } from "../../lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

/** Resolves the MFE root element for portal rendering so dialogs appear within the MFE boundary. */
function getDialogPortalContainer(): HTMLElement | undefined {
  if (typeof document === 'undefined') {
    return undefined
  }

  return document.querySelector<HTMLElement>('.admin-mfe-root') ?? undefined
}

const DialogOverlay = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => {
  const portalContainer = getDialogPortalContainer()

  return (
    <DialogPortal container={portalContainer}>
      <DialogOverlay />
      <DialogPrimitive.Content
        ref={ref}
        className={cn(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
          <Cross2Icon className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
})
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
  getDialogPortalContainer,
}
===ENDFILE

===FILE: src/components/ui/input.tsx
import * as React from "react"

import { cn } from "../../lib/utils"

/** Props for the Input component extending native HTML input attributes. */
type InputProps = React.InputHTMLAttributes<HTMLInputElement>

/** Styled text input with focus ring and disabled state support. */
const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
===ENDFILE

===FILE: src/components/ui/label.tsx
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

/** Label style variants for form field labels. */
const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

/** Accessible label component built on Radix UI Label primitive. */
const Label = React.forwardRef<
  React.ComponentRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
===ENDFILE

===FILE: src/components/ui/scroll-area.tsx
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "../../lib/utils"

/** Props for ScrollArea extending Radix ScrollArea with optional vertical scrollbar control. */
interface ScrollAreaProps extends React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root> {
  showVerticalScrollbar?: boolean
}

/** Scrollable container with custom scrollbar styling, built on Radix UI ScrollArea. */
const ScrollArea = React.forwardRef<
  React.ComponentRef<typeof ScrollAreaPrimitive.Root>,
  ScrollAreaProps
>(({ className, children, showVerticalScrollbar = true, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    type="always"
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    {showVerticalScrollbar ? (
      <>
        <ScrollBar />
        <ScrollAreaPrimitive.Corner />
      </>
    ) : null}
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

/** Custom scrollbar track and thumb supporting vertical and horizontal orientations. */
const ScrollBar = React.forwardRef<
  React.ComponentRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-border/60 bg-background/95 p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-gray-400/70 hover:bg-gray-500/80 transition-colors" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
===ENDFILE

===FILE: src/components/ui/select.tsx
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "../../lib/utils"
import { getDialogPortalContainer } from "./dialog"

const Select = SelectPrimitive.Root

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => {
  const portalContainer = getDialogPortalContainer()

  return (
  <SelectPrimitive.Portal container={portalContainer}>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
  )
})
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectItem,
}
===ENDFILE

===FILE: src/components/ui/separator.tsx
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "../../lib/utils"

/** Visual divider supporting horizontal and vertical orientations via Radix Separator primitive. */
const Separator = React.forwardRef<
  React.ComponentRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
===ENDFILE

===FILE: src/components/ui/sheet.tsx
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"
import { getDialogPortalContainer } from "./dialog"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetOverlay = React.forwardRef<
  React.ComponentRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

/** Sheet slide-in animation variants for top, bottom, left, and right positioning. */
const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

/** Props for SheetContent combining Radix Dialog content with side variant positioning. */
interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ComponentRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => {
  const portalContainer = getDialogPortalContainer()

  return (
    <SheetPrimitive.Portal container={portalContainer}>
      <SheetOverlay />
      <SheetPrimitive.Content
        ref={ref}
        className={cn(sheetVariants({ side }), className)}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
          <X className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPrimitive.Portal>
  )
})
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ComponentRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ComponentRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetTrigger,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
===ENDFILE

===FILE: src/components/ui/skeleton.tsx
import { cn } from "../../lib/utils"

/** Animated placeholder component used during loading states. */
function Skeleton({
  className,
  ...props
}: Readonly<React.HTMLAttributes<HTMLDivElement>>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  )
}

export { Skeleton }
===ENDFILE

===FILE: src/components/ui/switch.tsx
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "../../lib/utils"

/** Toggle switch component with sliding thumb animation, built on Radix UI Switch primitive. */
const Switch = React.forwardRef<
  React.ComponentRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
===ENDFILE

===FILE: src/components/ui/table.tsx
import * as React from "react"

import { cn } from "../../lib/utils"
import { ScrollArea, ScrollBar } from "./scroll-area"

/** Scrollable table wrapper with horizontal scroll support via ScrollArea. */
const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <ScrollArea className="relative h-full w-full">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
    <ScrollBar orientation="horizontal" />
  </ScrollArea>
))
Table.displayName = "Table"

/** Table header section (thead) with bottom border. */
const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

/** Table body section (tbody) with last-row border removal. */
const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

/** Table row with hover and selection state styles. */
const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

/** Column header cell (th) with muted foreground text. */
const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    scope="col"
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

/** Standard table data cell (td) with padding and checkbox alignment support. */
const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableHead,
  TableRow,
  TableCell,
}
===ENDFILE

===FILE: src/components/ui/tabs.tsx
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "../../lib/utils"

const Tabs = TabsPrimitive.Root

/** Horizontal tab list container with muted background and rounded corners. */
const TabsList = React.forwardRef<
  React.ComponentRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

/** Individual tab button with active state shadow and focus ring. */
const TabsTrigger = React.forwardRef<
  React.ComponentRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

/** Tab panel content area displayed when its corresponding tab trigger is active. */
const TabsContent = React.forwardRef<
  React.ComponentRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
===ENDFILE

===FILE: src/components/ui/textarea.tsx
import * as React from "react"
import { cn } from "../../lib/utils"

/** Props for the Textarea component extending native HTML textarea attributes. */
type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>

/** Styled multi-line text input with focus ring and disabled state support. */
const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
===ENDFILE

===FILE: src/components/ui/time-slot-panel.tsx
import { format } from 'date-fns'
import { Button } from './button'
import { ScrollArea } from './scroll-area'
import { cn } from '../../lib/utils'
import { formatTimeLabel } from './date-time-picker-utils'

/** Props for the TimeSlotPanel component. */
interface TimeSlotPanelProps {
  /** Currently selected calendar date or null */
  selectedDate: Date | null
  /** Currently selected time slot value or null */
  selectedTime: string | null
  /** Available time slot options with availability flags */
  timeSlots: readonly { time: string; available: boolean }[]
  /** Callback invoked when a time slot button is clicked */
  onTimeSelect: (time: string) => void
}

/** Renders a scrollable grid of selectable time slots alongside the calendar date picker. */
export function TimeSlotPanel({
  selectedDate,
  selectedTime,
  timeSlots,
  onTimeSelect
}: Readonly<TimeSlotPanelProps>) {
  return (
    <div className="relative w-full border-t sm:w-48 sm:border-l sm:border-t-0">
      <ScrollArea className="h-64 sm:h-72">
        <div className="space-y-3 p-4">
          <div className="flex h-5 items-center">
            <p className={cn(
              "text-xs sm:text-sm font-medium truncate",
              selectedDate ? "text-foreground" : "text-muted-foreground"
            )}>
              {selectedDate ? format(selectedDate, 'EEEE, MMM d') : 'Select a date to view times'}
            </p>
          </div>
          <div className="grid gap-2 grid-cols-2 sm:grid-cols-1">
            {timeSlots.map(({ time: timeSlot, available }) => (
              <Button
                key={timeSlot}
                type="button"
                variant={selectedTime === timeSlot ? 'default' : 'outline'}
                size="sm"
                className={cn(
                  'justify-center',
                  selectedTime === timeSlot && 'bg-primary text-primary-foreground hover:bg-primary/90'
                )}
                onClick={() => onTimeSelect(timeSlot)}
                disabled={!selectedDate || !available}
              >
                {formatTimeLabel(timeSlot)}
              </Button>
            ))}
          </div>
        </div>
      </ScrollArea>
    </div>
  )
}
===ENDFILE

===FILE: src/components/ui/toast.tsx
import React from "react"
import { cn } from "../../lib/utils"
import {
  CircleCheck,
  CircleAlert,
  ShieldAlert,
  Info,
  X
} from "lucide-react"

/** Available severity levels for toast notifications. */
export type ToastVariant = "info" | "success" | "warning" | "error" | "critical"

/** Props for the Toast notification component. */
export interface ToastProps {
  id: string
  title?: string
  description?: string
  action?: React.ReactNode
  variant?: ToastVariant
  onClose?: () => void
  duration?: number
  persistent?: boolean
  metaKey?: string
}

/** Maps each toast variant to its Tailwind CSS class sets for container, icon, and text elements. */
const VARIANT_STYLES: Record<ToastVariant, {
  container: string
  accentBar: string
  iconWrap: string
  icon: string
  title: string
  description: string
  action?: string
}> = {
  info: {
    container: "bg-white/95 border border-slate-200",
    accentBar: "bg-slate-500/70",
    iconWrap: "bg-slate-100 text-slate-600",
    icon: "text-slate-700",
    title: "text-slate-900",
    description: "text-slate-600",
    action: "text-slate-600 hover:text-slate-900"
  },
  success: {
    container: "bg-white border-green-500",
    accentBar: "bg-green-500",
    iconWrap: "bg-green-50 text-green-600",
    icon: "text-green-600",
    title: "text-[#333333] font-semibold",
    description: "text-[#666666]",
    action: "text-green-700 hover:text-green-900"
  },
  warning: {
    container: "bg-white border border-amber-100",
    accentBar: "bg-amber-500",
    iconWrap: "bg-amber-50 text-amber-600",
    icon: "text-amber-600",
    title: "text-amber-900",
    description: "text-amber-700",
    action: "text-amber-700 hover:text-amber-900"
  },
  error: {
    container: "bg-white border border-red-200",
    accentBar: "bg-red-600",
    iconWrap: "bg-red-50 text-red-600",
    icon: "text-red-600",
    title: "text-red-900",
    description: "text-red-700",
    action: "text-red-700 hover:text-red-900"
  },
  critical: {
    container: "bg-red-50 border border-red-200",
    accentBar: "bg-red-700",
    iconWrap: "bg-red-100 text-red-700",
    icon: "text-red-700",
    title: "text-red-950",
    description: "text-red-900",
    action: "text-red-900 hover:text-red-950"
  }
}

/** Maps each toast variant to its corresponding lucide icon component. */
const VARIANT_ICON: Record<ToastVariant, React.ComponentType<{ className?: string }>> = {
  info: Info,
  success: CircleCheck,
  warning: CircleAlert,
  error: CircleAlert,
  critical: ShieldAlert
}

/** Renders a styled toast notification with icon, title, description, and optional dismiss button. */
export function Toast({
  title,
  description,
  action,
  variant = "info",
  onClose,
}: Readonly<ToastProps>) {
  const styles = VARIANT_STYLES[variant]
  const Icon = VARIANT_ICON[variant]

  return (
    <output
      role={variant === "error" || variant === "critical" ? "alert" : undefined}
      aria-live={variant === "error" || variant === "critical" ? "assertive" : "polite"}
      className={cn(
        "relative flex w-full items-start gap-3 overflow-hidden rounded-lg p-4 shadow-lg transition-all",
        "pointer-events-auto bg-white border-2",
        styles.container
      )}
    >
      <span className={cn("absolute left-0 top-0 h-full w-1.5", styles.accentBar)} aria-hidden />
      <div className={cn("mt-0.5 flex h-9 w-9 flex-shrink-0 items-center justify-center rounded-full", styles.iconWrap)}>
        <Icon className={cn("h-4 w-4", styles.icon)} />
      </div>
      <div className="flex min-w-0 flex-1 flex-col gap-1">
        {title && <p className={cn("text-sm font-semibold", styles.title)}>{title}</p>}
        {description && (
          <p className={cn("text-sm leading-snug break-words", styles.description)}>{description}</p>
        )}
        {action && <div className={cn("text-xs font-medium", styles.action)}>{action}</div>}
      </div>
      {onClose && (
        <button
          onClick={onClose}
          className="ml-2 inline-flex h-7 w-7 items-center justify-center rounded-full text-slate-400 transition hover:bg-slate-100 hover:text-slate-800"
          aria-label="Dismiss notification"
        >
          <X className="h-4 w-4" />
        </button>
      )}
    </output>
  )
}

/** Fixed-position container for rendering stacked toast notifications in the top-right corner. */
export function ToastContainer({ children }: Readonly<{ children: React.ReactNode }>) {
  const count = React.Children.count(children)
  if (count === 0) return null

  return (
    <div className="pointer-events-none fixed right-6 top-20 z-[999] flex max-h-[70vh] w-full max-w-sm flex-col gap-3 overflow-y-auto pr-1 sm:right-10">
      {React.Children.map(children, (child) => (
        <div className="pointer-events-auto w-full animate-notification-drawer">
          {child}
        </div>
      ))}
    </div>
  )
}
===ENDFILE

===FILE: src/components/ui/toggle-group.tsx
import * as React from 'react'
import * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group'
import { VariantProps } from 'class-variance-authority'

import { cn } from '../../lib/utils'
import { toggleVariants } from './toggle'

/** Context providing inherited variant and size props to child ToggleGroupItem components. */
const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: 'default',
  variant: 'default',
})

/** Container for a group of mutually exclusive or multi-select toggle buttons. */
const ToggleGroup = React.forwardRef<
  React.ComponentRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => {
  const contextValue = React.useMemo(() => ({ variant, size }), [variant, size])
  return (
    <ToggleGroupPrimitive.Root
      ref={ref}
      className={cn('flex items-center justify-center gap-1', className)}
      {...props}
    >
      <ToggleGroupContext.Provider value={contextValue}>
        {children}
      </ToggleGroupContext.Provider>
    </ToggleGroupPrimitive.Root>
  )
})

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

/** Individual toggle button within a ToggleGroup, inheriting variant/size from context. */
const ToggleGroupItem = React.forwardRef<
  React.ComponentRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }
===ENDFILE

===FILE: src/components/ui/toggle.tsx
import * as React from 'react'
import * as TogglePrimitive from '@radix-ui/react-toggle'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '../../lib/utils'

/** Toggle style variants using class-variance-authority for on/off button states. */
const toggleVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground',
  {
    variants: {
      variant: {
        default: 'bg-transparent',
        outline:
          'border border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
      },
      size: {
        default: 'h-10 px-3',
        sm: 'h-9 px-2.5',
        lg: 'h-11 px-5',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

/** Pressable toggle button with active accent state, built on Radix UI Toggle primitive. */
const Toggle = React.forwardRef<
  React.ComponentRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }
===ENDFILE

===FILE: src/components/ui/tooltip.tsx
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"
import { cn } from "../../lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

/** Animated tooltip popup with configurable offset and directional slide-in animations. */
const TooltipContent = React.forwardRef<
  React.ComponentRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
===ENDFILE

===FILE: src/constants/__tests__/permission-levels.test.ts
import { describe, expect, it } from 'vitest'
import { permissionLevels } from '../permission-levels'

describe('permissionLevels', () => {
  it('exports exactly 2 sections', () => {
    const sections = Object.keys(permissionLevels)
    expect(sections).toEqual(['capabilities', 'workspacePreferences'])
  })

  it('each section has required config properties', () => {
    Object.entries(permissionLevels).forEach(([key, config]) => {
      expect(config.title).toBeTruthy()
      expect(typeof config.title).toBe('string')
      expect(config.description).toBeTruthy()
      expect(typeof config.description).toBe('string')
      expect(config.icon).toBeDefined()
      expect(['function', 'object']).toContain(typeof config.icon)
      expect(config.businessNames).toBeDefined()
      expect(typeof config.businessNames).toBe('object')
    })
  })

  it('businessNames values are non-empty strings', () => {
    Object.entries(permissionLevels).forEach(([, config]) => {
      Object.entries(config.businessNames).forEach(([key, name]) => {
        expect(typeof name).toBe('string')
        expect(name.length).toBeGreaterThan(0)
      })
    })
  })

  it('capabilities section contains column and micro_frontends prefixed keys only', () => {
    const businessNames = permissionLevels.capabilities.businessNames
    const keys = Object.keys(businessNames)

    const columnKeys = keys.filter(k => k.startsWith('columns.'))
    const mfKeys = keys.filter(k => k.startsWith('micro_frontends.'))

    expect(columnKeys.length).toBeGreaterThan(0)
    expect(mfKeys.length).toBeGreaterThan(0)
    // No features.* keys (those are linked, not displayed)
    expect(keys.filter(k => k.startsWith('features.')).length).toBe(0)
  })

  it('workspacePreferences section contains only settings_options keys', () => {
    const businessNames = permissionLevels.workspacePreferences.businessNames
    const keys = Object.keys(businessNames)

    const optionKeys = keys.filter(k => k.startsWith('settings_options.'))
    expect(optionKeys.length).toBe(keys.length)
    // No widgets.* or settings_tabs.* keys
    expect(keys.filter(k => k.startsWith('widgets.')).length).toBe(0)
    expect(keys.filter(k => k.startsWith('settings_tabs.')).length).toBe(0)
  })

  it('each section has a unique icon', () => {
    const icons = Object.values(permissionLevels).map(c => c.icon)
    const uniqueIcons = new Set(icons)
    expect(uniqueIcons.size).toBe(icons.length)
  })

  it('capabilities has 5 business names', () => {
    expect(Object.keys(permissionLevels.capabilities.businessNames).length).toBe(5)
  })

  it('workspacePreferences has 5 business names', () => {
    expect(Object.keys(permissionLevels.workspacePreferences.businessNames).length).toBe(5)
  })
})
===ENDFILE

===FILE: src/constants/permission-levels.ts
import {
  Shield,
  Sliders,
  type LucideIcon
} from 'lucide-react'

/**
 * Configuration for a compound permission level displayed in the permission grid.
 * Each level groups related permissions under a business-friendly heading.
 */
interface PermissionLevelConfig {
  title: string
  description: string
  icon: LucideIcon
  businessNames: Record<string, string>
}

/**
 * Defines the two compound permission levels displayed in the AD group config modal.
 * 'capabilities' covers platform access controls (columns, MFEs, apps).
 * 'workspacePreferences' covers user-facing settings and workspace options.
 */
export const permissionLevels: Record<string, PermissionLevelConfig> = {
  capabilities: {
    title: 'Access Controls',
    description: 'Platform capabilities, dashboard panels, and applications',
    icon: Shield,
    businessNames: {
      'columns.kms': 'Knowledge Base',
      'columns.embeddedApps': 'Banking Applications',
      'columns.spaceCopilot': 'AI Assistant',
      'columns.chat': 'Chat Interface',
      'micro_frontends.mediaBar': 'Media Controls'
    }
  },

  workspacePreferences: {
    title: 'Workspace & Preferences',
    description: 'User preferences and workspace configuration',
    icon: Sliders,
    businessNames: {
      'settings_options.calls.autoAccept': 'Auto-Accept Calls',
      'settings_options.calls.doNotDisturb.duration': 'Do Not Disturb',
      'settings_options.interface.showTranscript': 'Show Transcripts',
      'settings_options.interface.autoCloseKnowledgeOnCallEnd': 'Auto-Close Knowledge',
      'settings_options.interface.spaceCopilotMode': 'AI Assistant Mode'
    }
  }
}
===ENDFILE

===FILE: src/hooks/admin/__tests__/ad-group-actions-helpers.test.ts
import { describe, it, expect, vi } from 'vitest'
import { buildCopyNotification, tallyCopyResults, resolveTargetGroups } from '../ad-group-actions-helpers'
import type { CopyResult } from '../../../types/features/admin.types'

vi.mock('../../../services/api/admin.service', () => ({
  adminService: {
    copyAdGroupConfiguration: vi.fn()
  }
}))

describe('buildCopyNotification', () => {
  it('returns success when all copies succeeded', () => {
    const result = buildCopyNotification({
      successCount: 3, failCount: 0, approvalSubmissionCount: 0, criticalCount: 0
    })
    expect(result.type).toBe('success')
    expect(result.title).toBe('Configuration copied')
    expect(result.description).toContain('3 groups')
  })

  it('returns success with singular when one copy succeeded', () => {
    const result = buildCopyNotification({
      successCount: 1, failCount: 0, approvalSubmissionCount: 0, criticalCount: 0
    })
    expect(result.description).toContain('1 group')
    expect(result.description).not.toContain('1 groups')
  })

  it('includes approval submission count', () => {
    const result = buildCopyNotification({
      successCount: 2, failCount: 0, approvalSubmissionCount: 2, criticalCount: 0
    })
    expect(result.description).toContain('2 submitted for approval')
  })

  it('includes critical count', () => {
    const result = buildCopyNotification({
      successCount: 2, failCount: 0, approvalSubmissionCount: 0, criticalCount: 1
    })
    expect(result.description).toContain('1 need L2')
  })

  it('returns warning on partial success', () => {
    const result = buildCopyNotification({
      successCount: 2, failCount: 1, approvalSubmissionCount: 0, criticalCount: 0
    })
    expect(result.type).toBe('warning')
    expect(result.title).toBe('Partial copy complete')
    expect(result.description).toContain('2 group')
    expect(result.description).toContain('1 failed')
  })

  it('returns error when all copies failed', () => {
    const result = buildCopyNotification({
      successCount: 0, failCount: 3, approvalSubmissionCount: 0, criticalCount: 0
    })
    expect(result.type).toBe('error')
    expect(result.title).toBe('Copy failed')
    expect(result.metaKey).toBe('ad-group-copy-error')
  })
})

describe('tallyCopyResults', () => {
  it('counts successful results', () => {
    const results: CopyResult[] = [
      { success: true, message: 'ok' },
      { success: true, message: 'ok' },
      { success: false, message: 'fail', error: 'err' }
    ]
    const counts = tallyCopyResults(results)
    expect(counts.successCount).toBe(2)
    expect(counts.failCount).toBe(1)
  })

  it('counts approval submissions', () => {
    const results: CopyResult[] = [
      { success: true, message: 'ok', workflowStatusCode: 'SUBMITTED_FOR_APPROVAL' },
      { success: true, message: 'ok' }
    ]
    const counts = tallyCopyResults(results)
    expect(counts.approvalSubmissionCount).toBe(1)
  })

  it('counts critical indicators', () => {
    const results: CopyResult[] = [
      { success: true, message: 'ok', criticalIndicator: true },
      { success: true, message: 'ok', criticalIndicator: false }
    ]
    const counts = tallyCopyResults(results)
    expect(counts.criticalCount).toBe(1)
  })

  it('returns zeros for empty results', () => {
    const counts = tallyCopyResults([])
    expect(counts.successCount).toBe(0)
    expect(counts.failCount).toBe(0)
    expect(counts.approvalSubmissionCount).toBe(0)
    expect(counts.criticalCount).toBe(0)
  })
})

describe('resolveTargetGroups', () => {
  const makeGroup = (id: string) => ({
    id,
    groupIdentifier: `CN=${id}`,
    isActive: true,
    roleName: 'voice_agent'
  })

  it('resolves groups from cache first', () => {
    const cachedGroup = makeGroup('g1')
    const cacheRef = { current: new Map([['g1', cachedGroup]]) }
    const getGroupById = vi.fn()

    const result = resolveTargetGroups(['g1'], cacheRef as never, getGroupById)

    expect(result).toHaveLength(1)
    expect(result[0].id).toBe('g1')
    expect(getGroupById).not.toHaveBeenCalled()
  })

  it('falls back to getGroupById', () => {
    const cacheRef = { current: new Map() }
    const group = makeGroup('g2')
    const getGroupById = vi.fn().mockReturnValue(group)

    const result = resolveTargetGroups(['g2'], cacheRef as never, getGroupById)

    expect(result).toHaveLength(1)
    expect(getGroupById).toHaveBeenCalledWith('g2')
  })

  it('filters out unresolvable groups', () => {
    const cacheRef = { current: new Map() }
    const getGroupById = vi.fn().mockReturnValue(undefined)

    const result = resolveTargetGroups(['g3'], cacheRef as never, getGroupById)

    expect(result).toHaveLength(0)
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/ad-group-form-helpers.test.ts
import { describe, it, expect } from 'vitest'
import {
  toPermissionStateMap,
  transformApiTemplate,
  mapAssignmentKeyToLevel,
  buildOverridesFromAssignments
} from '../ad-group-form-helpers'

describe('toPermissionStateMap', () => {
  it('returns empty object for undefined', () => {
    expect(toPermissionStateMap(undefined)).toEqual({})
  })

  it('converts enabled state', () => {
    const result = toPermissionStateMap({
      chat: { stateText: 'Enabled' }
    })
    expect(result.chat).toEqual({ state: 'enabled' })
  })

  it('converts disabled state', () => {
    const result = toPermissionStateMap({
      kms: { stateText: 'Disabled' }
    })
    expect(result.kms).toEqual({ state: 'disabled' })
  })

  it('is case insensitive for Enabled', () => {
    const result = toPermissionStateMap({
      chat: { stateText: 'enabled' }
    })
    expect(result.chat).toEqual({ state: 'enabled' })
  })

  it('handles undefined value in section', () => {
    const result = toPermissionStateMap({
      chat: undefined
    })
    expect(result.chat).toEqual({ state: 'disabled' })
  })
})

describe('transformApiTemplate', () => {
  it('transforms a complete DTO', () => {
    const result = transformApiTemplate({
      roleNameCode: 'voice_agent',
      roleDisplayName: 'Voice Agent',
      columns: { chat: { stateText: 'Enabled' } },
      widgets: {},
      features: {},
      settingsTabs: {},
      settingsOptions: {},
      microFrontends: {}
    })
    expect(result.roleName).toBe('voice_agent')
    expect(result.roleDisplayName).toBe('Voice Agent')
    expect(result.columns!.chat).toEqual({ state: 'enabled' })
  })
})

describe('mapAssignmentKeyToLevel', () => {
  it('maps columnAssignments to columns', () => {
    expect(mapAssignmentKeyToLevel('columnAssignments')).toBe('columns')
  })

  it('maps widgetAssignments to widgets', () => {
    expect(mapAssignmentKeyToLevel('widgetAssignments')).toBe('widgets')
  })

  it('maps featureAssignments to features', () => {
    expect(mapAssignmentKeyToLevel('featureAssignments')).toBe('features')
  })

  it('returns key as-is for unknown mapping', () => {
    expect(mapAssignmentKeyToLevel('unknownKey')).toBe('unknownKey')
  })
})

describe('buildOverridesFromAssignments', () => {
  it('builds overrides from assignments', () => {
    const result = buildOverridesFromAssignments({
      columnAssignments: {
        chat: { state: 'enabled' },
        kms: { state: 'disabled' }
      }
    } as never)
    expect(result.columns).toEqual({ chat: true, kms: false })
  })

  it('handles multiple assignment levels', () => {
    const result = buildOverridesFromAssignments({
      columnAssignments: { chat: { state: 'enabled' } },
      widgetAssignments: { sentiment: { state: 'disabled' } }
    } as never)
    expect(result.columns).toEqual({ chat: true })
    expect(result.widgets).toEqual({ sentiment: false })
  })

  it('returns empty object when no assignments', () => {
    const result = buildOverridesFromAssignments({} as never)
    expect(result).toEqual({})
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/ad-groups-data-helpers.test.ts
import { describe, it, expect } from 'vitest'
import {
  toAssignments,
  resolveUserCount,
  mapGroupIdentity,
  mapGroupMetadata,
  transformGroup,
  parseAdGroupsResponse,
  buildQueryString
} from '../ad-groups-data-helpers'

describe('toAssignments', () => {
  it('returns undefined for undefined input', () => {
    expect(toAssignments(undefined)).toBeUndefined()
  })

  it('converts enabledIndicator true to enabled state', () => {
    const result = toAssignments({ chat: { enabledIndicator: true } })
    expect(result).toEqual({ chat: { state: 'enabled' } })
  })

  it('converts enabledIndicator false to disabled state', () => {
    const result = toAssignments({ chat: { enabledIndicator: false } })
    expect(result).toEqual({ chat: { state: 'disabled' } })
  })

  it('handles multiple entries', () => {
    const result = toAssignments({
      chat: { enabledIndicator: true },
      kms: { enabledIndicator: false }
    })
    expect(result).toEqual({
      chat: { state: 'enabled' },
      kms: { state: 'disabled' }
    })
  })
})

describe('resolveUserCount', () => {
  it('returns number as-is', () => {
    expect(resolveUserCount(42)).toBe(42)
  })

  it('parses string number', () => {
    expect(resolveUserCount('123')).toBe(123)
  })

  it('returns undefined for undefined', () => {
    expect(resolveUserCount(undefined)).toBeUndefined()
  })

  it('returns undefined for NaN string', () => {
    expect(resolveUserCount('abc')).toBeUndefined()
  })
})

describe('mapGroupIdentity', () => {
  it('maps group identifier fields', () => {
    const result = mapGroupIdentity({
      groupIdentifier: 'CN=test',
      logicalName: 'Test Group',
      roleName: 'voice_agent',
      marketCode: 'US',
      regionCode: 'AMER',
      businessUnitName: 'WPB',
      countryCode: 'US'
    }, 0)
    expect(result.id).toBe('CN=test')
    expect(result.groupIdentifier).toBe('CN=test')
    expect(result.logicalName).toBe('Test Group')
    expect(result.roleName).toBe('voice_agent')
    expect(result.market).toBe('US')
    expect(result.region).toBe('AMER')
  })

  it('uses fallback index when no groupIdentifier', () => {
    const result = mapGroupIdentity({}, 5)
    expect(result.id).toBe('6')
    expect(result.groupIdentifier).toBe('Unknown')
  })
})

describe('mapGroupMetadata', () => {
  it('maps metadata fields', () => {
    const result = mapGroupMetadata({
      activeIndicator: false,
      userAccessCode: 'MAKER',
      pendingChangeIndicator: true,
      versionNumber: 3,
      userCountNumber: 50,
      permissionCount: 10,
      overrideCount: 5,
      updatedAtDatetime: '2026-01-01'
    })
    expect(result.isActive).toBe(false)
    expect(result.accessLevel).toBe('MAKER')
    expect(result.pendingChangeIndicator).toBe(true)
    expect(result.versionNumber).toBe(3)
    expect(result.userCount).toBe(50)
    expect(result.permissionCount).toBe(10)
    expect(result.overrideCount).toBe(5)
    expect(result.lastModified).toBe('2026-01-01')
  })

  it('uses defaults for missing fields', () => {
    const result = mapGroupMetadata({})
    expect(result.isActive).toBe(true)
    expect(result.pendingChangeIndicator).toBe(false)
    expect(result.overrideCount).toBe(0)
  })
})

describe('transformGroup', () => {
  it('transforms a raw group record', () => {
    const result = transformGroup({
      groupIdentifier: 'CN=test',
      activeIndicator: true,
      currentConfig: {
        permissionChanges: {
          columnPermissions: { chat: { enabledIndicator: true } }
        }
      }
    }, 0)
    expect(result.id).toBe('CN=test')
    expect(result.columnAssignments).toEqual({ chat: { state: 'enabled' } })
  })

  it('handles missing currentConfig', () => {
    const result = transformGroup({ groupIdentifier: 'CN=test' }, 0)
    expect(result.columnAssignments).toBeUndefined()
    expect(result.widgetAssignments).toBeUndefined()
  })
})

describe('parseAdGroupsResponse', () => {
  it('parses valid response', () => {
    const result = parseAdGroupsResponse({
      data: {
        items: [{ groupIdentifier: 'CN=g1', activeIndicator: true }],
        totalCount: 10,
        limitNumber: 25
      }
    })
    expect(result.groups).toHaveLength(1)
    expect(result.total).toBe(10)
    expect(result.pageSize).toBe(25)
  })

  it('throws on invalid response', () => {
    expect(() => parseAdGroupsResponse({ data: undefined })).toThrow()
  })

  it('throws when items is not an array', () => {
    expect(() => parseAdGroupsResponse({ data: {} as never })).toThrow()
  })

  it('defaults total to items length', () => {
    const result = parseAdGroupsResponse({
      data: { items: [{ groupIdentifier: 'CN=g1' }] }
    })
    expect(result.total).toBe(1)
    expect(result.pageSize).toBe(25)
  })
})

describe('buildQueryString', () => {
  it('builds basic query with offset and limit', () => {
    const qs = buildQueryString({ page: 1, size: 25 })
    expect(qs).toContain('offset=0')
    expect(qs).toContain('limit=25')
  })

  it('includes search when provided', () => {
    const qs = buildQueryString({ page: 1, size: 25, search: 'test' })
    expect(qs).toContain('search=test')
  })

  it('omits search when undefined', () => {
    const qs = buildQueryString({ page: 1, size: 25 })
    expect(qs).not.toContain('search')
  })

  it('includes filters when not "all"', () => {
    const qs = buildQueryString({
      page: 1, size: 25, role: 'voice_agent', status: 'active',
      market: 'all', region: 'AMER', country: 'all', businessUnit: 'all'
    })
    expect(qs).toContain('roleText=voice_agent')
    expect(qs).toContain('statusCode=active')
    expect(qs).toContain('regionText=AMER')
    expect(qs).not.toContain('marketText')
  })

  it('calculates correct offset for page 2', () => {
    const qs = buildQueryString({ page: 2, size: 25 })
    expect(qs).toContain('offset=25')
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/ad-groups-data-scroll.test.ts
// @vitest-environment jsdom
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { renderHook, act } from '@testing-library/react'
import { useScrollPreservation } from '../ad-groups-data-scroll'

describe('useScrollPreservation', () => {
  beforeEach(() => {
    vi.useFakeTimers()
  })

  it('returns tableContainerRef, saveScrollPosition, and restoreScrollPosition', () => {
    const { result } = renderHook(() => useScrollPreservation())
    expect(result.current.tableContainerRef).toBeDefined()
    expect(typeof result.current.saveScrollPosition).toBe('function')
    expect(typeof result.current.restoreScrollPosition).toBe('function')
  })

  it('saveScrollPosition saves window scroll when no container', () => {
    const { result } = renderHook(() => useScrollPreservation())

    act(() => {
      result.current.saveScrollPosition()
    })

    // Should not throw
    expect(result.current).toBeDefined()
  })

  it('restoreScrollPosition does nothing when value is 0', () => {
    const { result } = renderHook(() => useScrollPreservation())

    act(() => {
      result.current.restoreScrollPosition()
    })

    // No-op when value is 0
    expect(result.current).toBeDefined()
  })

  it('saveScrollPosition saves container scroll when container is scrollable', () => {
    const { result } = renderHook(() => useScrollPreservation())

    // Simulate a scrollable container
    const mockContainer = document.createElement('div')
    Object.defineProperty(mockContainer, 'scrollHeight', { value: 500 })
    Object.defineProperty(mockContainer, 'clientHeight', { value: 200 })
    Object.defineProperty(mockContainer, 'scrollTop', { value: 100, writable: true })

    // Assign to ref
    ;(result.current.tableContainerRef as { current: HTMLDivElement | null }).current = mockContainer

    act(() => {
      result.current.saveScrollPosition()
    })

    expect(result.current).toBeDefined()
  })

  it('restoreScrollPosition restores container scroll', () => {
    const { result } = renderHook(() => useScrollPreservation())

    const mockContainer = document.createElement('div')
    Object.defineProperty(mockContainer, 'scrollHeight', { value: 500 })
    Object.defineProperty(mockContainer, 'clientHeight', { value: 200 })
    Object.defineProperty(mockContainer, 'scrollTop', { value: 150, writable: true })

    ;(result.current.tableContainerRef as { current: HTMLDivElement | null }).current = mockContainer

    act(() => {
      result.current.saveScrollPosition()
    })

    act(() => {
      result.current.restoreScrollPosition()
    })

    // Advance timer to let the setTimeout fire
    act(() => {
      vi.advanceTimersByTime(10)
    })

    expect(result.current).toBeDefined()
  })

  it('restoreScrollPosition restores window scroll when source is window', () => {
    const { result } = renderHook(() => useScrollPreservation())

    // Mock scrollY
    Object.defineProperty(globalThis, 'scrollY', { value: 300, configurable: true })

    act(() => {
      result.current.saveScrollPosition()
    })

    act(() => {
      result.current.restoreScrollPosition()
    })

    // Use rAF
    act(() => {
      vi.advanceTimersByTime(100)
    })

    expect(result.current).toBeDefined()

    Object.defineProperty(globalThis, 'scrollY', { value: 0, configurable: true })
  })

  vi.useRealTimers()
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/ad-groups-selection-helpers.test.ts
import { describe, it, expect } from 'vitest'
import {
  cacheGroup,
  removeGroupFromCache,
  buildCombinedGroupsList,
  addGroupsToCache,
  removeGroupsFromCache
} from '../ad-groups-selection-helpers'

const makeGroup = (id: string) => ({
  id,
  groupIdentifier: `CN=${id}`,
  isActive: true
})

describe('cacheGroup', () => {
  it('adds group to cache', () => {
    const ref = { current: new Map() }
    cacheGroup(ref as never, makeGroup('g1') as never)
    expect(ref.current.has('g1')).toBe(true)
  })

  it('does nothing when group is undefined', () => {
    const ref = { current: new Map() }
    cacheGroup(ref as never, undefined)
    expect(ref.current.size).toBe(0)
  })
})

describe('removeGroupFromCache', () => {
  it('removes group from cache', () => {
    const ref = { current: new Map([['g1', makeGroup('g1')]]) }
    removeGroupFromCache(ref as never, 'g1')
    expect(ref.current.has('g1')).toBe(false)
  })
})

describe('buildCombinedGroupsList', () => {
  it('combines all ad groups, current groups, and cached groups', () => {
    const allGroups = [makeGroup('a')]
    const currentGroups = [makeGroup('b')]
    const cacheRef = { current: new Map([['c', makeGroup('c')]]) }

    const result = buildCombinedGroupsList(allGroups as never[], currentGroups as never[], cacheRef as never)
    expect(result).toHaveLength(3)
  })

  it('deduplicates by ID', () => {
    const allGroups = [makeGroup('a')]
    const currentGroups = [makeGroup('a')]
    const cacheRef = { current: new Map([['a', makeGroup('a')]]) }

    const result = buildCombinedGroupsList(allGroups as never[], currentGroups as never[], cacheRef as never)
    expect(result).toHaveLength(1)
  })

  it('skips groups without id in allAdGroups', () => {
    const allGroups = [{ groupIdentifier: 'no-id' }]
    const cacheRef = { current: new Map() }

    const result = buildCombinedGroupsList(allGroups as never[], [], cacheRef as never)
    expect(result).toHaveLength(0)
  })
})

describe('addGroupsToCache', () => {
  it('adds multiple groups to cache', () => {
    const ref = { current: new Map() }
    addGroupsToCache(ref as never, [makeGroup('a'), makeGroup('b')] as never[])
    expect(ref.current.size).toBe(2)
  })

  it('skips groups without id', () => {
    const ref = { current: new Map() }
    addGroupsToCache(ref as never, [{ groupIdentifier: 'no-id' }] as never[])
    expect(ref.current.size).toBe(0)
  })
})

describe('removeGroupsFromCache', () => {
  it('removes multiple groups from cache', () => {
    const ref = { current: new Map([['a', makeGroup('a')], ['b', makeGroup('b')], ['c', makeGroup('c')]]) }
    removeGroupsFromCache(ref as never, ['a', 'c'])
    expect(ref.current.size).toBe(1)
    expect(ref.current.has('b')).toBe(true)
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/app-assignment-helpers.test.ts
import { describe, it, expect } from 'vitest'
import {
  hasFunctionSetChanged,
  computeStagedChanges,
  updateAvailableApps,
  updateSelectedApp,
  filterAppsBySearch
} from '../app-assignment-helpers'

describe('hasFunctionSetChanged', () => {
  it('returns false for identical sets', () => {
    expect(hasFunctionSetChanged(['a', 'b'], ['a', 'b'])).toBe(false)
  })

  it('returns false for same items in different order', () => {
    expect(hasFunctionSetChanged(['a', 'b'], ['b', 'a'])).toBe(false)
  })

  it('returns true when item added', () => {
    expect(hasFunctionSetChanged(['a'], ['a', 'b'])).toBe(true)
  })

  it('returns true when item removed', () => {
    expect(hasFunctionSetChanged(['a', 'b'], ['a'])).toBe(true)
  })

  it('returns true when item replaced', () => {
    expect(hasFunctionSetChanged(['a', 'b'], ['a', 'c'])).toBe(true)
  })

  it('returns false for empty arrays', () => {
    expect(hasFunctionSetChanged([], [])).toBe(false)
  })
})

describe('computeStagedChanges', () => {
  it('adds new staged change', () => {
    const result = computeStagedChanges([], 'app1', 'App 1', ['a'], ['a', 'b'])
    expect(result).toHaveLength(1)
    expect(result[0].appKey).toBe('app1')
  })

  it('does not add change when functions are identical', () => {
    const result = computeStagedChanges([], 'app1', 'App 1', ['a', 'b'], ['b', 'a'])
    expect(result).toHaveLength(0)
  })

  it('replaces existing change for same app', () => {
    const prev = [{ appKey: 'app1', appTitle: 'App 1', previousFunctions: ['a'], newFunctions: ['a', 'b'] }]
    const result = computeStagedChanges(prev, 'app1', 'App 1', ['a'], ['a', 'c'])
    expect(result).toHaveLength(1)
    expect(result[0].newFunctions).toEqual(['a', 'c'])
  })
})

const makeApp = (key: string, assigned = false, functions: string[] = []) => ({
  appIdentifier: key,
  titleText: `App ${key}`,
  descriptionText: `Description for ${key}`,
  categoryName: 'Category',
  isAssignedIndicator: assigned,
  assignedFunctionKeys: functions
})

describe('updateAvailableApps', () => {
  it('updates the matching app', () => {
    const apps = [makeApp('a', false), makeApp('b', false)]
    const result = updateAvailableApps(apps as never[], 'a', ['fn1'])
    expect(result[0].isAssignedIndicator).toBe(true)
    expect(result[0].assignedFunctionKeys).toEqual(['fn1'])
    expect(result[1].isAssignedIndicator).toBe(false)
  })

  it('sets isAssigned to false when functions empty', () => {
    const apps = [makeApp('a', true, ['fn1'])]
    const result = updateAvailableApps(apps as never[], 'a', [])
    expect(result[0].isAssignedIndicator).toBe(false)
  })
})

describe('updateSelectedApp', () => {
  it('returns null when selectedApp is null', () => {
    expect(updateSelectedApp(null, 'a', ['fn1'])).toBeNull()
  })

  it('returns unchanged when key does not match', () => {
    const app = makeApp('a')
    expect(updateSelectedApp(app as never, 'b', ['fn1'])).toBe(app)
  })

  it('updates matching app', () => {
    const app = makeApp('a')
    const result = updateSelectedApp(app as never, 'a', ['fn1'])
    expect(result?.isAssignedIndicator).toBe(true)
    expect(result?.assignedFunctionKeys).toEqual(['fn1'])
  })
})

describe('filterAppsBySearch', () => {
  const apps = [
    makeApp('credit', false, []),
    makeApp('banking', false, [])
  ]

  it('returns all apps when search is empty', () => {
    const result = filterAppsBySearch(apps as never[], '')
    expect(result).toHaveLength(2)
  })

  it('filters by title', () => {
    const result = filterAppsBySearch(apps as never[], 'credit')
    expect(result).toHaveLength(1)
    expect(result[0].appIdentifier).toBe('credit')
  })

  it('filters case insensitively', () => {
    const result = filterAppsBySearch(apps as never[], 'BANKING')
    expect(result).toHaveLength(1)
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/config-save-app-payload.test.ts
import { describe, it, expect } from 'vitest'
import { buildAppChangePayload } from '../config-save-app-payload'

describe('buildAppChangePayload', () => {
  it('classifies a newly added app', () => {
    const result = buildAppChangePayload([{
      appKey: 'credit',
      appTitle: 'Credit Card',
      previousFunctions: [],
      newFunctions: ['view', 'edit']
    }])
    expect(result.applicationChanges.added).toEqual(['credit'])
    expect(result.applicationChanges.removed).toEqual([])
    expect(result.applicationChanges.unchanged).toEqual([])
  })

  it('classifies a removed app', () => {
    const result = buildAppChangePayload([{
      appKey: 'banking',
      appTitle: 'Banking',
      previousFunctions: ['view'],
      newFunctions: []
    }])
    expect(result.applicationChanges.removed).toEqual(['banking'])
    expect(result.applicationChanges.added).toEqual([])
  })

  it('classifies unchanged app with modified functions', () => {
    const result = buildAppChangePayload([{
      appKey: 'transfer',
      appTitle: 'Transfer',
      previousFunctions: ['view'],
      newFunctions: ['view', 'edit']
    }])
    expect(result.applicationChanges.unchanged).toEqual(['transfer'])
  })

  it('computes function-level diffs correctly', () => {
    const result = buildAppChangePayload([{
      appKey: 'app1',
      appTitle: 'App 1',
      previousFunctions: ['view', 'delete'],
      newFunctions: ['view', 'edit']
    }])
    expect(result.appFunctionChanges.added).toEqual([
      { appIdentifier: 'app1', functionIdentifier: 'edit' }
    ])
    expect(result.appFunctionChanges.removed).toEqual([
      { appIdentifier: 'app1', functionIdentifier: 'delete' }
    ])
    expect(result.appFunctionChanges.unchanged).toEqual([
      { appIdentifier: 'app1', functionIdentifier: 'view' }
    ])
  })

  it('tracks changed apps and function keys', () => {
    const result = buildAppChangePayload([{
      appKey: 'app1',
      appTitle: 'App 1',
      previousFunctions: ['view'],
      newFunctions: ['view', 'edit']
    }])
    expect(result.changedApps).toEqual(['app1'])
    expect(result.changedFunctions).toEqual(['app1:edit'])
  })

  it('handles multiple app changes', () => {
    const result = buildAppChangePayload([
      {
        appKey: 'new-app',
        appTitle: 'New App',
        previousFunctions: [],
        newFunctions: ['fn1']
      },
      {
        appKey: 'old-app',
        appTitle: 'Old App',
        previousFunctions: ['fn2'],
        newFunctions: []
      }
    ])
    expect(result.applicationChanges.added).toEqual(['new-app'])
    expect(result.applicationChanges.removed).toEqual(['old-app'])
    expect(result.changedApps).toHaveLength(2)
  })

  it('returns empty arrays for empty input', () => {
    const result = buildAppChangePayload([])
    expect(result.applicationChanges.added).toEqual([])
    expect(result.applicationChanges.removed).toEqual([])
    expect(result.applicationChanges.unchanged).toEqual([])
    expect(result.appFunctionChanges.added).toEqual([])
    expect(result.appFunctionChanges.removed).toEqual([])
    expect(result.appFunctionChanges.unchanged).toEqual([])
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/config-save-helpers.test.ts
import { describe, it, expect, vi } from 'vitest'

vi.mock('../../../components/admin/ad-group-config/utils/permission-helpers', () => ({
  convertOverridesToAssignments: vi.fn(() => ({}))
}))

import { buildSavePayload } from '../config-save-helpers'
import { convertOverridesToAssignments } from '../../../components/admin/ad-group-config/utils/permission-helpers'
import type { AdGroup, StagedAppChange, PendingChanges, PermissionOverrides } from '../../../types/features/ad-group-config'

const makeGroup = (overrides: Partial<AdGroup> = {}): AdGroup => ({
  id: '1',
  groupIdentifier: 'CN=test-group',
  isActive: true,
  logicalName: 'Test Group',
  roleName: 'voice_agent',
  region: 'APAC',
  country: 'HK',
  market: 'Asia Pacific',
  businessUnit: 'WPB',
  ...overrides
} as AdGroup)

const emptyPending: PendingChanges = { permissions: {} }
const emptyOverrides: PermissionOverrides = {}

describe('config-save-helpers', () => {
  describe('buildSavePayload - basic config changes', () => {
    it('returns CONFIG_UPDATE when only business info changes', () => {
      const group = makeGroup()
      const formData = makeGroup({ logicalName: 'Updated Group' })
      const result = buildSavePayload(group, formData, emptyOverrides, emptyPending, [])
      expect(result.changeType).toBe('CONFIG_UPDATE')
      expect(result.changedFields).toContain('logicalName')
    })

    it('includes businessInfoChanges in proposed state', () => {
      const group = makeGroup()
      const formData = makeGroup({ region: 'EMEA' })
      const result = buildSavePayload(group, formData, emptyOverrides, emptyPending, [])
      expect(result.proposedState.businessInfoChanges).toBeDefined()
      const bic = result.proposedState.businessInfoChanges as Record<string, unknown>
      expect(bic.region).toBe('EMEA')
    })

    it('does not include businessInfoChanges when no fields differ', () => {
      const group = makeGroup()
      const formData = makeGroup()
      const result = buildSavePayload(group, formData, emptyOverrides, emptyPending, [])
      expect(result.proposedState.businessInfoChanges).toBeUndefined()
    })

    it('builds currentState from group fields', () => {
      const group = makeGroup()
      const result = buildSavePayload(group, makeGroup(), emptyOverrides, emptyPending, [])
      expect(result.currentState.logicalName).toBe('Test Group')
      expect(result.currentState.roleName).toBe('voice_agent')
      expect(result.currentState.region).toBe('APAC')
      expect(result.currentState.country).toBe('HK')
    })

    it('strips id and lastModified from proposed state', () => {
      const group = makeGroup()
      const formData = makeGroup({ lastModified: '2025-01-01' } as Partial<AdGroup>)
      const result = buildSavePayload(group, formData, emptyOverrides, emptyPending, [])
      expect(result.proposedState.id).toBeUndefined()
      expect(result.proposedState.lastModified).toBeUndefined()
    })
  })

  describe('buildSavePayload - permission changes', () => {
    it('includes permissionChanges in proposed state', () => {
      const overrides: PermissionOverrides = { columns: { chat: true } }
      const result = buildSavePayload(makeGroup(), makeGroup(), overrides, emptyPending, [])
      expect(result.proposedState.permissionChanges).toBeDefined()
    })

    it('merges pending permission changes with overrides', () => {
      const overrides: PermissionOverrides = { columns: { chat: true } }
      const pending: PendingChanges = { permissions: { columns: { kms: false } } }
      const result = buildSavePayload(makeGroup(), makeGroup(), overrides, pending, [])
      expect(result.mergedOverrides.columns).toEqual({ chat: true, kms: false })
    })

    it('does not include permissionChanges when overrides are empty', () => {
      const result = buildSavePayload(makeGroup(), makeGroup(), emptyOverrides, emptyPending, [])
      expect(result.proposedState.permissionChanges).toBeUndefined()
    })

    it('calls convertOverridesToAssignments with merged overrides', () => {
      const overrides: PermissionOverrides = { columns: { chat: true } }
      buildSavePayload(makeGroup(), makeGroup(), overrides, emptyPending, [])
      expect(convertOverridesToAssignments).toHaveBeenCalledWith(overrides)
    })
  })

  describe('buildSavePayload - app changes', () => {
    const addedApp: StagedAppChange = {
      appKey: 'credit-card',
      appTitle: 'Credit Card',
      previousFunctions: [],
      newFunctions: ['balance-check', 'payment']
    }

    const removedApp: StagedAppChange = {
      appKey: 'money-transfer',
      appTitle: 'Money Transfer',
      previousFunctions: ['send', 'receive'],
      newFunctions: []
    }

    const modifiedApp: StagedAppChange = {
      appKey: 'credit-card',
      appTitle: 'Credit Card',
      previousFunctions: ['balance-check'],
      newFunctions: ['balance-check', 'payment']
    }

    it('returns APP_UPDATE when only app changes and no config changes', () => {
      const group = makeGroup()
      const result = buildSavePayload(group, group, emptyOverrides, emptyPending, [addedApp])
      expect(result.changeType).toBe('APP_UPDATE')
    })

    it('returns CONFIG_UPDATE when both app and config changes', () => {
      const group = makeGroup()
      const formData = makeGroup({ logicalName: 'Changed' })
      const result = buildSavePayload(group, formData, emptyOverrides, emptyPending, [addedApp])
      expect(result.changeType).toBe('CONFIG_UPDATE')
    })

    it('classifies added apps in applicationChanges', () => {
      const result = buildSavePayload(makeGroup(), makeGroup(), emptyOverrides, emptyPending, [addedApp])
      const apps = result.proposedState.applicationChanges as Array<Record<string, unknown>>
      expect(apps).toHaveLength(1)
      expect(apps[0].appCode).toBe('credit-card')
      expect(apps[0].proposedStateIndicator).toBe(true)
      expect(apps[0].currentStateIndicator).toBe(false)
    })

    it('classifies removed apps in applicationChanges', () => {
      const result = buildSavePayload(makeGroup(), makeGroup(), emptyOverrides, emptyPending, [removedApp])
      const apps = result.proposedState.applicationChanges as Array<Record<string, unknown>>
      expect(apps[0].appCode).toBe('money-transfer')
      expect(apps[0].proposedStateIndicator).toBe(false)
      expect(apps[0].currentStateIndicator).toBe(true)
    })

    it('classifies added functions in appFunctionChanges', () => {
      const result = buildSavePayload(makeGroup(), makeGroup(), emptyOverrides, emptyPending, [addedApp])
      const fns = result.proposedState.appFunctionChanges as Array<Record<string, unknown>>
      expect(fns).toHaveLength(2)
      expect(fns.every(fn => fn.enabledIndicator === true)).toBe(true)
    })

    it('classifies removed functions in appFunctionChanges', () => {
      const result = buildSavePayload(makeGroup(), makeGroup(), emptyOverrides, emptyPending, [removedApp])
      const fns = result.proposedState.appFunctionChanges as Array<Record<string, unknown>>
      expect(fns).toHaveLength(2)
      expect(fns.every(fn => fn.enabledIndicator === false)).toBe(true)
    })

    it('handles modified app with added and unchanged functions', () => {
      const result = buildSavePayload(makeGroup(), makeGroup(), emptyOverrides, emptyPending, [modifiedApp])
      const payload = result.appPayload!
      expect(payload.appFunctionChanges.added).toHaveLength(1)
      expect(payload.appFunctionChanges.added[0].functionIdentifier).toBe('payment')
      expect(payload.appFunctionChanges.unchanged).toHaveLength(1)
      expect(payload.appFunctionChanges.unchanged[0].functionIdentifier).toBe('balance-check')
    })

    it('returns null appPayload when no app changes', () => {
      const result = buildSavePayload(makeGroup(), makeGroup(), emptyOverrides, emptyPending, [])
      expect(result.appPayload).toBeNull()
    })

    it('tracks changed apps and functions in appPayload', () => {
      const result = buildSavePayload(makeGroup(), makeGroup(), emptyOverrides, emptyPending, [addedApp])
      expect(result.appPayload!.changedApps).toEqual(['credit-card'])
      expect(result.appPayload!.changedFunctions).toEqual(['credit-card:balance-check', 'credit-card:payment'])
    })
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/config-save-notifications.test.ts
import { describe, it, expect } from 'vitest'
import {
  buildSaveSuccessNotification,
  buildSaveErrorNotification,
  resolveGroupDisplayName
} from '../config-save-notifications'

describe('buildSaveSuccessNotification', () => {
  it('returns direct save success notification', () => {
    const result = buildSaveSuccessNotification('My Group', true)
    expect(result.type).toBe('success')
    expect(result.title).toBe('Changes Applied')
    expect(result.description).toContain('My Group')
    expect(result.description).toContain('immediately')
  })

  it('returns approval-based success notification', () => {
    const result = buildSaveSuccessNotification('Test Group', false)
    expect(result.type).toBe('success')
    expect(result.title).toBe('Submitted for Approval')
    expect(result.description).toContain('Test Group')
    expect(result.description).toContain('awaiting review')
  })
})

describe('buildSaveErrorNotification', () => {
  it('returns direct save error notification', () => {
    const result = buildSaveErrorNotification(true)
    expect(result.type).toBe('error')
    expect(result.title).toBe('Save failed')
    expect(result.description).toContain('could not apply')
  })

  it('returns approval-based error notification', () => {
    const result = buildSaveErrorNotification(false)
    expect(result.type).toBe('error')
    expect(result.title).toBe('Submission Failed')
    expect(result.description).toContain('could not submit')
  })
})

describe('resolveGroupDisplayName', () => {
  it('prefers formData logicalName', () => {
    expect(resolveGroupDisplayName(
      { logicalName: 'Form Name' },
      { logicalName: 'Group Name', groupIdentifier: 'CN=test' }
    )).toBe('Form Name')
  })

  it('falls back to group logicalName', () => {
    expect(resolveGroupDisplayName(
      {},
      { logicalName: 'Group Name', groupIdentifier: 'CN=test' }
    )).toBe('Group Name')
  })

  it('falls back to groupIdentifier', () => {
    expect(resolveGroupDisplayName(
      {},
      { groupIdentifier: 'CN=test' }
    )).toBe('CN=test')
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/config-save-state-builders.test.ts
import { describe, it, expect } from 'vitest'
import {
  mergeOverrides,
  buildCurrentState,
  computeBusinessInfoChanges,
  computePermissionChanges,
  hasEntries
} from '../config-save-state-builders'

describe('mergeOverrides', () => {
  it('returns overrides unchanged when no pending permissions', () => {
    const overrides = { columns: { chat: true } }
    const result = mergeOverrides(overrides, { permissions: undefined as never })
    expect(result).toEqual({ columns: { chat: true } })
  })

  it('merges pending changes into overrides', () => {
    const overrides = { columns: { chat: true } }
    const pending = { permissions: { columns: { kms: false } } }
    const result = mergeOverrides(overrides, pending as never)
    expect(result.columns).toEqual({ chat: true, kms: false })
  })

  it('pending changes override existing values', () => {
    const overrides = { columns: { chat: true } }
    const pending = { permissions: { columns: { chat: false } } }
    const result = mergeOverrides(overrides, pending as never)
    expect(result.columns.chat).toBe(false)
  })

  it('creates new level when not in overrides', () => {
    const overrides = {}
    const pending = { permissions: { widgets: { sentiment: true } } }
    const result = mergeOverrides(overrides, pending as never)
    expect(result.widgets).toEqual({ sentiment: true })
  })
})

describe('buildCurrentState', () => {
  it('extracts known fields from group', () => {
    const group = {
      id: 'g1',
      groupIdentifier: 'CN=test',
      logicalName: 'Test',
      roleName: 'voice_agent',
      region: 'AMER',
      country: 'US',
      market: 'US',
      businessUnit: 'WPB',
      isActive: true,
      pendingChangeIndicator: false
    }
    const state = buildCurrentState(group as never)
    expect(state.logicalName).toBe('Test')
    expect(state.roleName).toBe('voice_agent')
    expect(state.region).toBe('AMER')
    expect(state.country).toBe('US')
    expect(state.market).toBe('US')
    expect(state.businessUnit).toBe('WPB')
  })

  it('omits falsy fields', () => {
    const group = {
      id: 'g1',
      groupIdentifier: 'CN=test',
      isActive: true,
      pendingChangeIndicator: false
    }
    const state = buildCurrentState(group as never)
    expect(state).toEqual({})
  })
})

describe('computeBusinessInfoChanges', () => {
  it('detects changed fields', () => {
    const group = { logicalName: 'Old', roleName: 'agent' } as never
    const formData = { logicalName: 'New', roleName: 'agent' } as never
    const changes = computeBusinessInfoChanges(group, formData)
    expect(changes.logicalName).toBe('New')
    expect(changes.roleName).toBeUndefined()
  })

  it('returns empty object when nothing changed', () => {
    const group = { logicalName: 'Same' } as never
    const formData = { logicalName: 'Same' } as never
    const changes = computeBusinessInfoChanges(group, formData)
    expect(changes).toEqual({})
  })

  it('ignores undefined proposed values', () => {
    const group = { logicalName: 'Test' } as never
    const formData = {} as never
    const changes = computeBusinessInfoChanges(group, formData)
    expect(changes).toEqual({})
  })
})

describe('computePermissionChanges', () => {
  it('includes levels with entries', () => {
    const overrides = { columns: { chat: true }, widgets: {} }
    const changes = computePermissionChanges(overrides)
    expect(changes.columns).toEqual({ chat: true })
    expect(changes.widgets).toBeUndefined()
  })

  it('returns empty for all-empty levels', () => {
    const changes = computePermissionChanges({ columns: {}, widgets: {} })
    expect(changes).toEqual({})
  })
})

describe('hasEntries', () => {
  it('returns true when object has keys', () => {
    expect(hasEntries({ a: 1 })).toBe(true)
  })

  it('returns false for empty object', () => {
    expect(hasEntries({})).toBe(false)
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/function-selection-helpers.test.ts
import { describe, it, expect } from 'vitest'
import { computeInitialSelection, ensureDefaultIncluded, hasSelectionChanged } from '../function-selection-helpers'

describe('computeInitialSelection', () => {
  it('returns empty array when not assigned and no default', () => {
    expect(computeInitialSelection(false, [], undefined)).toEqual([])
  })

  it('returns default key when not assigned', () => {
    expect(computeInitialSelection(false, [], 'default')).toEqual(['default'])
  })

  it('returns default key when assigned but no keys', () => {
    expect(computeInitialSelection(true, [], 'default')).toEqual(['default'])
  })

  it('returns assigned keys when default already included', () => {
    const result = computeInitialSelection(true, ['a', 'b', 'default'], 'default')
    expect(result).toEqual(['a', 'b', 'default'])
  })

  it('appends default key when not in assigned keys', () => {
    const result = computeInitialSelection(true, ['a', 'b'], 'default')
    expect(result).toEqual(['a', 'b', 'default'])
  })

  it('returns assigned keys when no default key', () => {
    const result = computeInitialSelection(true, ['a', 'b'], undefined)
    expect(result).toEqual(['a', 'b'])
  })
})

describe('ensureDefaultIncluded', () => {
  it('adds default key when missing', () => {
    const result = ensureDefaultIncluded(['a', 'b'], 'c')
    expect(result).toContain('c')
  })

  it('does not duplicate existing default key', () => {
    const result = ensureDefaultIncluded(['a', 'b'], 'b')
    expect(result.filter(k => k === 'b')).toHaveLength(1)
  })

  it('deduplicates input', () => {
    const result = ensureDefaultIncluded(['a', 'a', 'b'], undefined)
    expect(result).toEqual(['a', 'b'])
  })

  it('returns as-is when no default key', () => {
    const result = ensureDefaultIncluded(['a', 'b'], undefined)
    expect(result).toEqual(['a', 'b'])
  })
})

describe('hasSelectionChanged', () => {
  it('returns false when selection matches assignment', () => {
    expect(hasSelectionChanged(['a', 'b'], ['b', 'a'], 'x', 'x')).toBe(false)
  })

  it('returns true when function list differs', () => {
    expect(hasSelectionChanged(['a', 'b', 'c'], ['a', 'b'], 'x', 'x')).toBe(true)
  })

  it('returns true when default changed', () => {
    expect(hasSelectionChanged(['a'], ['a'], 'new', 'old')).toBe(true)
  })

  it('returns false for identical empty arrays', () => {
    expect(hasSelectionChanged([], [], undefined, undefined)).toBe(false)
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-ad-group-form.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: (fn: () => void) => fn(),
  useCallback: (fn: (...args: unknown[]) => unknown) => fn
}))

const mockFetchAdGroupData = vi.fn()
const mockUpdateAdGroupConfig = vi.fn()
const mockApplyRoleTemplate = vi.fn()
const mockGetRoleTemplateByName = vi.fn()

vi.mock('../../api/use-ad-group-api', () => ({
  useAdGroupApi: () => ({
    isLoading: false,
    fetchAdGroupData: (...args: unknown[]) => mockFetchAdGroupData(...args),
    updateAdGroupConfig: (...args: unknown[]) => mockUpdateAdGroupConfig(...args),
    applyRoleTemplate: (...args: unknown[]) => mockApplyRoleTemplate(...args)
  })
}))

vi.mock('../../../services/api/role-template.service', () => ({
  getRoleTemplateByName: (...args: unknown[]) => mockGetRoleTemplateByName(...args)
}))

vi.mock('../../../utils/core/debug', () => ({
  createLogger: () => ({
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
    debug: vi.fn()
  })
}))

const { useAdGroupForm } = await import('../use-ad-group-form')

const baseGroup = {
  id: 'g1',
  groupIdentifier: 'CN=test-group',
  logicalName: 'Test Group',
  roleName: 'voice_agent',
  isActive: true,
  market: 'HK',
  region: 'APAC',
  country: 'HK'
}

const roleTemplateResponse = {
  roleNameCode: 'voice_agent',
  roleDisplayName: 'Voice Agent',
  columns: { kms: { stateText: 'enabled' } },
  widgets: { timer: { stateText: 'disabled' } },
  features: { 'search.knowledgeBase': { stateText: 'enabled' } },
  settingsTabs: { help: { stateText: 'enabled' } },
  settingsOptions: { 'calls.autoAccept': { stateText: 'disabled' } },
  microFrontends: { mediaBar: { stateText: 'enabled' } }
}

function callHook(overrides: Record<string, unknown> = {}) {
  stateIndex = 0
  return useAdGroupForm({
    initialGroup: { ...baseGroup, ...overrides } as any,
    open: true,
    ...overrides
  } as any)
}

describe('useAdGroupForm', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
    mockFetchAdGroupData.mockResolvedValue(null)
    mockGetRoleTemplateByName.mockResolvedValue(roleTemplateResponse)
  })

  it('initializes form data from initialGroup', () => {
    const result = callHook()
    expect(result.formData.groupIdentifier).toBe('CN=test-group')
    expect(result.formData.logicalName).toBe('Test Group')
  })

  it('initializes with empty permission overrides', () => {
    const result = callHook()
    expect(result.permissionOverrides).toEqual({})
  })

  it('initializes pending changes with empty permissions', () => {
    const result = callHook()
    expect(result.pendingChanges).toEqual({ permissions: {} })
  })

  it('loads and transforms role template when roleName is set', async () => {
    callHook()

    await vi.waitFor(() => {
      expect(callHook().roleTemplate?.roleName).toBe('voice_agent')
    })

    const result = callHook()
    expect(result.roleTemplate?.roleName).toBe('voice_agent')
    expect(result.roleTemplate?.roleDisplayName).toBe('Voice Agent')
    expect(result.roleTemplate?.columns?.kms?.state).toBe('enabled')
    expect(result.roleTemplate?.widgets?.timer?.state).toBe('disabled')
    expect(result.roleTemplate?.settings_tabs?.help?.state).toBe('enabled')
    expect(result.roleTemplate?.settings_options?.['calls.autoAccept']?.state).toBe('disabled')
    expect(result.roleTemplate?.micro_frontends?.mediaBar?.state).toBe('enabled')
  })

  it('sets roleTemplate to null when no roleName', () => {
    const result = callHook({ roleName: undefined })
    expect(result.roleTemplate).toBeNull()
  })

  describe('updateFormData', () => {
    it('updates form data with partial updates', () => {
      callHook()
      const { updateFormData } = callHook()
      updateFormData({ logicalName: 'Updated Name' })
      const result = callHook()
      expect(result.formData.logicalName).toBe('Updated Name')
    })
  })

  describe('updatePermissionOverrides', () => {
    it('updates permission overrides', () => {
      callHook()
      const { updatePermissionOverrides } = callHook()
      updatePermissionOverrides({ columns: { kms: true, search: false } })
      const result = callHook()
      expect(result.permissionOverrides.columns).toEqual({ kms: true, search: false })
    })

    it('merges with existing overrides', () => {
      callHook()
      const { updatePermissionOverrides: update1 } = callHook()
      update1({ columns: { kms: true } })
      const { updatePermissionOverrides: update2 } = callHook()
      update2({ widgets: { timer: false } })
      const result = callHook()
      expect(result.permissionOverrides.columns).toEqual({ kms: true })
      expect(result.permissionOverrides.widgets).toEqual({ timer: false })
    })
  })

  describe('handleApplyRoleTemplate', () => {
    it('clears overrides and pending changes on success', async () => {
      mockApplyRoleTemplate.mockResolvedValue({ groupIdentifier: 'CN=test-group' })
      mockGetRoleTemplateByName.mockResolvedValue({
        ...roleTemplateResponse,
        roleNameCode: 'chat_agent',
        roleDisplayName: 'Chat Agent'
      })

      callHook()
      const { updatePermissionOverrides } = callHook()
      updatePermissionOverrides({ columns: { kms: true } })
      const { handleApplyRoleTemplate } = callHook()
      await handleApplyRoleTemplate('chat_agent')

      await vi.waitFor(() => {
        callHook()
        expect(mockGetRoleTemplateByName).toHaveBeenCalledWith('chat_agent')
      })

      const result = callHook()
      expect(result.formData.roleName).toBe('chat_agent')
      expect(result.permissionOverrides).toEqual({})
      expect(result.pendingChanges).toEqual({ permissions: {} })
      expect(result.roleTemplate?.roleName).toBe('chat_agent')
    })

    it('does not clear overrides when apply returns null', async () => {
      mockApplyRoleTemplate.mockResolvedValue(null)

      callHook()
      const { updatePermissionOverrides } = callHook()
      updatePermissionOverrides({ columns: { kms: true } })
      const { handleApplyRoleTemplate } = callHook()
      await handleApplyRoleTemplate('chat_agent')

      const result = callHook()
      expect(result.permissionOverrides).toEqual({ columns: { kms: true } })
    })
  })

  describe('fetchAdGroupData on open', () => {
    it('loads saved group data and converts assignments to overrides', async () => {
      mockFetchAdGroupData.mockResolvedValue({
        ...baseGroup,
        roleName: 'chat_agent',
        columnAssignments: {
          kms: { state: 'enabled' },
          search: { state: 'disabled' }
        },
        widgetAssignments: {
          timer: { state: 'enabled' }
        }
      })

      callHook()

      await vi.waitFor(() => {
        expect(mockFetchAdGroupData).toHaveBeenCalledWith('CN=test-group')
      })
    })

    it('does not fetch when dialog is closed', () => {
      callHook({ open: false } as any)
      expect(mockFetchAdGroupData).not.toHaveBeenCalled()
    })
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-ad-groups-data.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useRef: (init: unknown) => ({ current: init }),
  useCallback: (fn: (...args: unknown[]) => unknown) => fn
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}
vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockApiFetch = vi.fn()
vi.mock('../../../services/core/api-client', () => ({
  apiFetch: (...args: unknown[]) => mockApiFetch(...args)
}))

const { useAdGroupsData } = await import('../use-ad-groups-data')

describe('useAdGroupsData', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  function callHook() {
    stateIndex = 0
    return useAdGroupsData()
  }

  it('initializes with empty state', () => {
    const result = callHook()
    expect(result.adGroups).toEqual([])
    expect(result.loading).toBe(true)
    expect(result.totalCount).toBe(0)
    expect(result.totalPages).toBe(1)
  })

  it('fetchAdGroups transforms response items', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: {
          items: [{
            groupIdentifier: 'CN=test-group',
            logicalName: 'Test Group',
            roleName: 'voice_agent',
            activeIndicator: true,
            marketCode: 'HK',
            regionCode: 'APAC',
            countryCode: 'HK'
          }],
          totalCount: 1,
          limitNumber: 20
        }
      })
    })

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result).toHaveLength(1)
    expect(result[0].groupIdentifier).toBe('CN=test-group')
    expect(result[0].logicalName).toBe('Test Group')
    expect(result[0].isActive).toBe(true)
    expect(result[0].market).toBe('HK')
    expect(result[0].region).toBe('APAC')
  })

  it('fetchAdGroups builds correct query string with filters', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: { items: [], totalCount: 0 } })
    })

    const { fetchAdGroups } = callHook()
    await fetchAdGroups({
      page: 2,
      size: 10,
      search: 'test',
      role: 'voice_agent',
      status: 'active',
      market: 'HK',
      region: 'APAC',
      country: 'SG',
      businessUnit: 'WPB'
    })

    const calledUrl = mockApiFetch.mock.calls[0][0] as string
    expect(calledUrl).toContain('offset=10')
    expect(calledUrl).toContain('limit=10')
    expect(calledUrl).toContain('search=test')
    expect(calledUrl).toContain('roleText=voice_agent')
    expect(calledUrl).toContain('statusCode=active')
    expect(calledUrl).toContain('marketText=HK')
    expect(calledUrl).toContain('regionText=APAC')
    expect(calledUrl).toContain('countryText=SG')
    expect(calledUrl).toContain('businessUnitText=WPB')
  })

  it('fetchAdGroups excludes "all" filter values', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: { items: [], totalCount: 0 } })
    })

    const { fetchAdGroups } = callHook()
    await fetchAdGroups({ page: 1, size: 20, role: 'all', status: 'all' })

    const calledUrl = mockApiFetch.mock.calls[0][0] as string
    expect(calledUrl).not.toContain('roleText')
    expect(calledUrl).not.toContain('statusCode')
  })

  it('fetchAdGroups shows error notification on failure', async () => {
    mockApiFetch.mockRejectedValue(new Error('Network error'))

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result).toEqual([])
    expect(mockNotifications.error).toHaveBeenCalled()
  })

  it('fetchAdGroups throws on non-ok response', async () => {
    mockApiFetch.mockResolvedValue({
      ok: false,
      status: 500
    })

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result).toEqual([])
    expect(mockNotifications.error).toHaveBeenCalled()
  })

  it('fetchAdGroups throws on unexpected format', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: {} })
    })

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result).toEqual([])
    expect(mockNotifications.error).toHaveBeenCalled()
  })

  it('transforms group with permission assignments', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: {
          items: [{
            groupIdentifier: 'CN=g1',
            activeIndicator: true,
            currentConfig: {
              permissionChanges: {
                columnPermissions: {
                  kms: { enabledIndicator: true },
                  search: { enabledIndicator: false }
                }
              }
            }
          }],
          totalCount: 1
        }
      })
    })

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result[0].columnAssignments).toEqual({
      kms: { state: 'enabled' },
      search: { state: 'disabled' }
    })
  })

  it('defaults isActive to true and pendingChangeIndicator to false', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: {
          items: [{ groupIdentifier: 'CN=g1' }],
          totalCount: 1
        }
      })
    })

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result[0].isActive).toBe(true)
    expect(result[0].pendingChangeIndicator).toBe(false)
  })

  it('resolves userCount from string', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: {
          items: [{ groupIdentifier: 'CN=g1', userCountNumber: '42' }],
          totalCount: 1
        }
      })
    })

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result[0].userCount).toBe(42)
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-ad-groups-loader.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: vi.fn(),
  useCallback: (fn: unknown) => fn,
  useRef: (init: unknown) => ({ current: init })
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}

vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockSearchAdGroups = vi.fn()

vi.mock('../../../services/api/admin.service', () => ({
  adminService: {
    searchAdGroups: (...args: unknown[]) => mockSearchAdGroups(...args)
  }
}))

vi.mock('../../../utils/admin/notice-validators', () => ({
  isConfiguredGroup: ({ group }: { group: Record<string, unknown> }) => {
    return Boolean(group.groupIdentifier && group.roleName)
  }
}))

const { useAdGroupsLoader } = await import('../use-ad-groups-loader')

function callHook(overrides: Record<string, unknown> = {}) {
  stateIndex = 0
  return useAdGroupsLoader({
    open: true,
    searchTerm: '',
    debounceMs: 0,
    ...overrides
  } as any)
}

describe('useAdGroupsLoader', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  it('initializes with empty groups and not loading', () => {
    const result = callHook()
    expect(result.adGroups).toEqual([])
    expect(result.isLoadingGroups).toBe(false)
  })

  it('loadGroups fetches and filters configured groups', async () => {
    mockSearchAdGroups.mockResolvedValue([
      { id: 'g1', groupIdentifier: 'CN=g1', roleName: 'voice_agent' },
      { id: 'g2', groupIdentifier: 'CN=g2', roleName: 'chat_agent' },
      { id: 'g3', groupIdentifier: 'CN=g3', roleName: undefined } // not configured
    ])

    // The hook exposes loadGroups via useCallback
    // We test it by directly calling the internal loadGroups function
    // which is returned via useCallback mock (identity function)
    callHook({ open: true })

    // Get the loadGroups function from the hook internals
    // Since useCallback returns identity, the loadGroups from the hook is directly accessible
    // We need to access it through the hook - it's exposed only internally via useEffect
    // Instead, test via the useEffect mock
    const { useEffect } = await import('react')
    const effectFn = (useEffect as ReturnType<typeof vi.fn>).mock.calls[0]?.[0]
    if (effectFn) {
      effectFn()
    }

    // Wait for the async loadGroups to complete
    await vi.waitFor(() => {
      expect(mockSearchAdGroups).toHaveBeenCalledWith('', 750)
    })

    // Re-call hook to read updated state
    const result = callHook({ open: true })
    expect(result.adGroups).toHaveLength(2)
  })

  it('does not fetch when closed', () => {
    callHook({ open: false })
    // useEffect is mocked as vi.fn() so the effect body is never called
    // The test verifies initialization state is correct when closed
    expect(mockSearchAdGroups).not.toHaveBeenCalled()
  })

  it('handles search errors gracefully', async () => {
    mockSearchAdGroups.mockRejectedValue(new Error('Search failed'))

    callHook({ open: true })

    const { useEffect } = await import('react')
    const effectFn = (useEffect as ReturnType<typeof vi.fn>).mock.calls[0]?.[0]
    if (effectFn) {
      effectFn()
    }

    await vi.waitFor(() => {
      expect(mockNotifications.error).toHaveBeenCalled()
    })

    const result = callHook({ open: true })
    expect(result.adGroups).toEqual([])
  })

  it('returns cleanup function from effect', async () => {
    callHook({ open: true })

    const { useEffect } = await import('react')
    const effectFn = (useEffect as ReturnType<typeof vi.fn>).mock.calls[0]?.[0]
    const cleanup = effectFn?.()
    // The effect returns a cleanup function (clearTimeout + cancel ref)
    expect(typeof cleanup).toBe('function')
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-ad-groups-selection.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useRef: (init: unknown) => ({ current: init }),
  useCallback: (fn: unknown) => fn,
  useEffect: (fn: () => void | (() => void)) => { fn() }
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}

vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockSearchAdGroups = vi.fn()
const mockUpdateAdGroup = vi.fn()
const mockCopyAdGroupConfiguration = vi.fn()

vi.mock('../../../services/api/admin.service', () => ({
  adminService: {
    searchAdGroups: (...args: unknown[]) => mockSearchAdGroups(...args),
    updateAdGroup: (...args: unknown[]) => mockUpdateAdGroup(...args),
    copyAdGroupConfiguration: (...args: unknown[]) => mockCopyAdGroupConfiguration(...args)
  }
}))

const { useAdGroupsSelection } = await import('../use-ad-groups-selection')

const mockGroup1 = {
  id: 'g1',
  groupIdentifier: 'CN=group-1',
  logicalName: 'Group 1',
  isActive: true,
  roleName: 'voice_agent'
}

const mockGroup2 = {
  id: 'g2',
  groupIdentifier: 'CN=group-2',
  logicalName: 'Group 2',
  isActive: false,
  roleName: 'chat_agent'
}

const mockGroup3 = {
  id: 'g3',
  groupIdentifier: 'CN=group-3',
  logicalName: 'Group 3',
  isActive: true
}

function callHook(overrides: Record<string, unknown> = {}) {
  stateIndex = 0
  return useAdGroupsSelection({
    currentGroups: [mockGroup1, mockGroup2] as any[],
    getGroupById: (id: string) => [mockGroup1, mockGroup2, mockGroup3].find(g => g.id === id) as any,
    onRefresh: vi.fn().mockResolvedValue(undefined),
    saveScrollPosition: vi.fn(),
    restoreScrollPosition: vi.fn(),
    ...overrides
  } as any)
}

describe('useAdGroupsSelection', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
    mockSearchAdGroups.mockResolvedValue([])
  })

  it('initializes with empty selection', () => {
    const result = callHook()
    expect(result.selectedGroups).toBeInstanceOf(Set)
    expect(result.selectedGroups.size).toBe(0)
  })

  it('initializes with toggle confirm closed', () => {
    const result = callHook()
    expect(result.toggleConfirmOpen).toBe(false)
    expect(result.groupToToggle).toBeNull()
  })

  describe('handleSelectGroup', () => {
    it('adds a group to selection', () => {
      callHook()
      const { handleSelectGroup } = callHook()
      handleSelectGroup('g1')
      const result = callHook()
      expect(result.selectedGroups.has('g1')).toBe(true)
    })

    it('removes a group from selection when already selected', () => {
      callHook()
      const { handleSelectGroup: select1 } = callHook()
      select1('g1')
      const { handleSelectGroup: select2 } = callHook()
      select2('g1')
      const result = callHook()
      expect(result.selectedGroups.has('g1')).toBe(false)
    })
  })

  describe('handleSelectAll', () => {
    it('selects all current groups', () => {
      callHook()
      const { handleSelectAll } = callHook()
      handleSelectAll()
      const result = callHook()
      expect(result.selectedGroups.has('g1')).toBe(true)
      expect(result.selectedGroups.has('g2')).toBe(true)
    })

    it('does nothing when currentGroups is empty', () => {
      callHook({ currentGroups: [] })
      const { handleSelectAll } = callHook({ currentGroups: [] })
      handleSelectAll()
      const result = callHook({ currentGroups: [] })
      expect(result.selectedGroups.size).toBe(0)
    })
  })

  describe('handleDeselectAll', () => {
    it('clears all selections', () => {
      callHook()
      const { handleSelectAll } = callHook()
      handleSelectAll()
      const { handleDeselectAll } = callHook()
      handleDeselectAll()
      const result = callHook()
      expect(result.selectedGroups.size).toBe(0)
    })
  })

  describe('handleSelectGroups', () => {
    it('adds multiple groups to selection', () => {
      callHook()
      const { handleSelectGroups } = callHook()
      handleSelectGroups([mockGroup1, mockGroup3] as any[])
      const result = callHook()
      expect(result.selectedGroups.has('g1')).toBe(true)
      expect(result.selectedGroups.has('g3')).toBe(true)
    })

    it('does nothing with empty array', () => {
      callHook()
      const { handleSelectGroups } = callHook()
      handleSelectGroups([])
      const result = callHook()
      expect(result.selectedGroups.size).toBe(0)
    })
  })

  describe('handleDeselectGroups', () => {
    it('removes specific groups from selection', () => {
      callHook()
      const { handleSelectAll } = callHook()
      handleSelectAll()
      const { handleDeselectGroups } = callHook()
      handleDeselectGroups(['g1'])
      const result = callHook()
      expect(result.selectedGroups.has('g1')).toBe(false)
      expect(result.selectedGroups.has('g2')).toBe(true)
    })
  })

  describe('handleToggleActive', () => {
    it('sets groupToToggle and opens confirm dialog', () => {
      callHook()
      const { handleToggleActive } = callHook()
      handleToggleActive(mockGroup1 as any)
      const result = callHook()
      expect(result.toggleConfirmOpen).toBe(true)
      expect(result.groupToToggle).not.toBeNull()
    })
  })

  describe('confirmToggleActive', () => {
    it('toggles the active status and refreshes', async () => {
      mockUpdateAdGroup.mockResolvedValue({})
      const onRefresh = vi.fn().mockResolvedValue(undefined)
      const saveScrollPosition = vi.fn()
      const restoreScrollPosition = vi.fn()

      callHook({ onRefresh, saveScrollPosition, restoreScrollPosition })
      const { handleToggleActive } = callHook({ onRefresh, saveScrollPosition, restoreScrollPosition })
      handleToggleActive(mockGroup1 as any)
      const { confirmToggleActive } = callHook({ onRefresh, saveScrollPosition, restoreScrollPosition })
      await confirmToggleActive()

      expect(mockUpdateAdGroup).toHaveBeenCalledWith('CN=group-1', { isActive: false })
      expect(mockNotifications.success).toHaveBeenCalled()
    })

    it('shows error on failure', async () => {
      mockUpdateAdGroup.mockRejectedValue(new Error('Update failed'))
      const onRefresh = vi.fn().mockResolvedValue(undefined)

      callHook({ onRefresh })
      const { handleToggleActive } = callHook({ onRefresh })
      handleToggleActive(mockGroup1 as any)
      const { confirmToggleActive } = callHook({ onRefresh })
      await confirmToggleActive()

      expect(mockNotifications.error).toHaveBeenCalled()
    })

    it('does nothing when no group to toggle', async () => {
      callHook()
      const { confirmToggleActive } = callHook()
      await confirmToggleActive()
      expect(mockUpdateAdGroup).not.toHaveBeenCalled()
    })
  })

  describe('notifyCopyResult', () => {
    it('notifies success when all copies succeed', async () => {
      mockCopyAdGroupConfiguration.mockResolvedValue({ success: true })
      const onRefresh = vi.fn().mockResolvedValue(undefined)

      callHook({ onRefresh })
      // Select groups to get them in selection details
      const { handleSelectGroup } = callHook({ onRefresh })
      handleSelectGroup('g2')

      const { handleCopyFrom } = callHook({ onRefresh })
      await handleCopyFrom(
        mockGroup1 as any,
        ['g2'],
        {
          copyRoleAndPermissionsFlag: true,
          copyBusinessInfoFlag: true,
          copyApplicationsFlag: false,
          copyWorkflowModeCode: 'DIRECT_SAVE',
          functionMismatchPolicyCode: 'SKIP_UNAVAILABLE'
        }
      )

      expect(mockNotifications.success).toHaveBeenCalled()
    })

    it('notifies error when all copies fail', async () => {
      mockCopyAdGroupConfiguration.mockResolvedValue({ success: false })
      const onRefresh = vi.fn().mockResolvedValue(undefined)

      callHook({ onRefresh })
      const { handleSelectGroup } = callHook({ onRefresh })
      handleSelectGroup('g2')

      const { handleCopyFrom } = callHook({ onRefresh })
      await handleCopyFrom(
        mockGroup1 as any,
        ['g2'],
        {
          copyRoleAndPermissionsFlag: true,
          copyBusinessInfoFlag: true,
          copyApplicationsFlag: false,
          copyWorkflowModeCode: 'DIRECT_SAVE',
          functionMismatchPolicyCode: 'SKIP_UNAVAILABLE'
        }
      )

      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })

  describe('searchAdGroups (fetchLookup)', () => {
    it('searches and returns configured groups', async () => {
      mockSearchAdGroups.mockResolvedValue([
        { id: 'g1', groupIdentifier: 'CN=g1' },
        { id: 'g2', groupIdentifier: 'CN=g2' },
        { id: '', groupIdentifier: '' }
      ])

      const { searchAdGroups } = callHook()
      const result = await searchAdGroups('test')

      expect(mockSearchAdGroups).toHaveBeenCalledWith('test', 750)
      expect(result).toHaveLength(2) // filters out empty groupIdentifier
    })

    it('returns empty array and shows error on failure', async () => {
      mockSearchAdGroups.mockRejectedValue(new Error('Search failed'))

      const { searchAdGroups } = callHook()
      const result = await searchAdGroups('test')

      expect(result).toEqual([])
      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-application-assignment-extra.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number
let effectCallbacks: Array<() => void | (() => void)>

function resetState() {
  stateStore = new Map()
  stateIndex = 0
  effectCallbacks = []
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: (fn: () => void) => { effectCallbacks.push(fn) },
  useCallback: (fn: (...args: unknown[]) => unknown) => fn,
  useRef: (init: unknown) => ({ current: init })
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}
vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockLoadEmbeddedAppsData = vi.fn()
const mockSaveAppAssignment = vi.fn()

vi.mock('../../api/use-embedded-apps-api', () => ({
  useEmbeddedAppsApi: () => ({
    isLoadingApps: false,
    isSavingAppAssignment: false,
    loadEmbeddedAppsData: mockLoadEmbeddedAppsData,
    saveAppAssignment: mockSaveAppAssignment
  })
}))

const { useApplicationAssignment } = await import('../use-application-assignment')

describe('useApplicationAssignment - extra coverage', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  function callHook(overrides: Record<string, unknown> = {}) {
    stateIndex = 0
    return useApplicationAssignment({
      groupIdentifier: 'CN=test-group',
      groupDisplayName: 'Test Group',
      open: true,
      activeTab: 'applications',
      canDirectSave: true,
      ...overrides
    } as any)
  }

  it('handleFunctionSelectionChange stores unsaved selection', () => {
    callHook()
    const { handleFunctionSelectionChange } = callHook()
    handleFunctionSelectionChange('app1', 'App 1', ['fn1', 'fn2'], 'fn1')
    const result = callHook()
    expect(result.unsavedFunctionSelection).toEqual({
      appKey: 'app1',
      appTitle: 'App 1',
      functions: ['fn1', 'fn2'],
      defaultFunction: 'fn1'
    })
  })

  it('handleFunctionSelectionChange clears when empty functions', () => {
    callHook()
    const { handleFunctionSelectionChange } = callHook()
    handleFunctionSelectionChange('app1', 'App 1', ['fn1'], 'fn1')
    // Now clear it
    const { handleFunctionSelectionChange: clear } = callHook()
    clear('app1', 'App 1', [], undefined)
    const result = callHook()
    expect(result.unsavedFunctionSelection).toBeNull()
  })

  it('flushUnsavedFunctions saves via API when canDirectSave', async () => {
    mockSaveAppAssignment.mockResolvedValue(undefined)
    mockLoadEmbeddedAppsData.mockResolvedValue([])

    callHook({ canDirectSave: true })
    const { handleFunctionSelectionChange } = callHook({ canDirectSave: true })
    handleFunctionSelectionChange('app1', 'App 1', ['fn1'], 'fn1')

    const { flushUnsavedFunctions } = callHook({ canDirectSave: true })
    await flushUnsavedFunctions()

    expect(mockSaveAppAssignment).toHaveBeenCalledWith(
      'app1', 'App 1', 'CN=test-group', 'Test Group', ['fn1'], 'fn1'
    )
  })

  it('flushUnsavedFunctions does nothing when no unsaved selection', async () => {
    callHook()
    const { flushUnsavedFunctions } = callHook()
    await flushUnsavedFunctions()
    expect(mockSaveAppAssignment).not.toHaveBeenCalled()
  })

  it('flushUnsavedFunctions stages changes when canDirectSave is false', async () => {
    callHook({ canDirectSave: false })
    // Set an app in availableApps
    stateStore.set(0, [{ appIdentifier: 'app1', titleText: 'App 1', assignedFunctionKeys: [] }])
    const { handleFunctionSelectionChange } = callHook({ canDirectSave: false })
    handleFunctionSelectionChange('app1', 'App 1', ['fn1', 'fn2'], undefined)

    const { flushUnsavedFunctions } = callHook({ canDirectSave: false })
    await flushUnsavedFunctions()

    expect(mockNotifications.success).toHaveBeenCalled()
  })

  it('setAppSearchTerm updates the search term', () => {
    callHook()
    const { setAppSearchTerm } = callHook()
    setAppSearchTerm('banking')
    const result = callHook()
    expect(result.appSearchTerm).toBe('banking')
  })

  it('runs effects when open and on applications tab', () => {
    callHook({ open: true, activeTab: 'applications' })
    // Run all stored effects
    for (const effect of effectCallbacks) {
      const cleanup = effect()
      if (typeof cleanup === 'function') cleanup()
    }
    expect(mockLoadEmbeddedAppsData).toHaveBeenCalled()
  })

  it('skips loading when not on applications tab', () => {
    callHook({ open: true, activeTab: 'basic' })
    for (const effect of effectCallbacks) {
      effect()
    }
    // loadEmbeddedAppsData should not have been called from effects
    expect(mockLoadEmbeddedAppsData).not.toHaveBeenCalled()
  })

  it('skips loading when modal is closed', () => {
    callHook({ open: false })
    for (const effect of effectCallbacks) {
      effect()
    }
    expect(mockLoadEmbeddedAppsData).not.toHaveBeenCalled()
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-application-assignment.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number
let effectCallbacks: Array<() => void>

function resetState() {
  stateStore = new Map()
  stateIndex = 0
  effectCallbacks = []
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: (fn: () => void) => { effectCallbacks.push(fn) },
  useCallback: (fn: (...args: unknown[]) => unknown) => fn,
  useRef: (init: unknown) => ({ current: init })
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}
vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockLoadEmbeddedAppsData = vi.fn()
const mockSaveAppAssignment = vi.fn()

vi.mock('../../api/use-embedded-apps-api', () => ({
  useEmbeddedAppsApi: () => ({
    isLoadingApps: false,
    isSavingAppAssignment: false,
    loadEmbeddedAppsData: mockLoadEmbeddedAppsData,
    saveAppAssignment: mockSaveAppAssignment
  })
}))

const { useApplicationAssignment } = await import('../use-application-assignment')

describe('useApplicationAssignment', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  function callHook(overrides: Record<string, unknown> = {}) {
    stateIndex = 0
    return useApplicationAssignment({
      groupIdentifier: 'CN=test-group',
      groupDisplayName: 'Test Group',
      open: true,
      activeTab: 'applications',
      canDirectSave: true,
      ...overrides
    } as any)
  }

  it('initializes with empty state', () => {
    const result = callHook()
    expect(result.availableApps).toEqual([])
    expect(result.selectedApp).toBeNull()
    expect(result.appSearchTerm).toBe('')
    expect(result.stagedAppChanges).toEqual([])
  })

  it('handleAppSelect sets selectedApp', () => {
    callHook()
    const { handleAppSelect } = callHook()
    const testApp = { appIdentifier: 'app1', titleText: 'App 1' }
    handleAppSelect(testApp as any)
    const result = callHook()
    expect(result.selectedApp).toEqual(testApp)
  })

  it('handleAppCancel clears selectedApp', () => {
    callHook()
    const { handleAppSelect, handleAppCancel } = callHook()
    handleAppSelect({ appIdentifier: 'app1' } as any)
    handleAppCancel()
    const result = callHook()
    expect(result.selectedApp).toBeNull()
  })

  it('clearStagedAppChanges resets staged changes', () => {
    callHook()
    const { clearStagedAppChanges } = callHook()
    clearStagedAppChanges()
    const result = callHook()
    expect(result.stagedAppChanges).toEqual([])
  })

  it('handleSaveAppAssignment calls API directly when canDirectSave', async () => {
    mockSaveAppAssignment.mockResolvedValue(undefined)
    mockLoadEmbeddedAppsData.mockResolvedValue([])

    callHook({ canDirectSave: true })
    const { handleSaveAppAssignment } = callHook({ canDirectSave: true })
    await handleSaveAppAssignment('app1', 'App 1', ['fn1', 'fn2'], 'fn1')

    expect(mockSaveAppAssignment).toHaveBeenCalledWith(
      'app1', 'App 1', 'CN=test-group', 'Test Group', ['fn1', 'fn2'], 'fn1'
    )
  })

  it('handleSaveAppAssignment stages change when canDirectSave is false', async () => {
    // Setup with an existing app in availableApps
    callHook({ canDirectSave: false })
    // manually set availableApps
    stateStore.set(0, [{ appIdentifier: 'app1', titleText: 'App 1', assignedFunctionKeys: ['fn1'] }])
    const { handleSaveAppAssignment } = callHook({ canDirectSave: false })
    await handleSaveAppAssignment('app1', 'App 1', ['fn1', 'fn2'])

    const result = callHook({ canDirectSave: false })
    expect(result.stagedAppChanges).toHaveLength(1)
    expect(result.stagedAppChanges[0].appKey).toBe('app1')
    expect(result.stagedAppChanges[0].newFunctions).toEqual(['fn1', 'fn2'])
    expect(mockNotifications.success).toHaveBeenCalled()
  })

  it('filteredApps returns all apps when no search term', () => {
    callHook()
    stateStore.set(0, [
      { appIdentifier: 'app1', titleText: 'Banking', descriptionText: 'Banking app', categoryName: 'Finance' },
      { appIdentifier: 'app2', titleText: 'Search', descriptionText: 'Search app', categoryName: 'Tools' }
    ])
    const result = callHook()
    expect(result.filteredApps).toHaveLength(2)
  })

  it('filteredApps filters by search term', () => {
    callHook()
    stateStore.set(0, [
      { appIdentifier: 'app1', titleText: 'Banking', descriptionText: 'Banking app', categoryName: 'Finance' },
      { appIdentifier: 'app2', titleText: 'Search', descriptionText: 'Search app', categoryName: 'Tools' }
    ])
    stateStore.set(2, 'banking') // appSearchTerm is the 3rd useState call (index 2)
    const result = callHook()
    expect(result.filteredApps).toHaveLength(1)
    expect(result.filteredApps[0].appIdentifier).toBe('app1')
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-config-save.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  }
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}

vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockSubmitChange = vi.fn()
const mockDirectSave = vi.fn()

vi.mock('../../../services/api/admin-approval.service', () => ({
  adminApprovalService: {
    submitChange: (...args: unknown[]) => mockSubmitChange(...args),
    directSave: (...args: unknown[]) => mockDirectSave(...args)
  }
}))

vi.mock('../../../components/admin/ad-group-config/utils/permission-helpers', () => ({
  convertOverridesToAssignments: (overrides: Record<string, unknown>) => {
    const result: Record<string, unknown> = {}
    for (const [key, value] of Object.entries(overrides)) {
      if (value && typeof value === 'object' && Object.keys(value as object).length > 0) {
        result[`${key}Assignments`] = value
      }
    }
    return result
  }
}))

const { useConfigSave } = await import('../use-config-save')

describe('useConfigSave', () => {
  const baseGroup = {
    id: 'g1',
    groupIdentifier: 'CN=test-group',
    logicalName: 'Test Group',
    roleName: 'voice_agent',
    isActive: true,
    region: 'APAC',
    country: 'HK'
  }

  let updateAdGroupConfig: ReturnType<typeof vi.fn>
  let updatePermissionOverrides: ReturnType<typeof vi.fn>
  let setPendingChanges: ReturnType<typeof vi.fn>
  let clearStagedAppChanges: ReturnType<typeof vi.fn>
  let onSave: ReturnType<typeof vi.fn>
  let onClose: ReturnType<typeof vi.fn>

  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
    updateAdGroupConfig = vi.fn().mockResolvedValue(null)
    updatePermissionOverrides = vi.fn()
    setPendingChanges = vi.fn()
    clearStagedAppChanges = vi.fn()
    onSave = vi.fn()
    onClose = vi.fn()
  })

  function callHook(overrides: Record<string, unknown> = {}) {
    stateIndex = 0
    return useConfigSave({
      formData: { ...baseGroup } as any,
      group: { ...baseGroup } as any,
      permissionOverrides: {},
      pendingChanges: { permissions: {} },
      stagedAppChanges: [],
      canDirectSave: false,
      updateAdGroupConfig,
      updatePermissionOverrides,
      setPendingChanges,
      clearStagedAppChanges,
      onSave,
      onClose,
      ...overrides
    })
  }

  it('initializes showSaveDialog as false', () => {
    const result = callHook()
    expect(result.showSaveDialog).toBe(false)
  })

  it('handleSaveClick opens save dialog', () => {
    callHook()
    const { handleSaveClick } = callHook()
    handleSaveClick()
    const result = callHook()
    expect(result.showSaveDialog).toBe(true)
    expect(result.isDirectSave).toBe(false)
  })

  it('handleDirectSaveClick opens dialog with direct save flag', () => {
    callHook()
    const { handleDirectSaveClick } = callHook()
    handleDirectSaveClick()
    const result = callHook()
    expect(result.showSaveDialog).toBe(true)
    expect(result.isDirectSave).toBe(true)
  })

  it('handleConfirmSave submits change via approval workflow', async () => {
    mockSubmitChange.mockResolvedValue({})

    callHook()
    const { handleConfirmSave } = callHook()
    await handleConfirmSave()

    expect(mockSubmitChange).toHaveBeenCalledWith(
      'CN=test-group',
      expect.objectContaining({
        changeType: 'CONFIG_UPDATE',
        currentState: expect.any(Object),
        proposedState: expect.any(Object)
      })
    )
    expect(updatePermissionOverrides).toHaveBeenCalled()
    expect(setPendingChanges).toHaveBeenCalledWith({ permissions: {} })
    expect(onClose).toHaveBeenCalled()
    expect(mockNotifications.success).toHaveBeenCalled()
  })

  it('handleConfirmSave uses direct save when isDirectSave and canDirectSave', async () => {
    mockDirectSave.mockResolvedValue({})

    callHook({ canDirectSave: true })
    const { handleDirectSaveClick } = callHook({ canDirectSave: true })
    handleDirectSaveClick()
    const { handleConfirmSave } = callHook({ canDirectSave: true })
    await handleConfirmSave()

    expect(mockDirectSave).toHaveBeenCalledWith(
      'CN=test-group',
      expect.objectContaining({
        currentState: expect.any(Object),
        proposedState: expect.any(Object)
      })
    )
    expect(onClose).toHaveBeenCalled()
  })

  it('handleConfirmSave handles errors gracefully', async () => {
    mockSubmitChange.mockRejectedValue(new Error('Network error'))

    callHook()
    const { handleConfirmSave } = callHook()
    await handleConfirmSave()

    expect(mockNotifications.error).toHaveBeenCalled()
    expect(onClose).not.toHaveBeenCalled()
  })

  it('includes business info changes when form data differs', async () => {
    mockSubmitChange.mockResolvedValue({})

    const modifiedFormData = {
      ...baseGroup,
      logicalName: 'Updated Group Name'
    }

    callHook({ formData: modifiedFormData, group: baseGroup })
    const { handleConfirmSave } = callHook({ formData: modifiedFormData, group: baseGroup })
    await handleConfirmSave()

    expect(mockSubmitChange).toHaveBeenCalledWith(
      'CN=test-group',
      expect.objectContaining({
        proposedState: expect.objectContaining({
          businessInfoChanges: expect.objectContaining({
            logicalName: 'Updated Group Name'
          })
        })
      })
    )
  })

  it('includes permission changes when overrides exist', async () => {
    mockSubmitChange.mockResolvedValue({})

    callHook({
      pendingChanges: { permissions: { columns: { kms: false } } }
    })
    const { handleConfirmSave } = callHook({
      pendingChanges: { permissions: { columns: { kms: false } } }
    })
    await handleConfirmSave()

    expect(mockSubmitChange).toHaveBeenCalledWith(
      'CN=test-group',
      expect.objectContaining({
        proposedState: expect.objectContaining({
          permissionChanges: expect.objectContaining({
            columns: expect.any(Object)
          })
        })
      })
    )
  })

  it('sets changeType to APP_UPDATE when only app changes exist', async () => {
    mockSubmitChange.mockResolvedValue({})

    const stagedAppChanges = [{
      appKey: 'testApp',
      appTitle: 'Test App',
      previousFunctions: [],
      newFunctions: ['fn1']
    }]

    callHook({ stagedAppChanges })
    const { handleConfirmSave } = callHook({ stagedAppChanges })
    await handleConfirmSave()

    expect(mockSubmitChange).toHaveBeenCalledWith(
      'CN=test-group',
      expect.objectContaining({
        changeType: 'APP_UPDATE'
      })
    )
  })

  it('clears staged app changes on successful save', async () => {
    mockSubmitChange.mockResolvedValue({})

    callHook()
    const { handleConfirmSave } = callHook()
    await handleConfirmSave()

    expect(clearStagedAppChanges).toHaveBeenCalled()
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-function-selection.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

// Track state across useState calls
let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: (fn: () => void) => fn()
}))

const { useFunctionSelection } = await import('../use-function-selection')

function callHook(appOverrides: Record<string, unknown> = {}) {
  stateIndex = 0 // reset index for each hook call
  const baseApp = {
    appKey: 'myApp',
    displayName: 'My App',
    isAssignedIndicator: true,
    assignedFunctionKeys: ['fn1', 'fn2'],
    defaultFunctionKey: 'fn1',
    availableFunctions: [],
    ...appOverrides
  }
  return useFunctionSelection({ app: baseApp as any })
}

describe('useFunctionSelection', () => {
  beforeEach(() => {
    resetState()
  })

  it('initializes with assigned functions when assigned', () => {
    callHook()
    // After useEffect runs, selectedFunctions should be set
    const result = callHook() // re-call to read updated state
    expect(result.selectedFunctions).toEqual(['fn1', 'fn2'])
  })

  it('initializes with default function only when not assigned', () => {
    callHook({ isAssignedIndicator: false, assignedFunctionKeys: [] })
    const result = callHook({ isAssignedIndicator: false, assignedFunctionKeys: [] })
    expect(result.selectedFunctions).toEqual(['fn1'])
  })

  it('adds default function if missing from assigned', () => {
    callHook({ assignedFunctionKeys: ['fn2'] })
    const result = callHook({ assignedFunctionKeys: ['fn2'] })
    expect(result.selectedFunctions).toContain('fn1')
    expect(result.selectedFunctions).toContain('fn2')
  })

  it('handleFunctionToggle adds a function', () => {
    callHook() // init
    const { handleFunctionToggle } = callHook() // read
    handleFunctionToggle({ functionKey: 'fn3', checked: true })
    const result = callHook() // read updated
    expect(result.selectedFunctions).toContain('fn3')
  })

  it('handleFunctionToggle does not remove default function', () => {
    callHook()
    const { handleFunctionToggle } = callHook()
    handleFunctionToggle({ functionKey: 'fn1', checked: false })
    const result = callHook()
    // fn1 is defaultFunctionKey, should still be there
    expect(result.selectedFunctions).toContain('fn1')
  })

  it('handleClearSelection keeps only default', () => {
    callHook()
    const { handleClearSelection } = callHook()
    handleClearSelection()
    const result = callHook()
    expect(result.selectedFunctions).toEqual(['fn1'])
  })

  it('handleReset restores assigned functions', () => {
    callHook()
    const { handleClearSelection } = callHook()
    handleClearSelection()
    const { handleReset } = callHook()
    handleReset()
    const result = callHook()
    expect(result.selectedFunctions).toEqual(['fn1', 'fn2'])
  })

  it('hasChanges returns false when no changes made', () => {
    callHook()
    const { hasChanges } = callHook()
    expect(hasChanges()).toBe(false)
  })

  it('hasChanges returns true after clear', () => {
    callHook()
    const { handleClearSelection } = callHook()
    handleClearSelection()
    const { hasChanges } = callHook()
    expect(hasChanges()).toBe(true)
  })

  it('handleSelectAllFiltered adds filtered functions', () => {
    callHook()
    const { handleSelectAllFiltered } = callHook()
    handleSelectAllFiltered({ filteredFunctions: ['fn3', 'fn4'] })
    const result = callHook()
    expect(result.selectedFunctions).toContain('fn3')
    expect(result.selectedFunctions).toContain('fn4')
  })

  it('handles app with no defaultFunctionKey', () => {
    resetState()
    callHook({ defaultFunctionKey: undefined, isAssignedIndicator: false, assignedFunctionKeys: [] })
    const result = callHook({ defaultFunctionKey: undefined, isAssignedIndicator: false, assignedFunctionKeys: [] })
    expect(result.selectedFunctions).toEqual([])
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-notice-form.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: (fn: () => void) => fn(),
  useMemo: (fn: () => unknown) => fn()
}))

vi.mock('../../../utils/admin/notice-validators', () => ({
  isEndDateValid: ({ startAt, endAt }: { startAt?: string; endAt?: string }) => {
    if (!startAt || !endAt) return true
    return new Date(endAt) > new Date(startAt)
  }
}))

vi.mock('date-fns', () => ({
  startOfDay: (d: Date) => d
}))

const { useNoticeForm } = await import('../use-notice-form')

function callHook(params: { open: boolean; editNotice?: Record<string, unknown> } = { open: true }) {
  stateIndex = 0
  return useNoticeForm(params as any)
}

describe('useNoticeForm', () => {
  beforeEach(() => {
    resetState()
  })

  it('initializes with default form data when no editNotice', () => {
    callHook({ open: true })
    const result = callHook({ open: true })

    expect(result.formData.title).toBe('')
    expect(result.formData.message).toBe('')
    expect(result.formData.severity).toBe('INFO')
    expect(result.formData.broadcastToAll).toBe(true)
    expect(result.formData.targetRoles).toEqual([])
    expect(result.formData.targetAdGroups).toEqual([])
    expect(result.formData.requiresAcknowledgement).toBe(false)
  })

  it('populates form data from editNotice when open', () => {
    const editNotice = {
      id: 'n1',
      title: 'Test Notice',
      message: 'Test body',
      severity: 'WARNING',
      broadcastToAll: false,
      targetRoles: ['voice_agent'],
      targetAdGroups: ['CN=group1'],
      requiresAcknowledgement: true,
      startAt: '2025-01-01T00:00:00Z',
      endAt: '2025-12-31T00:00:00Z',
      status: 'ACTIVE',
      createdAt: '2025-01-01T00:00:00Z',
      createdBy: 'admin'
    }

    callHook({ open: true, editNotice })
    const result = callHook({ open: true, editNotice })

    expect(result.formData.title).toBe('Test Notice')
    expect(result.formData.message).toBe('Test body')
    expect(result.formData.severity).toBe('WARNING')
    expect(result.formData.broadcastToAll).toBe(false)
    expect(result.formData.targetRoles).toEqual(['voice_agent'])
    expect(result.formData.targetAdGroups).toEqual(['CN=group1'])
    expect(result.formData.requiresAcknowledgement).toBe(true)
  })

  it('toggleRole adds a role when not present', () => {
    callHook({ open: true })
    const { toggleRole } = callHook({ open: true })
    toggleRole({ roleValue: 'voice_agent' })
    const result = callHook({ open: true })

    expect(result.formData.targetRoles).toContain('voice_agent')
  })

  it('toggleRole removes a role when present', () => {
    const editNotice = {
      id: 'n1',
      title: 'T',
      message: 'M',
      severity: 'INFO',
      broadcastToAll: false,
      targetRoles: ['voice_agent', 'chat_agent'],
      targetAdGroups: [],
      requiresAcknowledgement: false,
      status: 'ACTIVE',
      createdAt: '2025-01-01T00:00:00Z',
      createdBy: 'admin'
    }

    callHook({ open: true, editNotice })
    const { toggleRole } = callHook({ open: true, editNotice })
    toggleRole({ roleValue: 'voice_agent' })
    const result = callHook({ open: true, editNotice })

    expect(result.formData.targetRoles).not.toContain('voice_agent')
    expect(result.formData.targetRoles).toContain('chat_agent')
  })

  it('isRoleSelected returns correct boolean', () => {
    const editNotice = {
      id: 'n1',
      title: 'T',
      message: 'M',
      severity: 'INFO',
      broadcastToAll: false,
      targetRoles: ['voice_agent'],
      targetAdGroups: [],
      requiresAcknowledgement: false,
      status: 'ACTIVE',
      createdAt: '2025-01-01T00:00:00Z',
      createdBy: 'admin'
    }

    callHook({ open: true, editNotice })
    const result = callHook({ open: true, editNotice })

    expect(result.isRoleSelected({ roleValue: 'voice_agent' })).toBe(true)
    expect(result.isRoleSelected({ roleValue: 'chat_agent' })).toBe(false)
  })

  it('toggleAdGroup adds a group when not present', () => {
    callHook({ open: true })
    const { toggleAdGroup } = callHook({ open: true })
    toggleAdGroup({ groupIdentifier: 'CN=test-group' })
    const result = callHook({ open: true })

    expect(result.formData.targetAdGroups).toContain('CN=test-group')
  })

  it('toggleAdGroup removes a group when present', () => {
    const editNotice = {
      id: 'n1',
      title: 'T',
      message: 'M',
      severity: 'INFO',
      broadcastToAll: false,
      targetRoles: [],
      targetAdGroups: ['CN=group1', 'CN=group2'],
      requiresAcknowledgement: false,
      status: 'ACTIVE',
      createdAt: '2025-01-01T00:00:00Z',
      createdBy: 'admin'
    }

    callHook({ open: true, editNotice })
    const { toggleAdGroup } = callHook({ open: true, editNotice })
    toggleAdGroup({ groupIdentifier: 'CN=group1' })
    const result = callHook({ open: true, editNotice })

    expect(result.formData.targetAdGroups).not.toContain('CN=group1')
    expect(result.formData.targetAdGroups).toContain('CN=group2')
  })

  it('isAdGroupSelected returns correct boolean', () => {
    const editNotice = {
      id: 'n1',
      title: 'T',
      message: 'M',
      severity: 'INFO',
      broadcastToAll: false,
      targetRoles: [],
      targetAdGroups: ['CN=group1'],
      requiresAcknowledgement: false,
      status: 'ACTIVE',
      createdAt: '2025-01-01T00:00:00Z',
      createdBy: 'admin'
    }

    callHook({ open: true, editNotice })
    const result = callHook({ open: true, editNotice })

    expect(result.isAdGroupSelected({ groupIdentifier: 'CN=group1' })).toBe(true)
    expect(result.isAdGroupSelected({ groupIdentifier: 'CN=other' })).toBe(false)
  })

  it('resetForm restores default values', () => {
    const editNotice = {
      id: 'n1',
      title: 'Test',
      message: 'Body',
      severity: 'CRITICAL',
      broadcastToAll: false,
      targetRoles: ['voice_agent'],
      targetAdGroups: ['CN=group1'],
      requiresAcknowledgement: true,
      status: 'ACTIVE',
      createdAt: '2025-01-01T00:00:00Z',
      createdBy: 'admin'
    }

    callHook({ open: true, editNotice })
    const hook = callHook({ open: true, editNotice })
    expect(hook.formData.title).toBe('Test')

    hook.resetForm()
    const result = callHook({ open: true, editNotice })

    expect(result.formData.title).toBe('')
    expect(result.formData.severity).toBe('INFO')
    expect(result.formData.broadcastToAll).toBe(true)
    expect(result.formData.targetRoles).toEqual([])
  })

  it('isEndDateValid returns true when no dates', () => {
    callHook({ open: true })
    const result = callHook({ open: true })
    expect(result.isEndDateValid).toBe(true)
  })

  it('isEndDateValid returns true when end is after start', () => {
    callHook({ open: true })
    const { setFormData, formData } = callHook({ open: true })
    setFormData({
      ...formData,
      startAt: '2025-01-01T00:00:00Z',
      endAt: '2025-12-31T00:00:00Z'
    })
    const result = callHook({ open: true })
    expect(result.isEndDateValid).toBe(true)
  })

  it('isEndDateValid returns false when end is before start', () => {
    callHook({ open: true })
    const { setFormData, formData } = callHook({ open: true })
    setFormData({
      ...formData,
      startAt: '2025-12-31T00:00:00Z',
      endAt: '2025-01-01T00:00:00Z'
    })
    const result = callHook({ open: true })
    expect(result.isEndDateValid).toBe(false)
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-notice-save.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

const mockCreateNotice = vi.fn()
const mockUpdateNotice = vi.fn()
const mockSuccess = vi.fn()
const mockError = vi.fn()
let isSavingValue = false

vi.mock('react', () => ({
  useState: (init: unknown) => {
    isSavingValue = init as boolean
    return [isSavingValue, (v: boolean) => { isSavingValue = v }]
  }
}))

vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => ({
    success: mockSuccess,
    error: mockError
  })
}))

vi.mock('../../../services/api/admin.service', () => ({
  adminService: {
    createNotice: (...args: unknown[]) => mockCreateNotice(...args),
    updateNotice: (...args: unknown[]) => mockUpdateNotice(...args)
  }
}))

vi.mock('../../../utils/admin/notice-validators', () => ({
  validateNoticeForm: ({ title, message }: { title?: string; message?: string }) => {
    if (!title) return { valid: false, error: 'titleRequired' }
    if (!message) return { valid: false, error: 'messageRequired' }
    return { valid: true }
  }
}))

const { useNoticeSave } = await import('../use-notice-save')

describe('useNoticeSave', () => {
  const onSuccess = vi.fn()

  beforeEach(() => {
    vi.clearAllMocks()
    mockCreateNotice.mockResolvedValue({})
    mockUpdateNotice.mockResolvedValue({})
  })

  it('shows validation error for missing title', async () => {
    const { handleSave } = useNoticeSave({
      formData: { message: 'Body' },
      isEndDateValid: true,
      onSuccess
    })
    await handleSave({ asDraft: false })
    expect(mockError).toHaveBeenCalledWith(expect.objectContaining({
      title: 'Validation failed'
    }))
    expect(mockCreateNotice).not.toHaveBeenCalled()
  })

  it('shows validation error for missing message', async () => {
    const { handleSave } = useNoticeSave({
      formData: { title: 'Title' },
      isEndDateValid: true,
      onSuccess
    })
    await handleSave({ asDraft: false })
    expect(mockError).toHaveBeenCalled()
  })

  it('shows error for invalid end date', async () => {
    const { handleSave } = useNoticeSave({
      formData: { title: 'Title', message: 'Body' },
      isEndDateValid: false,
      onSuccess
    })
    await handleSave({ asDraft: false })
    expect(mockError).toHaveBeenCalledWith(expect.objectContaining({
      title: 'Invalid date range'
    }))
  })

  it('creates notice when no editNotice', async () => {
    const { handleSave } = useNoticeSave({
      formData: { title: 'Title', message: 'Body' },
      isEndDateValid: true,
      onSuccess
    })
    await handleSave({ asDraft: false })
    expect(mockCreateNotice).toHaveBeenCalledWith(expect.objectContaining({
      title: 'Title',
      message: 'Body',
      status: 'ACTIVE'
    }))
    expect(mockSuccess).toHaveBeenCalled()
    expect(onSuccess).toHaveBeenCalled()
  })

  it('creates draft notice', async () => {
    const { handleSave } = useNoticeSave({
      formData: { title: 'Title', message: 'Body' },
      isEndDateValid: true,
      onSuccess
    })
    await handleSave({ asDraft: true })
    expect(mockCreateNotice).toHaveBeenCalledWith(expect.objectContaining({
      status: 'DRAFT'
    }))
  })

  it('updates notice when editNotice provided', async () => {
    const { handleSave } = useNoticeSave({
      formData: { title: 'Updated', message: 'Body' },
      editNotice: { id: 'n1' } as any,
      isEndDateValid: true,
      onSuccess
    })
    await handleSave({ asDraft: false })
    expect(mockUpdateNotice).toHaveBeenCalledWith('n1', expect.objectContaining({
      title: 'Updated'
    }))
    expect(mockSuccess).toHaveBeenCalled()
  })

  it('shows error on save failure', async () => {
    mockCreateNotice.mockRejectedValue(new Error('Network error'))
    const { handleSave } = useNoticeSave({
      formData: { title: 'Title', message: 'Body' },
      isEndDateValid: true,
      onSuccess
    })
    await handleSave({ asDraft: false })
    expect(mockError).toHaveBeenCalledWith(expect.objectContaining({
      title: 'Failed to save notice'
    }))
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-pending-changes.test.ts
import { beforeEach, describe, expect, it, vi } from 'vitest'
import type { PendingChangeFilters } from '../../../types/features/approval-workflow.types'

const useQueryMock = vi.fn()
const useMutationMock = vi.fn()
const useQueryClientMock = vi.fn()

vi.mock('@tanstack/react-query', () => ({
  useQuery: (...args: unknown[]) => useQueryMock(...args),
  useMutation: (...args: unknown[]) => useMutationMock(...args),
  useQueryClient: (...args: unknown[]) => useQueryClientMock(...args)
}))

vi.mock('../../../services/api/admin-approval.service', () => ({
  adminApprovalService: {
    listPendingChanges: vi.fn(),
    getPendingChange: vi.fn(),
    getPendingChangesCount: vi.fn(),
    submitChange: vi.fn(),
    directSave: vi.fn(),
    approveChange: vi.fn(),
    rejectChange: vi.fn(),
    getMyActivity: vi.fn(),
    cancelChange: vi.fn()
  }
}))

const {
  MY_ACTIVITY_QUERY_KEY,
  PENDING_CHANGES_COUNT_KEY,
  PENDING_CHANGES_QUERY_KEY,
  useApproveChange,
  useCancelChange,
  useDirectSave,
  useMyActivity,
  usePendingChange,
  usePendingChanges,
  usePendingChangesCount,
  useRejectChange,
  useSubmitChange
} = await import('../use-pending-changes')
const { adminApprovalService } = await import('../../../services/api/admin-approval.service')

describe('use-pending-changes hooks', () => {
  const invalidateQueries = vi.fn()

  beforeEach(() => {
    vi.clearAllMocks()

    useQueryMock.mockReset()
    useMutationMock.mockReset()
    useQueryClientMock.mockReset()

    useQueryMock.mockImplementation((options) => options)
    useMutationMock.mockImplementation((options) => options)
    useQueryClientMock.mockReturnValue({ invalidateQueries })
  })

  it('builds pending changes list query config', async () => {
    const filters: PendingChangeFilters = { status: ['PENDING_LEVEL_ONE'] }
    usePendingChanges(filters)
    const queryConfig = useQueryMock.mock.calls[0][0]

    expect(queryConfig.queryKey).toEqual([PENDING_CHANGES_QUERY_KEY, filters])
    expect(queryConfig.staleTime).toBe(30 * 1000)
    expect(queryConfig.refetchOnWindowFocus).toBe(true)

    await queryConfig.queryFn()
    expect(adminApprovalService.listPendingChanges).toHaveBeenCalledWith(filters)
  })

  it('builds pending change query config with enabled guard', async () => {
    usePendingChange(null)
    const disabledConfig = useQueryMock.mock.calls[0][0]
    expect(disabledConfig.enabled).toBe(false)
    expect(disabledConfig.queryKey).toEqual([PENDING_CHANGES_QUERY_KEY, null])

    usePendingChange('change-123')
    const enabledConfig = useQueryMock.mock.calls[1][0]
    expect(enabledConfig.enabled).toBe(true)
    expect(enabledConfig.staleTime).toBe(30 * 1000)

    await enabledConfig.queryFn()
    expect(adminApprovalService.getPendingChange).toHaveBeenCalledWith('change-123')
  })

  it('builds pending changes count query config', async () => {
    usePendingChangesCount()
    const enabledConfig = useQueryMock.mock.calls[0][0]
    expect(enabledConfig.queryKey).toEqual([PENDING_CHANGES_COUNT_KEY])
    expect(enabledConfig.enabled).toBe(true)
    expect(enabledConfig.refetchInterval).toBe(60 * 1000)

    await enabledConfig.queryFn()
    expect(adminApprovalService.getPendingChangesCount).toHaveBeenCalledTimes(1)

    usePendingChangesCount(false)
    const disabledConfig = useQueryMock.mock.calls[1][0]
    expect(disabledConfig.enabled).toBe(false)
  })

  it('builds my activity query config for all and filtered ranges', async () => {
    useMyActivity()
    const allConfig = useQueryMock.mock.calls[0][0]
    expect(allConfig.queryKey).toEqual([MY_ACTIVITY_QUERY_KEY, 1, 'all'])

    await allConfig.queryFn()
    expect(adminApprovalService.getMyActivity).toHaveBeenCalledWith(1, 25, undefined)

    useMyActivity(2, 'week')
    const filteredConfig = useQueryMock.mock.calls[1][0]
    expect(filteredConfig.queryKey).toEqual([MY_ACTIVITY_QUERY_KEY, 2, 'week'])

    await filteredConfig.queryFn()
    expect(adminApprovalService.getMyActivity).toHaveBeenCalledWith(2, 25, 'week')
  })

  it('submits changes and invalidates related queries', async () => {
    useSubmitChange()
    const mutationConfig = useMutationMock.mock.calls[0][0]

    const payload = {
      groupId: 'group-1',
      request: { changeType: 'UPDATE' }
    } as never

    await mutationConfig.mutationFn(payload)
    expect(adminApprovalService.submitChange).toHaveBeenCalledWith('group-1', { changeType: 'UPDATE' })

    mutationConfig.onSuccess?.()
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: ['adminAdGroups'] })
  })

  it('direct saves and invalidates ad group cache', async () => {
    useDirectSave()
    const mutationConfig = useMutationMock.mock.calls[0][0]

    const payload = {
      groupId: 'group-2',
      request: { reason: 'force-save' }
    } as never

    await mutationConfig.mutationFn(payload)
    expect(adminApprovalService.directSave).toHaveBeenCalledWith('group-2', { reason: 'force-save' })

    mutationConfig.onSuccess?.()
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: ['adminAdGroups'] })
  })

  it('approves changes and invalidates related queries', async () => {
    useApproveChange()
    const mutationConfig = useMutationMock.mock.calls[0][0]

    await mutationConfig.mutationFn({ changeId: 'change-1', request: { comment: 'ok' } } as never)
    expect(adminApprovalService.approveChange).toHaveBeenCalledWith('change-1', { comment: 'ok' })

    mutationConfig.onSuccess?.()
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: ['adminAdGroups'] })
  })

  it('rejects changes and invalidates pending caches', async () => {
    useRejectChange()
    const mutationConfig = useMutationMock.mock.calls[0][0]

    await mutationConfig.mutationFn({ changeId: 'change-2', request: { reason: 'invalid' } } as never)
    expect(adminApprovalService.rejectChange).toHaveBeenCalledWith('change-2', { reason: 'invalid' })

    mutationConfig.onSuccess?.()
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
  })

  it('cancels changes and invalidates pending caches', async () => {
    useCancelChange()
    const mutationConfig = useMutationMock.mock.calls[0][0]

    await mutationConfig.mutationFn('change-3')
    expect(adminApprovalService.cancelChange).toHaveBeenCalledWith('change-3')

    mutationConfig.onSuccess?.()
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-permission-aggregators.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('react', () => ({
  default: {
    useCallback: (fn: (...args: unknown[]) => unknown) => fn,
    useMemo: (fn: () => unknown) => fn()
  },
  useCallback: (fn: (...args: unknown[]) => unknown) => fn,
  useMemo: (fn: () => unknown) => fn()
}))

vi.mock('../../../constants/permission-levels', () => ({
  permissionLevels: {
    capabilities: {
      title: 'Access Controls',
      description: 'Core actions',
      icon: () => null,
      businessNames: {
        'columns.kms': 'Knowledge Base',
        'columns.embeddedApps': 'Banking Applications',
        'columns.spaceCopilot': 'AI Assistant',
        'columns.chat': 'Chat Interface',
        'micro_frontends.mediaBar': 'Media Controls'
      }
    },
    workspacePreferences: {
      title: 'Workspace & Preferences',
      description: 'User preferences',
      icon: () => null,
      businessNames: {
        'settings_options.calls.autoAccept': 'Auto-Accept Calls',
        'settings_options.calls.doNotDisturb.duration': 'Do Not Disturb',
        'settings_options.interface.showTranscript': 'Show Transcripts',
        'settings_options.interface.autoCloseKnowledgeOnCallEnd': 'Auto-Close Knowledge',
        'settings_options.interface.spaceCopilotMode': 'AI Assistant Mode'
      }
    }
  }
}))

vi.mock('../../../components/admin/ad-group-config/utils/permission-helpers', () => ({
  getTemplateSection: (template: Record<string, unknown> | null, level: string) => {
    if (!template) return {}
    const section = template[level]
    if (section && typeof section === 'object') return section
    return {}
  }
}))

vi.mock('../../../components/admin/business-relevant-toggles', () => ({
  businessRelevantToggles: {
    capabilities: {
      toggles: {
        'columns.kms': { visible: true, businessName: 'Knowledge Base', description: 'Access to knowledge base', section: 'Dashboard Access' },
        'columns.embeddedApps': { visible: true, businessName: 'Banking Applications', description: 'Access to banking apps', section: 'Dashboard Access' },
        'columns.spaceCopilot': { visible: true, businessName: 'AI Assistant', description: 'Access to AI features', section: 'Dashboard Access' },
        'columns.chat': { visible: true, businessName: 'Chat Interface', description: 'Access to chat', section: 'Dashboard Access' },
        'micro_frontends.mediaBar': { visible: true, businessName: 'Media Controls', description: 'Voice and video controls', section: 'Platform Apps' }
      }
    },
    workspacePreferences: {
      toggles: {
        'settings_options.calls.autoAccept': { visible: true, businessName: 'Auto-Accept Calls', description: 'Auto accept calls', section: 'Call Preferences' },
        'settings_options.calls.doNotDisturb.duration': { visible: true, businessName: 'Do Not Disturb', description: 'Set break duration', section: 'Call Preferences' },
        'settings_options.interface.showTranscript': { visible: true, businessName: 'Show Transcripts', description: 'Display transcripts', section: 'Privacy & Display' },
        'settings_options.interface.autoCloseKnowledgeOnCallEnd': { visible: true, businessName: 'Auto-Close Knowledge', description: 'Auto close knowledge', section: 'Privacy & Display' },
        'settings_options.interface.spaceCopilotMode': { visible: true, businessName: 'AI Assistant Mode', description: 'Choose AI level', section: 'AI Preference' }
      }
    }
  },
  isToggleBusinessRelevant: (_level: string, _key: string) => true
}))

vi.mock('../../../utils/admin/permission-level-resolver', () => ({
  COMPOUND_LEVELS: {
    capabilities: ['columns', 'features', 'micro_frontends'],
    workspacePreferences: ['widgets', 'settings_tabs', 'settings_options']
  }
}))

vi.mock('../../../utils/admin/permission-hierarchy-sorter', () => ({
  sortWithHierarchy: ({ keys }: { keys: string[] }) => keys
}))

const { usePermissionAggregators } = await import('../use-permission-aggregators')

describe('usePermissionAggregators', () => {
  const baseTemplate = {
    roleName: 'voice_agent',
    columns: {
      kms: { state: 'enabled' },
      embeddedApps: { state: 'enabled' },
      spaceCopilot: { state: 'enabled' },
      chat: { state: 'enabled' }
    },
    micro_frontends: {
      mediaBar: { state: 'enabled' }
    },
    settings_options: {
      'calls.autoAccept': { state: 'enabled' },
      'calls.doNotDisturb.duration': { state: 'enabled' },
      'interface.showTranscript': { state: 'enabled' },
      'interface.autoCloseKnowledgeOnCallEnd': { state: 'enabled' },
      'interface.spaceCopilotMode': { state: 'enabled' }
    }
  }

  describe('getPermissionCount', () => {
    it('returns 0 when no role template', () => {
      const { getPermissionCount } = usePermissionAggregators({
        roleTemplate: null,
        searchTerm: '',
        isPermissionEnabled: () => false
      })

      expect(getPermissionCount({ level: 'capabilities' })).toBe(0)
    })

    it('counts enabled capabilities (columns + micro_frontends)', () => {
      const { getPermissionCount } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      expect(getPermissionCount({ level: 'capabilities' })).toBe(5)
    })

    it('counts enabled workspacePreferences (settings_options)', () => {
      const { getPermissionCount } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      expect(getPermissionCount({ level: 'workspacePreferences' })).toBe(5)
    })
  })

  describe('getAllPermissions', () => {
    it('returns empty array when no role template', () => {
      const { getAllPermissions } = usePermissionAggregators({
        roleTemplate: null,
        searchTerm: '',
        isPermissionEnabled: () => false
      })

      expect(getAllPermissions({ level: 'capabilities' })).toEqual([])
    })

    it('returns all capabilities keys with prefixes', () => {
      const { getAllPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      const caps = getAllPermissions({ level: 'capabilities' })
      expect(caps).toContain('columns.kms')
      expect(caps).toContain('columns.spaceCopilot')
      expect(caps).toContain('micro_frontends.mediaBar')
    })

    it('returns workspacePreferences keys with settings_options prefix', () => {
      const { getAllPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      const prefs = getAllPermissions({ level: 'workspacePreferences' })
      expect(prefs).toContain('settings_options.calls.autoAccept')
      expect(prefs).toContain('settings_options.interface.spaceCopilotMode')
    })

    it('returns empty array for unknown level', () => {
      const { getAllPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      expect(getAllPermissions({ level: 'nonexistent' })).toEqual([])
    })
  })

  describe('getEnabledPermissions', () => {
    it('returns only enabled permissions', () => {
      const enabledKeys = new Set(['columns.kms'])
      const { getEnabledPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: ({ key }: { key: string }) => enabledKeys.has(key)
      })

      const enabled = getEnabledPermissions({ level: 'capabilities' })
      expect(enabled).toContain('columns.kms')
      expect(enabled).not.toContain('micro_frontends.mediaBar')
    })

    it('returns empty array when no template', () => {
      const { getEnabledPermissions } = usePermissionAggregators({
        roleTemplate: null,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      expect(getEnabledPermissions({ level: 'capabilities' })).toEqual([])
    })
  })

  describe('getFilteredPermissions', () => {
    it('returns all permissions when no search term', () => {
      const { getFilteredPermissions, getAllPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      expect(getFilteredPermissions({ level: 'capabilities' }))
        .toEqual(getAllPermissions({ level: 'capabilities' }))
    })

    it('filters by business name', () => {
      const { getFilteredPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: 'knowledge',
        isPermissionEnabled: () => true
      })

      const filtered = getFilteredPermissions({ level: 'capabilities' })
      expect(filtered).toContain('columns.kms')
    })

    it('returns empty when search matches nothing', () => {
      const { getFilteredPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: 'xyznonexistent',
        isPermissionEnabled: () => true
      })

      const filtered = getFilteredPermissions({ level: 'capabilities' })
      expect(filtered).toEqual([])
    })
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-permission-state.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('react', () => ({
  default: { useCallback: (fn: (...args: unknown[]) => unknown) => fn },
  useCallback: (fn: (...args: unknown[]) => unknown) => fn
}))

vi.mock('../../../components/admin/ad-group-config/utils/permission-helpers', () => ({
  getTemplateSection: (template: Record<string, unknown> | null, level: string) => {
    if (!template) return {}
    const section = template[level]
    if (section && typeof section === 'object') return section
    return {}
  }
}))

vi.mock('../../../utils/admin/permission-level-resolver', () => ({
  resolvePermissionLevel: ({ level, key }: { level: string; key: string }) => {
    const COMPOUND: Record<string, string[]> = {
      capabilities: ['columns', 'features', 'micro_frontends'],
      workspacePreferences: ['widgets', 'settings_tabs', 'settings_options']
    }
    const prefixes = COMPOUND[level]
    if (!prefixes) return { actualLevel: level, actualKey: key }
    for (const prefix of prefixes) {
      if (key.startsWith(prefix + '.')) {
        return { actualLevel: prefix, actualKey: key.slice(prefix.length + 1) }
      }
    }
    const [p, ...rest] = key.split('.')
    return { actualLevel: p, actualKey: rest.join('.') }
  },
  COMPOUND_LEVELS: {
    capabilities: ['columns', 'features', 'micro_frontends'],
    workspacePreferences: ['widgets', 'settings_tabs', 'settings_options']
  }
}))

const { usePermissionState } = await import('../use-permission-state')

describe('usePermissionState', () => {
  const baseTemplate = {
    roleName: 'voice_agent',
    columns: {
      kms: { state: 'enabled' },
      chat: { state: 'disabled' }
    },
    widgets: {
      'customer.info': { state: 'enabled' }
    },
    features: {
      'search.knowledgeBase': { state: 'enabled' }
    },
    micro_frontends: {
      mediaBar: { state: 'enabled' }
    },
    settings_tabs: {
      help: { state: 'enabled' }
    },
    settings_options: {
      'calls.autoAccept': { state: 'enabled' }
    }
  }

  describe('isPermissionEnabled', () => {
    it('returns false when no role template', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: null,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'columns', key: 'kms' })).toBe(false)
    })

    it('returns template value when no overrides', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'columns', key: 'kms' })).toBe(true)
      expect(isPermissionEnabled({ level: 'columns', key: 'chat' })).toBe(false)
    })

    it('override takes precedence over template', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: { columns: { kms: false } },
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'columns', key: 'kms' })).toBe(false)
    })

    it('pending change takes precedence over override', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: { columns: { kms: false } },
        pendingChanges: { permissions: { columns: { kms: true } } }
      })
      expect(isPermissionEnabled({ level: 'columns', key: 'kms' })).toBe(true)
    })

    it('handles capabilities level (columns prefix)', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'capabilities', key: 'columns.kms' })).toBe(true)
    })

    it('handles capabilities level (features prefix)', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'capabilities', key: 'features.search.knowledgeBase' })).toBe(true)
    })

    it('handles capabilities level (micro_frontends prefix)', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'capabilities', key: 'micro_frontends.mediaBar' })).toBe(true)
    })

    it('handles capabilities with pending change', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: { columns: { kms: false } } }
      })
      expect(isPermissionEnabled({ level: 'capabilities', key: 'columns.kms' })).toBe(false)
    })

    it('handles workspacePreferences level (widgets prefix)', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'workspacePreferences', key: 'widgets.customer.info' })).toBe(true)
    })

    it('handles workspacePreferences level (settings_tabs prefix)', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'workspacePreferences', key: 'settings_tabs.help' })).toBe(true)
    })

    it('handles workspacePreferences level (settings_options prefix)', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'workspacePreferences', key: 'settings_options.calls.autoAccept' })).toBe(true)
    })

    it('handles workspacePreferences with override', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: { settings_tabs: { help: false } },
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'workspacePreferences', key: 'settings_tabs.help' })).toBe(false)
    })
  })

  describe('hasUnsavedChanges', () => {
    it('returns false when no role template', () => {
      const { hasUnsavedChanges } = usePermissionState({
        roleTemplate: null,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(hasUnsavedChanges({ level: 'columns', key: 'kms' })).toBe(false)
    })

    it('returns false when no pending change', () => {
      const { hasUnsavedChanges } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(hasUnsavedChanges({ level: 'columns', key: 'kms' })).toBe(false)
    })

    it('returns true when pending differs from saved', () => {
      const { hasUnsavedChanges } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: { columns: { kms: false } } }
      })
      expect(hasUnsavedChanges({ level: 'columns', key: 'kms' })).toBe(true)
    })

    it('returns false when pending matches saved override', () => {
      const { hasUnsavedChanges } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: { columns: { kms: false } },
        pendingChanges: { permissions: { columns: { kms: false } } }
      })
      expect(hasUnsavedChanges({ level: 'columns', key: 'kms' })).toBe(false)
    })

    it('handles capabilities level', () => {
      const { hasUnsavedChanges } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: { columns: { kms: false } } }
      })
      expect(hasUnsavedChanges({ level: 'capabilities', key: 'columns.kms' })).toBe(true)
    })

    it('handles workspacePreferences level', () => {
      const { hasUnsavedChanges } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: { settings_tabs: { help: false } } }
      })
      expect(hasUnsavedChanges({ level: 'workspacePreferences', key: 'settings_tabs.help' })).toBe(true)
    })
  })
})
===ENDFILE

===FILE: src/hooks/admin/__tests__/use-permission-toggle.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  }
}))

vi.mock('../../../components/admin/business-relevant-toggles', () => ({
  businessRelevantToggles: {
    capabilities: {
      toggles: {
        'columns.kms': { businessName: 'Knowledge Base', linkedKeys: ['features.search.knowledgeBase'] },
        'columns.embeddedApps': { businessName: 'Banking Applications', linkedKeys: ['features.search.embeddedApps'] },
        'columns.spaceCopilot': { businessName: 'AI Assistant', linkedKeys: ['micro_frontends.spaceCopilot'] },
        'columns.chat': { businessName: 'Chat Interface' },
        'micro_frontends.mediaBar': { businessName: 'Media Controls', linkedKeys: ['widgets.mediaBar.callControls'] }
      }
    },
    workspacePreferences: {
      toggles: {
        'settings_options.calls.autoAccept': { businessName: 'Auto-Accept Calls' },
        'settings_options.calls.doNotDisturb.duration': { businessName: 'Do Not Disturb' },
        'settings_options.interface.showTranscript': { businessName: 'Show Transcripts' },
        'settings_options.interface.autoCloseKnowledgeOnCallEnd': { businessName: 'Auto-Close Knowledge' },
        'settings_options.interface.spaceCopilotMode': { businessName: 'AI Assistant Mode' }
      }
    },
    parentChild: {
      toggles: {
        'columns.parentToggle': { businessName: 'Parent Toggle' },
        'columns.childA': { businessName: 'Child A', parent: 'columns.parentToggle' },
        'columns.childB': { businessName: 'Child B', parent: 'columns.parentToggle' }
      }
    }
  },
  isToggleBusinessRelevant: () => true
}))

vi.mock('../../../components/admin/ad-group-config/utils/permission-helpers', () => ({
  getTemplateSection: (template: Record<string, unknown> | null, level: string) => {
    if (!template) return {}
    const section = template[level]
    if (section && typeof section === 'object') return section
    return {}
  }
}))

vi.mock('../../../utils/admin/permission-level-resolver', () => ({
  resolvePermissionLevel: ({ level, key }: { level: string; key: string }) => {
    const COMPOUND: Record<string, string[]> = {
      capabilities: ['columns', 'features', 'micro_frontends'],
      workspacePreferences: ['widgets', 'settings_tabs', 'settings_options'],
      parentChild: ['columns']
    }
    const prefixes = COMPOUND[level]
    if (!prefixes) return { actualLevel: level, actualKey: key }
    for (const prefix of prefixes) {
      if (key.startsWith(prefix + '.')) {
        return { actualLevel: prefix, actualKey: key.slice(prefix.length + 1) }
      }
    }
    const [p, ...rest] = key.split('.')
    return { actualLevel: p, actualKey: rest.join('.') }
  },
  resolveLinkedKey: (linkedKey: string) => {
    const allSections = ['columns', 'features', 'micro_frontends', 'widgets', 'settings_tabs', 'settings_options']
    for (const section of allSections) {
      if (linkedKey.startsWith(section + '.')) {
        return { actualLevel: section, actualKey: linkedKey.slice(section.length + 1) }
      }
    }
    const [level, ...rest] = linkedKey.split('.')
    return { actualLevel: level, actualKey: rest.join('.') }
  }
}))

const { usePermissionToggle } = await import('../use-permission-toggle')

describe('usePermissionToggle', () => {
  const baseTemplate = {
    roleName: 'voice_agent',
    columns: {
      kms: { state: 'enabled' },
      embeddedApps: { state: 'enabled' },
      spaceCopilot: { state: 'enabled' }
    },
    features: {
      'search.knowledgeBase': { state: 'enabled' },
      'search.embeddedApps': { state: 'enabled' }
    },
    micro_frontends: {
      mediaBar: { state: 'enabled' },
      spaceCopilot: { state: 'enabled' }
    },
    widgets: {
      'mediaBar.callControls': { state: 'enabled' }
    },
    settings_options: {
      'calls.autoAccept': { state: 'enabled' },
      'interface.showTranscript': { state: 'enabled' },
      'interface.autoCloseKnowledgeOnCallEnd': { state: 'enabled' },
      'interface.spaceCopilotMode': { state: 'enabled' }
    }
  }

  let setPendingChangesSpy: ReturnType<typeof vi.fn>

  beforeEach(() => {
    resetState()
    setPendingChangesSpy = vi.fn()
  })

  function callHook(overrides: Record<string, unknown> = {}) {
    stateIndex = 0
    return usePermissionToggle({
      roleTemplate: baseTemplate as any,
      permissionOverrides: {},
      pendingChanges: { permissions: {} },
      setPendingChanges: setPendingChangesSpy,
      ...overrides
    })
  }

  it('initializes loadingPermission as null', () => {
    const result = callHook()
    expect(result.loadingPermission).toBeNull()
  })

  it('toggles a capabilities column permission', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'capabilities', key: 'columns.kms', value: false })

    expect(setPendingChangesSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        permissions: expect.objectContaining({
          columns: expect.objectContaining({
            kms: false
          })
        })
      })
    )
  })

  it('toggles a workspacePreferences permission', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'workspacePreferences', key: 'settings_options.calls.autoAccept', value: false })

    expect(setPendingChangesSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        permissions: expect.objectContaining({
          settings_options: expect.objectContaining({
            'calls.autoAccept': false
          })
        })
      })
    )
  })

  it('toggles a micro_frontends capability', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'capabilities', key: 'micro_frontends.mediaBar', value: false })

    expect(setPendingChangesSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        permissions: expect.objectContaining({
          micro_frontends: expect.objectContaining({
            mediaBar: false
          })
        })
      })
    )
  })

  it('removes pending change when value matches saved override', () => {
    const result = callHook({
      permissionOverrides: { columns: { kms: false } }
    })
    result.handleTogglePermission({ level: 'capabilities', key: 'columns.kms', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    expect(call.permissions.columns?.kms).toBeUndefined()
  })

  it('cascades AI Assistant toggle to micro_frontends.spaceCopilot via linkedKeys', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'capabilities', key: 'columns.spaceCopilot', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    // Linked key: micro_frontends.spaceCopilot should also be set to false
    expect(call.permissions.micro_frontends?.spaceCopilot).toBe(false)
  })

  it('cascades Knowledge Base toggle to features.search.knowledgeBase via linkedKeys', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'capabilities', key: 'columns.kms', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    // Linked key: features.search.knowledgeBase should also be set to false
    expect(call.permissions.features?.['search.knowledgeBase']).toBe(false)
  })

  it('cascades Media Controls toggle to widgets.mediaBar.callControls via linkedKeys', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'capabilities', key: 'micro_frontends.mediaBar', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    // Linked key: widgets.mediaBar.callControls should also be set to false
    expect(call.permissions.widgets?.['mediaBar.callControls']).toBe(false)
  })

  it('does not cascade linkedKeys for toggles without them', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'capabilities', key: 'columns.chat', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    // Only columns.chat should be affected, no other sections
    expect(call.permissions.columns?.chat).toBe(false)
    expect(call.permissions.features).toBeUndefined()
    expect(call.permissions.micro_frontends).toBeUndefined()
    expect(call.permissions.widgets).toBeUndefined()
  })

  it('auto-enables parent when enabling a child toggle', () => {
    const result = callHook({
      roleTemplate: {
        ...baseTemplate,
        columns: {
          ...baseTemplate.columns,
          parentToggle: { state: 'disabled' },
          childA: { state: 'disabled' },
          childB: { state: 'disabled' }
        }
      }
    })
    result.handleTogglePermission({ level: 'parentChild', key: 'columns.childA', value: true })

    const call = setPendingChangesSpy.mock.calls[0][0]
    // Enabling a child should auto-enable the parent
    expect(call.permissions.columns?.childA).toBe(true)
    expect(call.permissions.columns?.parentToggle).toBe(true)
  })

  it('auto-disables parent when disabling the last enabled child', () => {
    const result = callHook({
      roleTemplate: {
        ...baseTemplate,
        columns: {
          ...baseTemplate.columns,
          parentToggle: { state: 'enabled' },
          childA: { state: 'enabled' },
          childB: { state: 'disabled' }
        }
      }
    })
    // childA is the only enabled child; disabling it should auto-disable parent
    result.handleTogglePermission({ level: 'parentChild', key: 'columns.childA', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    expect(call.permissions.columns?.childA).toBe(false)
    expect(call.permissions.columns?.parentToggle).toBe(false)
  })

  it('does not auto-disable parent when siblings are still enabled', () => {
    const result = callHook({
      roleTemplate: {
        ...baseTemplate,
        columns: {
          ...baseTemplate.columns,
          parentToggle: { state: 'enabled' },
          childA: { state: 'enabled' },
          childB: { state: 'enabled' }
        }
      }
    })
    // Disable childA but childB is still enabled, so parent stays enabled
    result.handleTogglePermission({ level: 'parentChild', key: 'columns.childA', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    expect(call.permissions.columns?.childA).toBe(false)
    // Parent should NOT be auto-disabled because childB is still enabled
    expect(call.permissions.columns?.parentToggle).toBeUndefined()
  })

  it('cascades disable to children when disabling parent', () => {
    const result = callHook({
      roleTemplate: {
        ...baseTemplate,
        columns: {
          ...baseTemplate.columns,
          parentToggle: { state: 'enabled' },
          childA: { state: 'enabled' },
          childB: { state: 'enabled' }
        }
      }
    })
    result.handleTogglePermission({ level: 'parentChild', key: 'columns.parentToggle', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    expect(call.permissions.columns?.parentToggle).toBe(false)
    // Children should be cascaded to false
    expect(call.permissions.columns?.childA).toBe(false)
    expect(call.permissions.columns?.childB).toBe(false)
  })

  it('cascades enable to children when enabling parent', () => {
    const result = callHook({
      roleTemplate: {
        ...baseTemplate,
        columns: {
          ...baseTemplate.columns,
          parentToggle: { state: 'disabled' },
          childA: { state: 'disabled' },
          childB: { state: 'disabled' }
        }
      }
    })
    result.handleTogglePermission({ level: 'parentChild', key: 'columns.parentToggle', value: true })

    const call = setPendingChangesSpy.mock.calls[0][0]
    expect(call.permissions.columns?.parentToggle).toBe(true)
    // Children should be cascaded to true
    expect(call.permissions.columns?.childA).toBe(true)
    expect(call.permissions.columns?.childB).toBe(true)
  })
})
===ENDFILE

===FILE: src/hooks/admin/ad-group-actions-helpers.ts
/**
 * AD Group Actions Helpers
 * Pure functions for copy result notification and types shared by action hooks.
 */

import type { AdGroup } from '../../types/features/ad-group-config'
import type { CopyResult } from '../../types/features/admin.types'
import { adminService } from '../../services/api/admin.service'

export interface BulkCopyExecutionOptions {
  copyRoleAndPermissionsFlag: boolean
  copyBusinessInfoFlag: boolean
  copyApplicationsFlag: boolean
  copyWorkflowModeCode: 'SUBMIT_FOR_APPROVAL' | 'DIRECT_SAVE'
  functionMismatchPolicyCode: 'FAIL_ON_MISMATCH' | 'SKIP_UNAVAILABLE'
}

export interface CopyResultCounts {
  successCount: number
  failCount: number
  approvalSubmissionCount: number
  criticalCount: number
}

function pluralSuffix(count: number): string {
  return count === 1 ? '' : 's'
}

function buildSuccessDescription(counts: CopyResultCounts): string {
  const base = `Copied settings to ${counts.successCount} group${pluralSuffix(counts.successCount)}.`
  const submitted = counts.approvalSubmissionCount > 0 ? ` ${counts.approvalSubmissionCount} submitted for approval.` : ''
  const critical = counts.criticalCount > 0 ? ` ${counts.criticalCount} need L2 after L1 approval.` : ''
  return `${base}${submitted}${critical}`
}

/** Builds a notification payload for copy operation results. */
export function buildCopyNotification(counts: CopyResultCounts): {
  type: 'success' | 'warning' | 'error'
  title: string
  description: string
  metaKey?: string
} {
  const { successCount, failCount } = counts
  const allFailed = successCount === 0

  if (allFailed) {
    return { type: 'error', title: 'Copy failed', description: 'No group configurations were updated.', metaKey: 'ad-group-copy-error' }
  }
  if (failCount > 0) {
    return { type: 'warning', title: 'Partial copy complete', description: `Success for ${successCount} group${pluralSuffix(successCount)}; ${failCount} failed.` }
  }
  return { type: 'success', title: 'Configuration copied', description: buildSuccessDescription(counts) }
}

/** Copies configuration from source to target AD group via the admin service. */
export async function copyToTarget(
  sourceIdentifier: string,
  targetIdentifier: string,
  executionOptions: BulkCopyExecutionOptions
): Promise<CopyResult> {
  try {
    return await adminService.copyAdGroupConfiguration(sourceIdentifier, targetIdentifier, {
      copyRoleAndPermissionsFlag: executionOptions.copyRoleAndPermissionsFlag,
      copyBusinessInfoFlag: executionOptions.copyBusinessInfoFlag,
      copyApplicationsFlag: executionOptions.copyApplicationsFlag,
      overwriteExistingFlag: true,
      copyWorkflowModeCode: executionOptions.copyWorkflowModeCode,
      functionMismatchPolicyCode: executionOptions.functionMismatchPolicyCode
    })
  } catch {
    return {
      success: false,
      message: 'Copy request failed',
      error: 'COPY_FAILED'
    }
  }
}

/** Resolves target groups from IDs, checking the cache first then the lookup function. */
export function resolveTargetGroups(
  targetGroupIds: string[],
  selectedDetailsRef: React.RefObject<Map<string, AdGroup>>,
  getGroupById: (id: string) => AdGroup | undefined
): AdGroup[] {
  return targetGroupIds
    .map(id => selectedDetailsRef.current?.get(id) || getGroupById(id))
    .filter((group): group is AdGroup => !!group)
}

/** Tallies copy results across multiple targets into aggregate counts. */
export function tallyCopyResults(results: CopyResult[]): CopyResultCounts {
  const successes = results.filter(r => r.success)
  return {
    successCount: successes.length,
    failCount: results.length - successes.length,
    approvalSubmissionCount: successes.filter(r => r.workflowStatusCode === 'SUBMITTED_FOR_APPROVAL').length,
    criticalCount: successes.filter(r => r.criticalIndicator).length
  }
}
===ENDFILE

===FILE: src/hooks/admin/ad-group-form-helpers.ts
/**
 * AD Group Form Helpers
 * Pure functions for transforming role templates and building permission overrides.
 */

import type {
  AdGroup,
  PermissionOverrides,
  PermissionState,
  RoleTemplate
} from '../../types/features/ad-group-config'
import type { RoleTemplateDto } from '../../services/api/role-template.service'

/**
 * Converts a SAPI permission section (with stateText strings) to the
 * frontend PermissionState map. Normalizes 'Enabled'/'enabled' to 'enabled'.
 */
export function toPermissionStateMap(
  section: Record<string, { stateText: string } | undefined> | undefined
): Record<string, PermissionState> {
  if (!section) {
    return {}
  }

  return Object.fromEntries(
    Object.entries(section).map(([key, value]) => {
      const normalizedState = value?.stateText?.toLowerCase() === 'enabled' ? 'enabled' : 'disabled'
      return [key, { state: normalizedState }]
    })
  )
}

/** Transforms a PAPI RoleTemplateDto into the frontend RoleTemplate shape used by the permission grid. */
export function transformApiTemplate(dto: RoleTemplateDto): RoleTemplate {
  return {
    roleName: dto.roleNameCode,
    roleDisplayName: dto.roleDisplayName,
    columns: toPermissionStateMap(dto.columns),
    widgets: toPermissionStateMap(dto.widgets),
    features: toPermissionStateMap(dto.features),
    settings_tabs: toPermissionStateMap(dto.settingsTabs),
    settings_options: toPermissionStateMap(dto.settingsOptions),
    micro_frontends: toPermissionStateMap(dto.microFrontends)
  }
}

/** Maps assignment key names (e.g., 'columnAssignments') to permission level names (e.g., 'columns'). */
export function mapAssignmentKeyToLevel(key: string): string {
  const mapping: Record<string, string> = {
    columnAssignments: 'columns',
    widgetAssignments: 'widgets',
    featureAssignments: 'features',
    settingsTabAssignments: 'settings_tabs',
    settingsOptionAssignments: 'settings_options',
    microFrontendAssignments: 'micro_frontends'
  }
  return mapping[key] || key
}

const ASSIGNMENT_LEVELS = [
  'columnAssignments',
  'widgetAssignments',
  'featureAssignments',
  'settingsTabAssignments',
  'settingsOptionAssignments',
  'microFrontendAssignments'
] as const

/**
 * Reconstructs PermissionOverrides from saved AD group assignment maps.
 * Iterates all assignment levels (columns, widgets, features, etc.) and
 * converts each 'enabled'/'disabled' state into a boolean override map.
 */
function convertAssignmentBlock(assignments: Record<string, PermissionState>): Record<string, boolean> {
  return Object.fromEntries(
    Object.entries(assignments).map(([key, assignment]) => [key, assignment.state === 'enabled'])
  )
}

export function buildOverridesFromAssignments(savedData: AdGroup): PermissionOverrides {
  const overrides: PermissionOverrides = {}
  for (const level of ASSIGNMENT_LEVELS) {
    const assignmentBlock = savedData[level] as Record<string, PermissionState> | undefined
    if (!assignmentBlock) continue
    overrides[mapAssignmentKeyToLevel(level)] = convertAssignmentBlock(assignmentBlock)
  }
  return overrides
}
===ENDFILE

===FILE: src/hooks/admin/ad-groups-data-helpers.ts
/**
 * AD Groups Data Helpers - Pure transform functions and query builders
 * for the AD groups data layer.
 */

import type { AdGroup } from '../../types/features/ad-group-config'
import {
  toAssignments,
  mapGroupIdentity,
  mapGroupMetadata
} from './ad-groups-data-mappers'

// Re-export mappers for consumers
export { toAssignments, resolveUserCount, mapGroupIdentity, mapGroupMetadata } from './ad-groups-data-mappers'

// Re-export query builder for backward compatibility
export { buildQueryString } from './ad-groups-query-builder'

/** Parameters for paginated AD group queries with optional filter criteria. */
export interface FetchParams {
  page: number
  size: number
  search?: string
  role?: string
  status?: string
  market?: string
  region?: string
  country?: string
  businessUnit?: string
}

/** Transforms a raw PAPI group record into a typed AdGroup by combining identity, metadata, and permission assignments. */
export const transformGroup = (group: Record<string, unknown>, fallbackIndex: number): AdGroup => {
  const currentConfig = group.currentConfig as Record<string, unknown> | undefined
  const permissionChanges = currentConfig?.permissionChanges as Record<string, unknown> | undefined

  return {
    ...mapGroupIdentity(group, fallbackIndex),
    ...mapGroupMetadata(group),
    columnAssignments: toAssignments(
      permissionChanges?.columnPermissions as Record<string, unknown> | undefined
    ),
    widgetAssignments: toAssignments(
      permissionChanges?.widgetPermissions as Record<string, unknown> | undefined
    )
  }
}

/**
 * Parses the paginated PAPI response, transforming each item into an AdGroup
 * and extracting pagination metadata (totalCount, limitNumber).
 */
export function parseAdGroupsResponse(payload: {
  data?: {
    items?: Record<string, unknown>[]
    totalCount?: number
    limitNumber?: number
  }
}): { groups: AdGroup[]; total: number; pageSize: number } {
  const responseData = payload.data
  if (!responseData || !Array.isArray(responseData.items)) {
    throw new Error('Unexpected AD groups response format')
  }

  const groups = responseData.items.map((group, index) => transformGroup(group, index))
  return {
    groups,
    total: responseData.totalCount ?? groups.length,
    pageSize: responseData.limitNumber ?? 25
  }
}
===ENDFILE

===FILE: src/hooks/admin/ad-groups-data-mappers.ts
/**
 * AD Groups Data Mappers - Field extraction helpers for PAPI AD group records.
 */

import type { UserAccessLevel } from '../../types/features/ad-group-config'

/**
 * Converts a PAPI permission map (with enabledIndicator booleans) to the
 * frontend PermissionState format ('enabled'/'disabled' strings).
 */
export const toAssignments = (
  permissions: Record<string, unknown> | undefined
): Record<string, { state: 'enabled' | 'disabled' }> | undefined => {
  if (!permissions) return undefined

  return Object.fromEntries(
    Object.entries(permissions).map(([key, value]) => {
      const enabled = Boolean((value as { enabledIndicator?: boolean })?.enabledIndicator)
      return [key, { state: enabled ? 'enabled' : 'disabled' as const }]
    })
  )
}

/** Safely parses a user count from string or number, returning undefined for invalid values. */
export const resolveUserCount = (raw: number | string | undefined): number | undefined => {
  const parsed = typeof raw === 'string' ? Number.parseInt(raw, 10) : raw
  if (typeof parsed === 'number' && !Number.isNaN(parsed)) return parsed
  return undefined
}

/** Extracts identity fields (id, groupIdentifier, logicalName, etc.) from a raw PAPI group record. */
export const mapGroupIdentity = (group: Record<string, unknown>, fallbackIndex: number) => ({
  id: (group.groupIdentifier as string) || String(fallbackIndex + 1),
  groupIdentifier: (group.groupIdentifier as string) || 'Unknown',
  logicalName: (group.logicalName as string | null) || undefined,
  roleName: (group.roleName as string | null) || undefined,
  market: (group.marketCode as string | null) || undefined,
  region: (group.regionCode as string | null) || undefined,
  businessUnit: (group.businessUnitName as string | null) || undefined,
  country: (group.countryCode as string | null) || undefined,
})

/** Extracts metadata fields (isActive, accessLevel, userCount, etc.) from a raw PAPI group record. */
export const mapGroupMetadata = (group: Record<string, unknown>) => ({
  isActive: (group.activeIndicator as boolean | undefined) ?? true,
  accessLevel: (group.userAccessCode as UserAccessLevel | undefined),
  pendingChangeIndicator: (group.pendingChangeIndicator as boolean | undefined) ?? false,
  versionNumber: (group.versionNumber as number | undefined),
  userCount: resolveUserCount(group.userCountNumber as number | string | undefined),
  permissionCount: (group.permissionCount as number | undefined) || undefined,
  overrideCount: (group.overrideCount as number | undefined) || 0,
  lastModified: (group.updatedAtDatetime as string | undefined) || undefined,
})
===ENDFILE

===FILE: src/hooks/admin/ad-groups-data-scroll.ts
/**
 * AD Groups Data Scroll - Scroll position preservation utilities
 * for the AD groups table view.
 */

import { useRef } from 'react'

interface ScrollPosition {
  source: 'container' | 'window'
  value: number
}

/**
 * Provides scroll position save/restore for the AD groups table container.
 * Handles both container-level and window-level scroll positions.
 */
export function useScrollPreservation() {
  const tableContainerRef = useRef<HTMLDivElement | null>(null)
  const lastScrollPosition = useRef<ScrollPosition>({
    source: 'window',
    value: 0
  })

  const saveScrollPosition = () => {
    const container = tableContainerRef.current
    const isContainerScrollable = container && container.scrollHeight > container.clientHeight + 1

    if (isContainerScrollable && container) {
      lastScrollPosition.current = { source: 'container', value: container.scrollTop }
      return
    }
    if (globalThis.window !== undefined) {
      lastScrollPosition.current = { source: 'window', value: globalThis.scrollY ?? 0 }
    }
  }

  const restoreContainerScroll = (value: number) => {
    if (!tableContainerRef.current) return
    setTimeout(() => { if (tableContainerRef.current) tableContainerRef.current.scrollTop = value }, 0)
  }

  const restoreWindowScroll = (value: number) => {
    if (globalThis.window === undefined) return
    requestAnimationFrame(() => { globalThis.scrollTo({ top: value, behavior: 'auto' }) })
  }

  const restoreScrollPosition = () => {
    const { source, value } = lastScrollPosition.current
    if (value <= 0) return
    if (source === 'container') { restoreContainerScroll(value); return }
    restoreWindowScroll(value)
  }

  return {
    tableContainerRef,
    saveScrollPosition,
    restoreScrollPosition
  }
}
===ENDFILE

===FILE: src/hooks/admin/ad-groups-query-builder.ts
/**
 * AD Groups Query Builder
 * URL query string construction for AD groups API calls.
 * Extracted from ad-groups-data-helpers.ts to reduce per-file complexity.
 */

import type { FetchParams } from './ad-groups-data-helpers'

/** Checks whether a filter value is active (non-empty and not 'all'). */
export function isActiveFilter(value: string | undefined): value is string {
  return !!value && value !== 'all'
}

/** Maps frontend filter field names to their corresponding PAPI query parameter names. */
const FILTER_PARAM_MAPPINGS: Array<[keyof FetchParams, string]> = [
  ['role', 'roleText'],
  ['status', 'statusCode'],
  ['market', 'marketText'],
  ['region', 'regionText'],
  ['country', 'countryText'],
  ['businessUnit', 'businessUnitText']
]

/** Builds a URL query string from fetch params, mapping frontend filter names to PAPI parameter names. */
export function buildQueryString(params: FetchParams): string {
  const query = new URLSearchParams()
  query.set('offset', String((params.page - 1) * params.size))
  query.set('limit', String(params.size))

  if (params.search) query.set('search', params.search)

  for (const [paramKey, apiKey] of FILTER_PARAM_MAPPINGS) {
    const value = params[paramKey]
    if (typeof value === 'string' && isActiveFilter(value)) {
      query.set(apiKey, value)
    }
  }

  return query.toString()
}
===ENDFILE

===FILE: src/hooks/admin/ad-groups-selection-helpers.ts
/**
 * AD Groups Selection Helpers
 * Pure functions for managing selection cache and group deduplication.
 */

import type { AdGroup } from '../../types/features/ad-group-config'

export function cacheGroup(
  cacheRef: React.RefObject<Map<string, AdGroup>>,
  group: AdGroup | undefined
) {
  if (!group) return
  const cache = new Map(cacheRef.current)
  cache.set(group.id, group)
  cacheRef.current = cache
}

export function removeGroupFromCache(
  cacheRef: React.RefObject<Map<string, AdGroup>>,
  groupId: string
) {
  const cache = new Map(cacheRef.current)
  cache.delete(groupId)
  cacheRef.current = cache
}

export function buildCombinedGroupsList(
  allAdGroups: AdGroup[],
  currentGroups: AdGroup[],
  selectedDetailsRef: React.RefObject<Map<string, AdGroup>>
): AdGroup[] {
  const combined = new Map<string, AdGroup>()
  allAdGroups.forEach(group => {
    if (group?.id) {
      combined.set(group.id, group)
    }
  })
  currentGroups.forEach(group => combined.set(group.id, group))
  selectedDetailsRef.current?.forEach((group, id) => combined.set(id, group))
  return Array.from(combined.values())
}

export function addGroupsToCache(
  cacheRef: React.RefObject<Map<string, AdGroup>>,
  groups: AdGroup[]
) {
  const cache = new Map(cacheRef.current)
  groups.forEach(group => {
    if (group?.id) {
      cache.set(group.id, group)
    }
  })
  cacheRef.current = cache
}

export function removeGroupsFromCache(
  cacheRef: React.RefObject<Map<string, AdGroup>>,
  groupIds: string[]
) {
  const cache = new Map(cacheRef.current)
  groupIds.forEach(id => cache.delete(id))
  cacheRef.current = cache
}
===ENDFILE

===FILE: src/hooks/admin/app-assignment-actions.ts
/**
 * App Assignment Actions - Save, stage, and refresh operations for embedded app assignment.
 */

import type { EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'
import type { StagedAppChange } from '../../types/features/ad-group-config'
import { computeStagedChanges, updateAvailableApps, updateSelectedApp } from './app-assignment-helpers'

/** Stages an app change locally for batch submission. */
export function stageAppChange(
  appKey: string,
  appTitle: string,
  functions: string[],
  availableApps: EmbeddedAppWithStatus[],
  setStagedAppChanges: React.Dispatch<React.SetStateAction<StagedAppChange[]>>,
  setAvailableApps: React.Dispatch<React.SetStateAction<EmbeddedAppWithStatus[]>>,
  setSelectedApp: React.Dispatch<React.SetStateAction<EmbeddedAppWithStatus | null>>
): void {
  const currentApp = availableApps.find(a => a.appIdentifier === appKey)
  const previousFunctions = currentApp?.assignedFunctionKeys ?? []

  setStagedAppChanges(prev => computeStagedChanges(prev, appKey, appTitle, previousFunctions, functions))
  setAvailableApps(prev => updateAvailableApps(prev, appKey, functions))
  setSelectedApp(prev => updateSelectedApp(prev, appKey, functions))
}

/** Refreshes app data from the API and updates the selected app if present. */
export async function refreshAndUpdateSelected(
  selectedAppIdentifier: string | undefined,
  groupIdentifier: string,
  loadEmbeddedAppsData: (groupId: string) => Promise<EmbeddedAppWithStatus[]>,
  setAvailableApps: React.Dispatch<React.SetStateAction<EmbeddedAppWithStatus[]>>,
  setSelectedApp: React.Dispatch<React.SetStateAction<EmbeddedAppWithStatus | null>>
): Promise<void> {
  try {
    const apps = await loadEmbeddedAppsData(groupIdentifier)
    setAvailableApps(apps)
    const updatedApp = selectedAppIdentifier
      ? apps.find(app => app.appIdentifier === selectedAppIdentifier) ?? null
      : null
    if (updatedApp) setSelectedApp(updatedApp)
  } catch {
    // Reload failure handled silently
  }
}
===ENDFILE

===FILE: src/hooks/admin/app-assignment-helpers.ts
/**
 * Application Assignment Helpers
 * Pure functions for app assignment staging and comparison.
 */

import type { EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'
import type { StagedAppChange } from '../../types/features/ad-group-config'

export function hasFunctionSetChanged(previousFunctions: string[], newFunctions: string[]): boolean {
  const prevSet = new Set(previousFunctions)
  const newSet = new Set(newFunctions)
  if (prevSet.size !== newSet.size) return true
  return [...prevSet].some(f => !newSet.has(f)) || [...newSet].some(f => !prevSet.has(f))
}

export function computeStagedChanges(
  prev: StagedAppChange[],
  appKey: string,
  appTitle: string,
  previousFunctions: string[],
  newFunctions: string[]
): StagedAppChange[] {
  const existing = prev.filter(c => c.appKey !== appKey)
  if (!hasFunctionSetChanged(previousFunctions, newFunctions)) return existing
  return [...existing, { appKey, appTitle, previousFunctions, newFunctions }]
}

export function updateAvailableApps(
  apps: EmbeddedAppWithStatus[],
  appKey: string,
  functions: string[]
): EmbeddedAppWithStatus[] {
  return apps.map(app => {
    if (app.appIdentifier !== appKey) return app
    return { ...app, isAssignedIndicator: functions.length > 0, assignedFunctionKeys: functions }
  })
}

export function updateSelectedApp(
  selectedApp: EmbeddedAppWithStatus | null,
  appKey: string,
  functions: string[]
): EmbeddedAppWithStatus | null {
  if (selectedApp?.appIdentifier !== appKey) return selectedApp
  return {
    ...selectedApp,
    isAssignedIndicator: functions.length > 0,
    assignedFunctionKeys: functions
  }
}

export function filterAppsBySearch(
  apps: EmbeddedAppWithStatus[],
  searchTerm: string
): EmbeddedAppWithStatus[] {
  return apps.filter(app =>
    !searchTerm ||
    app.titleText.toLowerCase().includes(searchTerm.toLowerCase()) ||
    app.descriptionText.toLowerCase().includes(searchTerm.toLowerCase()) ||
    app.categoryName.toLowerCase().includes(searchTerm.toLowerCase())
  )
}
===ENDFILE

===FILE: src/hooks/admin/config-save-app-payload.ts
/**
 * Config Save App Payload - Functions for building app/function change payloads
 */

import type { StagedAppChange } from '../../types/features/ad-group-config'

/** Classifies an app change based on whether it had functions before/after (added, removed, or unchanged). */
function classifyAppChange(prevSize: number, newSize: number): 'added' | 'removed' | 'unchanged' {
  if (prevSize === 0 && newSize > 0) return 'added'
  if (prevSize > 0 && newSize === 0) return 'removed'
  return 'unchanged'
}

function makeEntry(appKey: string, fn: string) {
  return { appIdentifier: appKey, functionIdentifier: fn }
}

/** Computes per-function added/removed/unchanged arrays for a single app's staged change. */
function collectFunctionChanges(
  change: StagedAppChange,
  prevSet: Set<string>,
  newSet: Set<string>
) {
  const newInPrev = change.newFunctions.filter(fn => prevSet.has(fn))
  const newNotInPrev = change.newFunctions.filter(fn => !prevSet.has(fn))
  const prevNotInNew = change.previousFunctions.filter(fn => !newSet.has(fn))

  return {
    added: newNotInPrev.map(fn => makeEntry(change.appKey, fn)),
    removed: prevNotInNew.map(fn => makeEntry(change.appKey, fn)),
    unchanged: newInPrev.map(fn => makeEntry(change.appKey, fn)),
    changedKeys: [...newNotInPrev, ...prevNotInNew].map(fn => `${change.appKey}:${fn}`)
  }
}

/**
 * Aggregates all staged app changes into a structured payload with separate
 * application-level and function-level diff arrays for the PAPI save request.
 */
export function buildAppChangePayload(stagedAppChanges: StagedAppChange[]) {
  const addedApps: string[] = []
  const removedApps: string[] = []
  const unchangedApps: string[] = []
  const addedFunctions: Array<{ appIdentifier: string; functionIdentifier: string }> = []
  const removedFunctions: Array<{ appIdentifier: string; functionIdentifier: string }> = []
  const unchangedFunctions: Array<{ appIdentifier: string; functionIdentifier: string }> = []
  const changedApps: string[] = []
  const changedFunctionKeys: string[] = []

  for (const change of stagedAppChanges) {
    const prevSet = new Set(change.previousFunctions)
    const newSet = new Set(change.newFunctions)
    changedApps.push(change.appKey)

    const appBucket = { added: addedApps, removed: removedApps, unchanged: unchangedApps }
    appBucket[classifyAppChange(prevSet.size, newSet.size)].push(change.appKey)

    const fns = collectFunctionChanges(change, prevSet, newSet)
    addedFunctions.push(...fns.added)
    removedFunctions.push(...fns.removed)
    unchangedFunctions.push(...fns.unchanged)
    changedFunctionKeys.push(...fns.changedKeys)
  }

  return {
    applicationChanges: { added: addedApps, removed: removedApps, unchanged: unchangedApps },
    appFunctionChanges: { added: addedFunctions, removed: removedFunctions, unchanged: unchangedFunctions },
    changedApps,
    changedFunctions: changedFunctionKeys
  }
}
===ENDFILE

===FILE: src/hooks/admin/config-save-helpers.ts
/**
 * Config Save Helpers - Composes save/submit payloads from split modules
 */

import type { AdGroup, PermissionOverrides, PendingChanges, StagedAppChange } from '../../types/features/ad-group-config'
import { convertOverridesToAssignments } from '../../components/admin/ad-group-config/utils/permission-helpers'
import type { ChangeType } from '../../types/features/approval-workflow.types'
import { buildAppChangePayload } from './config-save-app-payload'
import {
  mergeOverrides,
  buildCurrentState,
  computeBusinessInfoChanges,
  computePermissionChanges,
  hasEntries
} from './config-save-state-builders'

// Re-export for consumers
export { buildAppChangePayload } from './config-save-app-payload'
export { mergeOverrides, buildCurrentState, computeBusinessInfoChanges, computePermissionChanges, hasEntries } from './config-save-state-builders'

/**
 * Builds the complete save/submit payload from form data, permission overrides, and staged app changes.
 * Computes business info diffs, permission diffs, and app/function change arrays.
 */
function applyConditionalEntries(proposedState: Record<string, unknown>, entries: Record<string, Record<string, unknown>>): void {
  for (const [key, value] of Object.entries(entries)) {
    if (hasEntries(value)) proposedState[key] = value
  }
}

function buildAppProposedArrays(appPayload: ReturnType<typeof buildAppChangePayload>): {
  applicationChanges: Array<Record<string, unknown>>
  appFunctionChanges: Array<Record<string, unknown>>
} {
  const { applicationChanges: ac, appFunctionChanges: fc } = appPayload
  return {
    applicationChanges: [
      ...ac.added.map(app => ({ appCode: app, proposedStateIndicator: true, currentStateIndicator: false })),
      ...ac.removed.map(app => ({ appCode: app, proposedStateIndicator: false, currentStateIndicator: true })),
      ...ac.unchanged.map(app => ({ appCode: app, proposedStateIndicator: true, currentStateIndicator: true }))
    ],
    appFunctionChanges: [
      ...fc.added.map(fn => ({ appCode: fn.appIdentifier, functionCode: fn.functionIdentifier, enabledIndicator: true })),
      ...fc.removed.map(fn => ({ appCode: fn.appIdentifier, functionCode: fn.functionIdentifier, enabledIndicator: false })),
      ...fc.unchanged.map(fn => ({ appCode: fn.appIdentifier, functionCode: fn.functionIdentifier, enabledIndicator: true }))
    ]
  }
}

function resolveChangeType(hasAppChanges: boolean, hasConfigChanges: boolean): ChangeType {
  return hasAppChanges && !hasConfigChanges ? 'APP_UPDATE' : 'CONFIG_UPDATE'
}

export function buildSavePayload(
  group: AdGroup,
  formData: AdGroup,
  permissionOverrides: PermissionOverrides,
  pendingChanges: PendingChanges,
  stagedAppChanges: StagedAppChange[]
) {
  const mergedOverrides = mergeOverrides(permissionOverrides, pendingChanges)
  const assignments = convertOverridesToAssignments(mergedOverrides)
  const { id: _id, lastModified: _lastModified, ...formDataWithoutMetadata } = formData
  const proposedState: Record<string, unknown> = { ...formDataWithoutMetadata, ...assignments }

  const currentState = buildCurrentState(group)
  const businessInfoChanges = computeBusinessInfoChanges(group, formData)
  const permissionChanges = computePermissionChanges(mergedOverrides)

  applyConditionalEntries(proposedState, { businessInfoChanges, permissionChanges })

  let appPayload: ReturnType<typeof buildAppChangePayload> | null = null
  if (stagedAppChanges.length > 0) {
    appPayload = buildAppChangePayload(stagedAppChanges)
    Object.assign(proposedState, buildAppProposedArrays(appPayload))
  }

  const changedFields = [...Object.keys(businessInfoChanges), ...Object.keys(permissionChanges)]
  const changeType = resolveChangeType(stagedAppChanges.length > 0, hasEntries(businessInfoChanges) || hasEntries(permissionChanges))

  return { mergedOverrides, currentState, proposedState, changeType, changedFields, appPayload }
}
===ENDFILE

===FILE: src/hooks/admin/config-save-notifications.ts
/**
 * Config Save Notifications
 * Pure functions for building save/submit notification payloads.
 */

export interface SaveNotification {
  type: 'success' | 'error'
  title: string
  description: string
}

/** Builds a success notification based on whether the save was direct or approval-based. */
export function buildSaveSuccessNotification(
  groupName: string,
  isDirectSave: boolean
): SaveNotification {
  if (isDirectSave) {
    return {
      type: 'success',
      title: 'Changes Applied',
      description: `Configuration changes have been applied immediately to ${groupName}.`
    }
  }
  return {
    type: 'success',
    title: 'Submitted for Approval',
    description: `Your changes to ${groupName} have been submitted and are awaiting review.`
  }
}

/** Builds an error notification based on whether the save was direct or approval-based. */
export function buildSaveErrorNotification(isDirectSave: boolean): SaveNotification {
  if (isDirectSave) {
    return {
      type: 'error',
      title: 'Save failed',
      description: 'We could not apply the configuration changes. Please review and try again.'
    }
  }
  return {
    type: 'error',
    title: 'Submission Failed',
    description: 'We could not submit the configuration changes for approval. Please try again.'
  }
}

/** Resolves the display name for a group, falling back through multiple fields. */
export function resolveGroupDisplayName(
  formData: { logicalName?: string },
  group: { logicalName?: string; groupIdentifier: string }
): string {
  return formData.logicalName || group.logicalName || group.groupIdentifier
}
===ENDFILE

===FILE: src/hooks/admin/config-save-state-builders.ts
/**
 * Config Save State Builders - Pure functions for computing current/proposed state diffs
 */

import type { AdGroup, PermissionOverrides, PendingChanges } from '../../types/features/ad-group-config'

/**
 * Combines explicit permission overrides with pending (unsaved) changes into a single override map.
 * Pending changes take precedence over existing overrides for the same permission key.
 */
export function mergeOverrides(permissionOverrides: PermissionOverrides, pendingChanges: PendingChanges): PermissionOverrides {
  const merged = { ...permissionOverrides }
  if (!pendingChanges.permissions) return merged
  for (const [level, changes] of Object.entries(pendingChanges.permissions)) {
    merged[level] = { ...merged[level], ...changes }
  }
  return merged
}

/** Extracts the current business info fields from an AdGroup to serve as the diff baseline. */
const BUSINESS_FIELDS = ['logicalName', 'roleName', 'region', 'country', 'market', 'businessUnit'] as const

export function buildCurrentState(group: AdGroup): Record<string, unknown> {
  return Object.fromEntries(
    BUSINESS_FIELDS.filter(field => group[field]).map(field => [field, group[field]])
  )
}

/** Computes the delta between original and edited business info fields, returning only changed values. */
export function computeBusinessInfoChanges(group: AdGroup, formData: AdGroup): Record<string, unknown> {
  return Object.fromEntries(
    BUSINESS_FIELDS
      .filter(field => {
        const proposed = formData[field as keyof AdGroup]
        return proposed !== undefined && proposed !== group[field as keyof AdGroup]
      })
      .map(field => [field, formData[field as keyof AdGroup]])
  )
}

/** Extracts non-empty permission levels from merged overrides to include in the save payload. */
export function computePermissionChanges(mergedOverrides: PermissionOverrides): Record<string, unknown> {
  return Object.fromEntries(
    Object.entries(mergedOverrides).filter(([, changes]) => changes && Object.keys(changes).length > 0)
  )
}

/** Returns true if the object has at least one key, used to skip empty change sections in payloads. */
export function hasEntries(obj: Record<string, unknown>): boolean {
  return Object.keys(obj).length > 0
}
===ENDFILE

===FILE: src/hooks/admin/function-selection-helpers.ts
/**
 * Function Selection Helpers
 * Pure functions for computing initial function selection state and change detection.
 */

function defaultKeyAsArray(defaultKey: string | undefined): string[] {
  return defaultKey ? [defaultKey] : []
}

/** Computes the initial set of selected functions from an app's assignment data. */
export function computeInitialSelection(
  isAssigned: boolean,
  assignedKeys: string[],
  defaultKey: string | undefined
): string[] {
  if (!isAssigned || assignedKeys.length === 0) return defaultKeyAsArray(defaultKey)
  return ensureDefaultIncluded(assignedKeys, defaultKey)
}

/** Ensures the default function key is always included in the selection set. */
export function ensureDefaultIncluded(functions: string[], defaultKey: string | undefined): string[] {
  const unique = Array.from(new Set(functions))
  if (defaultKey && !unique.includes(defaultKey)) {
    unique.push(defaultKey)
  }
  return Array.from(new Set(unique))
}

/** Detects whether the function selection has changed from the original assignment. */
export function hasSelectionChanged(
  selectedFunctions: string[],
  assignedFunctionKeys: string[],
  currentDefault: string | undefined,
  originalDefault: string | undefined
): boolean {
  const stringCompare = (a: string, b: string) => a.localeCompare(b)
  const functionsChanged = JSON.stringify([...selectedFunctions].sort(stringCompare)) !==
                           JSON.stringify([...assignedFunctionKeys].sort(stringCompare))
  const defaultChanged = currentDefault !== originalDefault
  return functionsChanged || defaultChanged
}
===ENDFILE

===FILE: src/hooks/admin/permission-aggregator-helpers.ts
/**
 * Permission Aggregator Helpers
 * Re-exports from split modules for backward compatibility.
 * Consumers can import from this file as before.
 */

// Re-export cache builders
export {
  buildEnabledPermissionsCache,
  buildAllPermissionsCache
} from './permission-cache-builders'

// Re-export filter and count functions
export {
  buildFilteredPermissionsCache,
  getPermissionCountForLevel
} from './permission-filter-and-count'
===ENDFILE

===FILE: src/hooks/admin/permission-aggregator-key-builders.ts
/**
 * Permission Aggregator Key Builders - Functions for building permission key lists from role templates.
 */

import type { RoleTemplate } from '../../types/features/ad-group-config'
import { getTemplateSection } from '../../components/admin/ad-group-config/utils/permission-helpers'
import {
  businessRelevantToggles,
  isToggleBusinessRelevant
} from '../../components/admin/business-relevant-toggles'

export function getRelevantKeysForSection(roleTemplate: RoleTemplate, level: string, section: string): string[] {
  const sectionData = getTemplateSection(roleTemplate, section)
  return Object.keys(sectionData)
    .filter(key => isToggleBusinessRelevant(level, `${section}.${key}`))
    .map(key => `${section}.${key}`)
}

export function getCompoundKeys(roleTemplate: RoleTemplate, level: string, sections: string[]): string[] {
  return sections.flatMap(section => getRelevantKeysForSection(roleTemplate, level, section))
}

export function getDirectKeys(roleTemplate: RoleTemplate, level: string): string[] {
  const templateLevel = getTemplateSection(roleTemplate, level)
  return Object.keys(templateLevel).filter(key => isToggleBusinessRelevant(level, key))
}

export function isParentEnabled(
  level: string, prefixedKey: string,
  isPermissionEnabled: (args: { level: string; key: string }) => boolean
): boolean {
  const parentKey = businessRelevantToggles[level]?.toggles[prefixedKey]?.parent
  return parentKey ? isPermissionEnabled({ level, key: parentKey }) : true
}
===ENDFILE

===FILE: src/hooks/admin/permission-cache-builders.ts
/**
 * Permission Cache Builders
 * Functions for building permission caches used by usePermissionAggregators.
 * Extracted from permission-aggregator-helpers.ts to reduce per-file complexity.
 */

import type { RoleTemplate } from '../../types/features/ad-group-config'
import { permissionLevels } from '../../constants/permission-levels'
import { COMPOUND_LEVELS } from '../../utils/admin/permission-level-resolver'
import { sortWithHierarchy } from '../../utils/admin/permission-hierarchy-sorter'
import {
  getCompoundKeys,
  getDirectKeys,
  isParentEnabled
} from './permission-aggregator-key-builders'

/**
 * Builds a cache of enabled permission keys per level, filtering by the
 * isPermissionEnabled predicate and checking parent enablement for compound keys.
 */
export function buildEnabledPermissionsCache(
  roleTemplate: RoleTemplate,
  isPermissionEnabled: (args: { level: string; key: string }) => boolean
): Record<string, string[]> {
  const cache: Record<string, string[]> = {}

  for (const level of Object.keys(permissionLevels)) {
    const sections = COMPOUND_LEVELS[level]
    if (sections) {
      cache[level] = getCompoundKeys(roleTemplate, level, sections)
        .filter(key => isPermissionEnabled({ level, key }) && isParentEnabled(level, key, isPermissionEnabled))
    } else {
      cache[level] = getDirectKeys(roleTemplate, level)
        .filter(key => isPermissionEnabled({ level, key }))
    }
  }

  return cache
}

/**
 * Builds a cache of all permission keys per level (regardless of enabled state),
 * applying hierarchy sorting to compound levels.
 */
export function buildAllPermissionsCache(roleTemplate: RoleTemplate): Record<string, string[]> {
  const cache: Record<string, string[]> = {}

  for (const level of Object.keys(permissionLevels)) {
    const sections = COMPOUND_LEVELS[level]
    cache[level] = sections
      ? sortWithHierarchy({ keys: getCompoundKeys(roleTemplate, level, sections), levelKey: level })
      : getDirectKeys(roleTemplate, level)
  }

  return cache
}
===ENDFILE

===FILE: src/hooks/admin/permission-filter-and-count.ts
/**
 * Permission Filter and Count
 * Functions for filtering permission caches by search term and counting
 * enabled permissions per level.
 * Extracted from permission-aggregator-helpers.ts to reduce per-file complexity.
 */

import type { RoleTemplate } from '../../types/features/ad-group-config'
import { permissionLevels } from '../../constants/permission-levels'
import { getTemplateSection } from '../../components/admin/ad-group-config/utils/permission-helpers'
import { businessRelevantToggles, isToggleBusinessRelevant } from '../../components/admin/business-relevant-toggles'
import { COMPOUND_LEVELS } from '../../utils/admin/permission-level-resolver'

/**
 * Filters a pre-built permissions cache by a search term, matching against
 * business names, descriptions, and raw key names.
 */
export function buildFilteredPermissionsCache(
  allPermissionsCache: Record<string, string[]>,
  searchTerm: string
): Record<string, string[]> {
  const cache: Record<string, string[]> = {}

  Object.keys(permissionLevels).forEach(level => {
    const allPermissions = allPermissionsCache[level] || []
    if (!searchTerm) {
      cache[level] = allPermissions
      return
    }

    cache[level] = allPermissions.filter(key => {
      const businessConfig = businessRelevantToggles[level]?.toggles[key]
      const businessName = businessConfig?.businessName || key
      const description = businessConfig?.description || ''

      const searchLower = searchTerm.toLowerCase()
      return businessName.toLowerCase().includes(searchLower) ||
             description.toLowerCase().includes(searchLower) ||
             key.toLowerCase().includes(searchLower)
    })
  })

  return cache
}

/**
 * Counts the number of enabled, business-relevant permissions for a specific level.
 * Handles both compound levels (capabilities, workspacePreferences) and direct levels.
 */
export function getPermissionCountForLevel(
  roleTemplate: RoleTemplate,
  level: string
): number {
  const templateSections = COMPOUND_LEVELS[level]
  if (templateSections) {
    return templateSections.reduce((total, section) => {
      const sectionData = getTemplateSection(roleTemplate, section)
      return total + Object.keys(sectionData).filter(key =>
        isToggleBusinessRelevant(level, `${section}.${key}`) && sectionData[key]?.state === 'enabled'
      ).length
    }, 0)
  }

  const templateLevel = getTemplateSection(roleTemplate, level)
  return Object.keys(templateLevel).filter(key =>
    isToggleBusinessRelevant(level, key) && templateLevel[key]?.state === 'enabled'
  ).length
}
===ENDFILE

===FILE: src/hooks/admin/permission-toggle-helpers.ts
/**
 * Permission Toggle Helpers - Pure functions for parent/child cascading and auto-enable/disable logic
 */

import type { RoleTemplate, PermissionOverrides, PendingChanges } from '../../types/features/ad-group-config'
import { businessRelevantToggles } from '../../components/admin/business-relevant-toggles'
import { getTemplateSection } from '../../components/admin/ad-group-config/utils/permission-helpers'
import { resolvePermissionLevel } from '../../utils/admin/permission-level-resolver'

export function getAllChildren({ parentKey, displayLevel }: { parentKey: string; displayLevel: string }): string[] {
  const config = businessRelevantToggles[displayLevel]
  if (!config) return []

  return Object.keys(config.toggles).filter(key =>
    config.toggles[key].parent === parentKey
  )
}

export function isToggleEnabled({
  level,
  key,
  pendingChanges,
  permissionOverrides,
  roleTemplate
}: {
  level: string
  key: string
  pendingChanges: PendingChanges
  permissionOverrides: PermissionOverrides
  roleTemplate: RoleTemplate | null
}): boolean {
  if (pendingChanges.permissions?.[level]?.[key] !== undefined) {
    return pendingChanges.permissions[level][key]
  }

  if (permissionOverrides[level]?.[key] !== undefined) {
    return permissionOverrides[level][key]
  }

  const templateLevel = getTemplateSection(roleTemplate, level)
  return templateLevel[key]?.state === 'enabled'
}

export function ensureLevelExists(permissions: Record<string, Record<string, boolean>>, level: string) {
  permissions[level] ??= {}
}

export function applyPendingValue(
  pendingChanges: PendingChanges,
  actualLevel: string,
  actualKey: string,
  value: boolean,
  permissionOverrides: PermissionOverrides
) {
  const savedValue = permissionOverrides[actualLevel]?.[actualKey]
  if (savedValue !== undefined && savedValue === value) {
    delete pendingChanges.permissions[actualLevel][actualKey]
    if (Object.keys(pendingChanges.permissions[actualLevel]).length === 0) {
      delete pendingChanges.permissions[actualLevel]
    }
    return
  }
  pendingChanges.permissions[actualLevel][actualKey] = value
}

export function cascadeToChildren(
  pendingPermissions: Record<string, Record<string, boolean>>,
  displayKey: string,
  displayLevel: string,
  value: boolean
) {
  const children = getAllChildren({ parentKey: displayKey, displayLevel })
  for (const childKey of children) {
    const { actualLevel, actualKey } = resolvePermissionLevel({ level: displayLevel, key: childKey })
    ensureLevelExists(pendingPermissions, actualLevel)
    pendingPermissions[actualLevel][actualKey] = value
  }
}

export function autoEnableParent(
  pendingPermissions: Record<string, Record<string, boolean>>,
  parentKey: string,
  level: string,
  pendingChanges: PendingChanges,
  permissionOverrides: PermissionOverrides,
  roleTemplate: RoleTemplate | null
) {
  const { actualLevel, actualKey } = resolvePermissionLevel({ level, key: parentKey })
  const parentEnabled = isToggleEnabled({
    level: actualLevel, key: actualKey, pendingChanges, permissionOverrides, roleTemplate
  })
  if (parentEnabled) return
  ensureLevelExists(pendingPermissions, actualLevel)
  pendingPermissions[actualLevel][actualKey] = true
}

function isSiblingEnabled(
  childKey: string,
  level: string,
  current: { actualLevel: string; actualKey: string },
  pendingPermissions: Record<string, Record<string, boolean>>,
  context: { pendingChanges: PendingChanges; permissionOverrides: PermissionOverrides; roleTemplate: RoleTemplate | null }
): boolean {
  const { actualLevel: resolvedLevel, actualKey: resolvedKey } = resolvePermissionLevel({ level, key: childKey })
  if (resolvedLevel === current.actualLevel && resolvedKey === current.actualKey) return false
  const pendingValue = pendingPermissions[resolvedLevel]?.[resolvedKey]
  if (pendingValue !== undefined) return pendingValue
  return isToggleEnabled({ level: resolvedLevel, key: resolvedKey, ...context })
}

export function autoDisableParent(
  pendingPermissions: Record<string, Record<string, boolean>>,
  parentKey: string,
  level: string,
  current: { actualLevel: string; actualKey: string },
  context: { pendingChanges: PendingChanges; permissionOverrides: PermissionOverrides; roleTemplate: RoleTemplate | null }
) {
  const allChildren = getAllChildren({ parentKey, displayLevel: level })
  const hasEnabledSibling = allChildren.some(childKey =>
    isSiblingEnabled(childKey, level, current, pendingPermissions, context)
  )
  if (hasEnabledSibling) return

  const { actualLevel, actualKey } = resolvePermissionLevel({ level, key: parentKey })
  ensureLevelExists(pendingPermissions, actualLevel)
  pendingPermissions[actualLevel][actualKey] = false
}
===ENDFILE

===FILE: src/hooks/admin/use-ad-group-actions.ts
/**
 * AD Group Actions - Copy and toggle operations for AD groups
 */

import { useCallback, useState } from 'react'
import { useNotifications } from '../features/use-notifications'
import { adminService } from '../../services/api/admin.service'
import type { AdGroup } from '../../types/features/ad-group-config'
import {
  type BulkCopyExecutionOptions,
  buildCopyNotification,
  copyToTarget,
  resolveTargetGroups,
  tallyCopyResults
} from './ad-group-actions-helpers'

export type { BulkCopyExecutionOptions } from './ad-group-actions-helpers'

interface UseAdGroupActionsParams {
  getGroupById: (id: string) => AdGroup | undefined
  selectedDetailsRef: React.RefObject<Map<string, AdGroup>>
  onRefresh: () => Promise<void>
  handleDeselectAll: () => void
  saveScrollPosition: () => void
  restoreScrollPosition: () => void
}

/**
 * Provides bulk copy and toggle-active operations for AD groups.
 * Handles sequential copy execution with success/failure counting and user notifications.
 */
export function useAdGroupActions({
  getGroupById,
  selectedDetailsRef,
  onRefresh,
  handleDeselectAll,
  saveScrollPosition,
  restoreScrollPosition
}: UseAdGroupActionsParams) {
  const notifications = useNotifications()
  const [toggleConfirmOpen, setToggleConfirmOpen] = useState(false)
  const [groupToToggle, setGroupToToggle] = useState<AdGroup | null>(null)

  const handleCopyFrom = useCallback(async (
    sourceGroup: AdGroup,
    targetGroupIds: string[],
    executionOptions: BulkCopyExecutionOptions
  ) => {
    const targetGroups = resolveTargetGroups(targetGroupIds, selectedDetailsRef, getGroupById)

    const results = []
    for (const targetGroup of targetGroups) {
      const result = await copyToTarget(
        sourceGroup.groupIdentifier,
        targetGroup.groupIdentifier,
        executionOptions
      )
      results.push(result)
    }

    const counts = tallyCopyResults(results)
    const notification = buildCopyNotification(counts)
    const notifyByType: Record<string, () => void> = {
      success: () => notifications.success({ title: notification.title, description: notification.description }),
      warning: () => notifications.warning({ title: notification.title, description: notification.description }),
      error: () => notifications.error({ title: notification.title, description: notification.description, metaKey: notification.metaKey })
    }
    notifyByType[notification.type]()

    await onRefresh()
    handleDeselectAll()
  }, [selectedDetailsRef, getGroupById, notifications, onRefresh, handleDeselectAll])

  const handleToggleActive = useCallback((group: AdGroup) => {
    setGroupToToggle(group)
    setToggleConfirmOpen(true)
  }, [])

  const confirmToggleActive = useCallback(async () => {
    if (!groupToToggle) return

    saveScrollPosition()

    try {
      const newStatus = !groupToToggle.isActive
      await adminService.updateAdGroup(groupToToggle.groupIdentifier, { isActive: newStatus })

      const groupName = groupToToggle.logicalName || groupToToggle.groupIdentifier
      notifications.success({
        title: newStatus ? 'Group enabled' : 'Group disabled',
        description: `${groupName} was updated successfully.`
      })

      await onRefresh()

      setToggleConfirmOpen(false)
      setGroupToToggle(null)
    } catch {
      notifications.error({
        title: 'Status update failed',
        description: 'We could not update the selected AD group. Please try again.',
        metaKey: 'ad-group-toggle-error'
      })
    } finally {
      restoreScrollPosition()
    }
  }, [groupToToggle, saveScrollPosition, restoreScrollPosition, notifications, onRefresh])

  return {
    handleCopyFrom,
    handleToggleActive,
    confirmToggleActive,
    toggleConfirmOpen,
    setToggleConfirmOpen,
    groupToToggle
  }
}
===ENDFILE

===FILE: src/hooks/admin/use-ad-group-form.ts
import { useState, useEffect, useCallback } from 'react'
import { useAdGroupApi } from '../api/use-ad-group-api'
import { getRoleTemplateByName } from '../../services/api/role-template.service'
import { createLogger } from '../../utils/core/debug'
import type {
  AdGroup,
  PermissionOverrides,
  PendingChanges,
  RoleTemplate
} from '../../types/features/ad-group-config'
import { transformApiTemplate, buildOverridesFromAssignments } from './ad-group-form-helpers'

/** Re-export helpers for backward compatibility */
export { toPermissionStateMap, transformApiTemplate, mapAssignmentKeyToLevel, buildOverridesFromAssignments } from './ad-group-form-helpers'

/** Props for the AD group form hook, providing the initial group data and modal open state. */
interface UseAdGroupFormProps {
  initialGroup: AdGroup
  open: boolean
}

const logger = createLogger('useAdGroupForm')

/**
 * Manages the AD group configuration form state including form data, role template,
 * permission overrides, and pending changes. Fetches saved data when modal opens.
 */
export function useAdGroupForm({ initialGroup, open }: UseAdGroupFormProps) {
  const [formData, setFormData] = useState<AdGroup>({ ...initialGroup })
  const [roleTemplate, setRoleTemplate] = useState<RoleTemplate | null>(null)
  const [isLoadingRoleTemplate, setIsLoadingRoleTemplate] = useState(false)
  const [permissionOverrides, setPermissionOverrides] = useState<PermissionOverrides>({})
  const [pendingChanges, setPendingChanges] = useState<PendingChanges>({ permissions: {} })

  const {
    isLoading: isLoadingAdGroup,
    fetchAdGroupData,
    updateAdGroupConfig,
    applyRoleTemplate: applyRoleTemplateApi
  } = useAdGroupApi()

  const loadRoleTemplate = useCallback(async (roleNameCode: string): Promise<RoleTemplate> => {
    const templateDto = await getRoleTemplateByName(roleNameCode)
    return transformApiTemplate(templateDto)
  }, [])

  useEffect(() => {
    const roleNameCode = formData.roleName

    if (!roleNameCode) {
      setRoleTemplate(null)
      setIsLoadingRoleTemplate(false)
      return undefined
    }

    let active = true

    setIsLoadingRoleTemplate(true)
    loadRoleTemplate(roleNameCode)
      .then(template => { if (active) setRoleTemplate(template) })
      .catch(error => {
        logger.error('Failed to load role template', { roleNameCode, error })
        if (active) setRoleTemplate(null)
      })
      .finally(() => { if (active) setIsLoadingRoleTemplate(false) })

    return () => { active = false }
  }, [formData.roleName, loadRoleTemplate])

  // Fetch saved AD group data when modal opens
  useEffect(() => {
    const loadSavedGroupData = async () => {
      if (!open) return

      const savedData = await fetchAdGroupData(initialGroup.groupIdentifier).catch(() => null)
      if (savedData) {
          setFormData(savedData)

          setPermissionOverrides(buildOverridesFromAssignments(savedData))
        }
    }

    loadSavedGroupData()
  }, [open, initialGroup.groupIdentifier, fetchAdGroupData])

  const updateFormData = (updates: Partial<AdGroup>) => {
    setFormData(prev => ({ ...prev, ...updates }))
  }

  const updatePermissionOverrides = (updates: Partial<PermissionOverrides>) => {
    setPermissionOverrides(prev => {
      const defined = Object.fromEntries(
        Object.entries(updates).filter(([, v]) => v !== undefined)
      )
      return { ...prev, ...defined }
    })
  }

  const handleApplyRoleTemplate = async (roleName: string): Promise<void> => {
    const result = await applyRoleTemplateApi(formData.groupIdentifier, roleName)

    if (result) {
      setFormData(prev => ({ ...prev, roleName }))
      setPermissionOverrides({})
      setPendingChanges({ permissions: {} })
      setRoleTemplate(null)
    }
  }

  return {
    formData,
    roleTemplate,
    isLoadingRoleTemplate,
    permissionOverrides,
    pendingChanges,
    isLoadingAdGroup,
    updateFormData,
    updatePermissionOverrides,
    setPendingChanges,
    handleApplyRoleTemplate,
    updateAdGroupConfig,
  }
}
===ENDFILE

===FILE: src/hooks/admin/use-ad-groups-data.ts
import { useState, useRef, useCallback } from 'react'
import { useNotifications } from '../features/use-notifications'
import type { AdGroup, AdGroupSummaryCounts } from '../../types/features/ad-group-config'
import { apiFetch } from '../../services/core/api-client'
import { parseAdGroupsResponse, buildQueryString } from './ad-groups-data-helpers'
import { useScrollPreservation } from './ad-groups-data-scroll'
import type { FetchParams } from './ad-groups-data-helpers'

// Re-export for consumers
export type { FetchParams } from './ad-groups-data-helpers'
export { toAssignments, resolveUserCount, mapGroupIdentity, mapGroupMetadata, transformGroup, parseAdGroupsResponse, buildQueryString } from './ad-groups-data-helpers'
export { useScrollPreservation } from './ad-groups-data-scroll'

/**
 * Manages paginated AD group data fetching, caching, and scroll position preservation.
 * Provides the core data layer for the AD groups list view.
 */
export function useAdGroupsData() {
  const [adGroups, setAdGroups] = useState<AdGroup[]>([])
  const [loading, setLoading] = useState(true)
  const [totalCount, setTotalCount] = useState(0)
  const [totalPages, setTotalPages] = useState(1)
  const [summary, setSummary] = useState<AdGroupSummaryCounts>({})
  const notifications = useNotifications()

  const groupCacheRef = useRef<Map<string, AdGroup>>(new Map())

  const {
    tableContainerRef,
    saveScrollPosition,
    restoreScrollPosition
  } = useScrollPreservation()

  const fetchAdGroups = useCallback(async (params: FetchParams) => {
    try {
      setLoading(true)
      const queryString = buildQueryString(params)
      const response = await apiFetch(`/papi/v1/ad-groups?${queryString}`, {
        method: 'GET'
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const payload = await response.json() as {
        data?: {
          items?: Record<string, unknown>[]
          totalCount?: number
          limitNumber?: number
        }
      }

      const { groups: transformedGroups, total, pageSize } = parseAdGroupsResponse(payload)

      // Cache most recent representation for each group
      const cache = new Map(groupCacheRef.current)
      transformedGroups.forEach(group => {
        cache.set(group.id, group)
      })
      groupCacheRef.current = cache

      setAdGroups(transformedGroups)
      setTotalCount(total)
      setTotalPages(Math.max(1, Math.ceil(total / pageSize)))
      setSummary({})

      return transformedGroups
    } catch {
      notifications.error({
        title: 'Unable to load AD groups',
        description: 'Please refresh the page or try again later.',
        metaKey: 'ad-groups-fetch-error'
      })
      setAdGroups([])
      setTotalCount(0)
      setTotalPages(1)
      setSummary({})
      return []
    } finally {
      setLoading(false)
    }
  }, [notifications])

  const getGroupById = useCallback((id: string) => groupCacheRef.current.get(id), [])

  return {
    adGroups,
    loading,
    totalCount,
    totalPages,
    summary,
    fetchAdGroups,
    saveScrollPosition,
    restoreScrollPosition,
    tableContainerRef,
    getGroupById
  }
}
===ENDFILE

===FILE: src/hooks/admin/use-ad-groups-loader.ts
import { useEffect, useState, useCallback, useRef } from 'react'
import type { AdGroup } from '../../types/features/ad-group-config'
import { adminService } from '../../services/api/admin.service'
import { useNotifications } from '../features/use-notifications'
import { isConfiguredGroup } from '../../utils/admin/notice-validators'

interface UseAdGroupsLoaderParams {
  open: boolean
  searchTerm: string
  debounceMs?: number
}

/**
 * Loads and filters configured AD groups with debounced search for selection dialogs.
 * Only fetches when the modal is open; cancels in-flight requests on unmount.
 */
export function useAdGroupsLoader({ open, searchTerm, debounceMs = 250 }: UseAdGroupsLoaderParams) {
  const notifications = useNotifications()
  const [adGroups, setAdGroups] = useState<AdGroup[]>([])
  const [isLoadingGroups, setIsLoadingGroups] = useState(false)
  const cancelledRef = useRef(false)
  const notificationsRef = useRef(notifications)
  notificationsRef.current = notifications
  const searchTermRef = useRef(searchTerm)
  searchTermRef.current = searchTerm

  const guardedUpdate = <T>(setter: (val: T) => void, val: T) => {
    if (!cancelledRef.current) setter(val)
  }

  const loadGroups = useCallback(async () => {
    cancelledRef.current = false
    setIsLoadingGroups(true)
    try {
      const groups = await adminService.searchAdGroups(searchTermRef.current, 750)
      guardedUpdate(setAdGroups, groups.filter(group => isConfiguredGroup({ group })))
    } catch (error) {
      if (cancelledRef.current) return
      notificationsRef.current.error({
        title: 'Unable to load AD groups',
        description: error instanceof Error ? error.message : 'Please try again later.'
      })
      guardedUpdate(setAdGroups, [])
    } finally {
      guardedUpdate(setIsLoadingGroups, false)
    }
  }, [])

  useEffect(() => {
    if (!open) return undefined

    const handle = setTimeout(() => { loadGroups() }, debounceMs)

    return () => {
      cancelledRef.current = true
      clearTimeout(handle)
    }
  }, [open, searchTerm, debounceMs, loadGroups])

  return {
    adGroups,
    isLoadingGroups
  }
}
===ENDFILE

===FILE: src/hooks/admin/use-ad-groups-selection.ts
import { useCallback, useEffect, useRef, useState } from 'react'
import { useNotifications } from '../features/use-notifications'
import { adminService } from '../../services/api/admin.service'
import type { AdGroup } from '../../types/features/ad-group-config'
import { useAdGroupActions } from './use-ad-group-actions'
import {
  cacheGroup,
  removeGroupFromCache,
  buildCombinedGroupsList,
  addGroupsToCache,
  removeGroupsFromCache
} from './ad-groups-selection-helpers'

export type { BulkCopyExecutionOptions } from './use-ad-group-actions'

interface UseAdGroupsSelectionProps {
  currentGroups: AdGroup[]
  getGroupById: (id: string) => AdGroup | undefined
  onRefresh: () => Promise<void>
  saveScrollPosition: () => void
  restoreScrollPosition: () => void
}

/**
 * Manages multi-select state for AD groups including select/deselect, bulk operations,
 * and AD group search/lookup. Composes with useAdGroupActions for copy and toggle.
 */
export function useAdGroupsSelection({
  currentGroups,
  getGroupById,
  onRefresh,
  saveScrollPosition,
  restoreScrollPosition
}: UseAdGroupsSelectionProps) {
  const [selectedGroups, setSelectedGroups] = useState<Set<string>>(new Set())
  const [allAdGroups, setAllAdGroups] = useState<AdGroup[]>([])
  const [isLookupLoading, setIsLookupLoading] = useState(false)
  const selectedDetailsRef = useRef<Map<string, AdGroup>>(new Map())
  const notifications = useNotifications()

  const fetchLookup = useCallback(async (query: string) => {
    setIsLookupLoading(true)
    try {
      const groups = await adminService.searchAdGroups(query || undefined, 750)
      const configuredGroups = groups.filter(group => group?.groupIdentifier)

      addGroupsToCache(selectedDetailsRef, configuredGroups)

      setAllAdGroups(configuredGroups)

      return configuredGroups
    } catch (error) {
      notifications.error({
        title: 'Unable to load AD groups',
        description: error instanceof Error ? error.message : 'Please refresh the page or try again later.',
        metaKey: 'ad-group-search-error'
      })
      return []
    } finally {
      setIsLookupLoading(false)
    }
  }, [notifications])

  useEffect(() => {
    let mounted = true

    const loadInitialData = async () => {
      if (mounted) {
        await fetchLookup('')
      }
    }

    loadInitialData()

    return () => {
      mounted = false
    }
  }, [fetchLookup])

  const handleSelectGroup = (groupId: string) => {
    setSelectedGroups(prev => {
      const updated = new Set(prev)
      if (updated.has(groupId)) {
        updated.delete(groupId)
        removeGroupFromCache(selectedDetailsRef, groupId)
      } else {
        updated.add(groupId)
        const group = getGroupById(groupId) || currentGroups.find(g => g.id === groupId)
        cacheGroup(selectedDetailsRef, group)
      }
      return updated
    })
  }

  const handleSelectAll = () => {
    if (currentGroups.length === 0) {
      return
    }
    addGroupsToCache(selectedDetailsRef, currentGroups)
    setSelectedGroups(prev => {
      const updated = new Set(prev)
      currentGroups.forEach(group => updated.add(group.id))
      return updated
    })
  }

  const handleDeselectAll = useCallback(() => {
    setSelectedGroups(new Set())
    selectedDetailsRef.current = new Map()
  }, [])

  const handleSelectGroups = (groups: AdGroup[]) => {
    if (!groups || groups.length === 0) return
    addGroupsToCache(selectedDetailsRef, groups)
    setSelectedGroups(prev => {
      const updated = new Set(prev)
      groups.forEach(group => updated.add(group.id))
      return updated
    })
  }

  const handleDeselectGroups = (groupIds: string[]) => {
    if (groupIds.length === 0) return
    removeGroupsFromCache(selectedDetailsRef, groupIds)
    setSelectedGroups(prev => {
      const updated = new Set(prev)
      groupIds.forEach(id => updated.delete(id))
      return updated
    })
  }

  const {
    handleCopyFrom,
    handleToggleActive: handleToggleActiveBase,
    confirmToggleActive,
    toggleConfirmOpen,
    setToggleConfirmOpen,
    groupToToggle
  } = useAdGroupActions({
    getGroupById,
    selectedDetailsRef,
    onRefresh,
    handleDeselectAll,
    saveScrollPosition,
    restoreScrollPosition
  })

  const handleToggleActive = (group: AdGroup) => {
    cacheGroup(selectedDetailsRef, group)
    handleToggleActiveBase(group)
  }

  const availableGroupsForSelection = buildCombinedGroupsList(
    allAdGroups,
    currentGroups,
    selectedDetailsRef
  )

  return {
    selectedGroups,
    handleSelectGroup,
    handleSelectAll,
    handleDeselectAll,
    handleSelectGroups,
    handleDeselectGroups,
    handleCopyFrom,
    handleToggleActive,
    confirmToggleActive,
    toggleConfirmOpen,
    setToggleConfirmOpen,
    groupToToggle,
    availableGroupsForSelection,
    searchAdGroups: fetchLookup,
    isLookupLoading
  }
}
===ENDFILE

===FILE: src/hooks/admin/use-application-assignment.ts
import { useState, useEffect, useCallback, useRef } from 'react'
import { useEmbeddedAppsApi } from '../api/use-embedded-apps-api'
import { useNotifications } from '../features/use-notifications'
import type { EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'
import type { StagedAppChange } from '../../types/features/ad-group-config'
import { filterAppsBySearch } from './app-assignment-helpers'
import { stageAppChange, refreshAndUpdateSelected } from './app-assignment-actions'

// Re-export helpers for consumers
export { hasFunctionSetChanged, filterAppsBySearch } from './app-assignment-helpers'

interface UseApplicationAssignmentProps {
  groupIdentifier: string
  groupDisplayName: string
  open: boolean
  activeTab: string
  canDirectSave?: boolean
}

/**
 * Manages embedded application assignment for an AD group, including loading available apps,
 * staging function changes for approval workflow, and direct-saving when permitted.
 */
export function useApplicationAssignment({
  groupIdentifier,
  groupDisplayName,
  open,
  activeTab,
  canDirectSave = true
}: UseApplicationAssignmentProps) {
  const notifications = useNotifications()
  const [availableApps, setAvailableApps] = useState<EmbeddedAppWithStatus[]>([])
  const [selectedApp, setSelectedApp] = useState<EmbeddedAppWithStatus | null>(null)
  const [appSearchTerm, setAppSearchTerm] = useState('')
  const [stagedAppChanges, setStagedAppChanges] = useState<StagedAppChange[]>([])
  const loadedForGroupRef = useRef<string | null>(null)
  const [unsavedFunctionSelection, setUnsavedFunctionSelection] = useState<{
    appKey: string
    appTitle: string
    functions: string[]
    defaultFunction?: string
  } | null>(null)

  const {
    isLoadingApps,
    isSavingAppAssignment,
    loadEmbeddedAppsData,
    saveAppAssignment: saveAppAssignmentApi
  } = useEmbeddedAppsApi()

  const handleLoadEmbeddedAppsData = useCallback(async () => {
    try {
      const apps = await loadEmbeddedAppsData(groupIdentifier)
      setAvailableApps(apps)
    } catch {
      // Load failure handled silently
    }
  }, [loadEmbeddedAppsData, groupIdentifier])

  useEffect(() => {
    if (!open) { loadedForGroupRef.current = null; return undefined }
    if (activeTab !== 'applications') return undefined
    if (loadedForGroupRef.current === groupIdentifier) return undefined

    loadedForGroupRef.current = groupIdentifier
    let ignore = false
    loadEmbeddedAppsData(groupIdentifier).then(apps => { if (!ignore) setAvailableApps(apps) }).catch(() => { /* handled silently */ })
    return () => { ignore = true }
  }, [open, activeTab, groupIdentifier, loadEmbeddedAppsData])

  const handleStageAppChange = (appKey: string, appTitle: string, functions: string[]) => {
    stageAppChange(appKey, appTitle, functions, availableApps, setStagedAppChanges, setAvailableApps, setSelectedApp)
    notifications.success({
      title: 'App Changes Staged',
      description: `Changes to ${appTitle} will be included when you submit for approval.`
    })
  }

  const handleSaveAppAssignment = async (
    appKey: string,
    appTitle: string,
    functions: string[],
    defaultFunction?: string
  ): Promise<void> => {
    if (canDirectSave) {
      await saveAppAssignmentApi(appKey, appTitle, groupIdentifier, groupDisplayName, functions, defaultFunction)
      await refreshAndUpdateSelected(selectedApp?.appIdentifier, groupIdentifier, loadEmbeddedAppsData, setAvailableApps, setSelectedApp)
      return
    }
    handleStageAppChange(appKey, appTitle, functions)
  }

  const handleAppSelect = (app: EmbeddedAppWithStatus) => {
    setSelectedApp(app)
  }

  const handleAppCancel = () => {
    setSelectedApp(null)
  }

  const clearStagedAppChanges = useCallback(() => {
    setStagedAppChanges([])
  }, [])

  const handleFunctionSelectionChange = useCallback((
    appKey: string,
    appTitle: string,
    functions: string[],
    defaultFunction?: string
  ) => {
    // Empty functions array means the selection was saved/reset (no pending changes)
    if (functions.length === 0 && !defaultFunction) {
      setUnsavedFunctionSelection(null)
      return
    }
    setUnsavedFunctionSelection({ appKey, appTitle, functions, defaultFunction })
  }, [])

  const flushUnsavedFunctions = async () => {
    if (!unsavedFunctionSelection) return
    const { appKey, appTitle, functions, defaultFunction } = unsavedFunctionSelection
    if (canDirectSave) {
      await saveAppAssignmentApi(appKey, appTitle, groupIdentifier, groupDisplayName, functions, defaultFunction)
    } else {
      handleStageAppChange(appKey, appTitle, functions)
    }
    setUnsavedFunctionSelection(null)
  }

  const filteredApps = filterAppsBySearch(availableApps, appSearchTerm)

  return {
    availableApps,
    selectedApp,
    appSearchTerm,
    filteredApps,
    isLoadingApps,
    isSavingAppAssignment,
    stagedAppChanges,
    unsavedFunctionSelection,
    setAppSearchTerm,
    handleAppSelect,
    handleAppCancel,
    handleSaveAppAssignment,
    handleFunctionSelectionChange,
    flushUnsavedFunctions,
    handleLoadEmbeddedAppsData,
    clearStagedAppChanges
  }
}
===ENDFILE

===FILE: src/hooks/admin/use-config-save.ts
import { useState } from 'react'
import type { AdGroup, PermissionOverrides, PendingChanges, StagedAppChange } from '../../types/features/ad-group-config'
import { useNotifications } from '../features/use-notifications'
import { adminApprovalService } from '../../services/api/admin-approval.service'
import { buildSavePayload } from './config-save-helpers'
import {
  buildSaveSuccessNotification,
  buildSaveErrorNotification,
  resolveGroupDisplayName
} from './config-save-notifications'

interface UseConfigSaveParams {
  formData: AdGroup
  group: AdGroup
  permissionOverrides: PermissionOverrides
  pendingChanges: PendingChanges
  stagedAppChanges?: StagedAppChange[]
  canDirectSave?: boolean  // Super Admin can bypass approval workflow
  updateAdGroupConfig: (
    groupIdentifier: string,
    data: Partial<AdGroup>,
    options?: { suppressSuccessToast?: boolean }
  ) => Promise<AdGroup | null>
  updatePermissionOverrides: (overrides: PermissionOverrides) => void
  setPendingChanges: (changes: PendingChanges) => void
  clearStagedAppChanges?: () => void
  flushUnsavedFunctions?: () => Promise<void>
  onSave: (group: AdGroup) => void
  onClose: () => void
}

/**
 * Manages the save/submit workflow for AD group configuration changes.
 * Supports both direct save (Super Admin) and submit-for-approval (Maker) paths.
 */
export function useConfigSave({
  formData,
  group,
  permissionOverrides,
  pendingChanges,
  stagedAppChanges = [],
  canDirectSave = false,
  updateAdGroupConfig: _updateAdGroupConfig,
  updatePermissionOverrides,
  setPendingChanges,
  clearStagedAppChanges,
  flushUnsavedFunctions,
  onSave: _onSave,
  onClose
}: UseConfigSaveParams) {
  const notifications = useNotifications()
  const [showSaveDialog, setShowSaveDialog] = useState(false)
  const [isDirectSave, setIsDirectSave] = useState(false)

  const handleSaveClick = () => {
    setIsDirectSave(false)
    setShowSaveDialog(true)
  }

  const handleDirectSaveClick = () => {
    setIsDirectSave(true)
    setShowSaveDialog(true)
  }

  const executeSave = async () => {
    await flushUnsavedFunctions?.()

    const { mergedOverrides, currentState, proposedState, changeType, changedFields, appPayload } =
      buildSavePayload(group, formData, permissionOverrides, pendingChanges, stagedAppChanges)

    const useDirectSave = isDirectSave && canDirectSave
    if (useDirectSave) {
      await adminApprovalService.directSave(group.groupIdentifier, {
        currentState, proposedState,
        changedApps: appPayload?.changedApps, changedFunctions: appPayload?.changedFunctions
      })
    } else {
      await adminApprovalService.submitChange(group.groupIdentifier, {
        changeType, currentState, proposedState,
        changedFields: changedFields.length > 0 ? changedFields : undefined,
        changedApps: appPayload?.changedApps, changedFunctions: appPayload?.changedFunctions
      })
    }

    updatePermissionOverrides(mergedOverrides)
    setPendingChanges({ permissions: {} })
    clearStagedAppChanges?.()
    return useDirectSave
  }

  const handleConfirmSave = async () => {
    setShowSaveDialog(false)

    try {
      const wasDirectSave = await executeSave()
      const groupName = resolveGroupDisplayName(formData, group)
      notifications.success(buildSaveSuccessNotification(groupName, wasDirectSave))
      onClose()
    } catch {
      notifications.error(buildSaveErrorNotification(isDirectSave))
    }
  }

  return {
    showSaveDialog,
    setShowSaveDialog,
    handleSaveClick,
    handleDirectSaveClick,
    handleConfirmSave,
    isDirectSave
  }
}
===ENDFILE

===FILE: src/hooks/admin/use-function-selection.ts
import { useState, useEffect } from 'react'
import { EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'
import {
  computeInitialSelection,
  ensureDefaultIncluded,
  hasSelectionChanged
} from './function-selection-helpers'

interface UseFunctionSelectionParams {
  app: EmbeddedAppWithStatus
}

/**
 * Manages function selection state for an embedded app, ensuring the default function
 * is always included and providing toggle, select-all, clear, and reset operations.
 */
export function useFunctionSelection({ app }: UseFunctionSelectionParams) {
  const [selectedFunctions, setSelectedFunctions] = useState<string[]>([])
  const [defaultFunction, setDefaultFunction] = useState<string | undefined>(
    app.defaultFunctionKey
  )

  useEffect(() => {
    const assigned = app.assignedFunctionKeys || []
    const defaultKey = app.defaultFunctionKey
    setSelectedFunctions(computeInitialSelection(app.isAssignedIndicator, assigned, defaultKey))
    setDefaultFunction(defaultKey)
  }, [app.assignedFunctionKeys, app.defaultFunctionKey, app.isAssignedIndicator])

  const applySelection = (functions: string[]) => {
    setSelectedFunctions(ensureDefaultIncluded(functions, app.defaultFunctionKey))
  }

  const hasChanges = () => {
    return hasSelectionChanged(
      selectedFunctions,
      app.assignedFunctionKeys || [],
      defaultFunction,
      app.defaultFunctionKey
    )
  }

  const handleFunctionToggle = ({ functionKey, checked }: { functionKey: string; checked: boolean }) => {
    if (!checked && app.defaultFunctionKey === functionKey) return

    const updated = checked
      ? [...selectedFunctions, functionKey]
      : selectedFunctions.filter(f => f !== functionKey)
    applySelection(updated)
  }

  const handleSelectAllFiltered = ({ filteredFunctions }: { filteredFunctions: string[] }) => {
    const defaultKey = app.defaultFunctionKey
    const filteredKeys = filteredFunctions.filter(fk => {
      return fk !== defaultKey
    })
    applySelection([...selectedFunctions, ...filteredKeys])
  }

  const handleClearSelection = () => {
    const defaultKey = app.defaultFunctionKey
    setSelectedFunctions(defaultKey ? [defaultKey] : [])
  }

  const handleReset = () => {
    const assigned = app.assignedFunctionKeys || []
    const defaultKey = app.defaultFunctionKey
    setSelectedFunctions(computeInitialSelection(app.isAssignedIndicator, assigned, defaultKey))
    setDefaultFunction(defaultKey)
  }

  return {
    selectedFunctions,
    defaultFunction,
    setDefaultFunction,
    hasChanges,
    handleFunctionToggle,
    handleSelectAllFiltered,
    handleClearSelection,
    handleReset
  }
}
===ENDFILE

===FILE: src/hooks/admin/use-notice-form.ts
import { useEffect, useMemo, useState } from 'react'
import type { AdminNoticeRequest, AdminNoticeResponse } from '../../services/api/admin.service'
import { startOfDay } from 'date-fns'
import { isEndDateValid as validateEndDate } from '../../utils/admin/notice-validators'

interface UseNoticeFormParams {
  open: boolean
  editNotice?: AdminNoticeResponse | null
}

const DEFAULT_FORM_DATA: Partial<AdminNoticeRequest> = {
  title: '',
  message: '',
  severity: 'INFO',
  broadcastToAll: true,
  targetRoles: [],
  targetAdGroups: [],
  requiresAcknowledgement: false
}

/**
 * Manages form state for the notice create/edit dialog, including role and AD group targeting,
 * schedule date validation, and form reset on open/close.
 */
export function useNoticeForm({ open, editNotice }: UseNoticeFormParams) {
  const [formData, setFormData] = useState<Partial<AdminNoticeRequest>>(DEFAULT_FORM_DATA)

  useEffect(() => {
    if (!open) return
    if (!editNotice) { setFormData(DEFAULT_FORM_DATA); return }
    setFormData({
      title: editNotice.title,
      message: editNotice.message,
      severity: editNotice.severity,
      broadcastToAll: editNotice.broadcastToAll,
      targetRoles: editNotice.targetRoles || [],
      targetAdGroups: editNotice.targetAdGroups || [],
      requiresAcknowledgement: editNotice.requiresAcknowledgement,
      startAt: editNotice.startAt || undefined,
      endAt: editNotice.endAt || undefined
    })
  }, [open, editNotice])

  const minScheduleDate = useMemo(() => startOfDay(new Date()), [])
  const parsedStartDate = useMemo(() => (formData.startAt ? new Date(formData.startAt) : undefined), [formData.startAt])

  const isEndDateValid = useMemo(() => {
    return validateEndDate({ startAt: formData.startAt, endAt: formData.endAt })
  }, [formData.startAt, formData.endAt])

  const toggleRole = ({ roleValue }: { roleValue: string }) => {
    const currentRoles = formData.targetRoles || []
    const newRoles = currentRoles.includes(roleValue)
      ? currentRoles.filter(r => r !== roleValue)
      : [...currentRoles, roleValue]
    setFormData({ ...formData, targetRoles: newRoles })
  }

  const isRoleSelected = ({ roleValue }: { roleValue: string }) => {
    return (formData.targetRoles || []).includes(roleValue)
  }

  const toggleAdGroup = ({ groupIdentifier }: { groupIdentifier: string }) => {
    const currentGroups = formData.targetAdGroups || []
    const newGroups = currentGroups.includes(groupIdentifier)
      ? currentGroups.filter(g => g !== groupIdentifier)
      : [...currentGroups, groupIdentifier]
    setFormData({ ...formData, targetAdGroups: newGroups })
  }

  const isAdGroupSelected = ({ groupIdentifier }: { groupIdentifier: string }) => {
    return (formData.targetAdGroups || []).includes(groupIdentifier)
  }

  const resetForm = () => {
    setFormData(DEFAULT_FORM_DATA)
  }

  return {
    formData,
    setFormData,
    minScheduleDate,
    parsedStartDate,
    isEndDateValid,
    toggleRole,
    isRoleSelected,
    toggleAdGroup,
    isAdGroupSelected,
    resetForm
  }
}
===ENDFILE

===FILE: src/hooks/admin/use-notice-save.ts
import { useState } from 'react'
import type { AdminNoticeRequest, AdminNoticeResponse } from '../../services/api/admin.service'
import { adminService } from '../../services/api/admin.service'
import { useNotifications } from '../features/use-notifications'
import { validateNoticeForm } from '../../utils/admin/notice-validators'

const noticeValidationMessages: Record<string, string> = {
  titleMessageRequired: 'Title and message are required'
}

function buildSaveSuccessNotification(isUpdate: boolean, asDraft: boolean): { title: string; description: string } {
  if (isUpdate) {
    return { title: 'Notice updated', description: 'Draft notice has been updated successfully' }
  }
  return {
    title: asDraft ? 'Draft saved' : 'Notice published',
    description: asDraft ? 'Notice saved as draft' : 'Notice is now active and visible to users'
  }
}

interface UseNoticeSaveParams {
  formData: Partial<AdminNoticeRequest>
  editNotice?: AdminNoticeResponse | null
  isEndDateValid: boolean
  onSuccess: () => void
}

/**
 * Handles notice save/update operations with form validation, error handling,
 * and success notifications. Supports both draft and publish workflows.
 */
export function useNoticeSave({ formData, editNotice, isEndDateValid, onSuccess }: UseNoticeSaveParams) {
  const notifications = useNotifications()
  const [isSaving, setIsSaving] = useState(false)

  const validateBeforeSave = (): boolean => {
    const validation = validateNoticeForm({ title: formData.title, message: formData.message })
    if (!validation.valid) {
      notifications.error({
        title: 'Validation failed',
        description: noticeValidationMessages[validation.error ?? ''] ?? 'Validation error'
      })
      return false
    }
    if (!isEndDateValid) {
      notifications.error({
        title: 'Invalid date range',
        description: 'End date and time must be after start date and time'
      })
      return false
    }
    return true
  }

  const persistNotice = async (requestData: AdminNoticeRequest): Promise<void> => {
    if (editNotice) {
      await adminService.updateNotice(editNotice.id, requestData)
    } else {
      await adminService.createNotice(requestData)
    }
  }

  const getErrorMessage = (error: unknown): string => {
    return error instanceof Error ? error.message : 'An error occurred'
  }

  const handleSave = async ({ asDraft }: { asDraft: boolean }) => {
    if (!validateBeforeSave()) return

    setIsSaving(true)
    try {
      const requestData = { ...formData, status: asDraft ? 'DRAFT' : 'ACTIVE' } as AdminNoticeRequest
      await persistNotice(requestData)
      notifications.success(buildSaveSuccessNotification(!!editNotice, asDraft))
      onSuccess()
    } catch (error) {
      const failTitle = editNotice ? 'Failed to update notice' : 'Failed to save notice'
      notifications.error({ title: failTitle, description: getErrorMessage(error) })
    } finally {
      setIsSaving(false)
    }
  }

  return {
    isSaving,
    handleSave
  }
}
===ENDFILE

===FILE: src/hooks/admin/use-pending-changes.ts
/**
 * React Query hooks for pending changes approval workflow
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { adminApprovalService } from '../../services/api/admin-approval.service'
import type {
  PendingChangeFilters,
  SubmitChangeRequest,
  DirectSaveRequest,
  ApproveChangeRequest,
  RejectChangeRequest,
  ActivityTimeRange
} from '../../types/features/approval-workflow.types'

export const PENDING_CHANGES_QUERY_KEY = 'pendingChanges'
export const PENDING_CHANGES_COUNT_KEY = 'pendingChangesCount'
export const MY_ACTIVITY_QUERY_KEY = 'myActivity'

/**
 * Hook to fetch list of pending changes
 */
export function usePendingChanges(filters?: PendingChangeFilters) {
  return useQuery({
    queryKey: [PENDING_CHANGES_QUERY_KEY, filters],
    queryFn: () => adminApprovalService.listPendingChanges(filters),
    staleTime: 30 * 1000, // 30 seconds
    refetchOnWindowFocus: true
  })
}

/**
 * Hook to fetch a single pending change by ID
 */
export function usePendingChange(changeId: string | null) {
  return useQuery({
    queryKey: [PENDING_CHANGES_QUERY_KEY, changeId],
    queryFn: () => adminApprovalService.getPendingChange(changeId!),
    enabled: !!changeId,
    staleTime: 30 * 1000
  })
}

/**
 * Hook to fetch pending changes count for sidebar badge
 */
export function usePendingChangesCount(enabled: boolean = true) {
  return useQuery({
    queryKey: [PENDING_CHANGES_COUNT_KEY],
    queryFn: () => adminApprovalService.getPendingChangesCount(),
    enabled,
    staleTime: 60 * 1000, // 1 minute
    refetchInterval: 60 * 1000 // Poll every minute
  })
}

/**
 * Hook to submit a configuration change for review
 */
export function useSubmitChange() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({
      groupId,
      request
    }: {
      groupId: string
      request: SubmitChangeRequest
    }) => adminApprovalService.submitChange(groupId, request),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
      queryClient.invalidateQueries({ queryKey: ['adminAdGroups'] })
    }
  })
}

/**
 * Hook to direct save configuration (Super Admin only)
 */
export function useDirectSave() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({
      groupId,
      request
    }: {
      groupId: string
      request: DirectSaveRequest
    }) => adminApprovalService.directSave(groupId, request),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['adminAdGroups'] })
    }
  })
}

/**
 * Hook to approve a pending change
 */
export function useApproveChange() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({
      changeId,
      request
    }: {
      changeId: string
      request?: ApproveChangeRequest
    }) => adminApprovalService.approveChange(changeId, request),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
      queryClient.invalidateQueries({ queryKey: ['adminAdGroups'] })
    }
  })
}

/**
 * Hook to reject a pending change
 */
export function useRejectChange() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({
      changeId,
      request
    }: {
      changeId: string
      request: RejectChangeRequest
    }) => adminApprovalService.rejectChange(changeId, request),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
    }
  })
}

/**
 * Hook to fetch current user's activity history (approvals, rejections, submissions, etc.)
 */
export function useMyActivity(page: number = 1, timeRange: ActivityTimeRange = 'all', enabled: boolean = true) {
  return useQuery({
    queryKey: [MY_ACTIVITY_QUERY_KEY, page, timeRange],
    queryFn: () => adminApprovalService.getMyActivity(page, 25, timeRange === 'all' ? undefined : timeRange),
    enabled,
    staleTime: 30 * 1000
  })
}

/**
 * Hook to cancel a pending change (submitter only)
 */
export function useCancelChange() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (changeId: string) => adminApprovalService.cancelChange(changeId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
    }
  })
}
===ENDFILE

===FILE: src/hooks/admin/use-permission-aggregators.ts
import React from 'react'
import type { RoleTemplate } from '../../types/features/ad-group-config'
import {
  buildEnabledPermissionsCache,
  buildAllPermissionsCache,
  buildFilteredPermissionsCache,
  getPermissionCountForLevel
} from './permission-aggregator-helpers'

// Re-export for consumers
export {
  buildEnabledPermissionsCache,
  buildAllPermissionsCache,
  buildFilteredPermissionsCache,
  getPermissionCountForLevel
} from './permission-aggregator-helpers'

interface UsePermissionAggregatorsParams {
  roleTemplate: RoleTemplate | null
  searchTerm: string
  isPermissionEnabled: ({ level, key }: { level: string; key: string }) => boolean
}

/**
 * Provides memoized permission aggregation: counts, enabled lists, all permissions,
 * and filtered permissions by search term. Handles compound permission levels.
 */
export function usePermissionAggregators({
  roleTemplate,
  searchTerm,
  isPermissionEnabled
}: UsePermissionAggregatorsParams) {
  const getPermissionCount = React.useCallback(({ level }: { level: string }) => {
    if (!roleTemplate) return 0
    return getPermissionCountForLevel(roleTemplate, level)
  }, [roleTemplate])

  const enabledPermissionsCache = React.useMemo(() => {
    if (!roleTemplate) return {}
    return buildEnabledPermissionsCache(roleTemplate, isPermissionEnabled)
  }, [roleTemplate, isPermissionEnabled])

  const getEnabledPermissions = React.useCallback(({ level }: { level: string }) => {
    return enabledPermissionsCache[level] || []
  }, [enabledPermissionsCache])

  const allPermissionsCache = React.useMemo(() => {
    if (!roleTemplate) return {}
    return buildAllPermissionsCache(roleTemplate)
  }, [roleTemplate])

  const getAllPermissions = React.useCallback(({ level }: { level: string }) => {
    return allPermissionsCache[level] || []
  }, [allPermissionsCache])

  const filteredPermissionsCache = React.useMemo(() => {
    return buildFilteredPermissionsCache(allPermissionsCache, searchTerm)
  }, [searchTerm, allPermissionsCache])

  const getFilteredPermissions = React.useCallback(({ level }: { level: string }) => {
    return filteredPermissionsCache[level] || []
  }, [filteredPermissionsCache])

  return {
    getPermissionCount,
    getEnabledPermissions,
    getAllPermissions,
    getFilteredPermissions
  }
}
===ENDFILE

===FILE: src/hooks/admin/use-permission-state.ts
import React from 'react'
import type {
  RoleTemplate,
  PermissionOverrides,
  PendingChanges
} from '../../types/features/ad-group-config'
import { getTemplateSection } from '../../components/admin/ad-group-config/utils/permission-helpers'
import { resolvePermissionLevel, COMPOUND_LEVELS } from '../../utils/admin/permission-level-resolver'

interface UsePermissionStateParams {
  roleTemplate: RoleTemplate | null
  permissionOverrides: PermissionOverrides
  pendingChanges: PendingChanges
}

function resolveLevel(level: string, key: string): { resolvedLevel: string; resolvedKey: string } {
  if (!COMPOUND_LEVELS[level]) return { resolvedLevel: level, resolvedKey: key }
  const { actualLevel, actualKey } = resolvePermissionLevel({ level, key })
  return { resolvedLevel: actualLevel, resolvedKey: actualKey }
}

function resolveEffectiveState(
  resolvedLevel: string,
  resolvedKey: string,
  pendingChanges: PendingChanges,
  permissionOverrides: PermissionOverrides,
  roleTemplate: RoleTemplate
): boolean {
  const pendingChange = pendingChanges?.permissions?.[resolvedLevel]?.[resolvedKey]
  if (pendingChange !== undefined) return pendingChange

  const override = permissionOverrides[resolvedLevel]?.[resolvedKey]
  if (override !== undefined) return override

  const templateLevel = getTemplateSection(roleTemplate, resolvedLevel)
  return templateLevel[resolvedKey]?.state === 'enabled'
}

function resolveSavedValue(
  resolvedLevel: string,
  resolvedKey: string,
  permissionOverrides: PermissionOverrides,
  roleTemplate: RoleTemplate
): boolean {
  const templateSection = getTemplateSection(roleTemplate, resolvedLevel)
  const templateValue = templateSection[resolvedKey]?.state === 'enabled'
  const savedOverride = permissionOverrides[resolvedLevel]?.[resolvedKey]
  return savedOverride === undefined ? templateValue : savedOverride
}

/**
 * Resolves the effective state of individual permissions by layering pending changes
 * over saved overrides over the base role template. Handles compound levels.
 */
export function usePermissionState({
  roleTemplate,
  permissionOverrides,
  pendingChanges
}: UsePermissionStateParams) {
  const isPermissionEnabled = React.useCallback(({ level, key }: { level: string; key: string }) => {
    if (!roleTemplate) return false
    const { resolvedLevel, resolvedKey } = resolveLevel(level, key)
    return resolveEffectiveState(resolvedLevel, resolvedKey, pendingChanges, permissionOverrides, roleTemplate)
  }, [roleTemplate, permissionOverrides, pendingChanges])

  const hasUnsavedChanges = React.useCallback(({ level, key }: { level: string; key: string }) => {
    if (!roleTemplate) return false
    const { resolvedLevel, resolvedKey } = resolveLevel(level, key)
    const pendingValue = pendingChanges.permissions?.[resolvedLevel]?.[resolvedKey]
    if (pendingValue === undefined) return false
    return pendingValue !== resolveSavedValue(resolvedLevel, resolvedKey, permissionOverrides, roleTemplate)
  }, [roleTemplate, permissionOverrides, pendingChanges])

  return {
    isPermissionEnabled,
    hasUnsavedChanges
  }
}
===ENDFILE

===FILE: src/hooks/admin/use-permission-toggle.ts
import { useState } from 'react'
import type { RoleTemplate, PermissionOverrides, PendingChanges } from '../../types/features/ad-group-config'
import { businessRelevantToggles } from '../../components/admin/business-relevant-toggles'
import { resolvePermissionLevel, resolveLinkedKey } from '../../utils/admin/permission-level-resolver'
import {
  ensureLevelExists,
  applyPendingValue,
  cascadeToChildren,
  autoEnableParent,
  autoDisableParent
} from './permission-toggle-helpers'

interface UsePermissionToggleParams {
  roleTemplate: RoleTemplate | null
  permissionOverrides: PermissionOverrides
  pendingChanges: PendingChanges
  setPendingChanges: (changes: PendingChanges) => void
}

/**
 * Handles permission toggle operations with parent/child cascading, linked key synchronization,
 * and auto-enable/disable of parent toggles based on sibling state.
 */
export function usePermissionToggle({
  roleTemplate,
  permissionOverrides,
  pendingChanges,
  setPendingChanges
}: UsePermissionToggleParams) {
  const [loadingPermission, setLoadingPermission] = useState<string | null>(null)

  const enableParentCascade = (
    permissions: Record<string, Record<string, boolean>>,
    parentKey: string, level: string
  ) => {
    autoEnableParent(permissions, parentKey, level, pendingChanges, permissionOverrides, roleTemplate)
  }

  const disableParentCascade = (
    permissions: Record<string, Record<string, boolean>>,
    parentKey: string, level: string, actualLevel: string, actualKey: string
  ) => {
    autoDisableParent(permissions, parentKey, level, { actualLevel, actualKey }, { pendingChanges, permissionOverrides, roleTemplate })
  }

  const applyLinkedKeyCascade = (
    permissions: Record<string, Record<string, boolean>>,
    linkedKeys: Array<{ level: string; key: string }>,
    value: boolean
  ) => {
    for (const lk of linkedKeys) {
      const { actualLevel: lkLevel, actualKey: lkKey } = resolveLinkedKey(lk)
      ensureLevelExists(permissions, lkLevel)
      permissions[lkLevel][lkKey] = value
    }
  }

  const handleTogglePermission = ({ level, key, value }: { level: string; key: string; value: boolean }) => {
    setLoadingPermission(`${level}.${key}`)

    const { actualLevel, actualKey } = resolvePermissionLevel({ level, key })

    const newPendingChanges: PendingChanges = {
      ...pendingChanges,
      permissions: { ...pendingChanges.permissions, [actualLevel]: { ...pendingChanges.permissions[actualLevel] } }
    }

    applyPendingValue(newPendingChanges, actualLevel, actualKey, value, permissionOverrides)
    cascadeToChildren(newPendingChanges.permissions, key, level, value)

    const toggleConfig = businessRelevantToggles[level]?.toggles[key]
    if (toggleConfig?.parent) {
      if (value) {
        enableParentCascade(newPendingChanges.permissions, toggleConfig.parent, level)
      } else {
        disableParentCascade(newPendingChanges.permissions, toggleConfig.parent, level, actualLevel, actualKey)
      }
    }
    if (toggleConfig?.linkedKeys) {
      applyLinkedKeyCascade(newPendingChanges.permissions, toggleConfig.linkedKeys, value)
    }

    setPendingChanges(newPendingChanges)
    setLoadingPermission(null)
  }

  return {
    loadingPermission,
    handleTogglePermission
  }
}
===ENDFILE

===FILE: src/hooks/api/__tests__/use-ad-group-api.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useCallback: (fn: unknown) => fn
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}

vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockApiFetch = vi.fn()

vi.mock('../../../services/core/api-client', () => ({
  apiFetch: (...args: unknown[]) => mockApiFetch(...args)
}))

const { useAdGroupApi } = await import('../use-ad-group-api')

function callHook() {
  stateIndex = 0
  return useAdGroupApi()
}

describe('useAdGroupApi', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  it('initializes with isLoading false', () => {
    const result = callHook()
    expect(result.isLoading).toBe(false)
  })

  describe('fetchAdGroupData', () => {
    it('fetches and transforms AD group data', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            groupIdentifier: 'CN=test-group',
            logicalName: 'Test Group',
            roleName: 'voice_agent',
            marketCode: 'HK',
            regionCode: 'APAC',
            countryCode: 'HK',
            businessUnitName: 'WPB',
            activeIndicator: true,
            userAccessCode: 'FULL',
            pendingChangeIndicator: false,
            versionNumber: 3,
            userCountNumber: 42,
            updatedAtDatetime: '2025-01-01T00:00:00Z',
            currentConfig: {
              permissionChanges: {
                columnPermissions: {
                  kms: { enabledIndicator: true }
                },
                widgetPermissions: {
                  search: { enabledIndicator: false }
                }
              }
            }
          }
        })
      })

      const { fetchAdGroupData } = callHook()
      const result = await fetchAdGroupData('CN=test-group')

      expect(result).not.toBeNull()
      expect(result!.groupIdentifier).toBe('CN=test-group')
      expect(result!.logicalName).toBe('Test Group')
      expect(result!.roleName).toBe('voice_agent')
      expect(result!.market).toBe('HK')
      expect(result!.region).toBe('APAC')
      expect(result!.country).toBe('HK')
      expect(result!.businessUnit).toBe('WPB')
      expect(result!.isActive).toBe(true)
      expect(result!.accessLevel).toBe('FULL')
      expect(result!.userCount).toBe(42)
      expect(result!.columnAssignments).toEqual({ kms: { state: 'enabled' } })
      expect(result!.widgetAssignments).toEqual({ search: { state: 'disabled' } })
    })

    it('returns null for 404 response', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 404
      })

      const { fetchAdGroupData } = callHook()
      const result = await fetchAdGroupData('CN=nonexistent')
      expect(result).toBeNull()
    })

    it('throws on 403 response', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 403
      })

      const { fetchAdGroupData } = callHook()
      await expect(fetchAdGroupData('CN=forbidden')).rejects.toThrow('Access denied')
    })

    it('throws on other error statuses', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 500
      })

      const { fetchAdGroupData } = callHook()
      await expect(fetchAdGroupData('CN=error')).rejects.toThrow('Failed to fetch AD group data: 500')
    })

    it('throws on missing data in response', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({})
      })

      const { fetchAdGroupData } = callHook()
      await expect(fetchAdGroupData('CN=bad')).rejects.toThrow('Unexpected AD group lookup response')
    })

    it('wraps network errors', async () => {
      const fetchError = new TypeError('fetch failed')
      mockApiFetch.mockRejectedValue(fetchError)

      const { fetchAdGroupData } = callHook()
      await expect(fetchAdGroupData('CN=network')).rejects.toThrow('Network error')
    })

    it('re-throws non-network errors', async () => {
      mockApiFetch.mockRejectedValue(new Error('Something else'))

      const { fetchAdGroupData } = callHook()
      await expect(fetchAdGroupData('CN=other')).rejects.toThrow('Something else')
    })

    it('defaults isActive to true when missing', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: { groupIdentifier: 'CN=g1' }
        })
      })

      const { fetchAdGroupData } = callHook()
      const result = await fetchAdGroupData('CN=g1')
      expect(result!.isActive).toBe(true)
    })
  })

  describe('updateAdGroupConfig', () => {
    it('sends update and fetches refreshed data', async () => {
      // First call: update POST
      // Second call: fetchAdGroupData POST (re-fetch)
      mockApiFetch
        .mockResolvedValueOnce({ ok: true })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: { groupIdentifier: 'CN=g1', activeIndicator: true }
          })
        })

      const { updateAdGroupConfig } = callHook()
      const result = await updateAdGroupConfig('CN=g1', { logicalName: 'Updated' })

      expect(result).not.toBeNull()
      expect(mockNotifications.success).toHaveBeenCalled()
      expect(mockApiFetch).toHaveBeenCalledTimes(2)
    })

    it('suppresses success toast when option set', async () => {
      mockApiFetch
        .mockResolvedValueOnce({ ok: true })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: { groupIdentifier: 'CN=g1' }
          })
        })

      const { updateAdGroupConfig } = callHook()
      await updateAdGroupConfig('CN=g1', { logicalName: 'Updated' }, { suppressSuccessToast: true })

      expect(mockNotifications.success).not.toHaveBeenCalled()
    })

    it('shows error notification on failure', async () => {
      mockApiFetch.mockResolvedValue({ ok: false, status: 500 })

      const { updateAdGroupConfig } = callHook()
      await expect(updateAdGroupConfig('CN=g1', {})).rejects.toThrow()

      expect(mockNotifications.error).toHaveBeenCalled()
    })

    it('converts isActive to activeIndicator in payload', async () => {
      mockApiFetch
        .mockResolvedValueOnce({ ok: true })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: { groupIdentifier: 'CN=g1' }
          })
        })

      const { updateAdGroupConfig } = callHook()
      await updateAdGroupConfig('CN=g1', { isActive: false })

      const body = JSON.parse(mockApiFetch.mock.calls[0][1].body)
      expect(body.data.proposedState.activeIndicator).toBe(false)
      expect(body.data.proposedState.isActive).toBeUndefined()
    })

    it('includes configVersionNumber when versionNumber provided', async () => {
      mockApiFetch
        .mockResolvedValueOnce({ ok: true })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: { groupIdentifier: 'CN=g1' }
          })
        })

      const { updateAdGroupConfig } = callHook()
      await updateAdGroupConfig('CN=g1', { versionNumber: 5 })

      const body = JSON.parse(mockApiFetch.mock.calls[0][1].body)
      expect(body.data.configVersionNumber).toBe(5)
    })
  })

  describe('applyRoleTemplate', () => {
    it('applies role template and shows success', async () => {
      mockApiFetch
        .mockResolvedValueOnce({ ok: true })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: { groupIdentifier: 'CN=g1', roleName: 'chat_agent' }
          })
        })

      const { applyRoleTemplate } = callHook()
      const result = await applyRoleTemplate('CN=g1', 'chat_agent')

      expect(result).not.toBeNull()
      expect(mockNotifications.success).toHaveBeenCalled()
    })

    it('shows error notification on failure', async () => {
      mockApiFetch.mockResolvedValue({ ok: false, status: 500 })

      const { applyRoleTemplate } = callHook()
      await expect(applyRoleTemplate('CN=g1', 'chat_agent')).rejects.toThrow()

      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })

  describe('copyFromAdGroup', () => {
    it('copies configuration and shows success', async () => {
      mockApiFetch
        .mockResolvedValueOnce({ ok: true })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: { groupIdentifier: 'CN=target' }
          })
        })

      const { copyFromAdGroup } = callHook()
      const result = await copyFromAdGroup('CN=target', 'CN=source')

      expect(result).not.toBeNull()
      expect(mockNotifications.success).toHaveBeenCalled()
      const body = JSON.parse(mockApiFetch.mock.calls[0][1].body)
      expect(body.data.sourceGroupIdentifier).toBe('CN=source')
      expect(body.data.targetGroupIdentifier).toBe('CN=target')
    })

    it('shows error notification on failure', async () => {
      mockApiFetch.mockResolvedValue({ ok: false, status: 500 })

      const { copyFromAdGroup } = callHook()
      await expect(copyFromAdGroup('CN=target', 'CN=source')).rejects.toThrow()

      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })

  describe('fetchAllAdGroups', () => {
    it('fetches and transforms all groups', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            items: [
              { groupIdentifier: 'CN=g1', logicalName: 'Group 1', activeIndicator: true },
              { groupIdentifier: 'CN=g2', logicalName: 'Group 2', activeIndicator: false }
            ]
          }
        })
      })

      const { fetchAllAdGroups } = callHook()
      const result = await fetchAllAdGroups()

      expect(result).toHaveLength(2)
      expect(result[0].groupIdentifier).toBe('CN=g1')
      expect(result[1].isActive).toBe(false)
    })

    it('returns empty array on error', async () => {
      mockApiFetch.mockRejectedValue(new Error('Network error'))

      const { fetchAllAdGroups } = callHook()
      const result = await fetchAllAdGroups()

      expect(result).toEqual([])
      expect(mockNotifications.error).toHaveBeenCalled()
    })

    it('returns empty array when no items', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: {} })
      })

      const { fetchAllAdGroups } = callHook()
      const result = await fetchAllAdGroups()

      expect(result).toEqual([])
    })
  })
})
===ENDFILE

===FILE: src/hooks/api/__tests__/use-embedded-apps-api.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useCallback: (fn: (...args: unknown[]) => unknown) => fn,
  useMemo: (fn: () => unknown) => fn()
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}
vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockApiFetch = vi.fn()
vi.mock('../../../services/core/api-client', () => ({
  apiFetch: (...args: unknown[]) => mockApiFetch(...args)
}))

vi.mock('@/utils/core/debug', () => ({
  createLogger: () => ({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  })
}))

vi.mock('@/utils/core/error-tracking', () => ({
  logErrorToTracking: vi.fn()
}))

const { useEmbeddedAppsApi } = await import('../use-embedded-apps-api')

describe('useEmbeddedAppsApi', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  function callHook() {
    stateIndex = 0
    return useEmbeddedAppsApi()
  }

  describe('fetchAllEmbeddedApps', () => {
    it('fetches and transforms embedded apps from PAPI', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            embeddedApps: [{
              appKey: 'testApp',
              titleText: 'Test App',
              description: 'A test app',
              categoryText: 'Tools',
              isActiveFlag: true,
              functionDefinitionMap: {
                fn1: { displayName: 'Function 1', description: 'Desc 1' }
              }
            }]
          }
        })
      })

      const { fetchAllEmbeddedApps } = callHook()
      const apps = await fetchAllEmbeddedApps()

      expect(apps).toHaveLength(1)
      expect(apps[0].appIdentifier).toBe('testApp')
      expect(apps[0].titleText).toBe('Test App')
      expect(apps[0].descriptionText).toBe('A test app')
      expect(apps[0].categoryName).toBe('Tools')
      expect(apps[0].isActiveIndicator).toBe(true)
      expect(apps[0].functionDefinitionsObject.fn1.displayName).toBe('Function 1')
    })

    it('throws on non-ok response', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 500
      })

      const { fetchAllEmbeddedApps } = callHook()
      await expect(fetchAllEmbeddedApps()).rejects.toThrow('Failed to fetch embedded apps')
    })

    it('handles alternate field names in function definitions', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            embeddedApps: [{
              appKey: 'app1',
              titleText: 'App',
              description: 'Desc',
              categoryText: 'Cat',
              functionDefinitionMap: {
                fn1: { displayNameText: 'Alt Name', descriptionText: 'Alt Desc', categoryName: 'AltCat' }
              }
            }]
          }
        })
      })

      const { fetchAllEmbeddedApps } = callHook()
      const apps = await fetchAllEmbeddedApps()

      expect(apps[0].functionDefinitionsObject.fn1.displayName).toBe('Alt Name')
      expect(apps[0].functionDefinitionsObject.fn1.description).toBe('Alt Desc')
    })

    it('returns empty function definitions for invalid input', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            embeddedApps: [{
              appKey: 'app1',
              titleText: 'App',
              description: 'Desc',
              categoryText: 'Cat',
              functionDefinitionMap: null
            }]
          }
        })
      })

      const { fetchAllEmbeddedApps } = callHook()
      const apps = await fetchAllEmbeddedApps()

      expect(apps[0].functionDefinitionsObject).toEqual({})
    })
  })

  describe('fetchAssignedApps', () => {
    it('fetches assigned apps for a group', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            embeddedApps: [{
              appKey: 'assignedApp',
              titleText: 'Assigned App',
              description: 'Desc',
              categoryText: 'Cat'
            }]
          }
        })
      })

      const { fetchAssignedApps } = callHook()
      const apps = await fetchAssignedApps('CN=test-group')

      expect(apps).toHaveLength(1)
      expect(apps[0].appIdentifier).toBe('assignedApp')
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/embedded-apps-ad-groups', expect.objectContaining({
        method: 'POST',
        body: expect.stringContaining('CN=test-group')
      }))
    })

    it('returns empty array on 404', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 404
      })

      const { fetchAssignedApps } = callHook()
      const apps = await fetchAssignedApps('CN=test-group')

      expect(apps).toEqual([])
    })

    it('throws on non-404 error', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 500
      })

      const { fetchAssignedApps } = callHook()
      await expect(fetchAssignedApps('CN=test-group')).rejects.toThrow('Failed to fetch assigned apps')
    })
  })

  describe('loadEmbeddedAppsData', () => {
    it('merges all apps with assigned status', async () => {
      // Mock fetchAllEmbeddedApps
      mockApiFetch
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: {
              embeddedApps: [
                { appKey: 'app1', titleText: 'App 1', description: 'D', categoryText: 'C' },
                { appKey: 'app2', titleText: 'App 2', description: 'D', categoryText: 'C' }
              ]
            }
          })
        })
        // Mock fetchAssignedApps
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: {
              embeddedApps: [{
                appKey: 'app1',
                titleText: 'App 1',
                description: 'D',
                categoryText: 'C',
                adGroupAccess: {
                  'CN=test-group': { functionValues: ['fn1', 'fn2'] }
                }
              }]
            }
          })
        })

      const { loadEmbeddedAppsData } = callHook()
      const apps = await loadEmbeddedAppsData('CN=test-group')

      expect(apps).toHaveLength(2)
      const assignedApp = apps.find(a => a.appIdentifier === 'app1')
      const unassignedApp = apps.find(a => a.appIdentifier === 'app2')
      expect(assignedApp?.isAssignedIndicator).toBe(true)
      expect(assignedApp?.assignedFunctionKeys).toEqual(['fn1', 'fn2'])
      expect(unassignedApp?.isAssignedIndicator).toBe(false)
      expect(unassignedApp?.assignedFunctionKeys).toEqual([])
    })

    it('shows error notification on failure', async () => {
      mockApiFetch.mockRejectedValue(new Error('Network error'))

      const { loadEmbeddedAppsData } = callHook()
      await expect(loadEmbeddedAppsData('CN=test-group')).rejects.toThrow()

      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })

  describe('saveAppAssignment', () => {
    it('saves assignment and shows success notification', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: {} })
      })

      const { saveAppAssignment } = callHook()
      await saveAppAssignment('app1', 'App 1', 'CN=test-group', 'Test Group', ['fn1', 'fn2'], 'fn1')

      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/embedded-apps-ad-groups/app1', expect.objectContaining({
        method: 'PUT',
        body: expect.stringContaining('fn1')
      }))
      expect(mockNotifications.success).toHaveBeenCalled()
    })

    it('shows remove success notification when functions empty', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: {} })
      })

      const { saveAppAssignment } = callHook()
      await saveAppAssignment('app1', 'App 1', 'CN=test-group', 'Test Group', [])

      expect(mockNotifications.success).toHaveBeenCalledWith(
        expect.objectContaining({
          title: 'App assignment removed'
        })
      )
    })

    it('throws and shows error notification on failure', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 500
      })

      const { saveAppAssignment } = callHook()
      await expect(
        saveAppAssignment('app1', 'App 1', 'CN=test-group', 'Test Group', ['fn1'])
      ).rejects.toThrow('Failed to save app assignment')

      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })
})
===ENDFILE

===FILE: src/hooks/api/__tests__/use-reference-data.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: vi.fn(),
  useCallback: (fn: (...args: unknown[]) => unknown) => fn
}))

const mockGetAllRegions = vi.fn()
const mockGetAllBusinessUnits = vi.fn()
const mockGetAllCountries = vi.fn()
const mockGetAllRoleTemplates = vi.fn()
const mockGetCountriesByRegion = vi.fn()
const mockGetMarketsByRegion = vi.fn()
const mockGetCountriesByMarket = vi.fn()

vi.mock('../../../services/api/reference-data.service', () => ({
  getAllRegions: (...args: unknown[]) => mockGetAllRegions(...args),
  getAllBusinessUnits: (...args: unknown[]) => mockGetAllBusinessUnits(...args),
  getAllCountries: (...args: unknown[]) => mockGetAllCountries(...args),
  getCountriesByRegion: (...args: unknown[]) => mockGetCountriesByRegion(...args),
  getMarketsByRegion: (...args: unknown[]) => mockGetMarketsByRegion(...args),
  getCountriesByMarket: (...args: unknown[]) => mockGetCountriesByMarket(...args)
}))

vi.mock('../../../services/api/role-template.service', () => ({
  getAllRoleTemplates: (...args: unknown[]) => mockGetAllRoleTemplates(...args)
}))

vi.mock('../../../utils/core/debug', () => ({
  createLogger: () => ({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  })
}))

const { useReferenceData } = await import('../use-reference-data')

describe('useReferenceData', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  function callHook() {
    stateIndex = 0
    return useReferenceData()
  }

  it('initializes with empty arrays and no error', () => {
    const result = callHook()
    expect(result.regions).toEqual([])
    expect(result.businessUnits).toEqual([])
    expect(result.countries).toEqual([])
    expect(result.roleTemplates).toEqual([])
    expect(result.isLoading).toBe(false)
    expect(result.error).toBeNull()
  })

  it('fetchAllData populates state when called directly', async () => {
    const mockRegions = [{ regionCode: 'APAC', regionName: 'Asia Pacific', displayOrder: 1, isActive: true }]
    const mockBUs = [{ unitCode: 'WPB', unitName: 'Wealth', description: '', effectiveDate: '', displayOrder: 1, isActive: true }]
    const mockCountries = [{ countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true }]
    const mockRoleTemplates = [{ roleNameCode: 'voice_agent', roleDisplayName: 'Voice Agent' }]

    mockGetAllRegions.mockResolvedValue(mockRegions)
    mockGetAllBusinessUnits.mockResolvedValue(mockBUs)
    mockGetAllCountries.mockResolvedValue(mockCountries)
    mockGetAllRoleTemplates.mockResolvedValue(mockRoleTemplates)

    // Call refetch which clears module caches and calls fetchAllData
    const { refetch } = callHook()
    await refetch()

    const result = callHook()
    expect(result.regions).toEqual(mockRegions)
    expect(result.businessUnits).toEqual(mockBUs)
    expect(result.countries).toEqual(mockCountries)
    expect(result.roleTemplates).toEqual(mockRoleTemplates)
  })

  it('fetchAllData sets error on failure', async () => {
    mockGetAllRegions.mockRejectedValue(new Error('Network error'))
    mockGetAllBusinessUnits.mockResolvedValue([])
    mockGetAllCountries.mockResolvedValue([])
    mockGetAllRoleTemplates.mockResolvedValue([])

    const { refetch } = callHook()
    await refetch()

    const result = callHook()
    expect(result.error).toBe('Network error')
  })

  it('refetch clears caches and re-fetches', async () => {
    const mockRegions = [{ regionCode: 'APAC', regionName: 'Asia', displayOrder: 1, isActive: true }]
    mockGetAllRegions.mockResolvedValue(mockRegions)
    mockGetAllBusinessUnits.mockResolvedValue([])
    mockGetAllCountries.mockResolvedValue([])
    mockGetAllRoleTemplates.mockResolvedValue([])

    const { refetch } = callHook()
    await refetch()

    // Second refetch should call APIs again since caches were cleared
    await refetch()
    expect(mockGetAllRegions).toHaveBeenCalledTimes(2)
  })

  it('getCountriesForRegion fetches and returns countries', async () => {
    const mockCountries = [{ countryCode: 'SG', countryName: 'Singapore', regionCode: 'APAC', marketCode: 'SG', displayOrder: 1, isActive: true }]
    mockGetCountriesByRegion.mockResolvedValue(mockCountries)

    const { getCountriesForRegion } = callHook()
    const result = await getCountriesForRegion('APAC')

    expect(result).toEqual(mockCountries)
    expect(mockGetCountriesByRegion).toHaveBeenCalledWith('APAC')
  })

  it('getMarketsForRegion fetches and returns markets', async () => {
    const mockMarkets = [{ marketCode: 'SG', marketName: 'Singapore', regionCode: 'APAC', displayOrder: 1, isActive: true }]
    mockGetMarketsByRegion.mockResolvedValue(mockMarkets)

    const { getMarketsForRegion } = callHook()
    const result = await getMarketsForRegion('APAC')

    expect(result).toEqual(mockMarkets)
    expect(mockGetMarketsByRegion).toHaveBeenCalledWith('APAC')
  })

  it('getCountriesForMarket fetches and returns countries', async () => {
    const mockCountries = [{ countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true }]
    mockGetCountriesByMarket.mockResolvedValue(mockCountries)

    const { getCountriesForMarket } = callHook()
    const result = await getCountriesForMarket('HK')

    expect(result).toEqual(mockCountries)
    expect(mockGetCountriesByMarket).toHaveBeenCalledWith('HK')
  })

  it('getCountriesForRegion throws on error', async () => {
    mockGetCountriesByRegion.mockRejectedValue(new Error('API error'))

    const { getCountriesForRegion } = callHook()
    await expect(getCountriesForRegion('BAD')).rejects.toThrow('API error')
  })

  it('getMarketsForRegion throws on error', async () => {
    mockGetMarketsByRegion.mockRejectedValue(new Error('Market error'))

    const { getMarketsForRegion } = callHook()
    await expect(getMarketsForRegion('BAD')).rejects.toThrow('Market error')
  })

  it('getCountriesForMarket throws on error', async () => {
    mockGetCountriesByMarket.mockRejectedValue(new Error('Market lookup error'))

    const { getCountriesForMarket } = callHook()
    await expect(getCountriesForMarket('BAD')).rejects.toThrow('Market lookup error')
  })
})
===ENDFILE

===FILE: src/hooks/api/ad-group-api-transformers.ts
/**
 * AD Group API Transformers - Response mapping functions for the AD Group API
 */

import type { AdGroupData, UserAccessLevel } from '../../types/features/ad-group-config'

/**
 * Maps PAPI response fields to frontend AdGroupData fields.
 * PAPI returns: marketCode, regionCode, countryCode, activeIndicator, userCountNumber, userAccessCode, etc.
 * Frontend expects: market, region, country, isActive, userCount, accessLevel, etc.
 */
export function transformAdGroupResponse(raw: Record<string, unknown>): AdGroupData {
  const currentConfig = raw.currentConfig as Record<string, unknown> | undefined
  const permissionChanges = currentConfig?.permissionChanges as Record<string, unknown> | undefined
  const toAssignments = (permissions: Record<string, unknown> | undefined): Record<string, { state: 'enabled' | 'disabled' }> | undefined => {
    if (!permissions) {
      return undefined
    }
    return Object.fromEntries(
      Object.entries(permissions).map(([key, value]) => {
        const enabled = Boolean((value as { enabledIndicator?: boolean })?.enabledIndicator)
        return [key, { state: enabled ? 'enabled' : 'disabled' as const }]
      })
    )
  }

  return {
    id: (raw.groupIdentifier as string) ?? '',
    groupIdentifier: (raw.groupIdentifier as string) ?? '',
    logicalName: (raw.logicalName as string | undefined) ?? undefined,
    roleName: (raw.roleName as string | undefined) ?? undefined,
    market: raw.marketCode as string | undefined,
    region: raw.regionCode as string | undefined,
    country: raw.countryCode as string | undefined,
    businessUnit: raw.businessUnitName as string | undefined,
    isActive: (raw.activeIndicator as boolean | undefined) ?? true,
    accessLevel: raw.userAccessCode as UserAccessLevel | undefined,
    pendingChangeIndicator: (raw.pendingChangeIndicator as boolean | undefined) ?? false,
    versionNumber: (raw.versionNumber as number | undefined),
    userCount: raw.userCountNumber as number | undefined,
    lastModified: raw.updatedAtDatetime as string | undefined,
    columnAssignments: toAssignments(
      permissionChanges?.columnPermissions as Record<string, unknown> | undefined
    ),
    widgetAssignments: toAssignments(
      permissionChanges?.widgetPermissions as Record<string, unknown> | undefined
    )
  }
}

/**
 * Transforms frontend AdGroupData fields into the PAPI proposed state format.
 * Renames isActive to activeIndicator and strips undefined values.
 */
export function toDirectSaveProposedState(payload: Partial<AdGroupData>): Record<string, unknown> {
  const proposedState: Record<string, unknown> = { ...payload }
  if ('isActive' in proposedState && typeof proposedState.isActive === 'boolean') {
    proposedState.activeIndicator = proposedState.isActive
    delete proposedState.isActive
  }
  return Object.fromEntries(Object.entries(proposedState).filter(([, value]) => value !== undefined))
}
===ENDFILE

===FILE: src/hooks/api/embedded-apps-api-calls.ts
/**
 * Embedded Apps API Calls
 * Pure async functions for embedded apps PAPI endpoints.
 * Separated from the React hook for lower complexity.
 */

import { apiFetch } from '../../services/core/api-client'
import { createLogger } from '@/utils/core/debug'
import { logErrorToTracking } from '@/utils/core/error-tracking'
import { transformPapiApp } from './embedded-apps-transformers'
import type { EmbeddedApp } from '../../types/integration/embedded-apps'

const logger = createLogger('EMBEDDED_APPS_API')

function wrapError(message: string, cause: unknown): Error {
  const typedError = new Error(message)
  ;(typedError as Error & { cause?: unknown }).cause = cause
  return typedError
}

function toErrorMessage(error: unknown): string {
  return error instanceof Error ? error.message : String(error)
}

function logAndThrow(logMessage: string, trackingCode: string, context: Record<string, unknown>, error: unknown): never {
  const message = toErrorMessage(error)
  logger.error(logMessage, { error, ...context })
  logErrorToTracking(trackingCode, { error: message, ...context })
  throw wrapError(`${logMessage}: ${message}`, error)
}

function extractAppsArray(raw: Record<string, unknown>): Record<string, unknown>[] {
  const dataObj = raw.data as Record<string, unknown> | undefined
  return (dataObj?.embeddedApps ?? (Array.isArray(raw) ? raw : [])) as Record<string, unknown>[]
}

export async function fetchAllEmbeddedAppsApi(): Promise<EmbeddedApp[]> {
  try {
    const response = await apiFetch('/papi/v1/embedded-apps', { method: 'GET' })
    if (!response.ok) throw new Error(`Failed to fetch embedded apps: ${response.status}`)
    const raw = await response.json() as Record<string, unknown>
    return extractAppsArray(raw).map(app => transformPapiApp(app))
  } catch (error) {
    logAndThrow('Failed to fetch embedded apps catalogue', 'EMBEDDED_APPS_FETCH_FAILED', {}, error)
  }
}

export async function fetchAssignedAppsApi(groupIdentifier: string): Promise<EmbeddedApp[]> {
  try {
    const response = await apiFetch('/papi/v1/embedded-apps-ad-groups', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ data: { groupIdentifier } })
    })
    if (response.status === 404) return []
    if (!response.ok) throw new Error(`Failed to fetch assigned apps: ${response.status}`)
    const raw = await response.json() as Record<string, unknown>
    return extractAppsArray(raw).map(app => transformPapiApp(app))
  } catch (error) {
    logAndThrow('Failed to fetch assigned embedded apps', 'EMBEDDED_APPS_ASSIGNED_FETCH_FAILED', { groupIdentifier }, error)
  }
}

export async function saveAppAssignmentApi(
  appKey: string,
  groupIdentifier: string,
  functions: string[],
  defaultFunction?: string
): Promise<void> {
  const response = await apiFetch(`/papi/v1/embedded-apps-ad-groups/${appKey}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      data: {
        groupIdentifier,
        functionValues: functions,
        defaultFunctionText: defaultFunction
      }
    })
  })

  if (!response.ok) {
    throw new Error(`Failed to save app assignment: ${response.status}`)
  }

  await response.json()
}
===ENDFILE

===FILE: src/hooks/api/embedded-apps-definition-mapper.ts
/**
 * Embedded Apps Definition Mapper - Maps raw PAPI function definitions to frontend format
 */

import { EmbeddedApp } from '../../types/integration/embedded-apps'

/**
 * Maps PAPI response fields to frontend EmbeddedApp fields.
 * PAPI returns: appKey, description, categoryText, baseUrlText, isActiveFlag, etc.
 * Frontend keeps app-level aliases, while function definitions use contract keys.
 */
export function mapDefinitionFields(definition: Record<string, unknown>, functionKey: string) {
  return {
    displayName:
      (definition.displayName as string) ??
      (definition.displayNameText as string) ??
      functionKey,
    description:
      (definition.description as string) ??
      (definition.descriptionText as string),
    categoryText:
      (definition.categoryText as string) ??
      (definition.categoryName as string),
    searchKeywordValues:
      (definition.searchKeywordValues as string[]) ??
      (definition.searchKeywords as string[]),
    requiresApprovalFlag: (definition.requiresApprovalFlag as boolean) ?? undefined,
    mfeConfig:
      (definition.mfeConfig as Record<string, unknown>) ??
      (definition.mfeConfigObject as Record<string, unknown>)
  }
}

/**
 * Transforms raw PAPI function definition objects into the frontend format.
 * Handles missing or invalid input by returning an empty map.
 */
export function transformFunctionDefinitions(rawDefinitions: unknown): EmbeddedApp['functionDefinitionsObject'] {
  if (!rawDefinitions || typeof rawDefinitions !== 'object' || Array.isArray(rawDefinitions)) {
    return {}
  }

  return Object.entries(rawDefinitions as Record<string, unknown>).reduce((acc, [functionKey, rawDefinition]) => {
    if (!rawDefinition || typeof rawDefinition !== 'object' || Array.isArray(rawDefinition)) {
      return acc
    }

    acc[functionKey] = mapDefinitionFields(rawDefinition as Record<string, unknown>, functionKey)
    return acc
  }, {} as EmbeddedApp['functionDefinitionsObject'])
}
===ENDFILE

===FILE: src/hooks/api/embedded-apps-field-resolver.ts
/**
 * Embedded Apps Field Resolver - Resolves alternate PAPI field names for app responses
 */

/**
 * Resolves a string value from a PAPI response object, checking the primary
 * field name first then falling back to an alternate field name.
 */
export function resolveString(raw: Record<string, unknown>, primary: string, fallback: string, defaultValue = ''): string {
  return (raw[primary] as string) ?? (raw[fallback] as string) ?? defaultValue
}

/**
 * Normalizes alternate PAPI field names for embedded app responses into
 * a consistent set of field names used by the frontend.
 */
export function mapAppResponseFields(raw: Record<string, unknown>) {
  return {
    baseUrlAddress: (raw.baseUrlText as string) ?? (raw.baseUrlAddress as string),
    loadingStrategyCode: (raw.loadingStrategyText as string) ?? (raw.loadingStrategyCode as string),
    primaryKeywordsText: (raw.primaryKeywordValues as string[]) ?? (raw.primaryKeywordsText as string[]),
    secondaryKeywordsText: (raw.secondaryKeywordValues as string[]) ?? (raw.secondaryKeywordsText as string[]),
    mfeConfigObject: (raw.mfeConfig as Record<string, unknown>) ?? (raw.mfeConfigObject as Record<string, unknown>),
    regionalUrlsObject: (raw.regionalUrls as Record<string, unknown>) ?? (raw.regionalUrlsObject as Record<string, unknown>),
    isActiveIndicator: (raw.isActiveFlag as boolean) ?? (raw.isActiveIndicator as boolean) ?? true,
  }
}
===ENDFILE

===FILE: src/hooks/api/embedded-apps-transformers.ts
/**
 * Embedded Apps Transformers - Maps raw PAPI app responses to the frontend EmbeddedApp DTO.
 * Handles alternate field names between different PAPI response versions.
 */

import { EmbeddedApp } from '../../types/integration/embedded-apps'
import { transformFunctionDefinitions } from './embedded-apps-definition-mapper'
import { resolveString, mapAppResponseFields } from './embedded-apps-field-resolver'

// Re-export for consumers that import from this module
export { mapDefinitionFields, transformFunctionDefinitions } from './embedded-apps-definition-mapper'
export { resolveString, mapAppResponseFields } from './embedded-apps-field-resolver'

/**
 * Converts a raw PAPI embedded app response to the frontend EmbeddedApp DTO.
 * Resolves alternate PAPI field names (e.g., appKey vs appIdentifier, isActiveFlag vs isActiveIndicator).
 * @param raw - Raw PAPI response object for a single embedded app
 * @returns Normalized EmbeddedApp with consistent field names
 */
export function transformPapiApp(raw: Record<string, unknown>): EmbeddedApp {
  const rawFunctionDefinitions = raw.functionDefinitionMap ?? raw.functionDefinitionsObject

  return {
    appIdentifier: resolveString(raw, 'appKey', 'appIdentifier'),
    titleText: (raw.titleText as string) ?? '',
    descriptionText: resolveString(raw, 'description', 'descriptionText'),
    categoryName: resolveString(raw, 'categoryText', 'categoryName'),
    ...mapAppResponseFields(raw),
    functionDefinitionsObject: transformFunctionDefinitions(rawFunctionDefinitions),
    adGroupAccessObject: (raw.adGroupAccess ?? raw.adGroupAccessObject) as EmbeddedApp['adGroupAccessObject'],
    appFunctionKeys: (raw.appFunctionValues as string[]) ?? (raw.appFunctionKeys as string[])
  }
}
===ENDFILE

===FILE: src/hooks/api/reference-data-cache.ts
/**
 * Reference Data Cache - Module-level cache for reference data lookups
 */

import type { RegionDto, BusinessUnitDto, CountryDto, MarketDto } from '../../services/api/reference-data.service'
import type { RoleTemplateSummaryDto } from '../../services/api/role-template.service'

interface CacheState {
  regions: RegionDto[] | null
  businessUnits: BusinessUnitDto[] | null
  countries: CountryDto[] | null
  roleTemplates: RoleTemplateSummaryDto[] | null
}

const cache: CacheState = {
  regions: null,
  businessUnits: null,
  countries: null,
  roleTemplates: null,
}

export const cachedCountriesByRegion = new Map<string, CountryDto[]>()
export const cachedMarketsByRegion = new Map<string, MarketDto[]>()
export const cachedCountriesByMarket = new Map<string, CountryDto[]>()

export function getCachedRegions(): RegionDto[] | null { return cache.regions }
export function getCachedBusinessUnits(): BusinessUnitDto[] | null { return cache.businessUnits }
export function getCachedCountries(): CountryDto[] | null { return cache.countries }
export function getCachedRoleTemplates(): RoleTemplateSummaryDto[] | null { return cache.roleTemplates }

export function setCachedRegions(data: RegionDto[]) { cache.regions = data }
export function setCachedBusinessUnits(data: BusinessUnitDto[]) { cache.businessUnits = data }
export function setCachedCountries(data: CountryDto[]) { cache.countries = data }
export function setCachedRoleTemplates(data: RoleTemplateSummaryDto[]) { cache.roleTemplates = data }

export function isAllCached(): boolean {
  return Boolean(cache.regions && cache.businessUnits && cache.countries && cache.roleTemplates)
}

export function clearAllCaches() {
  cache.regions = null
  cache.businessUnits = null
  cache.countries = null
  cache.roleTemplates = null
  if (cachedCountriesByRegion.size > 0) cachedCountriesByRegion.clear()
  if (cachedMarketsByRegion.size > 0) cachedMarketsByRegion.clear()
  if (cachedCountriesByMarket.size > 0) cachedCountriesByMarket.clear()
}
===ENDFILE

===FILE: src/hooks/api/reference-data-fetchers.ts
/**
 * Reference Data Fetchers - Cached fetch functions for hierarchical reference data lookups.
 */

import { getCountriesByRegion, getMarketsByRegion, getCountriesByMarket } from '../../services/api/reference-data.service'
import { createLogger } from '../../utils/core/debug'
import type { CountryDto, MarketDto } from '../../services/api/reference-data.service'
import {
  getCachedRegions,
  cachedCountriesByRegion,
  cachedMarketsByRegion,
  cachedCountriesByMarket
} from './reference-data-cache'

const logger = createLogger('useReferenceData')

/** Fetches countries for a given region, caching results by region code. */
export async function fetchCountriesForRegion(regionNameOrCode: string): Promise<CountryDto[]> {
  const allRegions = getCachedRegions()
  const region = allRegions?.find(r => r.regionName === regionNameOrCode || r.regionCode === regionNameOrCode)
  const regionCode = region?.regionCode ?? regionNameOrCode

  if (cachedCountriesByRegion.has(regionCode)) {
    return cachedCountriesByRegion.get(regionCode)!
  }

  try {
    const countriesData = await getCountriesByRegion(regionCode)
    cachedCountriesByRegion.set(regionCode, countriesData)
    return countriesData
  } catch (err) {
    logger.error('Error fetching countries for region', { regionNameOrCode, regionCode, error: err })
    throw err
  }
}

/** Fetches markets for a given region code, caching results. */
export async function fetchMarketsForRegion(regionCode: string): Promise<MarketDto[]> {
  if (cachedMarketsByRegion.has(regionCode)) {
    return cachedMarketsByRegion.get(regionCode)!
  }

  try {
    const marketsData = await getMarketsByRegion(regionCode)
    cachedMarketsByRegion.set(regionCode, marketsData)
    return marketsData
  } catch (err) {
    logger.error('Error fetching markets for region', { regionCode, error: err })
    throw err
  }
}

/** Fetches countries for a given market code, caching results. */
export async function fetchCountriesForMarket(marketCode: string): Promise<CountryDto[]> {
  if (cachedCountriesByMarket.has(marketCode)) {
    return cachedCountriesByMarket.get(marketCode)!
  }

  try {
    const countriesData = await getCountriesByMarket(marketCode)
    cachedCountriesByMarket.set(marketCode, countriesData)
    return countriesData
  } catch (err) {
    logger.error('Error fetching countries for market', { marketCode, error: err })
    throw err
  }
}
===ENDFILE

===FILE: src/hooks/api/use-ad-group-api.ts
import { useState, useCallback } from 'react'
import { useNotifications } from '../features/use-notifications'
import type { AdGroupData } from '../../types/features/ad-group-config'
import { apiFetch } from '../../services/core/api-client'
import { transformAdGroupResponse, toDirectSaveProposedState } from './ad-group-api-transformers'

function isNetworkFetchError(error: unknown): boolean {
  return error instanceof TypeError && error.message.includes('fetch')
}

function rethrowAsNetworkError(error: unknown): Error {
  if (isNetworkFetchError(error)) return new Error('Network error: Unable to connect to server')
  return error as Error
}


export interface UpdateAdGroupOptions {
  suppressSuccessToast?: boolean
}

interface UseAdGroupApiReturn {
  isLoading: boolean
  fetchAdGroupData: (groupIdentifier: string) => Promise<AdGroupData | null>
  updateAdGroupConfig: (groupIdentifier: string, updatePayload: Partial<AdGroupData>, options?: UpdateAdGroupOptions) => Promise<AdGroupData | null>
  applyRoleTemplate: (groupIdentifier: string, roleName: string) => Promise<AdGroupData | null>
  copyFromAdGroup: (targetGroupIdentifier: string, sourceGroupIdentifier: string) => Promise<AdGroupData | null>
  fetchAllAdGroups: () => Promise<AdGroupData[]>
}

/**
 * Provides CRUD operations for AD group configurations via the PAPI.
 * Includes fetch, update, apply role template, copy from source, and list operations
 * with built-in error handling and user notifications.
 */
export function useAdGroupApi(): UseAdGroupApiReturn {
  const [isLoading, setIsLoading] = useState(false)
  const notifications = useNotifications()

  const fetchAdGroupData = useCallback(async (groupIdentifier: string): Promise<AdGroupData | null> => {
    try {
      const response = await apiFetch('/papi/v1/ad-groups/lookup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ data: { groupIdentifier } })
      })

      if (response.status === 404) return null

      const STATUS_ERRORS: Record<number, string> = {
        403: 'Access denied: Admin privileges required'
      }
      const statusError = STATUS_ERRORS[response.status]
      if (statusError) throw new Error(statusError)
      if (!response.ok) throw new Error(`Failed to fetch AD group data: ${response.status}`)

      const raw = await response.json() as { data?: Record<string, unknown> }
      if (!raw.data) throw new Error('Unexpected AD group lookup response')
      return transformAdGroupResponse(raw.data)
    } catch (error) {
      throw rethrowAsNetworkError(error)
    }
  }, [])

  const updateAdGroupConfig = useCallback(async (
    groupIdentifier: string,
    updatePayload: Partial<AdGroupData>,
    options: UpdateAdGroupOptions = {}
  ): Promise<AdGroupData | null> => {
    setIsLoading(true)
    try {
      const response = await apiFetch('/papi/v1/ad-group-configs', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          data: {
            targetGroupIdentifier: groupIdentifier,
            proposedState: toDirectSaveProposedState(updatePayload),
            ...(typeof updatePayload.versionNumber === 'number'
              ? { configVersionNumber: updatePayload.versionNumber }
              : {})
          }
        })
      })

      if (!response.ok) throw new Error(`Failed to update configuration: ${response.status}`)

      const updatedConfig = await fetchAdGroupData(groupIdentifier)
      if (!options.suppressSuccessToast) notifications.success({ title: 'Configuration saved', description: 'AD group settings were updated successfully.' })
      return updatedConfig
    } catch (error) {
      notifications.error({
        title: 'Unable to save configuration',
        description: 'Please review the details and try again.',
        metaKey: `ad-group-save-${groupIdentifier}`
      })
      throw error
    } finally {
      setIsLoading(false)
    }
  }, [fetchAdGroupData, notifications])

  const applyRoleTemplate = useCallback(async (
    groupIdentifier: string,
    roleName: string
  ): Promise<AdGroupData | null> => {
    setIsLoading(true)
    try {
      const response = await apiFetch('/papi/v1/ad-group-configs', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          data: {
            targetGroupIdentifier: groupIdentifier,
            proposedState: { roleName }
          }
        })
      })

      if (!response.ok) {
        throw new Error(`Failed to apply role template: ${response.status}`)
      }

      const updatedConfig = await fetchAdGroupData(groupIdentifier)
      notifications.success({
        title: 'Role template applied',
        description: `${roleName} permissions have been applied to this AD group.`
      })
      return updatedConfig
    } catch (error) {
      notifications.error({
        title: 'Role template failed',
        description: 'We could not apply the selected template. Please try again.',
        metaKey: `ad-group-template-${groupIdentifier}`
      })
      throw error
    } finally {
      setIsLoading(false)
    }
  }, [fetchAdGroupData, notifications])

  const copyFromAdGroup = useCallback(async (
    targetGroupIdentifier: string,
    sourceGroupIdentifier: string
  ): Promise<AdGroupData | null> => {
    setIsLoading(true)
    try {
      // Copy the configuration to the target group
      const response = await apiFetch('/papi/v1/ad-group-configuration-copies', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          data: {
            sourceGroupIdentifier,
            targetGroupIdentifier
          }
        })
      })

      if (!response.ok) {
        throw new Error(`Failed to copy configuration: ${response.status}`)
      }

      const updatedConfig = await fetchAdGroupData(targetGroupIdentifier)
      notifications.success({
        title: 'Configuration copied',
        description: `${sourceGroupIdentifier} settings are now active for ${targetGroupIdentifier}.`
      })
      return updatedConfig
    } catch (error) {
      notifications.error({
        title: 'Copy operation failed',
        description: 'We could not copy the configuration. Please try again.',
        metaKey: `ad-group-copy-${targetGroupIdentifier}`
      })
      throw error
    } finally {
      setIsLoading(false)
    }
  }, [fetchAdGroupData, notifications])

  const fetchAllAdGroups = useCallback(async (): Promise<AdGroupData[]> => {
    try {
      const response = await apiFetch('/papi/v1/ad-groups', {
        method: 'GET',
        headers: {}
      })

      if (!response.ok) {
        throw new Error(`Failed to fetch AD groups: ${response.status}`)
      }

      const raw = await response.json() as {
        data?: { items?: Record<string, unknown>[] }
      }
      const items = raw.data?.items ?? []
      return items.map(item => transformAdGroupResponse(item))
    } catch {
      notifications.error({
        title: 'Unable to load AD groups',
        description: 'Check your connection and try refreshing the page.',
        metaKey: 'ad-groups-load-error'
      })
      return []
    }
  }, [notifications])

  return {
    isLoading,
    fetchAdGroupData,
    updateAdGroupConfig,
    applyRoleTemplate,
    copyFromAdGroup,
    fetchAllAdGroups
  }
}
===ENDFILE

===FILE: src/hooks/api/use-embedded-apps-api.ts
import { useState, useCallback, useMemo } from 'react'
import { useNotifications } from '../features/use-notifications'
import type { EmbeddedApp, EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'
import { createLogger } from '@/utils/core/debug'
import { logErrorToTracking } from '@/utils/core/error-tracking'
import {
  fetchAllEmbeddedAppsApi,
  fetchAssignedAppsApi,
  saveAppAssignmentApi
} from './embedded-apps-api-calls'

// Re-export for consumers
export { fetchAllEmbeddedAppsApi, fetchAssignedAppsApi, saveAppAssignmentApi } from './embedded-apps-api-calls'

function toErrorMessage(error: unknown): string {
  return error instanceof Error ? error.message : String(error)
}

function wrapError(message: string, cause: unknown): Error {
  const typedError = new Error(message)
  ;(typedError as Error & { cause?: unknown }).cause = cause
  return typedError
}

function logAndRethrow(lgr: ReturnType<typeof createLogger>, logMessage: string, trackingCode: string, context: Record<string, unknown>, error: unknown): never {
  const message = toErrorMessage(error)
  lgr.error(logMessage, { error, ...context })
  logErrorToTracking(trackingCode, { error: message, ...context })
  throw wrapError(`${logMessage}: ${message}`, error)
}

interface UseEmbeddedAppsApiReturn {
  isLoadingApps: boolean
  isSavingAppAssignment: boolean
  fetchAllEmbeddedApps: () => Promise<EmbeddedApp[]>
  fetchAssignedApps: (groupIdentifier: string) => Promise<EmbeddedApp[]>
  loadEmbeddedAppsData: (groupIdentifier: string) => Promise<EmbeddedAppWithStatus[]>
  saveAppAssignment: (
    appKey: string,
    appTitle: string,
    groupIdentifier: string,
    groupDisplayName: string,
    functions: string[],
    defaultFunction?: string
  ) => Promise<void>
}

/**
 * Provides CRUD operations for embedded app assignments via the PAPI.
 * Loads the full app catalogue and merges with per-group assignments to produce
 * EmbeddedAppWithStatus objects for the applications tab UI.
 */
export function useEmbeddedAppsApi(): UseEmbeddedAppsApiReturn {
  const [isLoadingApps, setIsLoadingApps] = useState(false)
  const [isSavingAppAssignment, setIsSavingAppAssignment] = useState(false)
  const notifications = useNotifications()
  const logger = useMemo(() => createLogger('EMBEDDED_APPS_API'), [])

  const fetchAllEmbeddedApps = useCallback(async (): Promise<EmbeddedApp[]> => {
    return fetchAllEmbeddedAppsApi()
  }, [])

  const fetchAssignedApps = useCallback(async (groupIdentifier: string): Promise<EmbeddedApp[]> => {
    return fetchAssignedAppsApi(groupIdentifier)
  }, [])

  const loadEmbeddedAppsData = useCallback(async (groupIdentifier: string): Promise<EmbeddedAppWithStatus[]> => {
    setIsLoadingApps(true)
    try {
      // Load both all apps and assigned apps in parallel
      const [allApps, assignedApps] = await Promise.all([
        fetchAllEmbeddedApps(),
        fetchAssignedApps(groupIdentifier)
      ])

      // Create a map of assigned apps for quick lookup
      const assignedAppsMap = new Map(
        assignedApps.map(app => [app.appIdentifier, app])
      )

      // Merge the data to show assignment status
      const appsWithStatus: EmbeddedAppWithStatus[] = allApps.map(app => {
        const assignedApp = assignedAppsMap.get(app.appIdentifier)
        const assignedAccess = assignedApp?.adGroupAccessObject?.[groupIdentifier]
        const assignedFunctionKeys = assignedAccess?.functionValues || []
        const isAssignedIndicator = assignedFunctionKeys.length > 0

        return {
          ...app,
          isAssignedIndicator,
          assignedFunctionKeys,
        }
      })

      return appsWithStatus
    } catch (error) {
      notifications.error({
        title: 'Application data unavailable',
        description: 'We could not load the embedded app configuration for this group.',
        persistent: true,
        metaKey: 'embedded-apps-data-unavailable'
      })
      logAndRethrow(logger, 'Failed to load embedded apps data', 'EMBEDDED_APPS_DATA_FAILED', { groupIdentifier }, error)
    } finally {
      setIsLoadingApps(false)
    }
  }, [fetchAllEmbeddedApps, fetchAssignedApps, logger, notifications])

  const saveAppAssignment = useCallback(async (
    appKey: string,
    appTitle: string,
    groupIdentifier: string,
    groupDisplayName: string,
    functions: string[],
    defaultFunction?: string
  ): Promise<void> => {
    setIsSavingAppAssignment(true)
    try {
      await saveAppAssignmentApi(appKey, groupIdentifier, functions, defaultFunction)
      const displayName = appTitle || appKey
      const targetGroup = groupDisplayName || groupIdentifier
      const isAssigned = functions.length > 0
      const title = isAssigned ? 'App assignment saved' : 'App assignment removed'
      const description = isAssigned
        ? `${displayName} access has been updated for ${targetGroup}.`
        : `${displayName} has been unassigned from ${targetGroup}.`
      notifications.success({ title, description })
    } catch (error) {
      notifications.error({ title: 'Unable to save app assignment', description: 'Please review the selections and try saving again.' })
      logAndRethrow(logger, 'Failed to save app assignment', 'EMBEDDED_APPS_ASSIGNMENT_SAVE_FAILED', { appKey, groupIdentifier }, error)
    } finally {
      setIsSavingAppAssignment(false)
    }
  }, [logger, notifications])

  return {
    isLoadingApps,
    isSavingAppAssignment,
    fetchAllEmbeddedApps,
    fetchAssignedApps,
    loadEmbeddedAppsData,
    saveAppAssignment
  }
}
===ENDFILE

===FILE: src/hooks/api/use-reference-data.ts
import { useState, useEffect, useCallback } from 'react'
import { getAllRegions, getAllBusinessUnits, getAllCountries } from '../../services/api/reference-data.service'
import { getAllRoleTemplates } from '../../services/api/role-template.service'
import { createLogger } from '../../utils/core/debug'
import type { RegionDto, BusinessUnitDto, CountryDto, MarketDto } from '../../services/api/reference-data.service'
import type { RoleTemplateSummaryDto } from '../../services/api/role-template.service'
import {
  getCachedRegions, getCachedBusinessUnits, getCachedCountries, getCachedRoleTemplates,
  setCachedRegions, setCachedBusinessUnits, setCachedCountries, setCachedRoleTemplates,
  isAllCached, clearAllCaches
} from './reference-data-cache'
import {
  fetchCountriesForRegion,
  fetchMarketsForRegion,
  fetchCountriesForMarket
} from './reference-data-fetchers'

// Re-export for consumers
export { clearAllCaches } from './reference-data-cache'

interface UseReferenceDataReturn {
  regions: RegionDto[]
  businessUnits: BusinessUnitDto[]
  countries: CountryDto[]
  roleTemplates: RoleTemplateSummaryDto[]
  isLoading: boolean
  error: string | null
  getCountriesForRegion: (regionNameOrCode: string) => Promise<CountryDto[]>
  getMarketsForRegion: (regionCode: string) => Promise<MarketDto[]>
  getCountriesForMarket: (marketCode: string) => Promise<CountryDto[]>
  refetch: () => Promise<void>
}

const logger = createLogger('useReferenceData')

/**
 * Provides cached reference data (regions, business units, countries, role templates)
 * with lazy loading on first access. Data is cached at module level to avoid refetching
 * across component remounts. Includes hierarchical lookups (countries by region/market).
 */
export function useReferenceData(): UseReferenceDataReturn {
  const [regions, setRegions] = useState<RegionDto[]>(getCachedRegions() ?? [])
  const [businessUnits, setBusinessUnits] = useState<BusinessUnitDto[]>(getCachedBusinessUnits() ?? [])
  const [countries, setCountries] = useState<CountryDto[]>(getCachedCountries() ?? [])
  const [roleTemplates, setRoleTemplates] = useState<RoleTemplateSummaryDto[]>(getCachedRoleTemplates() ?? [])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const fetchAllData = useCallback(async () => {
    if (isAllCached()) return

    setIsLoading(true)
    setError(null)

    try {
      const cachedOrFetch = <T>(cached: T[] | null, fetcher: () => Promise<T[]>) =>
        cached ? Promise.resolve(cached) : fetcher()

      const safeRoleTemplatesFetch = () =>
        getAllRoleTemplates().catch((err) => {
          logger.warn('Role templates fetch failed; continuing with empty list', err)
          return [] as RoleTemplateSummaryDto[]
        })

      const [regionsData, businessUnitsData, countriesData, roleTemplatesData] = await Promise.all([
        cachedOrFetch(getCachedRegions(), getAllRegions),
        cachedOrFetch(getCachedBusinessUnits(), getAllBusinessUnits),
        cachedOrFetch(getCachedCountries(), getAllCountries),
        cachedOrFetch(getCachedRoleTemplates(), safeRoleTemplatesFetch)
      ])

      setCachedRegions(regionsData)
      setCachedBusinessUnits(businessUnitsData)
      setCachedCountries(countriesData)
      setCachedRoleTemplates(roleTemplatesData)

      setRegions(regionsData)
      setBusinessUnits(businessUnitsData)
      setCountries(countriesData)
      setRoleTemplates(roleTemplatesData)
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch reference data'
      setError(errorMessage)
      logger.error('Error fetching reference data', err)
    } finally {
      setIsLoading(false)
    }
  }, [])

  const getCountriesForRegion = useCallback(fetchCountriesForRegion, [])
  const getMarketsForRegion = useCallback(fetchMarketsForRegion, [])
  const getCountriesForMarket = useCallback(fetchCountriesForMarket, [])

  const refetch = useCallback(async () => {
    clearAllCaches()
    await fetchAllData()
  }, [fetchAllData])

  useEffect(() => {
    fetchAllData()
  }, [fetchAllData])

  return {
    regions,
    businessUnits,
    countries,
    roleTemplates,
    isLoading,
    error,
    getCountriesForRegion,
    getMarketsForRegion,
    getCountriesForMarket,
    refetch
  }
}
===ENDFILE

===FILE: src/hooks/common/__tests__/use-toast.test.ts
// @vitest-environment jsdom
import { describe, expect, it, vi, beforeEach, afterEach } from 'vitest'
import { renderHook, act } from '@testing-library/react'
import { render, screen } from '@testing-library/react'
import React from 'react'
import { ToastProvider, useToast } from '../use-toast'

vi.mock('../../../components/ui/toast', () => ({
  Toast: ({ id, title, description, onClose }: { id: string; title?: string; description?: string; onClose?: () => void }) =>
    React.createElement('div', { 'data-testid': `toast-${id}`, 'data-title': title, 'data-description': description },
      title,
      onClose ? React.createElement('button', { onClick: onClose, 'data-testid': `close-${id}` }, 'close') : null
    ),
  ToastContainer: ({ children }: { children: React.ReactNode }) =>
    React.createElement('div', { 'data-testid': 'toast-container' }, children)
}))

function wrapper({ children }: { children: React.ReactNode }) {
  return React.createElement(ToastProvider, null, children)
}

describe('useToast', () => {
  beforeEach(() => {
    vi.useFakeTimers()
  })

  afterEach(() => {
    vi.useRealTimers()
  })

  it('throws when used outside ToastProvider', () => {
    expect(() => {
      renderHook(() => useToast())
    }).toThrow('useToast must be used within ToastProvider')
  })

  it('returns notify and dismiss functions', () => {
    const { result } = renderHook(() => useToast(), { wrapper })
    expect(typeof result.current.notify).toBe('function')
    expect(typeof result.current.dismiss).toBe('function')
  })

  it('creates a toast on notify', () => {
    const { result } = renderHook(() => useToast(), { wrapper })

    act(() => {
      result.current.notify({ title: 'Test Toast', variant: 'success' })
    })

    // The toast should be rendered (we can check via the container)
    expect(result.current).toBeDefined()
  })

  it('auto-dismisses info toast after default duration', () => {
    const { result } = renderHook(() => useToast(), { wrapper })

    act(() => {
      result.current.notify({ title: 'Info Toast', variant: 'info' })
    })

    act(() => {
      vi.advanceTimersByTime(3000)
    })

    // After 3000ms, info toast should be auto-dismissed
    expect(result.current).toBeDefined()
  })

  it('auto-dismisses success toast after 2500ms', () => {
    const { result } = renderHook(() => useToast(), { wrapper })

    act(() => {
      result.current.notify({ title: 'Success', variant: 'success' })
    })

    act(() => {
      vi.advanceTimersByTime(2500)
    })

    expect(result.current).toBeDefined()
  })

  it('auto-dismisses warning toast after 4000ms', () => {
    const { result } = renderHook(() => useToast(), { wrapper })

    act(() => {
      result.current.notify({ title: 'Warning', variant: 'warning' })
    })

    act(() => {
      vi.advanceTimersByTime(4000)
    })

    expect(result.current).toBeDefined()
  })

  it('auto-dismisses error toast after 4000ms', () => {
    const { result } = renderHook(() => useToast(), { wrapper })

    act(() => {
      result.current.notify({ title: 'Error', variant: 'error' })
    })

    act(() => {
      vi.advanceTimersByTime(4000)
    })

    expect(result.current).toBeDefined()
  })

  it('auto-dismisses critical toast after 5000ms', () => {
    const { result } = renderHook(() => useToast(), { wrapper })

    act(() => {
      result.current.notify({ title: 'Critical', variant: 'critical' })
    })

    act(() => {
      vi.advanceTimersByTime(5000)
    })

    expect(result.current).toBeDefined()
  })

  it('uses custom duration when provided', () => {
    const { result } = renderHook(() => useToast(), { wrapper })

    act(() => {
      result.current.notify({ title: 'Custom', variant: 'info', duration: 1000 })
    })

    act(() => {
      vi.advanceTimersByTime(1000)
    })

    expect(result.current).toBeDefined()
  })

  it('does not auto-dismiss persistent toast', () => {
    const { result } = renderHook(() => useToast(), { wrapper })

    act(() => {
      result.current.notify({ title: 'Persistent', variant: 'info', persistent: true })
    })

    act(() => {
      vi.advanceTimersByTime(10000)
    })

    // Toast should still be there since it is persistent
    expect(result.current).toBeDefined()
  })

  it('defaults variant to info when not provided', () => {
    const { result } = renderHook(() => useToast(), { wrapper })

    act(() => {
      result.current.notify({ title: 'Default variant' })
    })

    // Should use 'info' default duration (3000ms)
    act(() => {
      vi.advanceTimersByTime(3000)
    })

    expect(result.current).toBeDefined()
  })

  it('dismiss removes a toast by id', () => {
    const { result } = renderHook(() => useToast(), { wrapper })

    act(() => {
      result.current.notify({ title: 'To Dismiss', variant: 'info', persistent: true })
    })

    // We need to get the ID somehow -- since we can't easily,
    // just exercise the dismiss path with a made-up id
    act(() => {
      result.current.dismiss('nonexistent-id')
    })

    expect(result.current).toBeDefined()
  })

  it('replaces toast with same metaKey', () => {
    const { result } = renderHook(() => useToast(), { wrapper })

    act(() => {
      result.current.notify({ title: 'First', variant: 'info', metaKey: 'loading' })
    })

    act(() => {
      result.current.notify({ title: 'Second', variant: 'success', metaKey: 'loading' })
    })

    // First toast should be dismissed and replaced by second
    expect(result.current).toBeDefined()
  })

  it('handles notify without metaKey', () => {
    const { result } = renderHook(() => useToast(), { wrapper })

    act(() => {
      result.current.notify({ title: 'No Meta', variant: 'info' })
    })

    act(() => {
      result.current.notify({ title: 'Another', variant: 'info' })
    })

    // Both should exist since no metaKey dedup
    expect(result.current).toBeDefined()
  })
})

describe('ToastProvider', () => {
  it('renders children', () => {
    render(
      React.createElement(ToastProvider, null,
        React.createElement('div', { 'data-testid': 'child' }, 'Hello')
      )
    )
    expect(screen.getByTestId('child')).toBeInTheDocument()
  })

  it('renders toast container', () => {
    render(
      React.createElement(ToastProvider, null,
        React.createElement('div', null, 'Content')
      )
    )
    expect(screen.getByTestId('toast-container')).toBeInTheDocument()
  })
})
===ENDFILE

===FILE: src/hooks/common/use-toast.tsx
import React, { createContext, useContext, useState, useCallback, useRef } from 'react'
import { Toast, ToastContainer, ToastProps, ToastVariant } from '../../components/ui/toast'

interface ToastContextValue {
  notify: (props: Omit<ToastProps, 'id' | 'onClose'>) => void
  dismiss: (id: string) => void
}

const ToastContext = createContext<ToastContextValue | null>(null)

const DEFAULT_DURATIONS: Record<ToastVariant, number> = {
  info: 3000,
  success: 2500,
  warning: 4000,
  error: 4000,
  critical: 5000
}

export function ToastProvider({ children }: Readonly<{ children: React.ReactNode }>) {
  const [toasts, setToasts] = useState<ToastProps[]>([])
  const timersRef = useRef<Map<string, number>>(new Map())
  const metaKeyIndexRef = useRef<Map<string, string>>(new Map())
  const idToMetaKeyRef = useRef<Map<string, string>>(new Map())
 
  const clearTimer = useCallback((id: string) => {
    const timeoutId = timersRef.current.get(id)
    if (!timeoutId) return
    globalThis.clearTimeout(timeoutId)
    timersRef.current.delete(id)
  }, [])

  const clearMetaKey = useCallback((id: string) => {
    const metaKey = idToMetaKeyRef.current.get(id)
    if (!metaKey) return
    metaKeyIndexRef.current.delete(metaKey)
    idToMetaKeyRef.current.delete(id)
  }, [])

  const dismiss = useCallback((id: string) => {
    setToasts((prev) => prev.filter((t) => t.id !== id))
    clearTimer(id)
    clearMetaKey(id)
  }, [clearTimer, clearMetaKey])

  const resolveDuration = (props: Omit<ToastProps, 'id' | 'onClose'>): number | undefined => {
    if (props.persistent) return undefined
    return props.duration ?? DEFAULT_DURATIONS[props.variant ?? 'info']
  }

  const registerMetaKey = (id: string, metaKey: string | undefined) => {
    if (!metaKey) return
    metaKeyIndexRef.current.set(metaKey, id)
    idToMetaKeyRef.current.set(id, metaKey)
  }

  const scheduleAutoDismiss = (id: string, duration: number | undefined) => {
    if (!duration) return
    timersRef.current.set(id, globalThis.setTimeout(() => dismiss(id), duration))
  }

  const notify = useCallback((props: Omit<ToastProps, 'id' | 'onClose'>) => {
    const existingId = props.metaKey ? metaKeyIndexRef.current.get(props.metaKey) : undefined
    if (existingId) dismiss(existingId)

    const id = `${Date.now()}-${Math.random().toString(16).slice(2)}`
    const variant: ToastVariant = props.variant ?? 'info'
    setToasts((prev) => [...prev, { ...props, id, onClose: () => dismiss(id), variant }])

    registerMetaKey(id, props.metaKey)
    scheduleAutoDismiss(id, resolveDuration(props))
  }, [dismiss])
  
  const contextValue = React.useMemo(() => ({ notify, dismiss }), [notify, dismiss])

  return (
    <ToastContext.Provider value={contextValue}>
      {children}
      <ToastContainer>
        {toasts.map((toastProps) => (
          <Toast key={toastProps.id} {...toastProps} />
        ))}
      </ToastContainer>
    </ToastContext.Provider>
  )
}

export function useToast() {
  const context = useContext(ToastContext)
  if (!context) {
    throw new Error('useToast must be used within ToastProvider')
  }
  return context
}
===ENDFILE

===FILE: src/hooks/features/__tests__/use-business-terminology.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('react', () => ({
  useMemo: (fn: () => unknown) => fn()
}))

const { useBusinessRoles, useBusinessStatus, getBusinessField } = await import('../use-business-terminology')

describe('useBusinessRoles', () => {
  it('returns all expected role keys', () => {
    const roles = useBusinessRoles()
    expect(roles).toHaveProperty('voice_agent')
    expect(roles).toHaveProperty('chat_agent')
    expect(roles).toHaveProperty('supervisor')
    expect(roles).toHaveProperty('admin')
    expect(roles).toHaveProperty('maker')
    expect(roles).toHaveProperty('checker')
    expect(roles).toHaveProperty('super_admin')
  })

  it('each role has displayName, description, category', () => {
    const roles = useBusinessRoles()
    for (const role of Object.values(roles)) {
      expect(role).toHaveProperty('displayName')
      expect(role).toHaveProperty('description')
      expect(role).toHaveProperty('category')
    }
  })

  it('assigns correct categories', () => {
    const roles = useBusinessRoles()
    expect(roles.voice_agent.category).toBe('Agent')
    expect(roles.supervisor.category).toBe('Management')
    expect(roles.admin.category).toBe('Administration')
    expect(roles.maker.category).toBe('Approval Workflow')
  })
})

describe('useBusinessStatus', () => {
  it('returns all expected status keys', () => {
    const statuses = useBusinessStatus()
    expect(statuses).toHaveProperty('active')
    expect(statuses).toHaveProperty('disabled')
    expect(statuses).toHaveProperty('needs_setup')
    expect(statuses).toHaveProperty('pending')
  })

  it('each status has label, description, variant', () => {
    const statuses = useBusinessStatus()
    for (const status of Object.values(statuses)) {
      expect(status).toHaveProperty('label')
      expect(status).toHaveProperty('variant')
    }
  })

  it('assigns correct variants', () => {
    const statuses = useBusinessStatus()
    expect(statuses.active.variant).toBe('success')
    expect(statuses.disabled.variant).toBe('error')
    expect(statuses.needs_setup.variant).toBe('warning')
    expect(statuses.pending.variant).toBe('info')
  })
})

describe('getBusinessField', () => {
  it('returns mapped business name for known fields', () => {
    expect(getBusinessField('groupName')).toBe('Team Group')
    expect(getBusinessField('role')).toBe('Role')
    expect(getBusinessField('userCount')).toBe('Members')
    expect(getBusinessField('businessUnit')).toBe('Department')
  })

  it('returns original field name for unknown fields', () => {
    expect(getBusinessField('someRandomField')).toBe('someRandomField')
  })
})
===ENDFILE

===FILE: src/hooks/features/__tests__/use-dropdown-options.test.ts
import { beforeEach, describe, expect, it, vi } from 'vitest'

const mockUseReferenceData = vi.fn(() => ({
  roleTemplates: [] as Array<{ roleNameCode: string; roleDisplayName: string }>
}))

vi.mock('react', () => ({
  useMemo: (fn: () => unknown) => fn()
}))

vi.mock('../../api/use-reference-data', () => ({
  useReferenceData: () => mockUseReferenceData()
}))

const { useDropdownOptions } = await import('../use-dropdown-options')

describe('useDropdownOptions', () => {
  beforeEach(() => {
    mockUseReferenceData.mockReturnValue({ roleTemplates: [] })
  })

  it('returns API roles and filters admin role', () => {
    mockUseReferenceData.mockReturnValue({
      roleTemplates: [
        { roleNameCode: 'chat_agent', roleDisplayName: 'Chat Agent' },
        { roleNameCode: 'admin', roleDisplayName: 'Administrator' },
        { roleNameCode: 'voice_agent', roleDisplayName: 'Voice Agent' }
      ]
    })

    const options = useDropdownOptions()
    expect(options.roles).toHaveLength(2)
    expect(options.roles.map(r => r.value)).toEqual(['chat_agent', 'voice_agent'])
  })

  it('falls back to static roles when API roles are unavailable', () => {
    mockUseReferenceData.mockReturnValue({ roleTemplates: [] })

    const options = useDropdownOptions()
    expect(options.roles).toHaveLength(3)
    expect(options.roles.map(r => r.value)).toEqual(['chat_agent', 'voice_agent', 'supervisor'])
  })

  it('returns empty markets array', () => {
    const options = useDropdownOptions()
    expect(options.markets).toEqual([])
  })

  it('returns regions dropdown options', () => {
    const options = useDropdownOptions()
    expect(options.regions).toHaveLength(3)
    expect(options.regions.map(r => r.value)).toEqual(['EMEA', 'AMER', 'APAC'])
  })

  it('returns businessUnits dropdown options', () => {
    const options = useDropdownOptions()
    expect(options.businessUnits.length).toBeGreaterThan(0)
    expect(options.businessUnits[0]).toHaveProperty('value')
    expect(options.businessUnits[0]).toHaveProperty('label')
  })

  it('returns countries dropdown options', () => {
    const options = useDropdownOptions()
    expect(options.countries.length).toBeGreaterThan(0)
    expect(options.countries.map(c => c.value)).toContain('United Kingdom')
    expect(options.countries.map(c => c.value)).toContain('United States')
  })
})
===ENDFILE

===FILE: src/hooks/features/__tests__/use-feature-mapping.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('react', () => ({
  useCallback: (fn: unknown) => fn
}))

const { useExtractEnabledFeatures } = await import('../use-feature-mapping')

describe('useExtractEnabledFeatures', () => {
  const extract = useExtractEnabledFeatures()

  it('returns empty array for empty template', () => {
    expect(extract({})).toEqual([])
  })

  it('extracts enabled features from columns', () => {
    const result = extract({
      columns: {
        kms: { state: 'enabled' },
        customer: { state: 'enabled' }
      }
    })
    expect(result).toContain('Knowledge Base')
    expect(result).toContain('Customer Info')
  })

  it('ignores disabled features', () => {
    const result = extract({
      columns: {
        kms: { state: 'disabled' },
        customer: { state: 'enabled' }
      }
    })
    expect(result).not.toContain('Knowledge Base')
    expect(result).toContain('Customer Info')
  })

  it('ignores unmapped feature keys', () => {
    const result = extract({
      columns: {
        unknownKey: { state: 'enabled' }
      }
    })
    expect(result).toEqual([])
  })

  it('extracts from multiple categories', () => {
    const result = extract({
      columns: { kms: { state: 'enabled' } },
      widgets: { embeddedApps: { state: 'enabled' } },
      features: { 'search.knowledgeBase': { state: 'enabled' } }
    })
    expect(result).toContain('Knowledge Base')
    expect(result).toContain('Banking Tools')
    expect(result).toContain('Knowledge Search')
  })

  it('returns sorted, unique results', () => {
    const result = extract({
      columns: { kms: { state: 'enabled' } },
      widgets: { kms: { state: 'enabled' } }
    })
    // 'kms' from both categories but same label
    expect(result.filter(f => f === 'Knowledge Base')).toHaveLength(1)
    // Result should be sorted
    const sorted = [...result].sort()
    expect(result).toEqual(sorted)
  })
})
===ENDFILE

===FILE: src/hooks/features/__tests__/use-notice-config.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('react', () => ({
  useMemo: (fn: () => unknown) => fn()
}))

vi.mock('lucide-react', () => ({
  Bell: 'Bell',
  Info: 'Info',
  CircleCheck: 'CircleCheck',
  TriangleAlert: 'TriangleAlert',
  CircleX: 'CircleX',
  OctagonAlert: 'OctagonAlert'
}))

const { useNoticeSeverities, useTargetRoles } = await import('../use-notice-config')

describe('useNoticeSeverities', () => {
  it('returns 5 severity options', () => {
    const severities = useNoticeSeverities()
    expect(severities).toHaveLength(5)
  })

  it('each severity has value, label, icon', () => {
    const severities = useNoticeSeverities()
    for (const s of severities) {
      expect(s).toHaveProperty('value')
      expect(s).toHaveProperty('label')
      expect(s).toHaveProperty('icon')
    }
  })

  it('includes expected severity values', () => {
    const severities = useNoticeSeverities()
    const values = severities.map(s => s.value)
    expect(values).toEqual(['INFO', 'SUCCESS', 'WARNING', 'ERROR', 'CRITICAL'])
  })
})

describe('useTargetRoles', () => {
  it('returns 3 role options', () => {
    const roles = useTargetRoles()
    expect(roles).toHaveLength(3)
  })

  it('includes expected role values', () => {
    const roles = useTargetRoles()
    const values = roles.map(r => r.value)
    expect(values).toEqual(['supervisor', 'chat_agent', 'voice_agent'])
  })
})
===ENDFILE

===FILE: src/hooks/features/__tests__/use-notifications.test.ts
import { describe, expect, it, vi } from 'vitest'

const mockNotify = vi.fn()
const mockDismiss = vi.fn()

vi.mock('../../common/use-toast', () => ({
  useToast: () => ({
    notify: mockNotify,
    dismiss: mockDismiss
  })
}))

vi.mock('react', () => ({
  useCallback: (fn: (...args: unknown[]) => unknown) => fn,
  useMemo: (fn: () => unknown) => fn()
}))

const { useNotifications } = await import('../use-notifications')

describe('useNotifications', () => {
  it('returns all notification methods', () => {
    const n = useNotifications()
    expect(n).toHaveProperty('push')
    expect(n).toHaveProperty('dismiss')
    expect(n).toHaveProperty('success')
    expect(n).toHaveProperty('error')
    expect(n).toHaveProperty('warning')
    expect(n).toHaveProperty('info')
    expect(n).toHaveProperty('critical')
  })

  it('success calls notify with success variant', () => {
    const n = useNotifications()
    n.success({ title: 'Done' })
    expect(mockNotify).toHaveBeenCalledWith({ title: 'Done', variant: 'success' })
  })

  it('error calls notify with error variant', () => {
    const n = useNotifications()
    n.error({ title: 'Failed', description: 'Something went wrong' })
    expect(mockNotify).toHaveBeenCalledWith({ title: 'Failed', description: 'Something went wrong', variant: 'error' })
  })

  it('warning calls notify with warning variant', () => {
    const n = useNotifications()
    n.warning({ title: 'Caution' })
    expect(mockNotify).toHaveBeenCalledWith({ title: 'Caution', variant: 'warning' })
  })

  it('info calls notify with info variant', () => {
    const n = useNotifications()
    n.info({ title: 'Note' })
    expect(mockNotify).toHaveBeenCalledWith({ title: 'Note', variant: 'info' })
  })

  it('critical calls notify with critical variant', () => {
    const n = useNotifications()
    n.critical({ title: 'Alert' })
    expect(mockNotify).toHaveBeenCalledWith({ title: 'Alert', variant: 'critical' })
  })

  it('dismiss is exposed', () => {
    const n = useNotifications()
    expect(n.dismiss).toBe(mockDismiss)
  })
})
===ENDFILE

===FILE: src/hooks/features/use-business-terminology.ts
import { useMemo } from 'react'

interface BusinessRole {
  displayName: string
  description: string
  category: string
}

interface BusinessStatus {
  label: string
  description: string
  variant: 'success' | 'warning' | 'error' | 'info'
}

const CATEGORY_APPROVAL_WORKFLOW = 'Approval Workflow'

/** Returns a memoized map of role codes to their business display names and categories. */
export function useBusinessRoles(): Record<string, BusinessRole> {
  return useMemo(() => {
    return {
      voice_agent: {
        displayName: 'Voice Agent',
        description: '',
        category: 'Agent'
      },
      chat_agent: {
        displayName: 'Chat Agent',
        description: '',
        category: 'Agent'
      },
      agent: {
        displayName: 'Agent',
        description: '',
        category: 'Agent'
      },
      supervisor: {
        displayName: 'Supervisor',
        description: '',
        category: 'Management'
      },
      manager: {
        displayName: 'Manager',
        description: '',
        category: 'Management'
      },
      admin: {
        displayName: 'Administrator',
        description: '',
        category: 'Administration'
      },
      maker: {
        displayName: 'Maker',
        description: '',
        category: CATEGORY_APPROVAL_WORKFLOW
      },
      checker: {
        displayName: 'Checker',
        description: '',
        category: CATEGORY_APPROVAL_WORKFLOW
      },
      super_admin: {
        displayName: 'Super Admin',
        description: '',
        category: CATEGORY_APPROVAL_WORKFLOW
      }
    }
  }, [])
}

/** Returns a memoized map of status codes to their business labels and visual variants. */
export function useBusinessStatus(): Record<string, BusinessStatus> {
  return useMemo(() => {
    return {
      active: {
        label: 'Enabled',
        description: '',
        variant: 'success' as const
      },
      disabled: {
        label: 'Disabled',
        description: '',
        variant: 'error' as const
      },
      needs_setup: {
        label: 'Configuration Required',
        description: '',
        variant: 'warning' as const
      },
      pending: {
        label: 'Pending Setup',
        description: '',
        variant: 'info' as const
      }
    }
  }, [])
}

// Internal field labels (used only by getBusinessField)
const businessFields: Record<string, string> = {
  groupName: 'Team Group',
  role: 'Role',
  location: 'Location',
  users: 'Members',
  userCount: 'Members',
  status: 'Status',
  lastModified: 'Last Updated',
  businessUnit: 'Department',
  actions: 'Manage',
  groupIdentifier: 'Group Identifier',
  logicalName: 'Group Name',
  roleName: 'Role',
  market: 'Market',
  region: 'Region',
  country: 'Country',
  isActive: 'Active Status',
  searchPlaceholder: 'Search team groups...',
  allRoles: 'All Roles',
  allStatus: 'All Status',
  allMarkets: 'All Markets',
  allRegions: 'All Regions',
  allCountries: 'All Countries',
  allBusinessUnits: 'All Departments'
}

/** Maps a technical field name to its user-facing business label. Falls back to the raw field name. */
export const getBusinessField = (technicalField: string): string => {
  return businessFields[technicalField] || technicalField
}
===ENDFILE

===FILE: src/hooks/features/use-dropdown-options.ts
import { useMemo } from 'react'
import { useReferenceData } from '../api/use-reference-data'
import type { RoleTemplateSummaryDto } from '../../services/api/role-template.service'

interface DropdownOption {
  value: string
  label: string
}

interface DropdownOptions {
  roles: DropdownOption[]
  markets: DropdownOption[]
  regions: DropdownOption[]
  businessUnits: DropdownOption[]
  countries: DropdownOption[]
}

interface UseDropdownOptionsParams {
  roleTemplates?: RoleTemplateSummaryDto[]
}

/**
 * Provides memoized dropdown option arrays for roles, markets, regions, business units,
 * and countries. Roles are derived from API role templates with a static fallback.
 */
export function useDropdownOptions(params: UseDropdownOptionsParams = {}): DropdownOptions {
  const { roleTemplates } = useReferenceData()
  const resolvedRoleTemplates = params.roleTemplates ?? roleTemplates

  const roles = useMemo(() => {
    const apiRoles = resolvedRoleTemplates
      .filter(template => template.roleNameCode.toLowerCase() !== 'admin')
      .map(template => ({
        value: template.roleNameCode,
        label: template.roleDisplayName || template.roleNameCode
      }))

    if (apiRoles.length > 0) {
      return apiRoles
    }

    return [
      { value: 'chat_agent', label: 'Chat Agent' },
      { value: 'voice_agent', label: 'Voice Agent' },
      { value: 'supervisor', label: 'Supervisor' }
    ]
  }, [resolvedRoleTemplates])

  return useMemo(() => ({
    roles,
    markets: [],
    regions: [
      { value: 'EMEA', label: 'EMEA' },
      { value: 'AMER', label: 'Americas' },
      { value: 'APAC', label: 'Asia Pacific' }
    ],
    businessUnits: [
      { value: 'Retail Banking', label: 'Retail Banking' },
      { value: 'Commercial Banking', label: 'Commercial Banking' },
      { value: 'Investment Banking', label: 'Investment Banking' },
      { value: 'Private Banking', label: 'Private Banking' },
      { value: 'IT Services', label: 'IT Services' }
    ],
    countries: [
      { value: 'United Kingdom', label: 'United Kingdom' },
      { value: 'United States', label: 'United States' },
      { value: 'Canada', label: 'Canada' },
      { value: 'Australia', label: 'Australia' },
      { value: 'Germany', label: 'Germany' },
      { value: 'France', label: 'France' }
    ]
  }), [roles])
}
===ENDFILE

===FILE: src/hooks/features/use-feature-mapping.ts
import { useCallback } from 'react'

/**
 * Returns a memoized callback that extracts business-relevant feature names from a role template.
 * Scans all permission categories and maps technical keys to user-friendly labels
 * (e.g., 'kms' -> 'Knowledge Base', 'spaceCopilot' -> 'AI Assistant').
 */
const IMPORTANT_FEATURES: Record<string, string> = {
  'kms': 'Knowledge Base',
  'customer': 'Customer Info',
  'embeddedApps': 'Banking Tools',
  'spaceCopilot': 'AI Assistant',
  'header.layoutManager': 'Layout Customization',
  'search.knowledgeBase': 'Knowledge Search',
  'search.embeddedApps': 'Application Search',
  'mediaBar.callControls': 'Call Controls',
  'supervisor.teamStatus': 'Team Monitor',
  'calls': 'Call Management',
  'calls.autoAccept': 'Auto Accept Calls'
}

const CATEGORIES = ['columns', 'widgets', 'features', 'settingsTabs', 'settingsOptions', 'microFrontends']

function isEnabled(value: unknown): boolean {
  return (value as { state?: string })?.state === 'enabled'
}

export function useExtractEnabledFeatures() {
  return useCallback((roleTemplate: Record<string, unknown>): string[] => {
    const labels = new Set<string>()

    for (const category of CATEGORIES) {
      const section = roleTemplate[category] as Record<string, unknown> | undefined
      if (!section) continue
      for (const [key, value] of Object.entries(section)) {
        const label = IMPORTANT_FEATURES[key]
        if (label && isEnabled(value)) labels.add(label)
      }
    }

    return [...labels].sort((a, b) => a.localeCompare(b))
  }, [])
}
===ENDFILE

===FILE: src/hooks/features/use-notice-config.ts
import { useMemo } from 'react'
import { Info, CircleCheck, TriangleAlert, CircleX, OctagonAlert, type LucideIcon } from 'lucide-react'

interface SeverityOption {
  value: string
  label: string
  icon: LucideIcon
}

interface RoleOption {
  value: string
  label: string
}

/** Returns the list of available notice severity options with labels and icons. */
export function useNoticeSeverities() {
  return useMemo<readonly SeverityOption[]>(() => [
    { value: 'INFO', label: 'Information', icon: Info },
    { value: 'SUCCESS', label: 'Success', icon: CircleCheck },
    { value: 'WARNING', label: 'Warning', icon: TriangleAlert },
    { value: 'ERROR', label: 'Error', icon: CircleX },
    { value: 'CRITICAL', label: 'Critical', icon: OctagonAlert }
  ] as const, [])
}

/** Returns the list of roles available for notice targeting. */
export function useTargetRoles() {
  return useMemo<readonly RoleOption[]>(() => [
    { value: 'supervisor', label: 'Supervisor' },
    { value: 'chat_agent', label: 'Chat Agent' },
    { value: 'voice_agent', label: 'Voice Agent' }
  ] as const, [])
}

export { Bell } from 'lucide-react'
===ENDFILE

===FILE: src/hooks/features/use-notifications.ts
import { useCallback, useMemo } from 'react'
import { useToast } from '../common/use-toast'
import type { ToastVariant } from '../../components/ui/toast'

interface NotificationParams {
  title: string
  description?: string
  action?: React.ReactNode
  duration?: number
  persistent?: boolean
  metaKey?: string
}

/**
 * Provides typed notification helpers (success, error, warning, info, critical)
 * wrapping the underlying toast system. Memoized for stable references.
 */
export function useNotifications() {
  const { notify, dismiss } = useToast()

  const push = useCallback((variant: ToastVariant, params: NotificationParams) => {
    notify({ ...params, variant })
  }, [notify])

  return useMemo(() => ({
    push,
    dismiss,
    success: (params: NotificationParams) => push('success', params),
    error: (params: NotificationParams) => push('error', params),
    warning: (params: NotificationParams) => push('warning', params),
    info: (params: NotificationParams) => push('info', params),
    critical: (params: NotificationParams) => push('critical', params)
  }), [dismiss, push])
}
===ENDFILE

===FILE: src/index.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  .admin-mfe-root {
    --background: 0 0% 100%;
    --foreground: 0 0% 13%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 13%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 13%;
    --primary: 356 100% 43%;
    --primary-foreground: 0 0% 100%;
    --secondary: 0 0% 96%;
    --secondary-foreground: 0 0% 13%;
    --muted: 0 0% 96%;
    --muted-foreground: 0 0% 45%;
    --accent: 356 100% 43%;
    --accent-foreground: 0 0% 100%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89%;
    --input: 0 0% 89%;
    --ring: 356 100% 43%;
    --radius: 0.375rem;

    /* Sidebar */
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 0 0% 13%;
    --sidebar-accent: 0 0% 94%;
    --sidebar-accent-foreground: 0 0% 13%;

    /* Status Colors */
    --status-pending: 45 93% 47%;
    --status-approved: 142 71% 45%;
    --status-rejected: 0 84% 60%;

    background-color: hsl(var(--background));
    color: hsl(var(--foreground));
    font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    -webkit-font-smoothing: antialiased;
    height: 100%;
    width: 100%;
    min-height: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .admin-mfe-root.dark,
  .dark .admin-mfe-root {
    --background: 0 0% 9%;
    --foreground: 0 0% 95%;
    --card: 0 0% 12%;
    --card-foreground: 0 0% 95%;
    --popover: 0 0% 9%;
    --popover-foreground: 0 0% 95%;
    --primary: 356 100% 43%;
    --primary-foreground: 0 0% 100%;
    --secondary: 0 0% 17%;
    --secondary-foreground: 0 0% 95%;
    --muted: 0 0% 17%;
    --muted-foreground: 0 0% 65%;
    --accent: 356 100% 43%;
    --accent-foreground: 0 0% 100%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 17%;
    --input: 0 0% 17%;
    --ring: 356 100% 43%;

    /* Sidebar Dark */
    --sidebar-background: 0 0% 7%;
    --sidebar-foreground: 0 0% 95%;
    --sidebar-accent: 0 0% 15%;
    --sidebar-accent-foreground: 0 0% 95%;
  }
}

@layer utilities {
  .admin-mfe-root .scrollbar-visible {
    scrollbar-width: thin;
    scrollbar-color: hsl(var(--border)) transparent;
  }

  .admin-mfe-root .scrollbar-visible::-webkit-scrollbar {
    width: 10px;
    height: 10px;
  }

  .admin-mfe-root .scrollbar-visible::-webkit-scrollbar-thumb {
    background-color: hsl(var(--border));
    border: 2px solid transparent;
    border-radius: 9999px;
    background-clip: padding-box;
  }

  .admin-mfe-root .scrollbar-visible::-webkit-scrollbar-track {
    background-color: transparent;
    border-radius: 9999px;
  }
}
===ENDFILE

===FILE: src/index.ts
export { AdminMFE, default } from './AdminMFE'
export type {
  AdminMFEProps,
  AdminPermissions,
  AdminView,
  ErrorInfo,
  RoleTemplate,
  AdGroup,
  PendingApproval,
  SystemNotice
} from './types'
===ENDFILE

===FILE: src/lib/__tests__/query-client.test.ts
import { describe, it, expect } from 'vitest'
import { queryClient } from '../query-client'

describe('queryClient', () => {
  it('is a QueryClient instance', () => {
    expect(queryClient).toBeDefined()
    expect(typeof queryClient.getDefaultOptions).toBe('function')
  })

  it('has default staleTime of 5 minutes', () => {
    const options = queryClient.getDefaultOptions()
    expect(options.queries?.staleTime).toBe(5 * 60 * 1000)
  })

  it('has default gcTime of 15 minutes', () => {
    const options = queryClient.getDefaultOptions()
    expect(options.queries?.gcTime).toBe(15 * 60 * 1000)
  })

  it('enables refetchOnWindowFocus by default', () => {
    const options = queryClient.getDefaultOptions()
    expect(options.queries?.refetchOnWindowFocus).toBe(true)
  })

  it('enables refetchOnReconnect by default', () => {
    const options = queryClient.getDefaultOptions()
    expect(options.queries?.refetchOnReconnect).toBe(true)
  })

  it('sets default retry count to 2', () => {
    const options = queryClient.getDefaultOptions()
    expect(options.queries?.retry).toBe(2)
  })

  it('has entitlements query defaults with shorter staleTime', () => {
    const defaults = queryClient.getQueryDefaults(['entitlements'])
    expect(defaults.staleTime).toBe(2 * 60 * 1000)
  })

  it('has entitlements query defaults with retry of 1', () => {
    const defaults = queryClient.getQueryDefaults(['entitlements'])
    expect(defaults.retry).toBe(1)
  })

  it('disables refetchOnWindowFocus for entitlements', () => {
    const defaults = queryClient.getQueryDefaults(['entitlements'])
    expect(defaults.refetchOnWindowFocus).toBe(false)
  })

  it('sets entitlements gcTime to 15 minutes', () => {
    const defaults = queryClient.getQueryDefaults(['entitlements'])
    expect(defaults.gcTime).toBe(15 * 60 * 1000)
  })
})
===ENDFILE

===FILE: src/lib/query-client.ts
/**
 * Shared React Query client for the Admin MFE.
 * Default stale time: 5 minutes, GC time: 15 minutes.
 * Entitlements queries have a shorter stale time (2 minutes) and no refetch on focus.
 */
import { QueryClient } from '@tanstack/react-query'

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,
      gcTime: 15 * 60 * 1000,
      refetchOnWindowFocus: true,
      refetchOnReconnect: true,
      retry: 2
    }
  }
})

queryClient.setQueryDefaults(['entitlements'], {
  staleTime: 2 * 60 * 1000,
  gcTime: 15 * 60 * 1000,
  retry: 1,
  refetchOnWindowFocus: false
})
===ENDFILE

===FILE: src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

/**
 * Merges Tailwind CSS class names with conflict resolution.
 * Combines clsx (conditional classes) with tailwind-merge (deduplication).
 * @param inputs - Class values, arrays, or conditional objects
 * @returns Merged class string with Tailwind conflicts resolved
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
===ENDFILE

===FILE: src/main.tsx
/**
 * Admin MFE - Main entry point
 * For standalone development and testing
 */

import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'

import { AdminMFE } from './AdminMFE'
import type { AdminPermissions } from './types'
import { createLogger } from './utils/core/debug'

const logger = createLogger('AdminMFE:Dev')

;(globalThis as { __ADMIN_MFE_BASE_PATH__?: string }).__ADMIN_MFE_BASE_PATH__ = ''

// Mock permissions for development
const mockPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

// Mock props for development
const mockProps = {
  authToken: 'ADMIN_GLOBAL_DEMO',
  language: 'en' as const,
  permissions: mockPermissions,
  onNavigate: (path: string) => {
    logger.info('Navigate to:', path)
  },
  onError: (error: { code: string; message: string; context?: Record<string, unknown> }) => {
    logger.error('Error:', error)
  }
}

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <div className="h-screen flex flex-col">
      <header className="h-12 bg-primary text-primary-foreground flex items-center px-4">
        <h1 className="text-lg font-semibold">Admin MFE - Development Mode</h1>
      </header>
      <div className="flex-1 overflow-hidden">
        <AdminMFE {...mockProps} />
      </div>
    </div>
  </React.StrictMode>
)
===ENDFILE

===FILE: src/services/__tests__/mock-data.test.ts
import { describe, expect, it } from 'vitest'
import {
  mockRoleTemplates,
  mockAdGroups,
  mockPendingApprovals,
  mockSystemNotices,
  delay,
  mockApi
} from '../mock-data'

describe('mock-data', () => {
  describe('static data exports', () => {
    it('exports role templates with expected shape', () => {
      expect(mockRoleTemplates).toHaveLength(4)
      expect(mockRoleTemplates[0]).toMatchObject({
        id: 'voice_agent',
        name: 'Voice Agent'
      })
      expect(mockRoleTemplates[0].permissions).toBeInstanceOf(Array)
      expect(mockRoleTemplates[0].widgets).toBeInstanceOf(Array)
    })

    it('exports AD groups with expected shape', () => {
      expect(mockAdGroups.length).toBeGreaterThan(0)
      expect(mockAdGroups[0]).toHaveProperty('id')
      expect(mockAdGroups[0]).toHaveProperty('distinguishedName')
      expect(mockAdGroups[0]).toHaveProperty('memberCount')
      expect(mockAdGroups[0]).toHaveProperty('isActive')
    })

    it('exports pending approvals with expected shape', () => {
      expect(mockPendingApprovals.length).toBeGreaterThan(0)
      expect(mockPendingApprovals[0]).toHaveProperty('id')
      expect(mockPendingApprovals[0]).toHaveProperty('type')
      expect(mockPendingApprovals[0]).toHaveProperty('status')
    })

    it('exports system notices with expected shape', () => {
      expect(mockSystemNotices.length).toBeGreaterThan(0)
      expect(mockSystemNotices[0]).toHaveProperty('id')
      expect(mockSystemNotices[0]).toHaveProperty('title')
      expect(mockSystemNotices[0]).toHaveProperty('type')
    })

    it('contains both active and inactive AD groups', () => {
      const active = mockAdGroups.filter(g => g.isActive)
      const inactive = mockAdGroups.filter(g => !g.isActive)
      expect(active.length).toBeGreaterThan(0)
      expect(inactive.length).toBeGreaterThan(0)
    })

    it('contains both active and inactive notices', () => {
      const active = mockSystemNotices.filter(n => n.isActive)
      const inactive = mockSystemNotices.filter(n => !n.isActive)
      expect(active.length).toBeGreaterThan(0)
      expect(inactive.length).toBeGreaterThan(0)
    })
  })

  describe('delay', () => {
    it('resolves after specified ms', async () => {
      const start = Date.now()
      await delay(10)
      const elapsed = Date.now() - start
      expect(elapsed).toBeGreaterThanOrEqual(5)
    })
  })

  describe('mockApi', () => {
    it('getRoleTemplates returns mock data', async () => {
      const result = await mockApi.getRoleTemplates()
      expect(result).toEqual(mockRoleTemplates)
    })

    it('getAdGroups returns mock data', async () => {
      const result = await mockApi.getAdGroups()
      expect(result).toEqual(mockAdGroups)
    })

    it('getPendingApprovals returns mock data', async () => {
      const result = await mockApi.getPendingApprovals()
      expect(result).toEqual(mockPendingApprovals)
    })

    it('getSystemNotices returns mock data', async () => {
      const result = await mockApi.getSystemNotices()
      expect(result).toEqual(mockSystemNotices)
    })

    it('approveChange returns success', async () => {
      const result = await mockApi.approveChange('pa-001')
      expect(result).toEqual({ success: true })
    })

    it('rejectChange returns success', async () => {
      const result = await mockApi.rejectChange('pa-001', 'invalid')
      expect(result).toEqual({ success: true })
    })

    it('createNotice returns notice with generated id', async () => {
      const result = await mockApi.createNotice({ title: 'Test', message: 'Msg' })
      expect(result.id).toContain('notice-')
      expect(result.createdBy).toBe('Current User')
    })

    it('updateNotice merges updates', async () => {
      const result = await mockApi.updateNotice('notice-001', { title: 'Updated' })
      expect(result.title).toBe('Updated')
      expect(result.id).toBe('notice-001')
    })

    it('toggleAdGroup returns success', async () => {
      const result = await mockApi.toggleAdGroup('adg-001', false)
      expect(result).toEqual({ success: true })
    })
  })
})
===ENDFILE

===FILE: src/services/api/__tests__/adgroup-mappers.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'

vi.mock('../../../utils/auth/auth-token-manager', () => ({
  getAuthToken: vi.fn()
}))

const { getAuthToken } = await import('../../../utils/auth/auth-token-manager')
const { ensureToken, toAssignmentMap, mapAdGroup, normalizeProposedState } = await import('../adgroup-mappers')

describe('ensureToken', () => {
  beforeEach(() => {
    vi.mocked(getAuthToken).mockReset()
  })

  it('returns token when present', () => {
    vi.mocked(getAuthToken).mockReturnValue('valid-token')
    expect(ensureToken()).toBe('valid-token')
  })

  it('throws when no token', () => {
    vi.mocked(getAuthToken).mockReturnValue(null)
    expect(() => ensureToken()).toThrow('No authentication token found')
  })
})

describe('toAssignmentMap', () => {
  it('returns undefined for undefined input', () => {
    expect(toAssignmentMap(undefined)).toBeUndefined()
  })

  it('converts enabledIndicator true to enabled state', () => {
    const result = toAssignmentMap({ chat: { enabledIndicator: true } })
    expect(result).toEqual({ chat: { state: 'enabled' } })
  })

  it('converts enabledIndicator false to disabled state', () => {
    const result = toAssignmentMap({ kms: { enabledIndicator: false } })
    expect(result).toEqual({ kms: { state: 'disabled' } })
  })

  it('handles missing enabledIndicator as disabled', () => {
    const result = toAssignmentMap({ email: {} })
    expect(result).toEqual({ email: { state: 'disabled' } })
  })
})

describe('mapAdGroup', () => {
  it('maps all fields from raw API response', () => {
    const raw = {
      groupIdentifier: 'CN=test-group',
      logicalName: 'Test Group',
      roleName: 'voice_agent',
      marketCode: 'US',
      regionCode: 'AMER',
      countryCode: 'US',
      businessUnitName: 'WPB',
      activeIndicator: true,
      userAccessCode: 'MAKER',
      pendingChangeIndicator: false,
      versionNumber: 2,
      userCountNumber: 50,
      updatedAtDatetime: '2026-01-15',
      currentConfig: {
        permissionChanges: {
          columnPermissions: { chat: { enabledIndicator: true } },
          widgetPermissions: { sentiment: { enabledIndicator: false } }
        }
      }
    }

    const result = mapAdGroup(raw)
    expect(result.id).toBe('CN=test-group')
    expect(result.groupIdentifier).toBe('CN=test-group')
    expect(result.logicalName).toBe('Test Group')
    expect(result.roleName).toBe('voice_agent')
    expect(result.market).toBe('US')
    expect(result.region).toBe('AMER')
    expect(result.country).toBe('US')
    expect(result.businessUnit).toBe('WPB')
    expect(result.isActive).toBe(true)
    expect(result.accessLevel).toBe('MAKER')
    expect(result.pendingChangeIndicator).toBe(false)
    expect(result.versionNumber).toBe(2)
    expect(result.userCount).toBe(50)
    expect(result.lastModified).toBe('2026-01-15')
    expect(result.columnAssignments).toEqual({ chat: { state: 'enabled' } })
    expect(result.widgetAssignments).toEqual({ sentiment: { state: 'disabled' } })
  })

  it('uses defaults for missing fields', () => {
    const result = mapAdGroup({})
    expect(result.id).toBe('')
    expect(result.groupIdentifier).toBe('')
    expect(result.isActive).toBe(true)
    expect(result.pendingChangeIndicator).toBe(false)
    expect(result.columnAssignments).toBeUndefined()
    expect(result.widgetAssignments).toBeUndefined()
  })

  it('handles missing currentConfig', () => {
    const result = mapAdGroup({ groupIdentifier: 'CN=g1' })
    expect(result.columnAssignments).toBeUndefined()
    expect(result.widgetAssignments).toBeUndefined()
  })

  it('handles missing permissionChanges in currentConfig', () => {
    const result = mapAdGroup({
      groupIdentifier: 'CN=g1',
      currentConfig: {}
    })
    expect(result.columnAssignments).toBeUndefined()
  })
})

describe('normalizeProposedState', () => {
  it('converts isActive to activeIndicator', () => {
    const result = normalizeProposedState({ isActive: true, logicalName: 'Test' })
    expect(result.activeIndicator).toBe(true)
    expect(result.isActive).toBeUndefined()
    expect(result.logicalName).toBe('Test')
  })

  it('strips undefined values', () => {
    const result = normalizeProposedState({ name: 'Test', region: undefined })
    expect(result).toEqual({ name: 'Test' })
    expect('region' in result).toBe(false)
  })

  it('does not convert non-boolean isActive', () => {
    const result = normalizeProposedState({ isActive: 'yes' } as never)
    expect(result.isActive).toBe('yes')
    expect(result.activeIndicator).toBeUndefined()
  })

  it('passes through other fields unchanged', () => {
    const result = normalizeProposedState({ roleName: 'agent', market: 'US' })
    expect(result).toEqual({ roleName: 'agent', market: 'US' })
  })
})
===ENDFILE

===FILE: src/services/api/__tests__/admin-adgroup.service.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'

vi.mock('../../core/api-client', () => ({
  apiFetch: vi.fn()
}))

vi.mock('../../../utils/auth/auth-token-manager', () => ({
  getAuthToken: vi.fn(() => 'mock-token')
}))

vi.mock('../../../utils/api/response-handler', () => ({
  handleApiResponse: vi.fn(async ({ response }: { response: Response }) => {
    if (!response.ok) throw new Error(`HTTP ${response.status}`)
    return response.json()
  })
}))

import { copyAdGroupConfiguration, getAllAdGroups, lookupAdGroup, searchAdGroups, updateAdGroup } from '../admin-adgroup.service'
import { apiFetch } from '../../core/api-client'
import { getAuthToken } from '../../../utils/auth/auth-token-manager'

const mockApiFetch = apiFetch as ReturnType<typeof vi.fn>
const mockGetAuthToken = getAuthToken as ReturnType<typeof vi.fn>

function jsonResponse(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), { status, statusText: status === 200 ? 'OK' : 'Error', headers: { 'Content-Type': 'application/json' } })
}

describe('admin-adgroup.service', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockGetAuthToken.mockReturnValue('mock-token')
  })

  describe('copyAdGroupConfiguration', () => {
    it('sends POST to /papi/v1/ad-group-configuration-copies', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { copyResult: { successFlag: true, messageText: 'Copied' } }
      }))
      const result = await copyAdGroupConfiguration('CN=source', 'CN=target')
      expect(mockApiFetch).toHaveBeenCalledWith(
        '/papi/v1/ad-group-configuration-copies',
        expect.objectContaining({ method: 'POST' })
      )
      expect(result.success).toBe(true)
    })

    it('returns failure on unsuccessful copy', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { copyResult: { successFlag: false, errorText: 'Copy failed' } }
      }))
      const result = await copyAdGroupConfiguration('CN=source', 'CN=target')
      expect(result.success).toBe(false)
      expect(result.error).toBe('Copy failed')
    })

    it('returns failure on HTTP error', async () => {
      mockApiFetch.mockResolvedValue(new Response(JSON.stringify({}), { status: 500, statusText: 'Server Error' }))
      const result = await copyAdGroupConfiguration('CN=source', 'CN=target')
      expect(result.success).toBe(false)
    })

    it('catches network errors', async () => {
      mockApiFetch.mockRejectedValue(new Error('Network error'))
      const result = await copyAdGroupConfiguration('CN=source', 'CN=target')
      expect(result.success).toBe(false)
      expect(result.error).toBe('NETWORK_ERROR')
    })

    it('merges custom options', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { copyResult: { successFlag: true } }
      }))
      await copyAdGroupConfiguration('CN=source', 'CN=target', {
        copyRoleAndPermissionsFlag: false,
        copyWorkflowModeCode: 'DIRECT_SAVE'
      })
      const callBody = JSON.parse(mockApiFetch.mock.calls[0][1].body)
      expect(callBody.data.copyOptions.copyRoleAndPermissionsFlag).toBe(false)
      expect(callBody.data.copyOptions.copyWorkflowModeCode).toBe('DIRECT_SAVE')
    })
  })

  describe('getAllAdGroups', () => {
    it('fetches all AD groups', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { items: [{ groupIdentifier: 'CN=group1', logicalName: 'Group 1', activeIndicator: true }] }
      }))
      const result = await getAllAdGroups()
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/ad-groups', expect.objectContaining({ method: 'GET' }))
      expect(result).toHaveLength(1)
      expect(result[0].groupIdentifier).toBe('CN=group1')
    })

    it('throws on missing auth token', async () => {
      mockGetAuthToken.mockReturnValue(null)
      await expect(getAllAdGroups()).rejects.toThrow('No authentication token found')
    })

    it('throws on unexpected response format', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: {} }))
      await expect(getAllAdGroups()).rejects.toThrow('Unexpected response format')
    })
  })

  describe('lookupAdGroup', () => {
    it('looks up AD group by identifier', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { groupIdentifier: 'CN=group1', logicalName: 'Group 1', activeIndicator: true }
      }))
      const result = await lookupAdGroup('CN=group1')
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/ad-groups/lookup', expect.objectContaining({ method: 'POST' }))
      expect(result.groupIdentifier).toBe('CN=group1')
    })

    it('throws when group not found', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: null }))
      await expect(lookupAdGroup('CN=missing')).rejects.toThrow('AD group not found')
    })
  })

  describe('searchAdGroups', () => {
    it('searches with query parameter', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { items: [{ groupIdentifier: 'CN=apac-group', logicalName: 'APAC Group', activeIndicator: true }] }
      }))
      const result = await searchAdGroups('apac')
      expect(mockApiFetch).toHaveBeenCalledWith(
        expect.stringContaining('search=apac'),
        expect.anything()
      )
      expect(result).toHaveLength(1)
    })

    it('clamps limit to 1-1000', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: { items: [] } }))
      await searchAdGroups('test', 5000)
      expect(mockApiFetch).toHaveBeenCalledWith(
        expect.stringContaining('limit=1000'),
        expect.anything()
      )
    })

    it('throws on unexpected format', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: {} }))
      await expect(searchAdGroups()).rejects.toThrow('Unexpected response format')
    })
  })

  describe('updateAdGroup', () => {
    it('sends POST to /papi/v1/ad-group-configs', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: { success: true } }))
      await updateAdGroup('CN=group1', { logicalName: 'Updated' })
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/ad-group-configs', expect.objectContaining({ method: 'POST' }))
    })

    it('normalizes isActive to activeIndicator', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: {} }))
      await updateAdGroup('CN=group1', { isActive: false })
      const callBody = JSON.parse(mockApiFetch.mock.calls[0][1].body)
      expect(callBody.data.proposedState.activeIndicator).toBe(false)
      expect(callBody.data.proposedState.isActive).toBeUndefined()
    })

    it('includes configVersionNumber when provided', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: {} }))
      await updateAdGroup('CN=group1', { logicalName: 'Test', configVersionNumber: 3 })
      const callBody = JSON.parse(mockApiFetch.mock.calls[0][1].body)
      expect(callBody.data.configVersionNumber).toBe(3)
    })
  })
})
===ENDFILE

===FILE: src/services/api/__tests__/admin-approval.service.test.ts
import { beforeEach, describe, expect, it, vi } from 'vitest'

vi.mock('../../core/api-client', () => ({
  apiFetch: vi.fn()
}))

vi.mock('../../../utils/auth/auth-token-manager', () => ({
  getAuthToken: vi.fn(() => 'test-token')
}))

const { apiFetch } = await import('../../core/api-client')
const { getAuthToken } = await import('../../../utils/auth/auth-token-manager')
const { adminApprovalService } = await import('../admin-approval.service')

describe('AdminApprovalService', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    vi.mocked(getAuthToken).mockReturnValue('test-token')
  })

  describe('getMyActivity', () => {
    it('uses OpenAPI query params and maps activityValues response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            activityValues: [
              {
                actionCode: 'L1_APPROVE',
                changeType: 'APP_UPDATE',
                targetGroupIdentifier: 'CN=APAC-TEAM,OU=ADMIN,DC=hsbc,DC=com',
                targetGroupName: 'APAC Team',
                isCriticalIndicator: true,
                createdAtDatetime: '2026-02-09T10:00:00Z',
                performedByRoleCode: 'CHECKER',
                completionReasonText: 'Approved after review',
                changeIdentifier: 'chg-001'
              }
            ]
          },
          meta: { pagination: { offset: 25, limit: 25, total: 60, hasMore: true } }
        })
      } as Response)

      const result = await adminApprovalService.getMyActivity(2, 25, 'week')

      const requestUrl = vi.mocked(apiFetch).mock.calls[0][0] as string
      const parsedUrl = new URL(requestUrl, 'http://localhost')
      expect(parsedUrl.searchParams.get('offset')).toBe('25')
      expect(parsedUrl.searchParams.get('limit')).toBe('25')
      expect(parsedUrl.searchParams.get('timeRange')).toBe('WEEK')

      expect(result.totalCount).toBe(60)
      expect(result.items).toHaveLength(1)
      expect(result.items[0]).toMatchObject({
        id: 'chg-001',
        action: 'L1_APPROVE',
        changeType: 'APP_UPDATE',
        targetGroupName: 'APAC Team',
        criticalIndicator: true
      })
    })

    it('falls back safely when optional activity fields are missing', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: { activityValues: [{ actionCode: 'UNKNOWN_ACTION', changeType: 'UNKNOWN_CHANGE', targetGroupIdentifier: 'CN=FALLBACK-GROUP,DC=hsbc,DC=com' }] },
          meta: { pagination: { offset: 0, limit: 25, total: 1, hasMore: false } }
        })
      } as Response)

      const result = await adminApprovalService.getMyActivity(1, 25)

      expect(result.items[0].action).toBe('SUBMIT')
      expect(result.items[0].changeType).toBe('CONFIG_UPDATE')
      expect(result.items[0].targetGroupName).toBe('CN=FALLBACK-GROUP,DC=hsbc,DC=com')
    })

    it('throws on non-ok response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 500, statusText: 'Internal Server Error'
      } as Response)

      await expect(adminApprovalService.getMyActivity()).rejects.toThrow('HTTP 500')
    })
  })

  describe('submitChange', () => {
    it('submits change for approval successfully', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            pendingChange: {
              changeIdentifier: 'chg-001',
              statusCode: 'PENDING_LEVEL_ONE',
              isCriticalIndicator: false
            }
          }
        })
      } as Response)

      const result = await adminApprovalService.submitChange('CN=GROUP', {
        changeType: 'CONFIG_UPDATE',
        currentState: {},
        changeDescription: 'Test change',
        proposedState: { logicalName: 'New Name' }
      })

      expect(result.successIndicator).toBe(true)
      expect(result.pendingChangeId).toBe('chg-001')
      expect(result.status).toBe('PENDING_LEVEL_ONE')
    })

    it('throws on 409 conflict with BERR_20024', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 409, statusText: 'Conflict',
        json: async () => ({ errorInfo: [{ code: 'BERR_20024', causes: ['existing change'] }] })
      } as unknown as Response)

      await expect(
        adminApprovalService.submitChange('CN=GROUP', {
          changeType: 'CONFIG_UPDATE',
          currentState: {},
          proposedState: {}
        })
      ).rejects.toThrow('A pending change already exists')
    })

    it('throws on 409 conflict with BERR_20025', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 409, statusText: 'Conflict',
        json: async () => ({ errorInfo: [{ code: 'BERR_20025', causes: ['version conflict'] }] })
      } as unknown as Response)

      await expect(
        adminApprovalService.submitChange('CN=GROUP', {
          changeType: 'CONFIG_UPDATE',
          currentState: {},
          proposedState: {}
        })
      ).rejects.toThrow('modified by another user')
    })

    it('throws generic error for other failures', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 400, statusText: 'Bad Request',
        json: async () => ({ errorInfo: [{ code: 'ERR', causes: ['invalid input'] }] })
      } as unknown as Response)

      await expect(
        adminApprovalService.submitChange('CN=GROUP', {
          changeType: 'CONFIG_UPDATE',
          currentState: {},
          proposedState: {}
        })
      ).rejects.toThrow('invalid input')
    })
  })

  describe('directSave', () => {
    it('saves directly and returns success', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({ data: { successIndicator: true, messageText: 'Saved' } })
      } as Response)

      const result = await adminApprovalService.directSave('CN=GROUP', {
        currentState: {},
        proposedState: { logicalName: 'Updated' }
      })

      expect(result.successIndicator).toBe(true)
      expect(result.message).toBe('Saved')
    })

    it('throws on non-ok response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 403, statusText: 'Forbidden'
      } as Response)

      await expect(
        adminApprovalService.directSave('CN=GROUP', { currentState: {}, proposedState: {} })
      ).rejects.toThrow('HTTP 403')
    })
  })

  describe('listPendingChanges', () => {
    it('fetches pending changes with filters', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            pendingChanges: [
              {
                changeIdentifier: 'pc-1',
                targetGroupIdentifier: 'CN=GROUP,DC=hsbc',
                targetGroupName: 'Test Group',
                changeType: 'CONFIG_UPDATE',
                currentConfig: null,
                proposedConfig: { businessInfoChanges: { roleName: 'supervisor' } },
                isCriticalIndicator: true,
                statusCode: 'PENDING_LEVEL_ONE',
                createdByText: 'user1',
                createdAtDatetime: '2026-01-01T00:00:00Z'
              }
            ]
          },
          meta: { pagination: { offset: 0, limit: 25, total: 1, hasMore: false } }
        })
      } as Response)

      const result = await adminApprovalService.listPendingChanges({
        status: ['PENDING_LEVEL_ONE'],
        offset: 0,
        limit: 25
      })

      expect(result.items).toHaveLength(1)
      expect(result.items[0].id).toBe('pc-1')
      expect(result.items[0].criticalIndicator).toBe(true)
      expect(result.items[0].status).toBe('PENDING_LEVEL_ONE')
      expect(result.counts.pendingLevelOne).toBe(1)
    })

    it('handles empty response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: { pendingChanges: [] },
          meta: { pagination: { offset: 0, limit: 25, total: 0, hasMore: false } }
        })
      } as Response)

      const result = await adminApprovalService.listPendingChanges()
      expect(result.items).toHaveLength(0)
      expect(result.totalCount).toBe(0)
    })

    it('throws on non-ok response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 500, statusText: 'Server Error'
      } as Response)

      await expect(adminApprovalService.listPendingChanges()).rejects.toThrow('HTTP 500')
    })

    it('unwraps nested config for diff', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            pendingChanges: [{
              changeIdentifier: 'pc-2',
              targetGroupIdentifier: 'CN=X,DC=hsbc',
              changeType: 'CONFIG_UPDATE',
              currentConfig: { businessInfoChanges: { roleName: 'agent' } },
              proposedConfig: { businessInfoChanges: { roleName: 'supervisor' } },
              isCriticalIndicator: false,
              statusCode: 'PENDING_LEVEL_ONE',
              createdAtDatetime: '2026-01-01T00:00:00Z'
            }]
          },
          meta: { pagination: { offset: 0, limit: 25, total: 1, hasMore: false } }
        })
      } as Response)

      const result = await adminApprovalService.listPendingChanges()
      expect(result.items[0].currentState.roleName).toBe('agent')
      expect(result.items[0].proposedState.roleName).toBe('supervisor')
    })

    it('computes app changes from current/proposed configs', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            pendingChanges: [{
              changeIdentifier: 'pc-3',
              targetGroupIdentifier: 'CN=X,DC=hsbc',
              changeType: 'APP_UPDATE',
              currentConfig: { applicationChanges: [{ appCode: 'APP_A' }] },
              proposedConfig: { applicationChanges: [{ appCode: 'APP_A' }, { appCode: 'APP_B' }] },
              isCriticalIndicator: false,
              statusCode: 'PENDING_LEVEL_ONE',
              createdAtDatetime: '2026-01-01T00:00:00Z'
            }]
          },
          meta: { pagination: { offset: 0, limit: 25, total: 1, hasMore: false } }
        })
      } as Response)

      const result = await adminApprovalService.listPendingChanges()
      expect(result.items[0].appsChanges?.added).toContain('APP_B')
      expect(result.items[0].appsChanges?.unchanged).toContain('APP_A')
    })
  })

  describe('getPendingChange', () => {
    it('fetches a single pending change', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            pendingChange: {
              changeIdentifier: 'pc-1',
              targetGroupIdentifier: 'CN=GROUP,DC=hsbc',
              targetGroupName: 'Group',
              statusCode: 'PENDING_LEVEL_ONE',
              createdAtDatetime: '2026-01-01T00:00:00Z'
            }
          }
        })
      } as Response)

      const result = await adminApprovalService.getPendingChange('pc-1')
      expect(result.id).toBe('pc-1')
      expect(result.canApproveIndicator).toBe(true)
    })

    it('throws when pending change not found', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({ data: {} })
      } as Response)

      await expect(adminApprovalService.getPendingChange('missing')).rejects.toThrow('Pending change not found')
    })

    it('throws on non-ok response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 404, statusText: 'Not Found'
      } as Response)

      await expect(adminApprovalService.getPendingChange('pc-1')).rejects.toThrow('HTTP 404')
    })
  })

  describe('approveChange', () => {
    it('approves a change successfully', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            approval: {
              changeIdentifier: 'pc-1',
              statusCode: 'APPROVED',
              messageText: 'Approved',
              approvedAtDatetime: '2026-01-01T10:00:00Z'
            }
          }
        })
      } as Response)

      const result = await adminApprovalService.approveChange('pc-1', { comment: 'Looks good' })

      expect(result.successIndicator).toBe(true)
      expect(result.changeId).toBe('pc-1')
      expect(result.newStatus).toBe('APPROVED')
    })

    it('throws self-approval error on 403 with self message', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 403, statusText: 'Forbidden',
        json: async () => ({ errorInfo: [{ code: 'ERR', causes: ['Cannot self-approve'] }] })
      } as unknown as Response)

      await expect(adminApprovalService.approveChange('pc-1')).rejects.toThrow('self-approval')
    })

    it('throws generic error for non-403 failures', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 400, statusText: 'Bad Request',
        json: async () => ({ errorInfo: [{ code: 'ERR', causes: ['Bad request'] }] })
      } as unknown as Response)

      await expect(adminApprovalService.approveChange('pc-1')).rejects.toThrow('Bad request')
    })
  })

  describe('rejectChange', () => {
    it('rejects a change successfully', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            rejection: {
              changeIdentifier: 'pc-1',
              statusCode: 'REJECTED',
              messageText: 'Rejected',
              rejectedAtDatetime: '2026-01-01T10:00:00Z'
            }
          }
        })
      } as Response)

      const result = await adminApprovalService.rejectChange('pc-1', { rejectionReason: 'Not valid' })

      expect(result.successIndicator).toBe(true)
      expect(result.newStatus).toBe('REJECTED')
    })

    it('throws on non-ok response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 400, statusText: 'Bad Request',
        json: async () => ({ errorInfo: [{ code: 'ERR', causes: ['Invalid'] }] })
      } as unknown as Response)

      await expect(
        adminApprovalService.rejectChange('pc-1', { rejectionReason: 'Bad' })
      ).rejects.toThrow('Invalid')
    })
  })

  describe('cancelChange', () => {
    it('cancels a change successfully', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: { statusCode: 'CANCELLED', messageText: 'Cancelled' }
        })
      } as Response)

      const result = await adminApprovalService.cancelChange('pc-1')

      expect(result.successIndicator).toBe(true)
      expect(result.newStatus).toBe('CANCELLED')
      expect(result.changeId).toBe('pc-1')
    })

    it('throws 403 with ownership message', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 403, statusText: 'Forbidden',
        json: async () => ({ errorInfo: [] })
      } as unknown as Response)

      await expect(adminApprovalService.cancelChange('pc-1')).rejects.toThrow('only cancel your own')
    })

    it('throws on other non-ok responses', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 500, statusText: 'Server Error',
        json: async () => ({ errorInfo: [{ code: 'ERR', causes: ['Server failure'] }] })
      } as unknown as Response)

      await expect(adminApprovalService.cancelChange('pc-1')).rejects.toThrow('Server failure')
    })
  })

  describe('getPendingChangesCount', () => {
    it('returns counts from listPendingChanges', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            pendingChanges: [
              { changeIdentifier: 'pc-1', targetGroupIdentifier: 'CN=X', statusCode: 'PENDING_LEVEL_ONE', isCriticalIndicator: false, createdAtDatetime: '2026-01-01' },
              { changeIdentifier: 'pc-2', targetGroupIdentifier: 'CN=Y', statusCode: 'PENDING_LEVEL_TWO', isCriticalIndicator: false, createdAtDatetime: '2026-01-01' }
            ]
          },
          meta: { pagination: { offset: 0, limit: 1, total: 2, hasMore: true } }
        })
      } as Response)

      const result = await adminApprovalService.getPendingChangesCount()
      expect(result.total).toBe(2)
      expect(result.levelOne).toBe(1)
      expect(result.levelTwo).toBe(1)
    })

    it('returns zeros on error', async () => {
      vi.mocked(apiFetch).mockRejectedValue(new Error('Network error'))

      const result = await adminApprovalService.getPendingChangesCount()
      expect(result).toEqual({ total: 0, levelOne: 0, levelTwo: 0 })
    })
  })

  describe('ensureToken', () => {
    it('throws when no token available', async () => {
      vi.mocked(getAuthToken).mockReturnValue(null)

      await expect(
        adminApprovalService.submitChange('CN=X', {
          changeType: 'CONFIG_UPDATE',
          currentState: {},
          proposedState: {}
        })
      ).rejects.toThrow('No authentication token found')
    })
  })
})
===ENDFILE

===FILE: src/services/api/__tests__/admin-notice.service.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'

vi.mock('../../core/api-client', () => ({
  apiFetch: vi.fn()
}))

vi.mock('../../../utils/auth/auth-token-manager', () => ({
  getAuthToken: vi.fn(() => 'mock-token')
}))

vi.mock('../../../utils/api/response-handler', () => ({
  handleApiResponse: vi.fn(async ({ response }: { response: Response }) => {
    if (!response.ok) throw new Error(`HTTP ${response.status}`)
    return response.json()
  })
}))

import { createNotice, listNotices, updateNotice, updateNoticeStatus } from '../admin-notice.service'
import { apiFetch } from '../../core/api-client'
import { getAuthToken } from '../../../utils/auth/auth-token-manager'

const mockApiFetch = apiFetch as ReturnType<typeof vi.fn>
const mockGetAuthToken = getAuthToken as ReturnType<typeof vi.fn>

const noticePayload = {
  identifier: 'n1',
  titleText: 'Test Notice',
  messageText: 'Body content',
  severityValue: 'INFO',
  statusCode: 'DRAFT',
  broadcastToAllFlag: false,
  requiresAckFlag: false,
  targetRoleValues: [],
  targetAdGroupValues: [],
  createdByText: 'user@test.com',
  createdAtDate: '2025-01-15T10:00:00Z'
}

function jsonResponse(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), { status, headers: { 'Content-Type': 'application/json' } })
}

describe('admin-notice.service', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockGetAuthToken.mockReturnValue('mock-token')
  })

  describe('createNotice', () => {
    it('sends POST to /papi/v1/notices', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: { notice: noticePayload } }))
      const result = await createNotice({
        title: 'Test Notice',
        message: 'Body content',
        severity: 'INFO',
        broadcastToAll: false
      })
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/notices', expect.objectContaining({ method: 'POST' }))
      expect(result.id).toBe('n1')
      expect(result.title).toBe('Test Notice')
    })

    it('throws on missing auth token', async () => {
      mockGetAuthToken.mockReturnValue(null)
      await expect(createNotice({
        title: 'Test',
        message: 'Body',
        severity: 'INFO',
        broadcastToAll: false
      })).rejects.toThrow('No authentication token found')
    })

    it('throws on unexpected response format', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: {} }))
      await expect(createNotice({
        title: 'Test',
        message: 'Body',
        severity: 'INFO',
        broadcastToAll: false
      })).rejects.toThrow('Unexpected response format')
    })
  })

  describe('listNotices', () => {
    it('fetches notices from /papi/v1/notices', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { notices: [noticePayload] }
      }))
      const result = await listNotices()
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/notices', expect.objectContaining({ method: 'GET' }))
      expect(result).toHaveLength(1)
      expect(result[0].id).toBe('n1')
    })

    it('appends status filter', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: { notices: [] } }))
      await listNotices('ACTIVE')
      expect(mockApiFetch).toHaveBeenCalledWith(
        expect.stringContaining('statusCode=ACTIVE'),
        expect.anything()
      )
    })

    it('throws on unexpected format', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: {} }))
      await expect(listNotices()).rejects.toThrow('Unexpected response format')
    })
  })

  describe('updateNotice', () => {
    it('sends PUT to /papi/v1/notices/{id}', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: { notice: noticePayload } }))
      const result = await updateNotice('n1', { title: 'Updated', message: 'New body', severity: 'WARNING', broadcastToAll: false })
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/notices/n1', expect.objectContaining({ method: 'PUT' }))
      expect(result.id).toBe('n1')
    })

    it('throws on missing notice in response', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: {} }))
      await expect(updateNotice('n1', { title: 'Test', message: 'Body', severity: 'INFO', broadcastToAll: false }))
        .rejects.toThrow('Unexpected response format')
    })
  })

  describe('updateNoticeStatus', () => {
    it('sends PATCH to /papi/v1/notices/{id}/status', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: { notice: noticePayload } }))
      const result = await updateNoticeStatus('n1', 'ACTIVE')
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/notices/n1/status', expect.objectContaining({ method: 'PATCH' }))
      expect(result.id).toBe('n1')
    })

    it('throws on missing notice in response', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: {} }))
      await expect(updateNoticeStatus('n1', 'ACTIVE')).rejects.toThrow('Unexpected response format')
    })
  })
})
===ENDFILE

===FILE: src/services/api/__tests__/admin.service.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

const mockApiFetch = vi.fn()
vi.mock('../../core/api-client', () => ({
  apiFetch: (...args: unknown[]) => mockApiFetch(...args)
}))

vi.mock('../../../utils/auth/auth-token-manager', () => ({
  getAuthToken: () => 'test-token'
}))

vi.mock('../../../utils/api/response-handler', () => ({
  handleApiResponse: async ({ response }: { response: Response }) => {
    if (!response.ok) throw new Error(`HTTP error: ${response.status}`)
    return response.json()
  }
}))

const { adminService } = await import('../admin.service')

describe('AdminService', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('getAllAdGroups', () => {
    it('returns mapped AD groups', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            items: [{
              groupIdentifier: 'CN=test-group',
              logicalName: 'Test Group',
              roleName: 'voice_agent',
              activeIndicator: true,
              marketCode: 'HK',
              regionCode: 'APAC'
            }]
          }
        })
      })

      const result = await adminService.getAllAdGroups()
      expect(result).toHaveLength(1)
      expect(result[0].groupIdentifier).toBe('CN=test-group')
      expect(result[0].logicalName).toBe('Test Group')
      expect(result[0].isActive).toBe(true)
    })

    it('throws on unexpected format', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: {} })
      })

      await expect(adminService.getAllAdGroups()).rejects.toThrow('Unexpected response format')
    })
  })

  describe('lookupAdGroup', () => {
    it('looks up and maps AD group', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            groupIdentifier: 'CN=test-group',
            logicalName: 'Test',
            activeIndicator: true
          }
        })
      })

      const result = await adminService.lookupAdGroup('CN=test-group')
      expect(result.groupIdentifier).toBe('CN=test-group')
      expect(mockApiFetch).toHaveBeenCalledWith(
        '/papi/v1/ad-groups/lookup',
        expect.objectContaining({ method: 'POST' })
      )
    })

    it('throws when group not found', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({})
      })

      await expect(adminService.lookupAdGroup('CN=missing')).rejects.toThrow('AD group not found')
    })
  })

  describe('searchAdGroups', () => {
    it('searches with search param and limit', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            items: [{ groupIdentifier: 'CN=g1', activeIndicator: true }]
          }
        })
      })

      const result = await adminService.searchAdGroups('test', 50)
      expect(result).toHaveLength(1)
      const calledUrl = mockApiFetch.mock.calls[0][0] as string
      expect(calledUrl).toContain('search=test')
      expect(calledUrl).toContain('limit=50')
    })

    it('clamps limit to valid range', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: { items: [] } })
      })

      await adminService.searchAdGroups('', 5000)
      const calledUrl = mockApiFetch.mock.calls[0][0] as string
      expect(calledUrl).toContain('limit=1000')
    })
  })

  describe('updateAdGroup', () => {
    it('normalizes isActive to activeIndicator', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: {} })
      })

      await adminService.updateAdGroup('CN=g1', { isActive: false })
      const body = JSON.parse(mockApiFetch.mock.calls[0][1].body)
      expect(body.data.proposedState.activeIndicator).toBe(false)
      expect(body.data.proposedState.isActive).toBeUndefined()
    })
  })

  describe('copyAdGroupConfiguration', () => {
    it('copies configuration successfully', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            copyResult: {
              successFlag: true,
              messageText: 'Copied',
              workflowStatusCode: 'DIRECT_APPLIED'
            }
          }
        })
      })

      const result = await adminService.copyAdGroupConfiguration('CN=source', 'CN=target')
      expect(result.success).toBe(true)
      expect(result.message).toBe('Copied')
      expect(result.workflowStatusCode).toBe('DIRECT_APPLIED')
    })

    it('returns failure on non-ok response', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        json: () => Promise.resolve({
          data: {
            copyResult: {
              successFlag: false,
              errorText: 'Server error'
            }
          }
        })
      })

      const result = await adminService.copyAdGroupConfiguration('CN=source', 'CN=target')
      expect(result.success).toBe(false)
    })

    it('returns failure on network error', async () => {
      mockApiFetch.mockRejectedValue(new Error('Network failure'))

      const result = await adminService.copyAdGroupConfiguration('CN=source', 'CN=target')
      expect(result.success).toBe(false)
      expect(result.error).toBe('NETWORK_ERROR')
      expect(result.message).toBe('Network failure')
    })
  })

  describe('notice operations', () => {
    it('createNotice maps request and response fields', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            notice: {
              identifier: 'n1',
              titleText: 'Test Notice',
              messageText: 'Hello',
              severityValue: 'WARNING',
              statusCode: 'DRAFT',
              broadcastToAllFlag: true,
              requiresAckFlag: false,
              targetRoleValues: ['voice_agent'],
              createdByText: 'admin',
              createdAtDate: '2025-01-01'
            }
          }
        })
      })

      const result = await adminService.createNotice({
        title: 'Test Notice',
        message: 'Hello',
        severity: 'WARNING',
        broadcastToAll: true,
        requiresAcknowledgement: false,
        targetRoles: ['voice_agent']
      })

      expect(result.id).toBe('n1')
      expect(result.title).toBe('Test Notice')
      expect(result.severity).toBe('WARNING')
      expect(result.broadcastToAll).toBe(true)
      expect(result.targetRoles).toEqual(['voice_agent'])
    })

    it('listNotices returns mapped notices', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            notices: [
              { identifier: 'n1', titleText: 'Notice 1', messageText: 'Msg', severityValue: 'INFO', statusCode: 'ACTIVE', broadcastToAllFlag: false, requiresAckFlag: false, createdByText: '', createdAtDate: '' }
            ]
          }
        })
      })

      const result = await adminService.listNotices('ACTIVE')
      expect(result).toHaveLength(1)
      expect(result[0].id).toBe('n1')

      const calledUrl = mockApiFetch.mock.calls[0][0] as string
      expect(calledUrl).toContain('statusCode=ACTIVE')
    })

    it('listNotices without status filter', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: { notices: [] } })
      })

      await adminService.listNotices()
      const calledUrl = mockApiFetch.mock.calls[0][0] as string
      expect(calledUrl).not.toContain('statusCode')
    })

    it('updateNotice maps fields correctly', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            notice: {
              identifier: 'n1',
              titleText: 'Updated',
              messageText: 'Updated msg',
              severityValue: 'INFO',
              statusCode: 'DRAFT',
              broadcastToAllFlag: false,
              requiresAckFlag: false,
              createdByText: '',
              createdAtDate: ''
            }
          }
        })
      })

      const result = await adminService.updateNotice('n1', {
        title: 'Updated',
        message: 'Updated msg',
        severity: 'INFO',
        broadcastToAll: false,
        requiresAcknowledgement: false
      })

      expect(result.title).toBe('Updated')
      expect(mockApiFetch).toHaveBeenCalledWith(
        '/papi/v1/notices/n1',
        expect.objectContaining({ method: 'PUT' })
      )
    })

    it('updateNoticeStatus sends PATCH request', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            notice: {
              identifier: 'n1',
              titleText: 'Notice',
              messageText: 'Msg',
              severityValue: 'INFO',
              statusCode: 'ACTIVE',
              broadcastToAllFlag: false,
              requiresAckFlag: false,
              createdByText: '',
              createdAtDate: ''
            }
          }
        })
      })

      const result = await adminService.updateNoticeStatus('n1', 'ACTIVE')
      expect(result.status).toBe('ACTIVE')
      expect(mockApiFetch).toHaveBeenCalledWith(
        '/papi/v1/notices/n1/status',
        expect.objectContaining({ method: 'PATCH' })
      )
    })
  })
})
===ENDFILE

===FILE: src/services/api/__tests__/approval-actions.service.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'

vi.mock('../../core/api-client', () => ({
  apiFetch: vi.fn()
}))

vi.mock('../../../utils/auth/auth-token-manager', () => ({
  getAuthToken: vi.fn(() => 'mock-token')
}))

vi.mock('../approval-formatters', () => ({
  parseApiError: vi.fn(async (response: Response) => {
    try {
      const body = await response.clone().json()
      const info = body.errorInfo?.[0]
      return { errorCode: info?.code ?? '', errorMessage: info?.causes?.[0] ?? `HTTP ${response.status}` }
    } catch {
      return { errorCode: '', errorMessage: `HTTP ${response.status}` }
    }
  })
}))

import { submitChange, directSave, approveChange, rejectChange, cancelChange } from '../approval-actions.service'
import { apiFetch } from '../../core/api-client'
import { getAuthToken } from '../../../utils/auth/auth-token-manager'

const mockApiFetch = apiFetch as ReturnType<typeof vi.fn>
const mockGetAuthToken = getAuthToken as ReturnType<typeof vi.fn>

function jsonResponse(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), { status, headers: { 'Content-Type': 'application/json' } })
}

describe('approval-actions.service', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockGetAuthToken.mockReturnValue('mock-token')
  })

  describe('submitChange', () => {
    it('sends POST to /papi/v1/pending-changes', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { pendingChange: { changeIdentifier: 'c1', statusCode: 'PENDING_LEVEL_ONE', isCriticalIndicator: false } }
      }))
      const result = await submitChange('group-1', { proposedState: {}, changedFields: ['logicalName'], changeType: 'CONFIG_UPDATE', currentState: {} })
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/pending-changes', expect.objectContaining({ method: 'POST' }))
      expect(result.successIndicator).toBe(true)
      expect(result.pendingChangeId).toBe('c1')
    })

    it('throws on missing auth token', async () => {
      mockGetAuthToken.mockReturnValue(null)
      await expect(submitChange('group-1', { proposedState: {}, changedFields: [], changeType: 'CONFIG_UPDATE', currentState: {} }))
        .rejects.toThrow('No authentication token found')
    })

    it('throws specific message for BERR_20024 conflict', async () => {
      mockApiFetch.mockResolvedValue(new Response(
        JSON.stringify({ errorInfo: [{ code: 'BERR_20024', causes: ['Conflict'] }] }),
        { status: 409 }
      ))
      await expect(submitChange('group-1', { proposedState: {}, changedFields: [], changeType: 'CONFIG_UPDATE', currentState: {} }))
        .rejects.toThrow('A pending change already exists')
    })

    it('throws specific message for BERR_20025 conflict', async () => {
      mockApiFetch.mockResolvedValue(new Response(
        JSON.stringify({ errorInfo: [{ code: 'BERR_20025', causes: ['Modified'] }] }),
        { status: 409 }
      ))
      await expect(submitChange('group-1', { proposedState: {}, changedFields: [], changeType: 'CONFIG_UPDATE', currentState: {} }))
        .rejects.toThrow('modified by another user')
    })
  })

  describe('directSave', () => {
    it('sends POST to /papi/v1/ad-group-configs', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { successIndicator: true, messageText: 'Saved' }
      }))
      const result = await directSave('group-1', { currentState: {}, proposedState: {} })
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/ad-group-configs', expect.objectContaining({ method: 'POST' }))
      expect(result.successIndicator).toBe(true)
    })

    it('throws on HTTP error', async () => {
      mockApiFetch.mockResolvedValue(new Response('', { status: 500, statusText: 'Server Error' }))
      await expect(directSave('group-1', { currentState: {}, proposedState: {} }))
        .rejects.toThrow('HTTP 500')
    })
  })

  describe('approveChange', () => {
    it('sends POST to /papi/v1/change-approvals', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { approval: { changeIdentifier: 'c1', statusCode: 'APPROVED', messageText: 'Approved' } }
      }))
      const result = await approveChange('c1', { comment: 'LGTM' })
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/change-approvals', expect.objectContaining({ method: 'POST' }))
      expect(result.successIndicator).toBe(true)
      expect(result.newStatus).toBe('APPROVED')
    })

    it('throws self-approval message on 403 with self keyword', async () => {
      mockApiFetch.mockResolvedValue(new Response(
        JSON.stringify({ errorInfo: [{ code: 'AUTH_ERR', causes: ['Cannot self-approve'] }] }),
        { status: 403 }
      ))
      await expect(approveChange('c1')).rejects.toThrow('self-approval')
    })
  })

  describe('rejectChange', () => {
    it('sends POST to /papi/v1/change-rejections', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { rejection: { changeIdentifier: 'c1', statusCode: 'REJECTED', messageText: 'Rejected' } }
      }))
      const result = await rejectChange('c1', { rejectionReason: 'Bad config' })
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/change-rejections', expect.objectContaining({ method: 'POST' }))
      expect(result.successIndicator).toBe(true)
      expect(result.newStatus).toBe('REJECTED')
    })

    it('throws on HTTP error', async () => {
      mockApiFetch.mockResolvedValue(new Response(
        JSON.stringify({ errorInfo: [{ code: 'ERR', causes: ['Validation failed'] }] }),
        { status: 400 }
      ))
      await expect(rejectChange('c1', { rejectionReason: '' })).rejects.toThrow('Validation failed')
    })
  })

  describe('cancelChange', () => {
    it('sends DELETE to /papi/v1/pending-changes/{id}', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { statusCode: 'CANCELLED', messageText: 'Cancelled' }
      }))
      const result = await cancelChange('c1')
      expect(mockApiFetch).toHaveBeenCalledWith(
        '/papi/v1/pending-changes/c1',
        expect.objectContaining({ method: 'DELETE' })
      )
      expect(result.successIndicator).toBe(true)
      expect(result.newStatus).toBe('CANCELLED')
    })

    it('throws permission error on 403', async () => {
      mockApiFetch.mockResolvedValue(new Response(
        JSON.stringify({ errorInfo: [{ code: 'AUTH_ERR', causes: ['Forbidden'] }] }),
        { status: 403 }
      ))
      await expect(cancelChange('c1')).rejects.toThrow('only cancel your own')
    })
  })
})
===ENDFILE

===FILE: src/services/api/__tests__/approval-formatters.test.ts
import { describe, it, expect } from 'vitest'
import {
  unwrapConfig,
  extractAppsChanges,
  extractFunctionsChanges,
  mapPapiItemToDto,
  mapActivityItem,
  parseApiError,
  type PapiPendingChange,
  type PapiActivityLogItem
} from '../approval-formatters'

describe('approval-formatters', () => {
  describe('unwrapConfig', () => {
    it('returns empty object for null', () => {
      expect(unwrapConfig(null)).toEqual({})
    })

    it('returns config as-is if already flat', () => {
      const config = { logicalName: 'Test', roleName: 'voice_agent', region: 'APAC' }
      expect(unwrapConfig(config)).toEqual(config)
    })

    it('unwraps businessInfoChanges with field mapping', () => {
      const config = {
        businessInfoChanges: {
          regionCode: 'APAC',
          countryCode: 'HK',
          marketCode: 'Asia Pacific',
          businessUnitName: 'WPB'
        }
      }
      const result = unwrapConfig(config)
      expect(result.region).toBe('APAC')
      expect(result.country).toBe('HK')
      expect(result.market).toBe('Asia Pacific')
      expect(result.businessUnit).toBe('WPB')
    })

    it('unwraps permissionChanges with level mapping', () => {
      const config = {
        permissionChanges: {
          columnPermissions: { chat: { enabledIndicator: true } }
        }
      }
      const result = unwrapConfig(config)
      expect(result['permissions.columns.chat']).toEqual({ enabledIndicator: true })
    })

    it('copies non-wrapper keys to result', () => {
      const config = {
        businessInfoChanges: { regionCode: 'APAC' },
        someOtherField: 'value'
      }
      const result = unwrapConfig(config)
      expect(result.region).toBe('APAC')
      expect(result.someOtherField).toBe('value')
    })
  })

  describe('extractAppsChanges', () => {
    it('returns null when proposedConfig is null', () => {
      expect(extractAppsChanges({}, null)).toBeNull()
    })

    it('returns null when no applicationChanges arrays', () => {
      expect(extractAppsChanges({}, {})).toBeNull()
    })

    it('returns null when no actual changes (same apps)', () => {
      const current = { applicationChanges: [{ appCode: 'app1' }] }
      const proposed = { applicationChanges: [{ appCode: 'app1' }] }
      expect(extractAppsChanges(current, proposed)).toBeNull()
    })

    it('detects added apps', () => {
      const current = { applicationChanges: [] }
      const proposed = { applicationChanges: [{ appCode: 'app1' }] }
      const result = extractAppsChanges(current, proposed)
      expect(result?.added).toEqual(['app1'])
      expect(result?.removed).toEqual([])
    })

    it('detects removed apps', () => {
      const current = { applicationChanges: [{ appCode: 'app1' }] }
      const proposed = { applicationChanges: [] }
      const result = extractAppsChanges(current, proposed)
      expect(result?.removed).toEqual(['app1'])
      expect(result?.added).toEqual([])
    })
  })

  describe('extractFunctionsChanges', () => {
    it('uses top-level functions when provided', () => {
      const topLevel = {
        added: [{ appIdentifier: 'app1', functionIdentifier: 'fn1' }],
        removed: [],
        unchanged: []
      }
      const result = extractFunctionsChanges(topLevel, null, null)
      expect(result?.added).toEqual([{ app: 'app1', function: 'fn1' }])
    })

    it('returns null when no proposed config and no top level', () => {
      expect(extractFunctionsChanges(null, null, null)).toBeNull()
    })

    it('computes diff from appFunctionChanges when no top level', () => {
      const current = {
        appFunctionChanges: [{ appCode: 'app1', functionCode: 'fn1' }]
      }
      const proposed = {
        appFunctionChanges: [
          { appCode: 'app1', functionCode: 'fn1' },
          { appCode: 'app1', functionCode: 'fn2' }
        ]
      }
      const result = extractFunctionsChanges(null, current, proposed)
      expect(result?.added).toEqual([{ app: 'app1', function: 'fn2' }])
      expect(result?.unchanged).toEqual([{ app: 'app1', function: 'fn1' }])
    })
  })

  describe('mapPapiItemToDto', () => {
    const basePapiItem: PapiPendingChange = {
      changeIdentifier: 'change-1',
      targetGroupIdentifier: 'CN=test-group,OU=Groups',
      targetGroupName: 'Test Group',
      changeType: 'CONFIG_UPDATE',
      currentConfig: { logicalName: 'Old Name' },
      proposedConfig: { logicalName: 'New Name' },
      isCriticalIndicator: false,
      statusCode: 'PENDING_LEVEL_ONE',
      createdByText: 'user@test.com',
      createdAtDatetime: '2025-01-15T10:00:00Z'
    }

    it('maps basic fields correctly', () => {
      const dto = mapPapiItemToDto(basePapiItem, false)
      expect(dto.id).toBe('change-1')
      expect(dto.targetGroupIdentifier).toBe('CN=test-group,OU=Groups')
      expect(dto.targetGroupName).toBe('Test Group')
      expect(dto.changeType).toBe('CONFIG_UPDATE')
      expect(dto.status).toBe('PENDING_LEVEL_ONE')
      expect(dto.criticalIndicator).toBe(false)
    })

    it('sets action permissions for non-submitter on pending item', () => {
      const dto = mapPapiItemToDto(basePapiItem, false)
      expect(dto.canApproveIndicator).toBe(true)
      expect(dto.canRejectIndicator).toBe(true)
      expect(dto.canCancelIndicator).toBe(false)
    })

    it('sets cancel permission for submitter on pending item', () => {
      const dto = mapPapiItemToDto(basePapiItem, true)
      expect(dto.canApproveIndicator).toBe(false)
      expect(dto.canRejectIndicator).toBe(false)
      expect(dto.canCancelIndicator).toBe(true)
    })

    it('extracts group name from DN when targetGroupName is null', () => {
      const item = { ...basePapiItem, targetGroupName: null }
      const dto = mapPapiItemToDto(item, false)
      expect(dto.targetGroupName).toBe('test-group')
    })

    it('maps approval info when present', () => {
      const item = {
        ...basePapiItem,
        approvedByText: 'approver@test.com',
        approvedAtDatetime: '2025-01-16T10:00:00Z',
        commentText: 'Looks good'
      }
      const dto = mapPapiItemToDto(item, false)
      expect(dto.levelOneApproval).toBeDefined()
      expect(dto.levelOneApproval?.approverUserId).toBe('approver@test.com')
    })

    it('maps rejection info when present', () => {
      const item = {
        ...basePapiItem,
        statusCode: 'REJECTED',
        rejectedByText: 'checker@test.com',
        rejectedAtDatetime: '2025-01-16T11:00:00Z',
        rejectionReasonText: 'Needs changes'
      }
      const dto = mapPapiItemToDto(item, false)
      expect(dto.rejectedBy?.userId).toBe('checker@test.com')
      expect(dto.rejectionReason).toBe('Needs changes')
    })
  })

  describe('mapActivityItem', () => {
    const baseItem: PapiActivityLogItem = {
      changeIdentifier: 'act-1',
      actionCode: 'SUBMIT',
      changeType: 'CONFIG_UPDATE',
      targetGroupIdentifier: 'CN=test-group',
      targetGroupName: 'Test Group',
      isCriticalIndicator: false,
      createdAtDatetime: '2025-01-15T10:00:00Z'
    }

    it('maps basic fields correctly', () => {
      const dto = mapActivityItem(baseItem, 0)
      expect(dto.id).toBe('act-1')
      expect(dto.action).toBe('SUBMIT')
      expect(dto.targetGroupName).toBe('Test Group')
      expect(dto.changeType).toBe('CONFIG_UPDATE')
      expect(dto.criticalIndicator).toBe(false)
    })

    it('defaults action to SUBMIT for unknown action codes', () => {
      const item = { ...baseItem, actionCode: 'UNKNOWN' }
      const dto = mapActivityItem(item, 0)
      expect(dto.action).toBe('SUBMIT')
    })

    it('generates fallback ID when changeIdentifier missing', () => {
      const item = { ...baseItem, changeIdentifier: undefined }
      const dto = mapActivityItem(item, 5)
      expect(dto.id).toContain(':SUBMIT:5')
    })

    it('falls back to groupIdentifier when targetGroupName missing', () => {
      const item = { ...baseItem, targetGroupName: undefined }
      const dto = mapActivityItem(item, 0)
      expect(dto.targetGroupName).toBe('CN=test-group')
    })

    it('maps APP_UPDATE change type', () => {
      const item = { ...baseItem, changeType: 'APP_UPDATE' }
      const dto = mapActivityItem(item, 0)
      expect(dto.changeType).toBe('APP_UPDATE')
    })

    it('maps valid action codes', () => {
      for (const action of ['L1_APPROVE', 'L2_APPROVE', 'REJECT', 'CANCEL', 'DIRECT_SAVE']) {
        const item = { ...baseItem, actionCode: action }
        const dto = mapActivityItem(item, 0)
        expect(dto.action).toBe(action)
      }
    })
  })

  describe('parseApiError', () => {
    it('extracts error code and message from errorInfo', async () => {
      const response = new Response(
        JSON.stringify({ errorInfo: [{ code: 'BERR_20024', causes: ['Already exists'] }] }),
        { status: 409 }
      )
      const result = await parseApiError(response)
      expect(result.errorCode).toBe('BERR_20024')
      expect(result.errorMessage).toBe('Already exists')
    })

    it('falls back to HTTP status when no errorInfo', async () => {
      const response = new Response('{}', { status: 500, statusText: 'Internal Server Error' })
      const result = await parseApiError(response)
      expect(result.errorCode).toBe('')
      expect(result.errorMessage).toBe('HTTP 500: Internal Server Error')
    })

    it('handles non-JSON response body', async () => {
      const response = new Response('not json', { status: 400, statusText: 'Bad Request' })
      const result = await parseApiError(response)
      expect(result.errorCode).toBe('')
      expect(result.errorMessage).toBe('HTTP 400: Bad Request')
    })
  })
})
===ENDFILE

===FILE: src/services/api/__tests__/approval-queries.service.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import type { PendingChangeStatus } from '../../../types/features/approval-workflow.types'

vi.mock('../../core/api-client', () => ({
  apiFetch: vi.fn()
}))

vi.mock('../../../utils/auth/auth-token-manager', () => ({
  getAuthToken: vi.fn(() => 'mock-token')
}))

vi.mock('../approval-formatters', () => ({
  mapPapiItemToDto: vi.fn((item: Record<string, unknown>, _isMy: boolean) => ({
    id: item.changeIdentifier,
    status: item.statusCode,
    targetGroupName: item.targetGroupName ?? 'Unknown'
  })),
  mapActivityItem: vi.fn((item: Record<string, unknown>, idx: number) => ({
    id: item.changeIdentifier ?? `fallback-${idx}`,
    action: item.actionCode ?? 'SUBMIT'
  }))
}))

import { listPendingChanges, getPendingChange, getMyActivity, getPendingChangesCount } from '../approval-queries.service'
import { apiFetch } from '../../core/api-client'
import { getAuthToken } from '../../../utils/auth/auth-token-manager'

const mockApiFetch = apiFetch as ReturnType<typeof vi.fn>
const mockGetAuthToken = getAuthToken as ReturnType<typeof vi.fn>

function jsonResponse(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), { status, headers: { 'Content-Type': 'application/json' } })
}

describe('approval-queries.service', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockGetAuthToken.mockReturnValue('mock-token')
  })

  describe('listPendingChanges', () => {
    it('fetches pending changes from /papi/v1/pending-changes', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { pendingChanges: [{ changeIdentifier: 'c1', statusCode: 'PENDING_LEVEL_ONE', targetGroupName: 'Group 1' }] },
        meta: { pagination: { offset: 0, limit: 25, total: 1, hasMore: false } }
      }))
      const result = await listPendingChanges()
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/pending-changes', expect.objectContaining({ method: 'GET' }))
      expect(result.items).toHaveLength(1)
      expect(result.totalCount).toBe(1)
    })

    it('appends status filter when supported', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { pendingChanges: [] },
        meta: { pagination: { offset: 0, limit: 25, total: 0, hasMore: false } }
      }))
      await listPendingChanges({ status: ['PENDING_LEVEL_ONE'] })
      expect(mockApiFetch).toHaveBeenCalledWith(
        expect.stringContaining('statusCode=PENDING_LEVEL_ONE'),
        expect.anything()
      )
    })

    it('ignores unsupported status filters', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { pendingChanges: [] },
        meta: { pagination: { offset: 0, limit: 25, total: 0, hasMore: false } }
      }))
      await listPendingChanges({ status: ['INVALID_STATUS' as PendingChangeStatus] })
      expect(mockApiFetch).toHaveBeenCalledWith(
        '/papi/v1/pending-changes',
        expect.anything()
      )
    })

    it('throws on missing auth token', async () => {
      mockGetAuthToken.mockReturnValue(null)
      await expect(listPendingChanges()).rejects.toThrow('No authentication token found')
    })

    it('throws on HTTP error', async () => {
      mockApiFetch.mockResolvedValue(new Response('', { status: 500, statusText: 'Server Error' }))
      await expect(listPendingChanges()).rejects.toThrow('HTTP 500')
    })

    it('computes level counts from items', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: {
          pendingChanges: [
            { changeIdentifier: 'c1', statusCode: 'PENDING_LEVEL_ONE' },
            { changeIdentifier: 'c2', statusCode: 'PENDING_LEVEL_TWO' }
          ]
        },
        meta: { pagination: { offset: 0, limit: 25, total: 2, hasMore: false } }
      }))
      const result = await listPendingChanges()
      expect(result.counts.pendingLevelOne).toBeDefined()
      expect(result.counts.pendingLevelTwo).toBeDefined()
    })
  })

  describe('getPendingChange', () => {
    it('fetches single pending change by ID', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: {
          pendingChange: {
            changeIdentifier: 'c1',
            targetGroupIdentifier: 'CN=group1',
            statusCode: 'PENDING_LEVEL_ONE'
          }
        }
      }))
      const result = await getPendingChange('c1')
      expect(mockApiFetch).toHaveBeenCalledWith(
        '/papi/v1/pending-changes/c1',
        expect.objectContaining({ method: 'GET' })
      )
      expect(result.id).toBe('c1')
    })

    it('throws when pending change not found', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({ data: { pendingChange: null } }))
      await expect(getPendingChange('missing')).rejects.toThrow('Pending change not found')
    })

    it('throws on HTTP error', async () => {
      mockApiFetch.mockResolvedValue(new Response('', { status: 404, statusText: 'Not Found' }))
      await expect(getPendingChange('c1')).rejects.toThrow('HTTP 404')
    })
  })

  describe('getMyActivity', () => {
    it('fetches activity log with default pagination', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { activityValues: [{ changeIdentifier: 'a1', actionCode: 'SUBMIT' }] },
        meta: { pagination: { offset: 0, limit: 25, total: 1, hasMore: false } }
      }))
      const result = await getMyActivity()
      expect(mockApiFetch).toHaveBeenCalledWith(
        expect.stringContaining('/papi/v1/my-activity'),
        expect.anything()
      )
      expect(result.items).toHaveLength(1)
      expect(result.page).toBe(1)
    })

    it('includes timeRange parameter', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { activityValues: [] },
        meta: { pagination: {} }
      }))
      await getMyActivity(1, 25, 'today')
      expect(mockApiFetch).toHaveBeenCalledWith(
        expect.stringContaining('timeRange=TODAY'),
        expect.anything()
      )
    })

    it('normalizes negative page numbers', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { activityValues: [] },
        meta: { pagination: {} }
      }))
      await getMyActivity(-5, 25)
      expect(mockApiFetch).toHaveBeenCalledWith(
        expect.stringContaining('offset=0'),
        expect.anything()
      )
    })
  })

  describe('getPendingChangesCount', () => {
    it('returns counts from listPendingChanges', async () => {
      mockApiFetch.mockResolvedValue(jsonResponse({
        data: { pendingChanges: [] },
        meta: { pagination: { offset: 0, limit: 1, total: 0, hasMore: false } }
      }))
      const result = await getPendingChangesCount()
      expect(result).toEqual({ total: 0, levelOne: 0, levelTwo: 0 })
    })

    it('returns zeros on error', async () => {
      mockApiFetch.mockRejectedValue(new Error('Network error'))
      const result = await getPendingChangesCount()
      expect(result).toEqual({ total: 0, levelOne: 0, levelTwo: 0 })
    })
  })
})
===ENDFILE

===FILE: src/services/api/__tests__/reference-data.service.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

const mockApiFetchJson = vi.fn()

vi.mock('../../core/api-client', () => ({
  apiFetchJson: (...args: unknown[]) => mockApiFetchJson(...args)
}))

const {
  getAllRegions,
  getAllBusinessUnits,
  getAllCountries,
  getCountriesByRegion,
  getAllMarkets,
  getMarketsByRegion,
  getCountriesByMarket
} = await import('../reference-data.service')

describe('reference-data.service', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('getAllRegions', () => {
    it('maps canonical fields correctly', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          regions: [
            { regionCode: 'APAC', regionName: 'Asia Pacific', displayOrder: 1, isActive: true }
          ]
        }
      })

      const result = await getAllRegions()
      expect(result).toEqual([
        { regionCode: 'APAC', regionName: 'Asia Pacific', displayOrder: 1, isActive: true }
      ])
    })

    it('maps alternate contract fields (displayOrderNumber/isActiveFlag)', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          regions: [
            { regionCode: 'EMEA', regionName: 'Europe', displayOrderNumber: 2, isActiveFlag: false }
          ]
        }
      })

      const result = await getAllRegions()
      expect(result).toEqual([
        { regionCode: 'EMEA', regionName: 'Europe', displayOrder: 2, isActive: false }
      ])
    })

    it('defaults displayOrder to 0 and isActive to true when missing', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          regions: [{ regionCode: 'NA', regionName: 'North America' }]
        }
      })

      const result = await getAllRegions()
      expect(result[0].displayOrder).toBe(0)
      expect(result[0].isActive).toBe(true)
    })

    it('returns empty array when no regions data', async () => {
      mockApiFetchJson.mockResolvedValue({ data: {} })
      const result = await getAllRegions()
      expect(result).toEqual([])
    })
  })

  describe('getAllBusinessUnits', () => {
    it('maps business unit fields correctly', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          businessUnits: [
            { unitCode: 'WPB', unitName: 'Wealth & PB', description: 'Wealth', effectiveDate: '2025-01-01', displayOrder: 1, isActive: true }
          ]
        }
      })

      const result = await getAllBusinessUnits()
      expect(result).toEqual([
        { unitCode: 'WPB', unitName: 'Wealth & PB', description: 'Wealth', effectiveDate: '2025-01-01', displayOrder: 1, isActive: true }
      ])
    })

    it('maps alternate contract fields', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          businessUnits: [
            { unitCode: 'CMB', unitName: 'Commercial', description: 'Desc', effectiveDate: '2025-01-01', displayOrderNumber: 3, isActiveFlag: true }
          ]
        }
      })

      const result = await getAllBusinessUnits()
      expect(result[0].displayOrder).toBe(3)
      expect(result[0].isActive).toBe(true)
    })
  })

  describe('getAllCountries', () => {
    it('maps country fields correctly', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          countries: [
            { countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true }
          ]
        }
      })

      const result = await getAllCountries()
      expect(result).toEqual([
        { countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true }
      ])
    })
  })

  describe('getCountriesByRegion', () => {
    it('fetches countries by region code', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          countries: [
            { countryCode: 'SG', countryName: 'Singapore', regionCode: 'APAC', marketCode: 'SG', displayOrder: 2, isActive: true }
          ]
        }
      })

      const result = await getCountriesByRegion('APAC')
      expect(mockApiFetchJson).toHaveBeenCalledWith('/papi/v1/regions-countries/APAC')
      expect(result[0].countryCode).toBe('SG')
    })

    it('encodes region code in URL', async () => {
      mockApiFetchJson.mockResolvedValue({ data: { countries: [] } })
      await getCountriesByRegion('A&B')
      expect(mockApiFetchJson).toHaveBeenCalledWith('/papi/v1/regions-countries/A%26B')
    })
  })

  describe('getAllMarkets', () => {
    it('maps market fields correctly', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          markets: [
            { marketCode: 'HK', marketName: 'Hong Kong', regionCode: 'APAC', displayOrder: 1, isActive: true }
          ]
        }
      })

      const result = await getAllMarkets()
      expect(result).toEqual([
        { marketCode: 'HK', marketName: 'Hong Kong', regionCode: 'APAC', displayOrder: 1, isActive: true }
      ])
    })
  })

  describe('getMarketsByRegion', () => {
    it('fetches markets by region code', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          markets: [
            { marketCode: 'SG', marketName: 'Singapore', regionCode: 'APAC', displayOrder: 1, isActive: true }
          ]
        }
      })

      const result = await getMarketsByRegion('APAC')
      expect(mockApiFetchJson).toHaveBeenCalledWith('/papi/v1/regions-markets/APAC')
      expect(result[0].marketCode).toBe('SG')
    })
  })

  describe('getCountriesByMarket', () => {
    it('filters all countries by market code', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          countries: [
            { countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true },
            { countryCode: 'SG', countryName: 'Singapore', regionCode: 'APAC', marketCode: 'SG', displayOrder: 2, isActive: true }
          ]
        }
      })

      const result = await getCountriesByMarket('HK')
      expect(result).toHaveLength(1)
      expect(result[0].countryCode).toBe('HK')
    })
  })
})
===ENDFILE

===FILE: src/services/api/__tests__/role-template.service.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

const mockApiFetchJson = vi.fn()

vi.mock('../../core/api-client', () => ({
  apiFetchJson: (...args: unknown[]) => mockApiFetchJson(...args)
}))

const {
  getAllRoleTemplates,
  getRoleTemplateByName
} = await import('../role-template.service')

describe('role-template.service', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('getAllRoleTemplates returns list from envelope', async () => {
    mockApiFetchJson.mockResolvedValue({
      data: {
        roleLayoutTemplates: [
          { roleNameCode: 'voice_agent', roleDisplayName: 'Voice Agent' },
          { roleNameCode: 'chat_agent', roleDisplayName: 'Chat Agent' }
        ]
      }
    })

    const result = await getAllRoleTemplates()
    expect(result).toHaveLength(2)
    expect(result[0].roleNameCode).toBe('voice_agent')
    expect(mockApiFetchJson).toHaveBeenCalledWith('/papi/v1/role-layout-templates')
  })

  it('getAllRoleTemplates returns empty array when payload missing', async () => {
    mockApiFetchJson.mockResolvedValue({ data: {} })
    const result = await getAllRoleTemplates()
    expect(result).toEqual([])
  })

  it('getRoleTemplateByName returns template from envelope', async () => {
    mockApiFetchJson.mockResolvedValue({
      data: {
        roleNameCode: 'voice_agent',
        roleDisplayName: 'Voice Agent',
        columns: { chat: { stateText: 'ENABLED' } },
        widgets: {},
        features: {},
        settingsTabs: {},
        settingsOptions: {},
        microFrontends: {}
      }
    })

    const result = await getRoleTemplateByName('voice_agent')
    expect(result.roleNameCode).toBe('voice_agent')
    expect(result.columns.chat.stateText).toBe('ENABLED')
    expect(mockApiFetchJson).toHaveBeenCalledWith('/papi/v1/role-layout-templates/voice_agent')
  })

  it('getRoleTemplateByName URL-encodes role name code', async () => {
    mockApiFetchJson.mockResolvedValue({ data: {} })
    await getRoleTemplateByName('voice/agent')
    expect(mockApiFetchJson).toHaveBeenCalledWith('/papi/v1/role-layout-templates/voice%2Fagent')
  })
})
===ENDFILE

===FILE: src/services/api/adgroup-copy-mappers.ts
/**
 * AD Group Copy Mappers - Response mapping for copy configuration results.
 */

import type { CopyResult } from '../../types/features/admin.types'

/** Raw PAPI response shape for a copy operation result. */
export interface PapiCopyResult {
  successFlag?: boolean
  messageText?: string
  errorText?: string
  updatedGroup?: Record<string, unknown>
  workflowStatusCode?: 'DIRECT_APPLIED' | 'SUBMITTED_FOR_APPROVAL'
  pendingChangeIdentifier?: string
  criticalIndicator?: boolean
  levelTwoApprovalRequiredIndicator?: boolean
  unavailableAppFunctionValues?: string[]
}

/** Maps a failed copy result to a CopyResult error response. */
export function mapCopyFailure(copyResult: PapiCopyResult | undefined, status: number, statusText: string): CopyResult {
  const message = copyResult?.messageText
    ?? copyResult?.errorText
    ?? `HTTP ${status}: ${statusText}`
  return {
    success: false,
    message,
    error: copyResult?.errorText ?? 'REQUEST_FAILED',
    errorDetails: {},
    workflowStatusCode: copyResult?.workflowStatusCode,
    pendingChangeIdentifier: copyResult?.pendingChangeIdentifier,
    criticalIndicator: copyResult?.criticalIndicator,
    levelTwoApprovalRequiredIndicator: copyResult?.levelTwoApprovalRequiredIndicator,
    unavailableAppFunctionValues: copyResult?.unavailableAppFunctionValues
  }
}

/** Maps a successful copy result to a CopyResult success response. */
export function mapCopySuccess(copyResult: PapiCopyResult | undefined): CopyResult {
  return {
    success: true,
    message: copyResult?.messageText ?? 'Configuration copied successfully',
    updatedGroup: copyResult?.updatedGroup,
    workflowStatusCode: copyResult?.workflowStatusCode,
    pendingChangeIdentifier: copyResult?.pendingChangeIdentifier,
    criticalIndicator: copyResult?.criticalIndicator,
    levelTwoApprovalRequiredIndicator: copyResult?.levelTwoApprovalRequiredIndicator,
    unavailableAppFunctionValues: copyResult?.unavailableAppFunctionValues
  }
}
===ENDFILE

===FILE: src/services/api/adgroup-copy.service.ts
/**
 * AD Group Copy Service - Copy configuration between AD groups
 */

import { apiFetch } from '../core/api-client'
import type { CopyOptions, CopyResult } from '../../types/features/admin.types'
import { ensureToken } from './adgroup-mappers'
import { mapCopyFailure, mapCopySuccess, type PapiCopyResult } from './adgroup-copy-mappers'

/**
 * Copies configuration from a source AD group to a target AD group.
 * Supports workflow mode selection (direct save vs submit for approval) and function mismatch handling.
 * @param sourceGroupIdentifier - DN of the source AD group
 * @param targetGroupIdentifier - DN of the target AD group
 * @param options - Copy options controlling which sections to copy and workflow mode
 * @returns Result with success flag, workflow status, and any unavailable function details
 */
export async function copyAdGroupConfiguration(
  sourceGroupIdentifier: string,
  targetGroupIdentifier: string,
  options?: CopyOptions
): Promise<CopyResult> {
  try {
    ensureToken();

    const requestBody = {
      sourceGroupIdentifier,
      targetGroupIdentifier,
      copyOptions: {
        copyRoleAndPermissionsFlag: true,
        copyBusinessInfoFlag: true,
        copyApplicationsFlag: true,
        overwriteExistingFlag: false,
        copyWorkflowModeCode: 'SUBMIT_FOR_APPROVAL',
        functionMismatchPolicyCode: 'FAIL_ON_MISMATCH',
        ...options
      }
    };

    const response = await apiFetch('/papi/v1/ad-group-configuration-copies', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ data: requestBody })
    });

    const payload = await response.json().catch(() => ({})) as {
      data?: { copyResult?: PapiCopyResult }
    };
    const copyResult = payload.data?.copyResult;

    if (!response.ok || copyResult?.successFlag === false) {
      return mapCopyFailure(copyResult, response.status, response.statusText);
    }

    return mapCopySuccess(copyResult);

  } catch (error) {
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Failed to copy configuration',
      error: 'NETWORK_ERROR',
      errorDetails: {}
    };
  }
}
===ENDFILE

===FILE: src/services/api/adgroup-crud.service.ts
/**
 * AD Group CRUD Service - Fetch, search, lookup, and update operations for AD Groups
 */

/* eslint-disable no-console */
import { apiFetch } from '../core/api-client'
import { handleApiResponse } from '../../utils/api/response-handler'
import type { AdGroup } from '../../types/features/ad-group-config'
import { ensureToken, mapAdGroup, normalizeProposedState } from './adgroup-mappers'

/**
 * Fetches all AD groups from the PAPI with their current configuration state.
 * @returns Array of mapped AdGroup objects
 */
export async function getAllAdGroups(): Promise<AdGroup[]> {
  ensureToken();

  const response = await apiFetch('/papi/v1/ad-groups', {
    method: 'GET'
  });

  const data = await handleApiResponse<Record<string, unknown>>({
    response,
    context: 'AdminService.getAllAdGroups'
  });

  const adGroupsData = data as { data?: { items?: Record<string, unknown>[] } };
  const items = adGroupsData.data?.items;

  if (!items || !Array.isArray(items)) {
    console.error('[AdminService] getAllAdGroups response has unexpected format:', data);
    throw new Error('Unexpected response format from AD groups endpoint');
  }

  return items.map(item => mapAdGroup(item));
}

/**
 * Looks up a single AD group by its DN identifier via POST-based lookup.
 * @param groupIdentifier - Full DN of the AD group to look up
 * @returns Mapped AdGroup object
 */
export async function lookupAdGroup(groupIdentifier: string): Promise<AdGroup> {
  ensureToken();

  const response = await apiFetch('/papi/v1/ad-groups/lookup', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      data: {
        groupIdentifier
      }
    })
  });

  const result = await handleApiResponse<{
    data?: Record<string, unknown>
  }>({
    response,
    context: 'AdminService.lookupAdGroup'
  });

  const item = result.data;
  if (!item) {
    throw new Error('AD group not found');
  }

  return mapAdGroup(item);
}

/**
 * Searches AD groups by text query with a configurable result limit (max 1000).
 * @param search - Optional search text to filter groups
 * @param limit - Maximum number of results (default 500, clamped to 1-1000)
 * @returns Array of matching AdGroup objects
 */
export async function searchAdGroups(search?: string, limit = 500): Promise<AdGroup[]> {
  ensureToken();

  const safeLimit = Math.min(Math.max(limit, 1), 1000);
  const params = new URLSearchParams({ limit: String(safeLimit) });
  if (search && search.trim().length > 0) {
    params.set('search', search.trim());
  }

  const response = await apiFetch(`/papi/v1/ad-groups?${params.toString()}`, {
    method: 'GET'
  });

  const rawData = await handleApiResponse<Record<string, unknown>>({
    response,
    context: 'AdminService.searchAdGroups'
  });

  const dataObj = rawData as { data?: { items?: Record<string, unknown>[] } };
  const payload = dataObj.data?.items;

  if (!payload || !Array.isArray(payload)) {
    console.error('[AdminService] searchAdGroups response is not an array:', rawData);
    throw new Error('Unexpected response format from AD groups search endpoint');
  }

  return payload.map((item: Record<string, unknown>): AdGroup => {
    const mapped = mapAdGroup(item);
    return {
      ...mapped,
      id: typeof item.id === 'string' && item.id.length > 0 ? item.id : mapped.id
    };
  });
}

/**
 * Updates an AD group's configuration by posting a proposed state change.
 * Normalizes frontend field names (isActive -> activeIndicator) before sending.
 * @param groupIdentifier - DN of the AD group to update
 * @param updateData - Partial update with fields to change
 * @returns Raw PAPI response data
 */
export async function updateAdGroup(groupIdentifier: string, updateData: Record<string, unknown>): Promise<Record<string, unknown>> {
  ensureToken();

  const proposedState = normalizeProposedState(updateData);
  const requestData: Record<string, unknown> = {
    targetGroupIdentifier: groupIdentifier,
    proposedState
  };
  if (typeof updateData.configVersionNumber === 'number') {
    requestData.configVersionNumber = updateData.configVersionNumber;
  }

  const response = await apiFetch('/papi/v1/ad-group-configs', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ data: requestData })
  });

  return handleApiResponse<Record<string, unknown>>({
    response,
    context: 'AdminService.updateAdGroup'
  });
}
===ENDFILE

===FILE: src/services/api/adgroup-mappers.ts
/**
 * AD Group Mappers - Transform functions for PAPI AD group responses
 */

import { getAuthToken } from '../../utils/auth/auth-token-manager'
import type { AdGroup } from '../../types/features/ad-group-config'

/** Retrieves the current auth token or throws if not authenticated. Used as a guard before API calls. */
export function ensureToken(): string {
  const token = getAuthToken()
  if (!token) {
    throw new Error('No authentication token found')
  }
  return token
}

/**
 * Converts PAPI permission objects (with enabledIndicator booleans) to
 * frontend state maps ('enabled'/'disabled' strings) for the permission grid.
 */
export function toAssignmentMap(
  permissions: Record<string, unknown> | undefined
): Record<string, { state: 'enabled' | 'disabled' }> | undefined {
  if (!permissions) {
    return undefined;
  }

  return Object.fromEntries(
    Object.entries(permissions).map(([key, value]) => {
      const permission = value as { enabledIndicator?: boolean };
      return [key, { state: permission?.enabledIndicator ? 'enabled' : 'disabled' as const }];
    })
  );
}

/**
 * Transforms a raw PAPI AD group record into the typed AdGroup interface.
 * Maps SAPI field names (regionCode, activeIndicator) to frontend names (region, isActive).
 */
export function mapAdGroup(item: Record<string, unknown>): AdGroup {
  const currentConfig = item.currentConfig as Record<string, unknown> | undefined;
  const permissionChanges = currentConfig?.permissionChanges as Record<string, unknown> | undefined;

  return {
    id: (item.groupIdentifier as string | undefined) ?? '',
    groupIdentifier: (item.groupIdentifier as string | undefined) ?? '',
    logicalName: item.logicalName as string | undefined,
    roleName: item.roleName as string | undefined,
    market: item.marketCode as string | undefined,
    region: item.regionCode as string | undefined,
    country: item.countryCode as string | undefined,
    businessUnit: item.businessUnitName as string | undefined,
    isActive: (item.activeIndicator as boolean | undefined) ?? true,
    accessLevel: item.userAccessCode as AdGroup['accessLevel'] | undefined,
    pendingChangeIndicator: (item.pendingChangeIndicator as boolean | undefined) ?? false,
    versionNumber: item.versionNumber as number | undefined,
    userCount: item.userCountNumber as number | undefined,
    lastModified: item.updatedAtDatetime as string | undefined,
    columnAssignments: toAssignmentMap(
      permissionChanges?.columnPermissions as Record<string, unknown> | undefined
    ),
    widgetAssignments: toAssignmentMap(
      permissionChanges?.widgetPermissions as Record<string, unknown> | undefined
    )
  };
}

/**
 * Normalizes frontend field names back to PAPI conventions before sending updates.
 * Converts 'isActive' to 'activeIndicator' and strips undefined values.
 */
export function normalizeProposedState(updateData: Record<string, unknown>): Record<string, unknown> {
  const proposedState: Record<string, unknown> = { ...updateData };

  if ('isActive' in proposedState && typeof proposedState.isActive === 'boolean') {
    proposedState.activeIndicator = proposedState.isActive;
    delete proposedState.isActive;
  }

  return Object.fromEntries(
    Object.entries(proposedState).filter(([, value]) => value !== undefined)
  );
}
===ENDFILE

===FILE: src/services/api/admin-adgroup.service.ts
/**
 * Admin AD Group Service - CRUD and copy operations for AD Groups
 *
 * Re-exports from split modules for reduced per-file complexity.
 */

// Re-export mapper utilities for consumers
export { ensureToken, toAssignmentMap, mapAdGroup, normalizeProposedState } from './adgroup-mappers'

// Re-export copy operation
export { copyAdGroupConfiguration } from './adgroup-copy.service'

// Re-export CRUD operations
export { getAllAdGroups, lookupAdGroup, searchAdGroups, updateAdGroup } from './adgroup-crud.service'
===ENDFILE

===FILE: src/services/api/admin-approval.service.ts
/**
 * Admin Approval Service - Facade re-exporting split approval modules
 * Preserves the singleton-style adminApprovalService API for backward compatibility.
 */

import {
  submitChange,
  directSave,
  approveChange,
  rejectChange,
  cancelChange
} from './approval-actions.service'

import {
  listPendingChanges,
  getPendingChange,
  getMyActivity,
  getPendingChangesCount
} from './approval-queries.service'

export const adminApprovalService = {
  submitChange,
  directSave,
  approveChange,
  rejectChange,
  cancelChange,
  listPendingChanges,
  getPendingChange,
  getMyActivity,
  getPendingChangesCount
}
===ENDFILE

===FILE: src/services/api/admin-notice-response-handler.ts
/**
 * Admin Notice Response Handler
 * Shared response validation and extraction logic for notice API calls.
 * Extracted from admin-notice.service.ts to reduce per-file complexity.
 */

import { handleApiResponse } from '../../utils/api/response-handler'
import { fromPapiNoticePayload } from './notice-mappers'
import type { AdminNoticeResponse } from '../../types/features/admin.types'

/** Standard PAPI response shape for single-notice endpoints. */
type SingleNoticeApiResponse = { data?: { notice?: Record<string, unknown> } }

/** Standard PAPI response shape for list-notices endpoint. */
type NoticeListApiResponse = { data?: { notices?: Record<string, unknown>[] } }

/**
 * Validates and extracts a single notice from a PAPI response.
 * Throws if the response does not contain a notice object.
 * @param response - Raw fetch Response from the API
 * @param context - Caller context string for error messages
 * @returns Mapped AdminNoticeResponse DTO
 */
export async function extractSingleNotice(
  response: Response,
  context: string
): Promise<AdminNoticeResponse> {
  const result = await handleApiResponse<SingleNoticeApiResponse>({
    response,
    context
  })

  const notice = result.data?.notice
  if (!notice) {
    throw new Error(`Unexpected response format from ${context}`)
  }
  return fromPapiNoticePayload(notice)
}

/**
 * Validates and extracts a notice list from a PAPI response.
 * Throws if the response does not contain a notices array.
 * @param response - Raw fetch Response from the API
 * @param context - Caller context string for error messages
 * @returns Array of mapped AdminNoticeResponse DTOs
 */
export async function extractNoticeList(
  response: Response,
  context: string
): Promise<AdminNoticeResponse[]> {
  const result = await handleApiResponse<NoticeListApiResponse>({
    response,
    context
  })

  const notices = result.data?.notices
  if (!notices || !Array.isArray(notices)) {
    throw new Error(`Unexpected response format from ${context}`)
  }
  return notices.map((n) => fromPapiNoticePayload(n))
}
===ENDFILE

===FILE: src/services/api/admin-notice.service.ts
/**
 * Admin Notice Service - CRUD operations for system notices
 */

import { apiFetch } from '../core/api-client'
import {
  ensureNoticeToken,
  toPapiNoticePayload
} from './notice-mappers'
import { extractSingleNotice, extractNoticeList } from './admin-notice-response-handler'
import type {
  AdminNoticeRequest,
  AdminNoticeResponse
} from '../../types/features/admin.types'

/**
 * Creates a new system notice with the specified content and targeting options.
 * @param noticeData - Notice payload with title, message, severity, and targeting
 * @returns The created notice response with server-assigned ID and timestamps
 */
export async function createNotice(noticeData: AdminNoticeRequest): Promise<AdminNoticeResponse> {
  const amtoken = ensureNoticeToken();
  const noticePayload = toPapiNoticePayload({ ...noticeData, createdBy: amtoken });

  const response = await apiFetch('/papi/v1/notices', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ data: noticePayload })
  });

  return extractSingleNotice(response, 'AdminService.createNotice');
}

/**
 * Lists all system notices, optionally filtered by status (DRAFT, ACTIVE, EXPIRED).
 * @param status - Optional status code filter
 * @returns Array of notice response objects
 */
export async function listNotices(status?: string): Promise<AdminNoticeResponse[]> {
  ensureNoticeToken();

  const url = status
    ? `/papi/v1/notices?statusCode=${encodeURIComponent(status)}`
    : '/papi/v1/notices';

  const response = await apiFetch(url, { method: 'GET' });

  return extractNoticeList(response, 'AdminService.listNotices');
}

/**
 * Updates an existing notice's content and targeting configuration.
 * @param noticeId - Server-assigned notice identifier
 * @param noticeData - Updated notice payload
 * @returns The updated notice response
 */
export async function updateNotice(noticeId: string, noticeData: AdminNoticeRequest): Promise<AdminNoticeResponse> {
  ensureNoticeToken();
  const noticePayload = toPapiNoticePayload(noticeData);

  const response = await apiFetch(`/papi/v1/notices/${noticeId}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ data: noticePayload })
  });

  return extractSingleNotice(response, 'AdminService.updateNotice');
}

/**
 * Changes a notice's status (e.g., DRAFT -> ACTIVE, ACTIVE -> EXPIRED).
 * @param noticeId - Server-assigned notice identifier
 * @param status - New status code to apply
 * @returns The updated notice response with new status
 */
export async function updateNoticeStatus(noticeId: string, status: string): Promise<AdminNoticeResponse> {
  ensureNoticeToken();

  const response = await apiFetch(`/papi/v1/notices/${noticeId}/status`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ data: { statusCode: status } })
  });

  return extractSingleNotice(response, 'AdminService.updateNoticeStatus');
}
===ENDFILE

===FILE: src/services/api/admin.service.ts
/**
 * Admin Service - Facade re-exporting split admin modules
 * Preserves the singleton-style adminService API for backward compatibility.
 */

import {
  copyAdGroupConfiguration,
  getAllAdGroups,
  lookupAdGroup,
  searchAdGroups,
  updateAdGroup
} from './admin-adgroup.service'

import {
  createNotice,
  listNotices,
  updateNotice,
  updateNoticeStatus
} from './admin-notice.service'

export type { AdminNoticeRequest, AdminNoticeResponse } from '../../types/features/admin.types'

export const adminService = {
  copyAdGroupConfiguration,
  getAllAdGroups,
  lookupAdGroup,
  searchAdGroups,
  updateAdGroup,
  createNotice,
  listNotices,
  updateNotice,
  updateNoticeStatus
}
===ENDFILE

===FILE: src/services/api/approval-actions.service.ts
/**
 * Approval Actions Service - Write operations for the Maker/Checker approval workflow
 * Handles submit, direct save, approve, reject, and cancel operations.
 *
 * Re-exports from split modules for reduced per-file complexity.
 */

// Re-export utility functions for consumers
export { ensureToken, generateCorrelationId, handleSubmitError } from './approval-service-utils'

// Re-export submit and direct save operations
export { submitChange, directSave } from './approval-submit.service'

// Re-export review operations (approve, reject, cancel)
export { approveChange, rejectChange, cancelChange } from './approval-review.service'
===ENDFILE

===FILE: src/services/api/approval-config-unwrap-helpers.ts
/**
 * Approval Config Unwrap Helpers - Low-level field mapping and unwrapping functions.
 */

const SAPI_FIELD_MAP: Record<string, string> = {
  regionCode: 'region',
  countryCode: 'country',
  marketCode: 'market',
  businessUnitName: 'businessUnit'
}

const PERM_LEVEL_MAP: Record<string, string> = {
  columnPermissions: 'columns',
  widgetPermissions: 'widgets',
  featurePermissions: 'features',
  settingsTabPermissions: 'settingsTabs',
  settingsOptionPermissions: 'settingsOptions',
  microFrontendPermissions: 'microFrontends'
}

export const NESTED_WRAPPER_KEYS = new Set(['businessInfoChanges', 'permissionChanges', 'applicationChanges', 'appFunctionChanges'])

function isNonNullValue(value: unknown): boolean {
  return value !== null && value !== undefined
}

/** Maps SAPI business info fields (regionCode, countryCode, etc.) to frontend field names (region, country, etc.). */
export function unwrapBusinessInfo(businessInfo: Record<string, unknown>, result: Record<string, unknown>): void {
  for (const [key, value] of Object.entries(businessInfo)) {
    if (isNonNullValue(value)) result[SAPI_FIELD_MAP[key] ?? key] = value
  }
}

function unwrapPermissionLevel(level: string, changes: unknown, result: Record<string, unknown>): void {
  if (!changes || typeof changes !== 'object') return
  const mappedLevel = PERM_LEVEL_MAP[level] ?? level
  for (const [key, value] of Object.entries(changes as Record<string, unknown>)) {
    result[`permissions.${mappedLevel}.${key}`] = value
  }
}

/** Flattens nested permission changes into dot-notation paths (e.g., 'permissions.columns.chat'). */
export function unwrapPermissions(permChanges: Record<string, unknown>, result: Record<string, unknown>): void {
  for (const [level, changes] of Object.entries(permChanges)) {
    unwrapPermissionLevel(level, changes, result)
  }
}

const FLAT_CONFIG_MARKERS = ['roleName', 'logicalName', 'region'] as const

/** Detects whether a config object is already flat (contains top-level business fields directly). */
export function isAlreadyFlat(config: Record<string, unknown>): boolean {
  return FLAT_CONFIG_MARKERS.some(key => key in config)
}

/** Copies all config keys that are not nested wrapper keys (businessInfoChanges, permissionChanges, etc.). */
export function copyNonWrapperKeys(config: Record<string, unknown>, result: Record<string, unknown>): void {
  for (const [key, value] of Object.entries(config)) {
    if (!NESTED_WRAPPER_KEYS.has(key) && !(key in result)) {
      result[key] = value
    }
  }
}

export function isNonNullObject(value: unknown): value is Record<string, unknown> {
  return value !== null && value !== undefined && typeof value === 'object'
}
===ENDFILE

===FILE: src/services/api/approval-config-unwrap.ts
/**
 * Approval Config Unwrap - Flattens nested SAPI config structures into flat key-value maps.
 * Handles businessInfoChanges field mapping and permissionChanges level mapping.
 */

import {
  unwrapBusinessInfo,
  unwrapPermissions,
  isAlreadyFlat,
  copyNonWrapperKeys,
  isNonNullObject
} from './approval-config-unwrap-helpers'

/**
 * Flattens nested SAPI config structure into a flat key-value map.
 * Handles businessInfoChanges, permissionChanges, and passes through already-flat configs.
 * @param config - Raw SAPI config with nested wrapper keys
 * @returns Flattened config with SAPI field names mapped to frontend field names
 */
export function unwrapConfig(config: Record<string, unknown> | null): Record<string, unknown> {
  if (!config) return {}
  if (isAlreadyFlat(config)) return config

  const result: Record<string, unknown> = {}

  const businessInfo = config.businessInfoChanges
  if (isNonNullObject(businessInfo)) unwrapBusinessInfo(businessInfo, result)

  const permChanges = config.permissionChanges
  if (isNonNullObject(permChanges)) unwrapPermissions(permChanges, result)

  copyNonWrapperKeys(config, result)

  return Object.keys(result).length > 0 ? result : config
}
===ENDFILE

===FILE: src/services/api/approval-count-query.service.ts
/**
 * Approval Count Query - Summary count of pending changes
 */

import { listPendingChanges } from './approval-list-query.service'

/**
 * Returns a summary count of pending changes by approval level.
 * Gracefully returns zeros on failure.
 * @returns Object with total, levelOne, and levelTwo counts
 */
export async function getPendingChangesCount(): Promise<{ total: number; levelOne: number; levelTwo: number }> {
  try {
    const data = await listPendingChanges({ limit: 1 })
    return {
      total: data.counts.pendingLevelOne + data.counts.pendingLevelTwo,
      levelOne: data.counts.pendingLevelOne,
      levelTwo: data.counts.pendingLevelTwo
    }
  } catch {
    return { total: 0, levelOne: 0, levelTwo: 0 }
  }
}
===ENDFILE

===FILE: src/services/api/approval-detail-mappers.ts
/**
 * Approval Detail Mappers - Response mapping for pending change detail and activity pagination.
 */

import type { PapiPendingChange } from './approval-formatters'

/** Extracts a PapiPendingChange from the raw detail API response shape. */
export function extractPendingChangeFromResponse(pc: {
  changeIdentifier: string
  targetGroupIdentifier: string
  targetGroupName?: string
  isCriticalIndicator?: boolean
  changeType?: string
  currentConfig?: Record<string, unknown>
  proposedConfig?: Record<string, unknown>
  statusCode: string
  createdByText?: string
  createdAtDatetime?: string
  approvedByText?: string
  approvedAtDatetime?: string
  commentText?: string
  rejectedByText?: string
  rejectedAtDatetime?: string
  rejectionReasonText?: string
  updatedAtDatetime?: string
}): PapiPendingChange {
  return {
    changeIdentifier: pc.changeIdentifier,
    targetGroupIdentifier: pc.targetGroupIdentifier,
    targetGroupName: pc.targetGroupName ?? null,
    changeType: pc.changeType ?? 'CONFIG_UPDATE',
    currentConfig: pc.currentConfig ?? null,
    proposedConfig: pc.proposedConfig ?? null,
    isCriticalIndicator: pc.isCriticalIndicator ?? false,
    statusCode: pc.statusCode,
    createdByText: pc.createdByText ?? null,
    createdAtDatetime: pc.createdAtDatetime ?? new Date().toISOString(),
    approvedByText: pc.approvedByText,
    approvedAtDatetime: pc.approvedAtDatetime,
    commentText: pc.commentText,
    rejectedByText: pc.rejectedByText,
    rejectedAtDatetime: pc.rejectedAtDatetime,
    rejectionReasonText: pc.rejectionReasonText,
    updatedAtDatetime: pc.updatedAtDatetime
  }
}

/** Computes pagination page number from offset and limit values. */
export function computePage(offset: number, limit: number): number {
  return limit > 0 ? Math.floor(offset / limit) + 1 : 1
}
===ENDFILE

===FILE: src/services/api/approval-detail-query.service.ts
/**
 * Approval Detail Query - Fetches single pending change and activity log
 */

import { apiFetch } from '../core/api-client'
import {
  mapPapiItemToDto,
  mapActivityItem,
  type PapiActivityLogItem
} from './approval-formatters'
import { ensureToken, generateCorrelationId } from './approval-service-utils'
import { extractPendingChangeFromResponse, computePage } from './approval-detail-mappers'
import type {
  PendingChangeDto,
  ActivityLogDto,
  ActivityListResponse
} from '../../types/features/approval-workflow.types'

/**
 * Fetches a single pending change by its identifier and maps to a frontend DTO.
 * @param changeId - The pending change identifier
 * @returns Fully mapped PendingChangeDto
 */
export async function getPendingChange(changeId: string): Promise<PendingChangeDto> {
  ensureToken()

  const response = await apiFetch(
    `/papi/v1/pending-changes/${encodeURIComponent(changeId)}`,
    {
      method: 'GET',
      headers: {
        'X-Correlation-Id': generateCorrelationId()
      }
    }
  )

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
  }

  const result = await response.json() as {
    data: {
      pendingChange: {
        changeIdentifier: string
        targetGroupIdentifier: string
        targetGroupName?: string
        isCriticalIndicator?: boolean
        changeType?: string
        currentConfig?: Record<string, unknown>
        proposedConfig?: Record<string, unknown>
        statusCode: string
        createdByText?: string
        createdAtDatetime?: string
        approvedByText?: string
        approvedAtDatetime?: string
        commentText?: string
        rejectedByText?: string
        rejectedAtDatetime?: string
        rejectionReasonText?: string
        updatedAtDatetime?: string
      }
    }
  }

  const pc = result.data?.pendingChange
  if (!pc) {
    throw new Error('Pending change not found')
  }

  const papiItem = extractPendingChangeFromResponse(pc)
  return mapPapiItemToDto(papiItem, false)
}

/**
 * Fetches the current user's activity log with pagination and optional time range filter.
 * @param page - Page number (1-based, defaults to 1)
 * @param size - Page size (defaults to 25)
 * @param timeRange - Optional time filter: 'today', 'week', or 'month'
 * @returns Paginated activity log items with total count
 */
export async function getMyActivity(page: number = 1, size: number = 25, timeRange?: 'today' | 'week' | 'month'): Promise<ActivityListResponse> {
  ensureToken()

  const normalizedPage = Math.max(1, Math.floor(page))
  const normalizedSize = Math.max(1, Math.floor(size))
  const offset = (normalizedPage - 1) * normalizedSize

  const params = new URLSearchParams({
    offset: String(offset),
    limit: String(normalizedSize)
  })
  if (timeRange) {
    params.append('timeRange', timeRange.toUpperCase())
  }

  const response = await apiFetch(
    `/papi/v1/my-activity?${params.toString()}`,
    {
      method: 'GET',
      headers: {
        'X-Correlation-Id': generateCorrelationId()
      }
    }
  )

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
  }

  const rawResponse = await response.json() as {
    data?: { activityValues?: PapiActivityLogItem[] }
    meta?: { pagination?: { offset?: number; limit?: number; total?: number; hasMore?: boolean } }
  }

  const rawItems = rawResponse.data?.activityValues ?? []
  const pagination = rawResponse.meta?.pagination ?? {}
  const responseOffset = pagination.offset ?? offset
  const responseLimit = pagination.limit ?? normalizedSize
  const responseTotal = pagination.total ?? 0

  const items: ActivityLogDto[] = rawItems.map((item, index) => mapActivityItem(item, index))

  return {
    items,
    totalCount: responseTotal,
    page: computePage(responseOffset, responseLimit),
    size: responseLimit
  }
}
===ENDFILE

===FILE: src/services/api/approval-diff-extractors.ts
/**
 * Approval Diff Extractors - Orchestrator for computing app-level and function-level diffs
 * between current and proposed SAPI configurations.
 */

// Re-export from split modules for backward compatibility
export { computeAppsDiff as extractAppsChanges } from './approval-diff-set-operations'
export { extractFunctionChanges as extractFunctionsChanges } from './approval-diff-function-operations'

/** Categorized function-level changes between current and proposed configs. */
export type FunctionDiffResult = {
  added: Array<{ app: string; function: string }>
  removed: Array<{ app: string; function: string }>
  unchanged: Array<{ app: string; function: string }>
}

/** A single function change record from the SAPI appFunctionChanges array. */
export type FunctionChangeEntry = { appCode?: string; functionCode?: string }
===ENDFILE

===FILE: src/services/api/approval-diff-function-operations.ts
/**
 * Approval Diff Function Operations
 * Functions for computing function-level diffs between current and proposed configurations.
 * Extracted from approval-diff-extractors.ts to reduce per-file complexity.
 */

import {
  mapTopLevelFunctions,
  buildFunctionsDiff
} from './approval-diff-helpers'
import type { FunctionDiffResult, FunctionChangeEntry } from './approval-diff-extractors'

/** Extracts appFunctionChanges from raw configs and computes function diff. */
export function computeFunctionsDiff(
  currentConfig: Record<string, unknown> | null,
  proposedConfig: Record<string, unknown> | null
): FunctionDiffResult | null {
  if (!proposedConfig) return null

  const proposedFuncs = proposedConfig.appFunctionChanges as FunctionChangeEntry[] | null | undefined
  const currentFuncs = currentConfig?.appFunctionChanges as FunctionChangeEntry[] | null | undefined

  if ((!Array.isArray(proposedFuncs) || proposedFuncs.length === 0) &&
      (!Array.isArray(currentFuncs) || currentFuncs.length === 0)) {
    return null
  }

  return buildFunctionsDiff(currentFuncs ?? [], proposedFuncs ?? [])
}

/**
 * Extracts function-level changes, preferring top-level PAPI diff when available,
 * otherwise computing diff from appFunctionChanges arrays in current/proposed config.
 */
export function extractFunctionChanges(
  topLevel: {
    added: Array<{ appIdentifier: string; functionIdentifier: string }>
    removed: Array<{ appIdentifier: string; functionIdentifier: string }>
    unchanged: Array<{ appIdentifier: string; functionIdentifier: string }>
  } | null | undefined,
  currentConfig: Record<string, unknown> | null,
  proposedConfig: Record<string, unknown> | null
): FunctionDiffResult | null {
  if (topLevel) return mapTopLevelFunctions(topLevel)
  return computeFunctionsDiff(currentConfig, proposedConfig)
}
===ENDFILE

===FILE: src/services/api/approval-diff-helpers.ts
/**
 * Approval Diff Helpers - Low-level set comparison functions for computing diffs.
 */

import type { FunctionDiffResult, FunctionChangeEntry } from './approval-diff-extractors'

/** Extracts app codes from an array of app change objects. */
export function extractAppCodes(apps: Array<{ appCode?: string }> | null | undefined): string[] {
  return Array.isArray(apps) ? (apps.map(a => a.appCode).filter(Boolean) as string[]) : []
}

export function hasNoApps(apps: Array<{ appCode?: string }> | null | undefined): boolean {
  return !Array.isArray(apps) || apps.length === 0
}

/** Transforms PAPI top-level function diff (using appIdentifier/functionIdentifier) to the frontend shape. */
export function mapTopLevelFunctions(topLevel: {
  added: Array<{ appIdentifier: string; functionIdentifier: string }>
  removed: Array<{ appIdentifier: string; functionIdentifier: string }>
  unchanged: Array<{ appIdentifier: string; functionIdentifier: string }>
}): FunctionDiffResult {
  const mapFn = (f: { appIdentifier: string; functionIdentifier: string }) => ({ app: f.appIdentifier, function: f.functionIdentifier })
  return {
    added: topLevel.added.map(mapFn),
    removed: topLevel.removed.map(mapFn),
    unchanged: topLevel.unchanged.map(mapFn)
  }
}

/** Creates a composite key for set-based comparison of function change entries. */
export function toFunctionKey(f: FunctionChangeEntry): string {
  return `${f.appCode}:${f.functionCode}`
}

export function toFunctionDiffEntry(f: FunctionChangeEntry): { app: string; function: string } {
  return { app: f.appCode ?? '', function: f.functionCode ?? '' }
}

/** Computes added/removed/unchanged function sets by comparing current and proposed function arrays. */
export function buildFunctionsDiff(
  currentFuncs: FunctionChangeEntry[],
  proposedFuncs: FunctionChangeEntry[]
): FunctionDiffResult | null {
  const currentSet = new Set(currentFuncs.map(toFunctionKey))
  const proposedSet = new Set(proposedFuncs.map(toFunctionKey))

  const added = proposedFuncs.filter(f => !currentSet.has(toFunctionKey(f))).map(toFunctionDiffEntry)
  const removed = currentFuncs.filter(f => !proposedSet.has(toFunctionKey(f))).map(toFunctionDiffEntry)
  const unchanged = proposedFuncs.filter(f => currentSet.has(toFunctionKey(f))).map(toFunctionDiffEntry)

  if (added.length === 0 && removed.length === 0) return null
  return { added, removed, unchanged }
}
===ENDFILE

===FILE: src/services/api/approval-diff-set-operations.ts
/**
 * Approval Diff Set Operations
 * Low-level set comparison functions for computing app-level diffs.
 * Extracted from approval-diff-extractors.ts to reduce per-file complexity.
 */

import {
  extractAppCodes,
  hasNoApps
} from './approval-diff-helpers'

/**
 * Computes app-level diff between current and proposed config by comparing applicationChanges arrays.
 * Returns categorized lists of added, removed, and unchanged app codes, or null if no changes.
 * @param currentConfig - The current SAPI config state
 * @param proposedConfig - The proposed SAPI config state
 * @returns Object with added, removed, and unchanged app codes, or null if no changes
 */
export function computeAppsDiff(
  currentConfig: Record<string, unknown> | null,
  proposedConfig: Record<string, unknown> | null
): { added: string[]; removed: string[]; unchanged: string[] } | null {
  if (!proposedConfig) return null
  const proposedApps = proposedConfig.applicationChanges as Array<{ appCode?: string }> | null | undefined
  const currentApps = currentConfig?.applicationChanges as Array<{ appCode?: string }> | null | undefined
  if (hasNoApps(proposedApps) && hasNoApps(currentApps)) return null

  const currentSet = new Set(extractAppCodes(currentApps))
  const proposedSet = new Set(extractAppCodes(proposedApps))

  const added = [...proposedSet].filter(a => !currentSet.has(a))
  const removed = [...currentSet].filter(a => !proposedSet.has(a))
  const unchanged = [...proposedSet].filter(a => currentSet.has(a))

  if (added.length === 0 && removed.length === 0) return null
  return { added, removed, unchanged }
}
===ENDFILE

===FILE: src/services/api/approval-formatter-helpers.ts
/**
 * Approval Formatter Helpers
 * Pure functions for extracting display names, mapping approval fields, and resolving actions.
 */

import type { PendingChangeDto, ActivityLogDto } from '../../types/features/approval-workflow.types'
import type { PapiPendingChange, PapiActivityLogItem } from './approval-formatters'

/** Extracts a display-friendly group name, falling back to parsing the CN from the DN identifier. */
export function extractGroupName(item: { targetGroupName?: string | null; targetGroupIdentifier: string }): string {
  return item.targetGroupName ?? item.targetGroupIdentifier.split(',')[0].replace('CN=', '')
}

/** Maps PAPI approval fields to the frontend levelOneApproval structure, returning undefined if not yet approved. */
export function mapApprovalInfo(item: PapiPendingChange): PendingChangeDto['levelOneApproval'] {
  if (!item.approvedByText) return undefined
  return {
    approverUserId: item.approvedByText,
    approverName: item.approvedByText,
    approvalDateTime: item.approvedAtDatetime ?? '',
    comment: item.commentText ?? undefined // eslint-disable-line typescript:S2138
  }
}

/** Maps PAPI rejection fields to the frontend rejection structure with null defaults for non-rejected items. */
export function mapRejectionInfo(item: PapiPendingChange) {
  if (!item.rejectedByText) return { rejectedBy: null, rejectedDateTime: null, rejectionReason: null }
  return {
    rejectedBy: { userId: item.rejectedByText, displayName: item.rejectedByText, email: '' },
    rejectedDateTime: item.rejectedAtDatetime ?? null,
    rejectionReason: item.rejectionReasonText ?? null
  }
}

/** Determines which actions (approve, reject, cancel) the current user can take on a pending change. */
export function resolveActionPermissions(isPending: boolean, isMySubmissions: boolean) {
  return {
    canApproveIndicator: isPending && !isMySubmissions,
    canRejectIndicator: isPending && !isMySubmissions,
    canCancelIndicator: isPending && isMySubmissions
  }
}

const VALID_ACTIONS = new Set<ActivityLogDto['action']>([
  'SUBMIT', 'L1_APPROVE', 'L2_APPROVE', 'REJECT', 'CANCEL', 'DIRECT_SAVE'
])

/** Validates and maps an action code string to a typed ActivityLogDto action, defaulting to 'SUBMIT'. */
export function resolveActivityAction(actionCode: string | undefined): ActivityLogDto['action'] {
  if (actionCode && VALID_ACTIONS.has(actionCode as ActivityLogDto['action'])) {
    return actionCode as ActivityLogDto['action']
  }
  return 'SUBMIT'
}

/** Generates a stable ID for activity log entries, falling back to a composite key when changeIdentifier is absent. */
export function resolveActivityId(item: PapiActivityLogItem, performedAt: string, index: number): string {
  return item.changeIdentifier ?? `${performedAt}:${item.actionCode ?? 'SUBMIT'}:${index}`
}
===ENDFILE

===FILE: src/services/api/approval-formatter-mappers.ts
/**
 * Approval Formatter Mappers - DTO mapping functions for pending changes and activity logs.
 */

import type {
  PendingChangeDto,
  ActivityLogDto
} from '../../types/features/approval-workflow.types'
import { unwrapConfig } from './approval-config-unwrap'
import { extractAppsChanges, extractFunctionsChanges } from './approval-diff-extractors'
import {
  extractGroupName,
  mapApprovalInfo,
  mapRejectionInfo,
  resolveActionPermissions,
  resolveActivityAction,
  resolveActivityId
} from './approval-formatter-helpers'
import type { PapiPendingChange, PapiActivityLogItem } from './approval-formatters'

/**
 * Transforms a raw PAPI pending change response into a frontend PendingChangeDto.
 * Unwraps nested configs, extracts app/function diffs, and resolves action permissions.
 * @param item - Raw PAPI pending change object
 * @param isMySubmissions - Whether the current view is filtered to user's own submissions
 * @returns Fully mapped PendingChangeDto for frontend consumption
 */
export function mapPapiItemToDto(item: PapiPendingChange, isMySubmissions: boolean): PendingChangeDto {
  const isPending = item.statusCode === 'PENDING_LEVEL_ONE' || item.statusCode === 'PENDING_LEVEL_TWO'
  const submittedAt = item.createdAtDatetime ?? new Date().toISOString()
  const rejection = mapRejectionInfo(item)

  return {
    id: item.changeIdentifier,
    targetGroupIdentifier: item.targetGroupIdentifier,
    targetGroupName: extractGroupName(item),
    changeType: (item.changeType as 'CONFIG_UPDATE' | 'APP_UPDATE') ?? 'CONFIG_UPDATE',
    status: item.statusCode as PendingChangeDto['status'],
    criticalIndicator: item.isCriticalIndicator ?? false,
    matchedRules: [],
    submittedBy: {
      userId: item.createdByText ?? 'Unknown',
      displayName: item.createdByText ?? 'Unknown User',
      email: ''
    },
    submittedDateTime: submittedAt,
    expiresDateTime: item.updatedAtDatetime ?? submittedAt,
    currentState: unwrapConfig(item.currentConfig),
    proposedState: unwrapConfig(item.proposedConfig),
    appsChanges: extractAppsChanges(item.currentConfig, item.proposedConfig),
    functionsChanges: extractFunctionsChanges(null, item.currentConfig, item.proposedConfig),
    levelOneApproval: mapApprovalInfo(item),
    ...rejection,
    ...resolveActionPermissions(isPending, isMySubmissions)
  }
}

/**
 * Transforms a raw PAPI activity log entry into a frontend ActivityLogDto.
 * @param item - Raw PAPI activity log object
 * @param index - Array index used as fallback for ID generation
 * @returns Mapped ActivityLogDto for the activity history view
 */
export function mapActivityItem(item: PapiActivityLogItem, index: number): ActivityLogDto {
  const performedAt = item.createdAtDatetime ?? new Date().toISOString()

  return {
    id: resolveActivityId(item, performedAt, index),
    action: resolveActivityAction(item.actionCode),
    targetGroupName: item.targetGroupName ?? item.targetGroupIdentifier ?? 'Unknown group',
    changeType: item.changeType === 'APP_UPDATE' ? 'APP_UPDATE' : 'CONFIG_UPDATE',
    criticalIndicator: Boolean(item.isCriticalIndicator),
    performedAt,
    performedByRole: item.performedByRoleCode ?? 'MAKER',
    completionReason: item.completionReasonText ?? undefined
  }
}
===ENDFILE

===FILE: src/services/api/approval-formatters.ts
/**
 * Approval Formatters - Transforms PAPI responses to frontend DTOs for pending changes and activity logs.
 * Delegates config unwrapping to approval-config-unwrap and diff extraction to approval-diff-extractors.
 */

export { unwrapConfig } from './approval-config-unwrap'
export { extractAppsChanges, extractFunctionsChanges } from './approval-diff-extractors'
export type { FunctionDiffResult, FunctionChangeEntry } from './approval-diff-extractors'
export {
  extractGroupName,
  mapApprovalInfo,
  mapRejectionInfo,
  resolveActionPermissions,
  resolveActivityAction,
  resolveActivityId
} from './approval-formatter-helpers'
export { mapPapiItemToDto, mapActivityItem } from './approval-formatter-mappers'

/** Raw shape of a pending change record returned by the PAPI. */
export interface PapiPendingChange {
  changeIdentifier: string
  targetGroupIdentifier: string
  targetGroupName: string | null
  changeType: string
  currentConfig: Record<string, unknown> | null
  proposedConfig: Record<string, unknown> | null
  isCriticalIndicator: boolean
  statusCode: string
  createdByText: string | null
  createdAtDatetime: string
  approvedByText?: string | null
  approvedAtDatetime?: string | null
  commentText?: string | null
  rejectedByText?: string | null
  rejectedAtDatetime?: string | null
  rejectionReasonText?: string | null
  updatedAtDatetime?: string | null
}

/** Raw shape of an activity log entry returned by the PAPI. */
export interface PapiActivityLogItem {
  changeIdentifier?: string
  actionCode?: string
  changeType?: string
  targetGroupIdentifier?: string
  targetGroupName?: string
  isCriticalIndicator?: boolean
  createdAtDatetime?: string
  performedByRoleCode?: string
  completionReasonText?: string
}

/**
 * Extracts structured error information from a failed PAPI response.
 * Falls back to HTTP status text when errorInfo is not present.
 * @param response - The failed fetch Response object
 * @returns Object with errorCode and human-readable errorMessage
 */
export async function parseApiError(response: Response): Promise<{ errorCode: string; errorMessage: string }> {
  const errorBody = await response.json().catch(() => ({})) as Record<string, unknown>
  const errorInfo = (errorBody.errorInfo as Array<{ code: string; causes: string[] }>) ?? []
  return {
    errorCode: errorInfo[0]?.code ?? '',
    errorMessage: errorInfo[0]?.causes?.[0] ?? `HTTP ${response.status}: ${response.statusText}`
  }
}
===ENDFILE

===FILE: src/services/api/approval-list-query.service.ts
/**
 * Approval List Query - Fetches paginated list of pending changes
 */

import { apiFetch } from '../core/api-client'
import {
  mapPapiItemToDto,
  type PapiPendingChange
} from './approval-formatters'
import { ensureToken, generateCorrelationId } from './approval-service-utils'
import type {
  PendingChangeDto,
  PendingChangeListResponse,
  PendingChangeFilters
} from '../../types/features/approval-workflow.types'

/**
 * Fetches a paginated list of pending changes with optional status filtering.
 * Transforms raw PAPI responses into frontend DTOs and computes level counts.
 * @param filters - Optional status, offset, and limit filters
 * @returns Paginated list of pending changes with L1/L2 counts
 */
const SUPPORTED_STATUS_FILTERS = new Set([
  'PENDING_LEVEL_ONE', 'PENDING_LEVEL_TWO', 'APPROVED', 'REJECTED', 'CANCELLED', 'MY_SUBMISSIONS'
])

function buildQueryUrl(filters?: PendingChangeFilters): string {
  const params = new URLSearchParams()

  const requestedStatus = filters?.status?.[0]
  if (requestedStatus && SUPPORTED_STATUS_FILTERS.has(requestedStatus)) {
    params.append('statusCode', requestedStatus)
  }
  if (filters?.offset !== undefined) params.append('offset', String(filters.offset))
  if (filters?.limit !== undefined) params.append('limit', String(filters.limit))

  const queryString = params.toString()
  return queryString ? `/papi/v1/pending-changes?${queryString}` : '/papi/v1/pending-changes'
}

export async function listPendingChanges(
  filters?: PendingChangeFilters
): Promise<PendingChangeListResponse> {
  ensureToken()
  const url = buildQueryUrl(filters)

  const response = await apiFetch(url, {
    method: 'GET',
    headers: {
      'X-Correlation-Id': generateCorrelationId()
    }
  })

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
  }

  const rawResponse = await response.json() as {
    data: { pendingChanges: PapiPendingChange[] }
    meta: { pagination: { offset: number; limit: number; total: number; hasMore: boolean } }
  }

  const rawItems = rawResponse.data?.pendingChanges ?? []
  const pagination = rawResponse.meta?.pagination ?? { offset: 0, limit: 25, total: 0, hasMore: false }
  const isMySubmissions = filters?.status?.[0] === 'MY_SUBMISSIONS'

  const items: PendingChangeDto[] = rawItems.map(item => mapPapiItemToDto(item, isMySubmissions))

  const pendingLevelOne = items.filter(item => item.status === 'PENDING_LEVEL_ONE').length
  const pendingLevelTwo = items.filter(item => item.status === 'PENDING_LEVEL_TWO').length

  return {
    items,
    counts: {
      pendingLevelOne,
      pendingLevelTwo
    },
    totalCount: pagination.total,
    offset: pagination.offset,
    limit: pagination.limit,
    links: {
      self: url,
      first: url,
      last: url,
      prev: '',
      next: ''
    }
  }
}
===ENDFILE

===FILE: src/services/api/approval-queries.service.ts
/**
 * Approval Queries Service - Read operations for the Maker/Checker approval workflow
 * Handles listing, fetching, and counting pending changes and activity logs.
 *
 * Re-exports from split modules for reduced per-file complexity.
 */

// Re-export list query
export { listPendingChanges } from './approval-list-query.service'

// Re-export detail queries
export { getPendingChange, getMyActivity } from './approval-detail-query.service'

// Re-export count query
export { getPendingChangesCount } from './approval-count-query.service'
===ENDFILE

===FILE: src/services/api/approval-review-mappers.ts
/**
 * Approval Review Mappers - Response mapping functions for approve, reject, cancel operations.
 */

import type {
  ApproveChangeResponse,
  RejectChangeResponse,
  CancelChangeResponse
} from '../../types/features/approval-workflow.types'

/** Maps the raw PAPI approval response to the frontend ApproveChangeResponse DTO. */
export function mapApproveResponse(
  result: {
    data: {
      approval: {
        changeIdentifier: string
        statusCode: string
        messageText: string
        approvedByText?: string
        approvedAtDatetime?: string
        commentText?: string
      }
    }
  },
  changeId: string
): ApproveChangeResponse {
  const approval = result.data?.approval
  return {
    successIndicator: true,
    changeId: approval?.changeIdentifier ?? changeId,
    newStatus: (approval?.statusCode ?? 'APPROVED') as ApproveChangeResponse['newStatus'],
    message: approval?.messageText ?? 'Change approved',
    appliedDateTime: approval?.approvedAtDatetime
  }
}

/** Maps the raw PAPI rejection response to the frontend RejectChangeResponse DTO. */
export function mapRejectResponse(
  result: {
    data: {
      rejection: {
        changeIdentifier: string
        statusCode: string
        messageText: string
        rejectedByText?: string
        rejectedAtDatetime?: string
        rejectionReasonText?: string
      }
    }
  },
  changeId: string
): RejectChangeResponse {
  const rejection = result.data?.rejection
  return {
    successIndicator: true,
    changeId: rejection?.changeIdentifier ?? changeId,
    newStatus: 'REJECTED',
    message: rejection?.messageText ?? 'Change rejected',
    rejectedDateTime: rejection?.rejectedAtDatetime ?? new Date().toISOString(),
    notificationSentIndicator: true
  }
}

/** Maps the raw PAPI cancel response to the frontend CancelChangeResponse DTO. */
export function mapCancelResponse(
  result: { data: { statusCode?: string; messageText?: string } },
  changeId: string
): CancelChangeResponse {
  return {
    successIndicator: true,
    changeId,
    newStatus: 'CANCELLED' as const,
    message: result.data?.messageText ?? 'Pending change cancelled'
  }
}
===ENDFILE

===FILE: src/services/api/approval-review.service.ts
/**
 * Approval Review Service - Approve, reject, and cancel operations
 */

import { apiFetch } from '../core/api-client'
import { parseApiError } from './approval-formatters'
import { ensureToken, generateCorrelationId } from './approval-service-utils'
import { mapApproveResponse, mapRejectResponse, mapCancelResponse } from './approval-review-mappers'
import type {
  ApproveChangeRequest,
  ApproveChangeResponse,
  RejectChangeRequest,
  RejectChangeResponse,
  CancelChangeResponse
} from '../../types/features/approval-workflow.types'

/**
 * Approves a pending change as a Checker. Detects self-approval attempts (403).
 * @param changeId - The pending change identifier to approve
 * @param request - Optional approval comment
 * @returns Approval response with new status and applied datetime
 */
export async function approveChange(
  changeId: string,
  request?: ApproveChangeRequest
): Promise<ApproveChangeResponse> {
  ensureToken()

  const response = await apiFetch(
    '/papi/v1/change-approvals',
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Correlation-Id': generateCorrelationId()
      },
      body: JSON.stringify({
        data: {
          changeIdentifier: changeId,
          commentText: request?.comment ?? ''
        }
      })
    }
  )

  if (!response.ok) {
    const { errorMessage } = await parseApiError(response)
    const isSelfApproval = response.status === 403 && errorMessage.toLowerCase().includes('self')
    throw new Error(isSelfApproval ? 'self-approval: Cannot approve your own changes' : errorMessage)
  }

  const result = await response.json() as {
    data: {
      approval: {
        changeIdentifier: string
        statusCode: string
        messageText: string
        approvedByText?: string
        approvedAtDatetime?: string
        commentText?: string
      }
    }
  }

  return mapApproveResponse(result, changeId)
}

/**
 * Rejects a pending change with a reason. Sends notification to the submitter.
 * @param changeId - The pending change identifier to reject
 * @param request - Rejection reason text
 * @returns Rejection response with new status and rejected datetime
 */
export async function rejectChange(
  changeId: string,
  request: RejectChangeRequest
): Promise<RejectChangeResponse> {
  ensureToken()

  const response = await apiFetch(
    '/papi/v1/change-rejections',
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Correlation-Id': generateCorrelationId()
      },
      body: JSON.stringify({
        data: {
          changeIdentifier: changeId,
          reasonText: request.rejectionReason ?? ''
        }
      })
    }
  )

  if (!response.ok) {
    const { errorMessage } = await parseApiError(response)
    throw new Error(errorMessage)
  }

  const result = await response.json() as {
    data: {
      rejection: {
        changeIdentifier: string
        statusCode: string
        messageText: string
        rejectedByText?: string
        rejectedAtDatetime?: string
        rejectionReasonText?: string
      }
    }
  }

  return mapRejectResponse(result, changeId)
}

/**
 * Cancels a pending change. Only the original submitter can cancel their own changes.
 * @param changeId - The pending change identifier to cancel
 * @returns Cancellation response with CANCELLED status
 */
export async function cancelChange(changeId: string): Promise<CancelChangeResponse> {
  ensureToken()

  const response = await apiFetch(
    `/papi/v1/pending-changes/${encodeURIComponent(changeId)}`,
    {
      method: 'DELETE',
      headers: {
        'X-Correlation-Id': generateCorrelationId()
      }
    }
  )

  if (response.status === 403) throw new Error('You can only cancel your own pending changes')
  if (!response.ok) { const { errorMessage } = await parseApiError(response); throw new Error(errorMessage) }

  const result = await response.json() as {
    data: {
      statusCode?: string
      messageText?: string
    }
  }

  return mapCancelResponse(result, changeId)
}
===ENDFILE

===FILE: src/services/api/approval-service-utils.ts
/**
 * Approval Service Utilities
 * Shared functions for approval workflow services (actions + queries).
 */

import { getAuthToken } from '../../utils/auth/auth-token-manager'

export function ensureToken(): string {
  const token = getAuthToken()
  if (!token) {
    throw new Error('No authentication token found')
  }
  return token
}

export function generateCorrelationId(): string {
  return crypto.randomUUID()
}

const CONFLICT_ERRORS: Record<string, string> = {
  BERR_20024: 'A pending change already exists for this AD group. Please wait for it to be resolved.',
  BERR_20025: 'This configuration was modified by another user. Please reload and try again.'
}

export function handleSubmitError(status: number, errorCode: string, errorMessage: string): never {
  const conflictMessage = status === 409 ? CONFLICT_ERRORS[errorCode] : undefined
  throw new Error(conflictMessage ?? errorMessage)
}
===ENDFILE

===FILE: src/services/api/approval-submit.service.ts
/**
 * Approval Submit Service - Submit and direct save operations
 */

import { apiFetch } from '../core/api-client'
import { parseApiError } from './approval-formatters'
import { ensureToken, generateCorrelationId, handleSubmitError } from './approval-service-utils'
import type {
  SubmitChangeRequest,
  SubmitChangeResponse,
  DirectSaveRequest,
  DirectSaveResponse
} from '../../types/features/approval-workflow.types'

/**
 * Submits a configuration change for approval via the Maker/Checker workflow.
 * Handles conflict detection (BERR_20024/25) and returns the new pending change status.
 * @param groupId - Target AD group identifier
 * @param request - Change payload with proposed state and changed fields
 * @returns Submit response with pending change ID, status, and critical approval flag
 */
export async function submitChange(
  groupId: string,
  request: SubmitChangeRequest
): Promise<SubmitChangeResponse> {
  ensureToken()

  const response = await apiFetch(
    '/papi/v1/pending-changes',
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Correlation-Id': generateCorrelationId()
      },
      body: JSON.stringify({
        data: {
          targetGroupIdentifier: groupId,
          changeDescription: request.changeDescription ?? 'Configuration update',
          proposedConfig: request.proposedState,
          changedFields: request.changedFields,
          ...(request.configVersionNumber === undefined ? {} : { configVersionNumber: request.configVersionNumber })
        }
      })
    }
  )

  if (!response.ok) {
    const { errorCode, errorMessage } = await parseApiError(response)
    handleSubmitError(response.status, errorCode, errorMessage)
  }

  const result = await response.json() as { data: { pendingChange: Record<string, unknown> } }
  const pc = result.data?.pendingChange ?? {}

  return {
    successIndicator: true,
    directSavedIndicator: false,
    pendingChangeId: pc.changeIdentifier as string | null,
    status: (pc.statusCode as string) ?? 'PENDING_LEVEL_ONE',
    criticalApprovalIndicator: (pc.isCriticalIndicator as boolean) ?? false,
    message: 'Change submitted for approval',
    matchedRules: []
  } as SubmitChangeResponse
}

/**
 * Applies configuration changes immediately, bypassing the approval workflow.
 * Only available to Super Admin users.
 * @param groupId - Target AD group identifier
 * @param request - Payload with current/proposed state and optional app/function changes
 * @returns Response indicating success or failure with a message
 */
export async function directSave(
  groupId: string,
  request: DirectSaveRequest
): Promise<DirectSaveResponse> {
  ensureToken()

  const response = await apiFetch(
    '/papi/v1/ad-group-configs',
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Correlation-Id': generateCorrelationId()
      },
      body: JSON.stringify({
        data: {
          targetGroupIdentifier: groupId,
          currentState: request.currentState,
          proposedState: request.proposedState,
          ...(request.changedApps?.length ? { changedApps: request.changedApps } : {}),
          ...(request.changedFunctions?.length ? { changedFunctions: request.changedFunctions } : {})
        }
      })
    }
  )

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
  }

  const result = await response.json() as {
    data?: {
      successIndicator?: boolean
      messageText?: string
    }
  }
  const success = result.data?.successIndicator ?? true
  return {
    successIndicator: success,
    message: result.data?.messageText ?? (success ? 'Configuration saved directly' : 'Direct save failed')
  }
}
===ENDFILE

===FILE: src/services/api/notice-mappers.ts
/**
 * Notice Mappers - PAPI field mapping helpers for system notices
 */

import { getAuthToken } from '../../utils/auth/auth-token-manager'
import type {
  AdminNoticeRequest,
  AdminNoticeResponse
} from '../../types/features/admin.types'

export function ensureNoticeToken(): string {
  const token = getAuthToken()
  if (!token) {
    throw new Error('No authentication token found')
  }
  return token
}

/** Extracts and maps identity fields (id, title, message, severity) from a raw PAPI notice response. */
export function mapNoticeIdentityFields(raw: Record<string, unknown>) {
  return {
    id: (raw.identifier as string) ?? '',
    title: (raw.titleText as string) ?? '',
    message: (raw.messageText as string) ?? '',
    severity: (raw.severityValue as string) ?? 'INFO',
    status: (raw.statusCode as string) ?? '',
    broadcastToAll: Boolean(raw.broadcastToAllFlag),
  };
}

/** Extracts and maps targeting and scheduling fields from a raw PAPI notice response. */
export function mapNoticeTargetFields(raw: Record<string, unknown>) {
  return {
    targetRoles: (raw.targetRoleValues as string[]) ?? [],
    targetAdGroups: (raw.targetAdGroupValues as string[]) ?? [],
    requiresAcknowledgement: Boolean(raw.requiresAckFlag),
    startAt: (raw.startAtDate as string) ?? undefined,
    endAt: (raw.endAtDate as string) ?? undefined,
    createdBy: (raw.createdByText as string) ?? '',
    createdAt: (raw.createdAtDate as string) ?? '',
  };
}

const OPTIONAL_FIELD_MAP: Array<[keyof (AdminNoticeRequest & { status?: string; createdBy?: string }), string]> = [
  ['status', 'statusCode'],
  ['targetRoles', 'targetRoleValues'],
  ['targetAdGroups', 'targetAdGroupValues'],
  ['startAt', 'startAtDate'],
  ['endAt', 'endAtDate'],
  ['createdBy', 'createdByText']
];

/** Converts frontend notice request fields to PAPI field names for the API request body. */
export function toPapiNoticePayload(data: AdminNoticeRequest & { status?: string; createdBy?: string }): Record<string, unknown> {
  const mapped: Record<string, unknown> = {
    titleText: data.title,
    messageText: data.message,
    severityValue: data.severity,
    broadcastToAllFlag: data.broadcastToAll,
    requiresAckFlag: data.requiresAcknowledgement
  };
  for (const [sourceKey, targetKey] of OPTIONAL_FIELD_MAP) {
    const value = data[sourceKey];
    if (value) mapped[targetKey] = value;
  }
  return mapped;
}

/** Converts a raw PAPI notice response into the frontend AdminNoticeResponse DTO. */
export function fromPapiNoticePayload(raw: Record<string, unknown>): AdminNoticeResponse {
  return {
    ...mapNoticeIdentityFields(raw),
    ...mapNoticeTargetFields(raw),
  };
}
===ENDFILE

===FILE: src/services/api/reference-data-country-service.ts
/**
 * Reference Data Country Service
 * API functions for fetching country and business unit reference data.
 * Extracted from reference-data.service.ts to reduce per-file complexity.
 */

import { apiFetchJson } from '../core/api-client'
import {
  mapCountry,
  mapBusinessUnit,
  type PapiCountryResponse,
  type PapiBusinessUnitResponse,
  type CountryDto,
  type BusinessUnitDto
} from './reference-data-mappers'

/** Fetches all business units from the reference data PAPI. */
export async function getAllBusinessUnits(): Promise<BusinessUnitDto[]> {
  const raw = await apiFetchJson<{ data: { businessUnits: PapiBusinessUnitResponse[] } }>('/papi/v1/business-units')
  return (raw.data?.businessUnits ?? []).map(mapBusinessUnit)
}

/** Fetches all countries from the reference data PAPI. */
export async function getAllCountries(): Promise<CountryDto[]> {
  const raw = await apiFetchJson<{ data: { countries: PapiCountryResponse[] } }>('/papi/v1/countries')
  return (raw.data?.countries ?? []).map(mapCountry)
}

/**
 * Fetches countries belonging to a specific region.
 * @param regionCode - Region code to filter by (e.g., 'EMEA', 'AMER', 'APAC')
 */
export async function getCountriesByRegion(regionCode: string): Promise<CountryDto[]> {
  const raw = await apiFetchJson<{ data: { countries: PapiCountryResponse[] } }>(
    `/papi/v1/regions-countries/${encodeURIComponent(regionCode)}`
  )
  return (raw.data?.countries ?? []).map(mapCountry)
}

/**
 * Fetches countries within a specific market by filtering client-side.
 * @param marketCode - Market code to filter by
 */
export async function getCountriesByMarket(marketCode: string): Promise<CountryDto[]> {
  const all = await getAllCountries()
  return all.filter((c) => c.marketCode === marketCode)
}
===ENDFILE

===FILE: src/services/api/reference-data-mappers.ts
/**
 * Reference Data Mappers - PAPI response to frontend DTO mapping helpers
 */

/** A geographic region (e.g., EMEA, AMER, APAC). */
export interface RegionDto {
  regionCode: string
  regionName: string
  displayOrder: number
  isActive: boolean
}

/** An organizational business unit (e.g., Retail Banking, Private Banking). */
export interface BusinessUnitDto {
  unitCode: string
  unitName: string
  description: string
  effectiveDate: string
  displayOrder: number
  isActive: boolean
}

/** A country belonging to a specific region and market. */
export interface CountryDto {
  countryCode: string
  countryName: string
  regionCode: string
  marketCode: string
  displayOrder: number
  isActive: boolean
}

/** A market within a region (e.g., UK, Hong Kong). */
export interface MarketDto {
  marketCode: string
  marketName: string
  regionCode: string
  displayOrder: number
  isActive: boolean
}

// ---------------------------------------------------------------------------
// PAPI response -> frontend field mapping helpers
// ---------------------------------------------------------------------------

export interface PapiRegionResponse {
  regionCode: string
  regionName: string
  displayOrderNumber?: number
  displayOrder?: number
  isActiveFlag?: boolean
  isActive?: boolean
}

export interface PapiMarketResponse {
  marketCode: string
  marketName: string
  regionCode: string
  displayOrderNumber?: number
  displayOrder?: number
  isActiveFlag?: boolean
  isActive?: boolean
}

export interface PapiCountryResponse {
  countryCode: string
  countryName: string
  regionCode: string
  marketCode: string
  displayOrderNumber?: number
  displayOrder?: number
  isActiveFlag?: boolean
  isActive?: boolean
}

export interface PapiBusinessUnitResponse {
  unitCode: string
  unitName: string
  description: string
  effectiveDate: string
  displayOrderNumber?: number
  displayOrder?: number
  isActiveFlag?: boolean
  isActive?: boolean
}

/** Maps PAPI region response to frontend DTO, normalizing alternate field names. */
export function mapRegion(r: PapiRegionResponse): RegionDto {
  return {
    regionCode: r.regionCode,
    regionName: r.regionName,
    displayOrder: r.displayOrder ?? r.displayOrderNumber ?? 0,
    isActive: r.isActive ?? r.isActiveFlag ?? true
  }
}

/** Maps PAPI market response to frontend DTO, normalizing alternate field names. */
export function mapMarket(m: PapiMarketResponse): MarketDto {
  return {
    marketCode: m.marketCode,
    marketName: m.marketName,
    regionCode: m.regionCode,
    displayOrder: m.displayOrder ?? m.displayOrderNumber ?? 0,
    isActive: m.isActive ?? m.isActiveFlag ?? true
  }
}

/** Maps PAPI country response to frontend DTO, normalizing alternate field names. */
export function mapCountry(c: PapiCountryResponse): CountryDto {
  return {
    countryCode: c.countryCode,
    countryName: c.countryName,
    regionCode: c.regionCode,
    marketCode: c.marketCode,
    displayOrder: c.displayOrder ?? c.displayOrderNumber ?? 0,
    isActive: c.isActive ?? c.isActiveFlag ?? true
  }
}

/** Maps PAPI business unit response to frontend DTO, normalizing alternate field names. */
export function mapBusinessUnit(b: PapiBusinessUnitResponse): BusinessUnitDto {
  return {
    unitCode: b.unitCode,
    unitName: b.unitName,
    description: b.description,
    effectiveDate: b.effectiveDate,
    displayOrder: b.displayOrder ?? b.displayOrderNumber ?? 0,
    isActive: b.isActive ?? b.isActiveFlag ?? true
  }
}
===ENDFILE

===FILE: src/services/api/reference-data-region-service.ts
/**
 * Reference Data Region Service
 * API functions for fetching region and market reference data.
 * Extracted from reference-data.service.ts to reduce per-file complexity.
 */

import { apiFetchJson } from '../core/api-client'
import {
  mapRegion,
  mapMarket,
  type PapiRegionResponse,
  type PapiMarketResponse,
  type RegionDto,
  type MarketDto
} from './reference-data-mappers'

/** Fetches all active regions from the reference data PAPI. */
export async function getAllRegions(): Promise<RegionDto[]> {
  const raw = await apiFetchJson<{ data: { regions: PapiRegionResponse[] } }>('/papi/v1/regions')
  return (raw.data?.regions ?? []).map(mapRegion)
}

/** Fetches all markets from the reference data PAPI. */
export async function getAllMarkets(): Promise<MarketDto[]> {
  const raw = await apiFetchJson<{ data: { markets: PapiMarketResponse[] } }>('/papi/v1/markets')
  return (raw.data?.markets ?? []).map(mapMarket)
}

/**
 * Fetches markets belonging to a specific region.
 * @param regionCode - Region code to filter by (e.g., 'EMEA', 'AMER', 'APAC')
 */
export async function getMarketsByRegion(regionCode: string): Promise<MarketDto[]> {
  const raw = await apiFetchJson<{ data: { markets: PapiMarketResponse[] } }>(
    `/papi/v1/regions-markets/${encodeURIComponent(regionCode)}`
  )
  return (raw.data?.markets ?? []).map(mapMarket)
}
===ENDFILE

===FILE: src/services/api/reference-data.service.ts
/**
 * Reference Data Service - Fetches static reference data (regions, markets, countries, business units)
 * from the PAPI for use in filter dropdowns and business info forms.
 */

// Re-export DTO types so consumers can still import from this file
export type { RegionDto, BusinessUnitDto, CountryDto, MarketDto } from './reference-data-mappers'

// Re-export region/market API functions
export { getAllRegions, getAllMarkets, getMarketsByRegion } from './reference-data-region-service'

// Re-export country/business-unit API functions
export { getAllBusinessUnits, getAllCountries, getCountriesByRegion, getCountriesByMarket } from './reference-data-country-service'
===ENDFILE

===FILE: src/services/api/role-template.service.ts
/**
 * Role Template Service - Fetches role template definitions from the PAPI.
 * Role templates define the default permission states for each role (e.g., voice_agent, supervisor).
 */

import { apiFetchJson } from '../core/api-client'

/** Permission state for a single toggle within a role template. */
export interface RoleTemplateStateDto {
  stateText: string
  reasonText?: string
}

/** Lightweight summary of a role template for dropdown lists. */
export interface RoleTemplateSummaryDto {
  roleNameCode: string
  roleDisplayName: string
}

/** Full role template with permission states for all six permission levels. */
export interface RoleTemplateDto {
  roleNameCode: string
  roleDisplayName: string
  columns: Record<string, RoleTemplateStateDto>
  widgets: Record<string, RoleTemplateStateDto>
  features: Record<string, RoleTemplateStateDto>
  settingsTabs: Record<string, RoleTemplateStateDto>
  settingsOptions: Record<string, RoleTemplateStateDto>
  microFrontends: Record<string, RoleTemplateStateDto>
}

/** Fetches all available role template summaries (code + display name). */
export async function getAllRoleTemplates(): Promise<RoleTemplateSummaryDto[]> {
  const raw = await apiFetchJson<{ data?: { roleLayoutTemplates?: RoleTemplateSummaryDto[] } }>(
    '/papi/v1/role-layout-templates'
  )
  return raw.data?.roleLayoutTemplates ?? []
}

/**
 * Fetches a full role template with all permission levels by role name code.
 * @param roleNameCode - Role identifier (e.g., 'voice_agent', 'supervisor')
 */
export async function getRoleTemplateByName(roleNameCode: string): Promise<RoleTemplateDto> {
  const raw = await apiFetchJson<{ data: RoleTemplateDto }>(
    `/papi/v1/role-layout-templates/${encodeURIComponent(roleNameCode)}`
  )
  return raw.data
}
===ENDFILE

===FILE: src/services/core/__tests__/api-client.test.ts
// @vitest-environment jsdom
import { beforeEach, describe, expect, it, vi } from 'vitest'

vi.mock('../../../utils/auth/auth-token-manager', () => ({
  getAuthToken: vi.fn(),
  clearAuthToken: vi.fn()
}))

const { getAuthToken, clearAuthToken } = await import('../../../utils/auth/auth-token-manager')
const { apiFetch, apiFetchJson } = await import('../api-client')

describe('api-client', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    vi.mocked(getAuthToken).mockReturnValue('test-token')
    vi.stubGlobal('fetch', vi.fn())
    // Stub document.cookie
    Object.defineProperty(document, 'cookie', { writable: true, value: '' })
  })

  describe('apiFetch', () => {
    it('sets AMToken cookie and header for authenticated requests', async () => {
      vi.mocked(fetch).mockResolvedValue(new Response('{}', { status: 200 }))

      await apiFetch('/papi/v1/test')

      expect(fetch).toHaveBeenCalledTimes(1)
      const [, init] = vi.mocked(fetch).mock.calls[0]
      const headers = init?.headers as Headers
      expect(headers.get('AMToken')).toBe('test-token')
      expect(init?.credentials).toBe('include')
    })

    it('throws when no auth token and skipAuth is false', async () => {
      vi.mocked(getAuthToken).mockReturnValue(null)

      await expect(apiFetch('/papi/v1/test')).rejects.toThrow('AMToken unavailable')
    })

    it('skips auth when skipAuth is true', async () => {
      vi.mocked(getAuthToken).mockReturnValue(null)
      vi.mocked(fetch).mockResolvedValue(new Response('{}', { status: 200 }))

      await apiFetch('/papi/v1/test', { skipAuth: true })

      expect(fetch).toHaveBeenCalledTimes(1)
      const [, init] = vi.mocked(fetch).mock.calls[0]
      const headers = init?.headers as Headers
      expect(headers.get('AMToken')).toBeNull()
    })

    it('clears auth token on 401 response', async () => {
      vi.mocked(fetch).mockResolvedValue(new Response('', { status: 401 }))

      await apiFetch('/papi/v1/test')

      expect(clearAuthToken).toHaveBeenCalledTimes(1)
    })

    it('does not clear auth token on non-401 responses', async () => {
      vi.mocked(fetch).mockResolvedValue(new Response('{}', { status: 200 }))

      await apiFetch('/papi/v1/test')

      expect(clearAuthToken).not.toHaveBeenCalled()
    })

    it('passes through request init options', async () => {
      vi.mocked(fetch).mockResolvedValue(new Response('{}', { status: 200 }))

      await apiFetch('/papi/v1/test', {
        method: 'POST',
        body: JSON.stringify({ key: 'value' })
      })

      const [, init] = vi.mocked(fetch).mock.calls[0]
      expect(init?.method).toBe('POST')
      expect(init?.body).toBe('{"key":"value"}')
    })
  })

  describe('apiFetchJson', () => {
    it('returns parsed JSON on success', async () => {
      const data = { result: 'ok' }
      vi.mocked(fetch).mockResolvedValue(new Response(JSON.stringify(data), { status: 200 }))

      const result = await apiFetchJson<{ result: string }>('/papi/v1/test')

      expect(result).toEqual(data)
    })

    it('throws with response text on non-ok response', async () => {
      vi.mocked(fetch).mockResolvedValue(
        new Response('Server Error', { status: 500, statusText: 'Internal Server Error' })
      )

      await expect(apiFetchJson('/papi/v1/test')).rejects.toThrow('Server Error')
    })

    it('sets Content-Type header for non-GET requests with body', async () => {
      vi.mocked(fetch).mockResolvedValue(new Response('{}', { status: 200 }))

      await apiFetchJson('/papi/v1/test', {
        method: 'POST',
        body: JSON.stringify({ data: 'test' })
      })

      const [, init] = vi.mocked(fetch).mock.calls[0]
      const headers = init?.headers as Headers
      expect(headers.get('Content-Type')).toBe('application/json')
    })

    it('does not override existing Content-Type header', async () => {
      vi.mocked(fetch).mockResolvedValue(new Response('{}', { status: 200 }))

      await apiFetchJson('/papi/v1/test', {
        method: 'POST',
        body: 'data',
        headers: { 'Content-Type': 'text/plain' }
      })

      const [, init] = vi.mocked(fetch).mock.calls[0]
      const headers = init?.headers as Headers
      expect(headers.get('Content-Type')).toBe('text/plain')
    })

    it('handles empty response body on error', async () => {
      const response = new Response('', { status: 500 })
      vi.mocked(fetch).mockResolvedValue(response)

      await expect(apiFetchJson('/papi/v1/test')).rejects.toThrow('Request failed with status 500')
    })
  })
})
===ENDFILE

===FILE: src/services/core/api-client-helpers.ts
/**
 * API Client Helpers - Auth token and header utilities for API requests.
 */

import { getAuthToken } from '../../utils/auth/auth-token-manager'

export function ensureAmTokenCookie(skipAuth?: boolean): void {
  if (skipAuth) return

  const token = getAuthToken()
  if (!token) {
    throw new Error('AMToken unavailable. Please log in again.')
  }

  // Set AMToken as a cookie so the proxy at :8095 can read it
  // and forward as X-HSBC-E2E-Trust-Token header to PAPI
  document.cookie = `AMToken=${encodeURIComponent(token)}; path=/; SameSite=Lax`
}

export function buildHeaders(init?: RequestInit, skipAuth?: boolean): Headers {
  const headers = new Headers(init?.headers ?? undefined)

  if (!skipAuth) {
    const token = getAuthToken()
    if (!token) {
      throw new Error('AMToken unavailable. Please log in again.')
    }
    // Also set as header for backward compatibility with direct PAPI calls
    headers.set('AMToken', token)
  }

  return headers
}

export async function safeReadResponse(res: Response): Promise<string> {
  try {
    const text = (await res.text())?.trim() ?? ''
    return text || `Request failed with status ${res.status}`
  } catch {
    return `Request failed with status ${res.status}`
  }
}
===ENDFILE

===FILE: src/services/core/api-client.ts
import { clearAuthToken } from '../../utils/auth/auth-token-manager'
import { ensureAmTokenCookie, buildHeaders, safeReadResponse } from './api-client-helpers'

type RequestInfoType = RequestInfo | URL

interface ApiFetchOptions extends RequestInit {
  skipAuth?: boolean
}

/**
 * Authenticated fetch wrapper that sets the AMToken cookie and header for PAPI calls.
 * Automatically clears the auth token on 401 responses.
 * @param input - Request URL or Request object
 * @param init - Fetch options with optional skipAuth flag
 * @returns Raw fetch Response
 */
export async function apiFetch(input: RequestInfoType, init: ApiFetchOptions = {}): Promise<Response> {
  const { skipAuth, ...rest } = init

  // Ensure AMToken cookie is set for proxy-based routing
  ensureAmTokenCookie(skipAuth)

  const headers = buildHeaders(rest, skipAuth)

  const response = await fetch(input, {
    ...rest,
    headers,
    credentials: 'include'
  })

  if (response.status === 401) {
    clearAuthToken()
  }

  return response
}

/**
 * Convenience wrapper around apiFetch that parses the response as JSON.
 * Throws on non-OK responses with the response body as the error message.
 * @param input - Request URL or Request object
 * @param init - Fetch options with optional skipAuth flag
 * @returns Parsed JSON response body typed as T
 */
function needsContentType(headers: Headers, init: ApiFetchOptions): boolean {
  return !headers.has('Content-Type') && !!init.body && init.method?.toUpperCase() !== 'GET'
}

export async function apiFetchJson<T>(input: RequestInfoType, init: ApiFetchOptions = {}): Promise<T> {
  const headers = new Headers(init.headers ?? undefined)
  if (needsContentType(headers, init)) headers.set('Content-Type', 'application/json')

  const response = await apiFetch(input, { ...init, headers })

  if (!response.ok) {
    const message = await safeReadResponse(response)
    throw new Error(message)
  }

  return response.json() as Promise<T>
}
===ENDFILE

===FILE: src/services/mock-data.ts
/**
 * Mock Data Service for Admin MFE
 * Provides simulated data for demonstration purposes
 */

import type { RoleTemplate, AdGroup, PendingApproval, SystemNotice } from '../types'

const MOCK_CREATED_TIMESTAMP = '2024-01-15T10:00:00Z'

// Role Templates Mock Data
export const mockRoleTemplates: RoleTemplate[] = [
  {
    id: 'voice_agent',
    name: 'Voice Agent',
    description: 'Handles inbound and outbound voice calls with full customer service capabilities',
    permissions: ['voice.calls', 'customer.view', 'knowledge.search', 'banking.apps'],
    widgets: ['mediaBar', 'customerInfo', 'knowledgeBase', 'embeddedApps'],
    createdAt: MOCK_CREATED_TIMESTAMP,
    updatedAt: '2024-03-20T14:30:00Z'
  },
  {
    id: 'chat_agent',
    name: 'Chat Agent',
    description: 'Manages digital chat interactions with customers across multiple channels',
    permissions: ['chat.conversations', 'customer.view', 'knowledge.search', 'templates.use'],
    widgets: ['chatConsole', 'customerInfo', 'knowledgeBase', 'responseTemplates'],
    createdAt: MOCK_CREATED_TIMESTAMP,
    updatedAt: '2024-03-18T09:15:00Z'
  },
  {
    id: 'supervisor',
    name: 'Supervisor',
    description: 'Team lead with monitoring capabilities and performance insights',
    permissions: ['team.monitor', 'metrics.view', 'escalations.handle', 'reports.access'],
    widgets: ['teamDashboard', 'performanceMetrics', 'escalationQueue', 'realTimeMonitor'],
    createdAt: MOCK_CREATED_TIMESTAMP,
    updatedAt: '2024-03-22T11:45:00Z'
  },
  {
    id: 'admin',
    name: 'Administrator',
    description: 'Full system administration with configuration and user management access',
    permissions: ['admin.full', 'config.manage', 'users.manage', 'audit.view'],
    widgets: ['adminPanel', 'configManager', 'userDirectory', 'auditLog'],
    createdAt: MOCK_CREATED_TIMESTAMP,
    updatedAt: '2024-03-25T16:00:00Z'
  }
]

// AD Groups Mock Data
export const mockAdGroups: AdGroup[] = [
  {
    id: 'adg-001',
    name: 'APAC Voice Team',
    distinguishedName: 'CN=CCAAS_APAC_VOICE,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 156,
    assignedLayouts: ['voice_agent'],
    isActive: true,
    createdAt: '2024-01-20T08:00:00Z',
    updatedAt: '2024-03-15T10:30:00Z'
  },
  {
    id: 'adg-002',
    name: 'EMEA Chat Support',
    distinguishedName: 'CN=CCAAS_EMEA_CHAT,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 89,
    assignedLayouts: ['chat_agent'],
    isActive: true,
    createdAt: '2024-01-22T09:15:00Z',
    updatedAt: '2024-03-18T14:20:00Z'
  },
  {
    id: 'adg-003',
    name: 'Americas Supervisors',
    distinguishedName: 'CN=CCAAS_AMER_SUPERVISORS,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 24,
    assignedLayouts: ['supervisor'],
    isActive: true,
    createdAt: '2024-02-01T11:00:00Z',
    updatedAt: '2024-03-20T09:45:00Z'
  },
  {
    id: 'adg-004',
    name: 'Global Admins',
    distinguishedName: 'CN=CCAAS_GLOBAL_ADMINS,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 8,
    assignedLayouts: ['admin'],
    isActive: true,
    createdAt: MOCK_CREATED_TIMESTAMP,
    updatedAt: '2024-03-22T16:30:00Z'
  },
  {
    id: 'adg-005',
    name: 'UK Voice Team',
    distinguishedName: 'CN=CCAAS_UK_VOICE,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 67,
    assignedLayouts: ['voice_agent'],
    isActive: true,
    createdAt: '2024-02-10T13:30:00Z',
    updatedAt: '2024-03-19T11:15:00Z'
  },
  {
    id: 'adg-006',
    name: 'HK Chat Team',
    distinguishedName: 'CN=CCAAS_HK_CHAT,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 45,
    assignedLayouts: ['chat_agent'],
    isActive: false,
    createdAt: '2024-02-15T14:00:00Z',
    updatedAt: '2024-03-10T08:30:00Z'
  },
  {
    id: 'adg-007',
    name: 'Singapore Multi-Channel',
    distinguishedName: 'CN=CCAAS_SG_MULTI,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 112,
    assignedLayouts: ['voice_agent', 'chat_agent'],
    isActive: true,
    createdAt: '2024-02-20T10:45:00Z',
    updatedAt: '2024-03-21T15:00:00Z'
  },
  {
    id: 'adg-008',
    name: 'New Team (Unconfigured)',
    distinguishedName: 'CN=CCAAS_NEW_TEAM,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 0,
    assignedLayouts: [],
    isActive: false,
    createdAt: '2024-03-25T09:00:00Z',
    updatedAt: '2024-03-25T09:00:00Z'
  }
]

// Pending Approvals Mock Data
export const mockPendingApprovals: PendingApproval[] = [
  {
    id: 'pa-001',
    type: 'ad-group',
    action: 'update',
    entityId: 'adg-002',
    entityName: 'EMEA Chat Support',
    requestedBy: 'John Smith',
    requestedAt: '2024-03-24T14:30:00Z',
    changes: {
      permissions: { added: ['banking.transfer'], removed: [] },
      widgets: { added: ['transferWidget'], removed: [] }
    },
    status: 'pending'
  },
  {
    id: 'pa-002',
    type: 'role-template',
    action: 'update',
    entityId: 'voice_agent',
    entityName: 'Voice Agent',
    requestedBy: 'Sarah Johnson',
    requestedAt: '2024-03-23T10:15:00Z',
    changes: {
      permissions: { added: ['customer.edit'], removed: ['customer.delete'] }
    },
    status: 'pending'
  },
  {
    id: 'pa-003',
    type: 'system-notice',
    action: 'create',
    entityId: 'notice-new',
    entityName: 'System Maintenance Notice',
    requestedBy: 'Mike Chen',
    requestedAt: '2024-03-22T16:45:00Z',
    changes: {
      title: 'Scheduled Maintenance',
      message: 'System will be down for maintenance on Saturday',
      type: 'warning'
    },
    status: 'pending'
  },
  {
    id: 'pa-004',
    type: 'ad-group',
    action: 'update',
    entityId: 'adg-005',
    entityName: 'UK Voice Team',
    requestedBy: 'Emma Wilson',
    requestedAt: '2024-03-21T11:00:00Z',
    changes: {
      isActive: false,
      reason: 'Team restructuring'
    },
    status: 'pending'
  },
  {
    id: 'pa-005',
    type: 'ad-group',
    action: 'update',
    entityId: 'adg-007',
    entityName: 'Singapore Multi-Channel',
    requestedBy: 'David Lee',
    requestedAt: '2024-03-20T09:30:00Z',
    changes: {
      permissions: { added: ['escalation.create'], removed: [] }
    },
    status: 'pending'
  }
]

// System Notices Mock Data
export const mockSystemNotices: SystemNotice[] = [
  {
    id: 'notice-001',
    title: 'New Feature: AI Assistant',
    message: 'The AI-powered assistant is now available for all agents. Access it through the Space Copilot panel.',
    type: 'info',
    isActive: true,
    startDate: '2024-03-20T00:00:00Z',
    endDate: '2024-04-20T23:59:59Z',
    createdBy: 'System Admin',
    createdAt: '2024-03-19T15:00:00Z'
  },
  {
    id: 'notice-002',
    title: 'Scheduled Maintenance',
    message: 'The platform will undergo scheduled maintenance on Saturday, March 30th from 2:00 AM to 6:00 AM UTC.',
    type: 'warning',
    isActive: true,
    startDate: '2024-03-25T00:00:00Z',
    endDate: '2024-03-30T06:00:00Z',
    createdBy: 'IT Operations',
    createdAt: '2024-03-22T10:00:00Z'
  },
  {
    id: 'notice-003',
    title: 'Training Session Reminder',
    message: 'Mandatory compliance training must be completed by all agents before March 31st.',
    type: 'warning',
    isActive: true,
    startDate: '2024-03-15T00:00:00Z',
    endDate: '2024-03-31T23:59:59Z',
    createdBy: 'HR Department',
    createdAt: '2024-03-14T09:00:00Z'
  },
  {
    id: 'notice-004',
    title: 'System Update Complete',
    message: 'The latest system update has been successfully deployed. New features include improved call quality and faster search.',
    type: 'success',
    isActive: false,
    startDate: '2024-03-10T00:00:00Z',
    endDate: '2024-03-17T23:59:59Z',
    createdBy: 'System Admin',
    createdAt: '2024-03-10T08:00:00Z'
  },
  {
    id: 'notice-005',
    title: 'Critical: Database Migration',
    message: 'Database migration is in progress. Some features may be temporarily unavailable.',
    type: 'error',
    isActive: false,
    startDate: '2024-03-05T02:00:00Z',
    endDate: '2024-03-05T06:00:00Z',
    createdBy: 'IT Operations',
    createdAt: '2024-03-04T18:00:00Z'
  }
]

// Helper function to simulate API delay
export const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))

/** Creates an async function that returns data after a simulated delay. */
function delayedReturn<T>(data: T, ms: number): () => Promise<T> {
  return async () => { await delay(ms); return data }
}

// Mock API functions
export const mockApi = {
  getRoleTemplates: delayedReturn(mockRoleTemplates, 500),
  getAdGroups: delayedReturn(mockAdGroups, 600),
  getPendingApprovals: delayedReturn(mockPendingApprovals, 400),
  getSystemNotices: delayedReturn(mockSystemNotices, 450),

  approveChange: async (_id: string): Promise<{ success: boolean }> => {
    await delay(800)
    return { success: true }
  },

  rejectChange: async (_id: string, _reason: string): Promise<{ success: boolean }> => {
    await delay(800)
    return { success: true }
  },

  createNotice: async (notice: Partial<SystemNotice>): Promise<SystemNotice> => {
    await delay(700)
    return {
      ...notice,
      id: `notice-${Date.now()}`,
      createdAt: new Date().toISOString(),
      createdBy: 'Current User'
    } as SystemNotice
  },

  updateNotice: async (id: string, updates: Partial<SystemNotice>): Promise<SystemNotice> => {
    await delay(600)
    const notice = mockSystemNotices.find(n => n.id === id)
    return { ...notice, ...updates } as SystemNotice
  },

  toggleAdGroup: async (_id: string, _isActive: boolean): Promise<{ success: boolean }> => {
    await delay(500)
    return { success: true }
  }
}
===ENDFILE

===FILE: src/test-setup.ts
import '@testing-library/jest-dom'

if (globalThis.ResizeObserver === undefined) {
  class ResizeObserverMock {
    observe() { /* no-op: mock for testing */ }
    unobserve() { /* no-op: mock for testing */ }
    disconnect() { /* no-op: mock for testing */ }
  }

  // Radix ScrollArea relies on ResizeObserver; jsdom does not provide it.
  globalThis.ResizeObserver = ResizeObserverMock as unknown as typeof ResizeObserver
}
===ENDFILE

===FILE: src/types/features/ad-group-config.ts
/** User access level determining what admin operations are permitted within the Maker/Checker workflow. */
export type UserAccessLevel = 'VIEWER' | 'MAKER' | 'CHECKER' | 'SUPER_ADMIN'

/**
 * Core AD Group data structure used throughout the admin UI.
 * Represents an Active Directory group with its configuration state.
 */
export interface AdGroup {
  id: string
  groupIdentifier: string
  logicalName?: string
  roleName?: string
  market?: string
  region?: string
  businessUnit?: string
  country?: string
  isActive: boolean
  userCount?: number
  permissionCount?: number
  lastModified?: string
  accessLevel?: UserAccessLevel
  pendingChangeIndicator?: boolean
  versionNumber?: number
  [key: string]: unknown
}

type PermissionStateValue = 'enabled' | 'disabled' | 'hidden' | 'inherited'

/** State of a single permission toggle (enabled/disabled/hidden/inherited from template). */
export interface PermissionState {
  state: PermissionStateValue
  [key: string]: unknown
}

type PermissionStateMap = Record<string, PermissionState>

// Permission assignments by category
interface PermissionAssignments {
  columnAssignments?: PermissionStateMap
  widgetAssignments?: PermissionStateMap
  featureAssignments?: PermissionStateMap
  settingsTabAssignments?: PermissionStateMap
  settingsOptionAssignments?: PermissionStateMap
  microFrontendAssignments?: PermissionStateMap
}

/** Full AD Group data including permission assignments, returned by the lookup API. */
export interface AdGroupData extends AdGroup, PermissionAssignments {
  lastModifiedBy?: string
  success?: boolean
  [key: string]: unknown
}

export interface AdGroupSummaryCounts {
  activeConfigured?: number
  needsConfiguration?: number
}

export interface PagedAdGroupResponse {
  items: AdGroup[]
  page: number
  size: number
  totalElements: number
  totalPages: number
  summary?: AdGroupSummaryCounts
}

/**
 * Permission overrides keyed by level (e.g., 'columns', 'widgets') then by permission key.
 * True means enabled, false means disabled. Overrides the base role template.
 */
export type PermissionOverrides = Record<string, Record<string, boolean>>

type PendingPermissionChanges = Record<string, Record<string, boolean>>

/** Records a staged application function change before it is submitted for approval. */
export interface StagedAppChange {
  /** Embedded app identifier (e.g., 'credit-card', 'money-transfer') */
  appKey: string
  /** Display name of the app for notification messages */
  appTitle: string
  /** Function keys assigned before this change */
  previousFunctions: string[]
  /** Function keys that will be assigned after this change */
  newFunctions: string[]
}

/** Tracks unsaved changes in the config modal before submitting for approval or direct-saving. */
export interface PendingChanges {
  /** Modified business info fields (region, market, etc.) */
  businessInfo?: Partial<AdGroup>
  /** Permission toggle changes keyed by level and permission key */
  permissions: PendingPermissionChanges
  /** Staged embedded app assignment changes */
  appChanges?: StagedAppChange[]
}

/** Role template defining default permission states for each permission level. */
export interface RoleTemplate {
  roleName: string
  roleDisplayName?: string
  columns?: PermissionStateMap
  widgets?: PermissionStateMap
  features?: PermissionStateMap
  settings_tabs?: PermissionStateMap
  settings_options?: PermissionStateMap
  micro_frontends?: PermissionStateMap
  [key: string]: unknown
}

/** Props for the AD group configuration modal (edit permissions, business info, and apps). */
export interface AdGroupConfigModalProps {
  group: AdGroup
  open: boolean
  onClose: () => void
  onSave: (group: AdGroup) => void
}
===ENDFILE

===FILE: src/types/features/admin.types.ts
/**
 * Options controlling which sections to copy and how conflicts are resolved
 * during an AD group configuration copy operation.
 */
export interface CopyOptions {
  /** Whether to copy the role template and permission overrides */
  copyRoleAndPermissionsFlag?: boolean
  /** Whether to copy business info fields (region, market, country, etc.) */
  copyBusinessInfoFlag?: boolean
  /** Whether to copy embedded application assignments */
  copyApplicationsFlag?: boolean
  /** Whether to overwrite existing configuration on the target group */
  overwriteExistingFlag?: boolean
  /** Workflow path: submit for Maker/Checker review or apply directly */
  copyWorkflowModeCode?: 'SUBMIT_FOR_APPROVAL' | 'DIRECT_SAVE'
  /** How to handle functions available on source but not on target */
  functionMismatchPolicyCode?: 'FAIL_ON_MISMATCH' | 'SKIP_UNAVAILABLE'
}

/**
 * Request payload for creating or updating a system notice.
 * Notices can target specific roles, AD groups, or broadcast to all users.
 */
export interface AdminNoticeRequest {
  /** Notice headline shown in the notification banner */
  title: string
  /** Full notice body text with details */
  message: string
  /** Severity level: INFO, SUCCESS, WARNING, ERROR, or CRITICAL */
  severity: string
  /** When true, notice is visible to all users regardless of targeting */
  broadcastToAll: boolean
  /** Role codes to target (e.g., 'voice_agent', 'supervisor') */
  targetRoles?: string[]
  /** AD group DNs to target */
  targetAdGroups?: string[]
  /** Whether users must explicitly acknowledge the notice */
  requiresAcknowledgement?: boolean
  /** ISO datetime when the notice becomes visible */
  startAt?: string
  /** ISO datetime when the notice auto-expires */
  endAt?: string
  /** User ID of the notice creator (set server-side from auth token) */
  createdBy?: string
}

/** Server response for a notice, including server-assigned fields like id and timestamps. */
export interface AdminNoticeResponse {
  /** Server-assigned unique identifier */
  id: string
  title: string
  message: string
  severity: string
  /** Lifecycle status: DRAFT, ACTIVE, or EXPIRED */
  status: string
  broadcastToAll: boolean
  targetRoles?: string[]
  targetAdGroups?: string[]
  requiresAcknowledgement: boolean
  startAt?: string
  endAt?: string
  createdBy: string
  /** ISO datetime when the notice was created */
  createdAt: string
}

/** Result of a configuration copy operation with workflow status and error details. */
export interface CopyResult {
  success: boolean
  /** Human-readable result message */
  message: string
  /** The updated target group data on success */
  updatedGroup?: Record<string, unknown>
  /** Error code on failure (e.g., 'NETWORK_ERROR', 'REQUEST_FAILED') */
  error?: string
  errorDetails?: Record<string, unknown>
  /** Whether the copy was applied directly or submitted for approval */
  workflowStatusCode?: 'DIRECT_APPLIED' | 'SUBMITTED_FOR_APPROVAL'
  /** ID of the pending change created (when submitted for approval) */
  pendingChangeIdentifier?: string
  /** Whether this change requires L2 approval due to critical rules */
  criticalIndicator?: boolean
  /** Whether L2 approval is required after L1 */
  levelTwoApprovalRequiredIndicator?: boolean
  /** Function keys that exist on source but not on target */
  unavailableAppFunctionValues?: string[]
}
===ENDFILE

===FILE: src/types/features/approval-workflow.types.ts
/**
 * Approval Workflow Types
 * Types for the Maker/Checker admin approval workflow
 */

export type UserAccessLevel = 'VIEWER' | 'MAKER' | 'CHECKER' | 'SUPER_ADMIN'

export type PendingChangeStatus =
  | 'PENDING_LEVEL_ONE'
  | 'PENDING_LEVEL_TWO'
  | 'APPROVED'
  | 'REJECTED'
  | 'CANCELLED'
  | 'EXPIRED'
  | 'MY_SUBMISSIONS'

export type ChangeType = 'CONFIG_UPDATE' | 'APP_UPDATE'

export interface MatchedRule {
  entityType: 'FIELD' | 'APP' | 'FUNCTION'
  entityKey: string
  reason: string
}

export interface AppsChangeDetail {
  added: string[]
  removed: string[]
  unchanged: string[]
}

export interface FunctionChange {
  app: string
  function: string
}

export interface FunctionsChangeDetail {
  added: FunctionChange[]
  removed: FunctionChange[]
  unchanged: FunctionChange[]
}

export interface SubmitterInfo {
  userId: string
  displayName: string
  email: string
}

export interface ApprovalInfo {
  approverUserId: string
  approverName: string
  approvalDateTime: string
  comment?: string
}

export interface PendingChangeDto {
  id: string
  targetGroupIdentifier: string
  targetGroupName: string
  changeType: ChangeType
  status: PendingChangeStatus
  criticalIndicator: boolean
  matchedRules: MatchedRule[]
  submittedBy: SubmitterInfo
  submittedDateTime: string
  expiresDateTime: string
  currentState: Record<string, unknown>
  proposedState: Record<string, unknown>
  appsChanges?: AppsChangeDetail | null
  functionsChanges?: FunctionsChangeDetail | null
  canApproveIndicator: boolean
  canRejectIndicator: boolean
  canCancelIndicator?: boolean
  levelOneApproval?: ApprovalInfo
  levelTwoApproval?: ApprovalInfo
  rejectionReason?: string | null
  rejectedBy?: SubmitterInfo | null
  rejectedDateTime?: string | null
}

export interface PendingChangeCounts {
  pendingLevelOne: number
  pendingLevelTwo: number
  mySubmissions?: number
}

export interface PaginationLinks {
  self: string
  first: string
  prev: string | null
  next: string | null
  last: string
}

export interface PendingChangeListResponse {
  items: PendingChangeDto[]
  counts: PendingChangeCounts
  totalCount: number
  offset: number
  limit: number
  links: PaginationLinks
}

export interface SubmitChangeRequest {
  changeType: ChangeType
  currentState: Record<string, unknown>
  proposedState: Record<string, unknown>
  changedApps?: string[]
  changedFunctions?: string[]
  changedFields?: string[]
  changeDescription?: string
  configVersionNumber?: number
}

export interface SubmitChangeResponse {
  successIndicator: boolean
  directSavedIndicator: boolean
  pendingChangeId: string | null
  status: PendingChangeStatus | 'APPROVED'
  criticalApprovalIndicator: boolean
  message: string
  matchedRules?: MatchedRule[]
}

export interface DirectSaveRequest {
  currentState: Record<string, unknown>
  proposedState: Record<string, unknown>
  changedApps?: string[]
  changedFunctions?: string[]
  changedFields?: string[]
}

export interface DirectSaveResponse {
  successIndicator: boolean
  message: string
}

export interface ApproveChangeRequest {
  comment?: string
}

export interface ApproveChangeResponse {
  successIndicator: boolean
  changeId: string
  newStatus: PendingChangeStatus
  message: string
  appliedDateTime?: string
  escalatedDateTime?: string
}

export interface RejectChangeRequest {
  rejectionReason: string
}

export interface RejectChangeResponse {
  successIndicator: boolean
  changeId: string
  newStatus: 'REJECTED'
  message: string
  rejectedDateTime: string
  notificationSentIndicator: boolean
}

export interface CancelChangeResponse {
  successIndicator: boolean
  changeId: string
  newStatus: 'CANCELLED'
  message: string
}

export interface PendingChangeFilters {
  status?: PendingChangeStatus[]
  offset?: number
  limit?: number
}

export interface AdGroupWithAccess {
  id: string
  groupIdentifier: string
  logicalName: string
  roleName: string
  market?: string
  region?: string
  country?: string
  businessUnit?: string
  activeIndicator: boolean
  userCount?: number
  userAccess: UserAccessLevel
  pendingChangeIndicator: boolean
  pendingChangeId?: string
}

export interface AdGroupListResponse {
  items: AdGroupWithAccess[]
  totalCount: number
  offset: number
  limit: number
  links: PaginationLinks
}

export interface AdGroupFilters {
  market?: string
  role?: string
  status?: string
  search?: string
  offset?: number
  limit?: number
}

export type AuditAction = 'SUBMIT' | 'L1_APPROVE' | 'L2_APPROVE' | 'REJECT' | 'CANCEL' | 'DIRECT_SAVE'

export type ActivityActionFilter = 'all' | 'approvals' | 'rejections' | 'submissions' | 'direct_saves'
export type ActivityTimeRange = 'today' | 'week' | 'month' | 'all'

export interface ActivityLogDto {
  id: string
  action: AuditAction
  targetGroupName: string
  changeType: ChangeType
  criticalIndicator: boolean
  performedAt: string
  performedByRole: string
  completionReason?: string
  escalationReason?: string
}

export interface ActivityListResponse {
  items: ActivityLogDto[]
  totalCount: number
  page: number
  size: number
}
===ENDFILE

===FILE: src/types/index.ts
/**
 * Permission flags controlling which admin UI features are accessible to the current user.
 * Derived from the user's access level (VIEWER, MAKER, CHECKER, SUPER_ADMIN).
 */
export interface AdminPermissions {
  canPreviewDashboards: boolean
  canViewRoleTemplates: boolean
  canViewAdGroups: boolean
  canViewPendingApprovals: boolean
  canApproveChanges: boolean
  canEditBusinessInfo: boolean
  canEditPermissions: boolean
  canEditApplications: boolean
  canEnableDisableGroups: boolean
  /** Super Admin only: bypass approval workflow and apply changes immediately */
  canDirectSave: boolean
  canViewNotices: boolean
  canCreateNotice: boolean
  canEditNotice: boolean
  canPublishNotice: boolean
  canArchiveNotice: boolean
  canSaveDraft: boolean
}

/** Structured error reported from the admin MFE to the host application. */
export interface ErrorInfo {
  /** Machine-readable error code (e.g., 'AUTH_FAILED', 'API_ERROR') */
  code: string
  /** Human-readable error description */
  message: string
  /** Additional diagnostic data for error tracking */
  context?: Record<string, unknown>
}

/**
 * Props passed from the host agent-frontend to the Admin MFE via Module Federation.
 * This is the primary communication interface between the host and the remote MFE.
 */
export interface AdminMFEProps {
  /** JWT or AM token for authenticating PAPI calls */
  authToken: string
  /** User's admin permission flags derived from their access level */
  permissions?: AdminPermissions
  /** Current user role code (e.g., 'MAKER', 'CHECKER', 'SUPER_ADMIN') */
  currentRole?: string
  /** Callback to request navigation in the host application */
  onNavigate?: (path: string) => void
  /** Callback to report errors to the host for centralized tracking */
  onError?: (error: ErrorInfo) => void
}

/** Sidebar navigation views available in the admin panel. */
export type AdminView =
  | 'dashboard'
  | 'ad-groups'
  | 'pending-approvals'
  | 'system-notices'

export interface RoleTemplate {
  id: string
  name: string
  description: string
  permissions: string[]
  widgets: string[]
  createdAt: string
  updatedAt: string
  roleName?: string
  roleDisplayName?: string
}

export interface AdGroup {
  id: string
  name: string
  distinguishedName: string
  memberCount: number
  assignedLayouts: string[]
  isActive: boolean
  createdAt: string
  updatedAt: string
  logicalName?: string
  roleName?: string
  market?: string
  region?: string
  country?: string
  businessUnit?: string
  accessLevel?: 'VIEWER' | 'MAKER' | 'CHECKER' | 'SUPER_ADMIN'
}

export interface PendingApproval {
  id: string
  type: 'role-template' | 'ad-group' | 'system-notice'
  action: 'create' | 'update' | 'delete'
  entityId: string
  entityName: string
  requestedBy: string
  requestedAt: string
  changes: Record<string, unknown>
  status: 'pending' | 'approved' | 'rejected'
}

export interface SystemNotice {
  id: string
  title: string
  message: string
  type: 'info' | 'warning' | 'error' | 'success'
  isActive: boolean
  startDate: string
  endDate: string
  createdBy: string
  createdAt: string
}
===ENDFILE

===FILE: src/types/integration/embedded-apps.ts
/**
 * Function definition using API contract naming conventions.
 */
interface FunctionDefinition {
  displayName: string;
  description?: string;
  categoryText?: string;
  searchKeywordValues?: string[];
  requiresApprovalFlag?: boolean;
  mfeConfig?: Record<string, unknown>;
}

/**
 * AD Group access configuration following PAPI naming conventions.
 */
interface AdGroupAccess {
  functionValues: string[];
  lastModifiedByText?: string;
  marketCode?: string;
}

/**
 * Embedded app DTO following PAPI naming conventions.
 * Field mappings from SAPI EmbeddedAppDto:
 * - appIdentifier (internal: appKey)
 * - titleText (internal: title)
 * - descriptionText (internal: description)
 * - categoryName (internal: category)
 * - baseUrlAddress (internal: baseUrl)
 * - isActiveIndicator (internal: isActive)
 * - functionDefinitionsObject (internal: functionDefinitions)
 * - adGroupAccessObject (internal: adGroupAccess)
 * - appFunctionKeys (derived from functionDefinitions keys)
 */
export interface EmbeddedApp {
  appIdentifier: string;
  titleText: string;
  descriptionText: string;
  categoryName: string;
  baseUrlAddress?: string;
  loadingStrategyCode?: string;
  primaryKeywordsText?: string[];
  secondaryKeywordsText?: string[];
  mfeConfigObject?: Record<string, unknown>;
  regionalUrlsObject?: Record<string, unknown>;
  isActiveIndicator: boolean;
  functionDefinitionsObject: Record<string, FunctionDefinition>;
  adGroupAccessObject?: Record<string, AdGroupAccess>;
  appFunctionKeys?: string[];
}

/**
 * Extended app DTO with assignment status for UI display.
 * These fields are computed client-side, not from SAPI.
 */
export interface EmbeddedAppWithStatus extends EmbeddedApp {
  isAssignedIndicator: boolean;
  assignedFunctionKeys: string[];
  defaultFunctionKey?: string;
}
===ENDFILE

===FILE: src/types/system/layout-template.ts
/**
 * Shared layout template types for admin preview components
 */

export interface PermissionState {
  state: 'enabled' | 'disabled' | 'hidden' | 'inherited';
  [key: string]: unknown;
}

export interface RoleTemplate {
  roleName: string;
  displayName: string;
  columns: Record<string, PermissionState>;
  widgets: Record<string, PermissionState>;
  features: Record<string, PermissionState>;
  settingsTabs: Record<string, PermissionState>;
  settingsOptions: Record<string, PermissionState>;
  microFrontends: Record<string, PermissionState>;
  [key: string]: unknown;
}
===ENDFILE

===FILE: src/utils/admin/__tests__/notice-validators.test.ts
import { describe, expect, it } from 'vitest'
import { hasValue, isConfiguredGroup, isEndDateValid, validateNoticeForm } from '../notice-validators'

describe('hasValue', () => {
  it('returns true for non-empty strings', () => {
    expect(hasValue({ value: 'hello' })).toBe(true)
    expect(hasValue({ value: ' a ' })).toBe(true)
  })

  it('returns false for empty, whitespace-only, null, undefined', () => {
    expect(hasValue({ value: '' })).toBe(false)
    expect(hasValue({ value: '   ' })).toBe(false)
    expect(hasValue({ value: null })).toBe(false)
    expect(hasValue({ value: undefined })).toBe(false)
    expect(hasValue({})).toBe(false)
  })
})

describe('isConfiguredGroup', () => {
  it('returns true when both logicalName and roleName present', () => {
    expect(isConfiguredGroup({
      group: { logicalName: 'Test', roleName: 'voice_agent' } as never
    })).toBe(true)
  })

  it('returns false when logicalName missing', () => {
    expect(isConfiguredGroup({
      group: { roleName: 'voice_agent' } as never
    })).toBe(false)
  })

  it('returns false when roleName missing', () => {
    expect(isConfiguredGroup({
      group: { logicalName: 'Test' } as never
    })).toBe(false)
  })

  it('returns false when both missing', () => {
    expect(isConfiguredGroup({ group: {} as never })).toBe(false)
  })
})

describe('isEndDateValid', () => {
  it('returns true when no dates provided', () => {
    expect(isEndDateValid({})).toBe(true)
    expect(isEndDateValid({ startAt: undefined })).toBe(true)
    expect(isEndDateValid({ endAt: undefined })).toBe(true)
  })

  it('returns true when only startAt provided', () => {
    expect(isEndDateValid({ startAt: '2026-01-01' })).toBe(true)
  })

  it('returns true when end is after start', () => {
    expect(isEndDateValid({ startAt: '2026-01-01', endAt: '2026-02-01' })).toBe(true)
  })

  it('returns false when end is before start', () => {
    expect(isEndDateValid({ startAt: '2026-02-01', endAt: '2026-01-01' })).toBe(false)
  })

  it('returns false when end equals start', () => {
    expect(isEndDateValid({ startAt: '2026-01-01T00:00:00Z', endAt: '2026-01-01T00:00:00Z' })).toBe(false)
  })
})

describe('validateNoticeForm', () => {
  it('returns valid when both title and message present', () => {
    expect(validateNoticeForm({ title: 'T', message: 'M' })).toEqual({ valid: true })
  })

  it('returns invalid when title missing', () => {
    const result = validateNoticeForm({ message: 'M' })
    expect(result.valid).toBe(false)
    expect(result.error).toBe('titleMessageRequired')
  })

  it('returns invalid when message missing', () => {
    const result = validateNoticeForm({ title: 'T' })
    expect(result.valid).toBe(false)
    expect(result.error).toBe('titleMessageRequired')
  })

  it('returns invalid when both missing', () => {
    const result = validateNoticeForm({})
    expect(result.valid).toBe(false)
  })

  it('returns invalid for empty strings', () => {
    const result = validateNoticeForm({ title: '', message: '' })
    expect(result.valid).toBe(false)
  })
})
===ENDFILE

===FILE: src/utils/admin/__tests__/permission-hierarchy-sorter-extra.test.ts
import { describe, it, expect, vi } from 'vitest'

vi.mock('../../../components/admin/business-relevant-toggles', () => ({
  businessRelevantToggles: {
    capabilities: {
      toggles: {
        'parent1': { visible: true, businessName: 'Parent 1', section: 'Access Controls' },
        'child1': { visible: true, businessName: 'Child 1', parent: 'parent1', section: 'Access Controls' },
        'child2': { visible: true, businessName: 'Child 2', parent: 'parent1', section: 'Access Controls' },
        'parent2': { visible: true, businessName: 'Parent 2', section: 'Workspace' },
        'child3': { visible: true, businessName: 'Child 3', parent: 'parent2', section: 'Workspace' },
        'standalone': { visible: true, businessName: 'Standalone', section: 'Other' }
      }
    },
    emptyLevel: {
      toggles: {}
    }
  }
}))

import { sortWithHierarchy } from '../permission-hierarchy-sorter'

describe('sortWithHierarchy - extended coverage', () => {
  it('places children after their parent', () => {
    const result = sortWithHierarchy({
      keys: ['child1', 'parent1', 'child2'],
      levelKey: 'capabilities'
    })
    const parentIdx = result.indexOf('parent1')
    const child1Idx = result.indexOf('child1')
    const child2Idx = result.indexOf('child2')
    expect(parentIdx).toBeLessThan(child1Idx)
    expect(parentIdx).toBeLessThan(child2Idx)
  })

  it('groups by section order', () => {
    const result = sortWithHierarchy({
      keys: ['parent2', 'parent1', 'standalone'],
      levelKey: 'capabilities'
    })
    // parent1 (Access Controls) should come before parent2 (Workspace) based on first-appearance
    expect(result.indexOf('parent2')).toBeLessThan(result.indexOf('standalone'))
  })

  it('handles keys with no config in toggle map', () => {
    const result = sortWithHierarchy({
      keys: ['unknown-key', 'parent1'],
      levelKey: 'capabilities'
    })
    // Should include both keys without error
    expect(result).toContain('unknown-key')
    expect(result).toContain('parent1')
  })

  it('handles empty keys array', () => {
    const result = sortWithHierarchy({
      keys: [],
      levelKey: 'capabilities'
    })
    expect(result).toEqual([])
  })

  it('handles non-existent levelKey', () => {
    const result = sortWithHierarchy({
      keys: ['key1', 'key2'],
      levelKey: 'nonexistent'
    })
    expect(result).toContain('key1')
    expect(result).toContain('key2')
  })

  it('includes parent with its children', () => {
    const result = sortWithHierarchy({
      keys: ['parent1', 'child1', 'child2', 'parent2', 'child3', 'standalone'],
      levelKey: 'capabilities'
    })
    expect(result).toHaveLength(6)
  })
})
===ENDFILE

===FILE: src/utils/admin/__tests__/permission-hierarchy-sorter.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('../../../components/admin/business-relevant-toggles', () => ({
  businessRelevantToggles: {
    capabilities: {
      toggles: {
        'columns.kms': { businessName: 'Knowledge Base', section: 'Dashboard Access', linkedKeys: ['features.search.knowledgeBase'] },
        'columns.embeddedApps': { businessName: 'Banking Applications', section: 'Dashboard Access', linkedKeys: ['features.search.embeddedApps'] },
        'columns.spaceCopilot': { businessName: 'AI Assistant', section: 'Dashboard Access', linkedKeys: ['micro_frontends.spaceCopilot'] },
        'columns.chat': { businessName: 'Chat Interface', section: 'Dashboard Access' },
        'micro_frontends.mediaBar': { businessName: 'Media Controls', section: 'Platform Apps', linkedKeys: ['widgets.mediaBar.callControls'] }
      }
    },
    workspacePreferences: {
      toggles: {
        'settings_options.calls.autoAccept': { businessName: 'Auto-Accept Calls', section: 'Call Preferences' },
        'settings_options.calls.doNotDisturb.duration': { businessName: 'Do Not Disturb', section: 'Call Preferences' },
        'settings_options.interface.showTranscript': { businessName: 'Show Transcripts', section: 'Privacy & Display' },
        'settings_options.interface.autoCloseKnowledgeOnCallEnd': { businessName: 'Auto-Close Knowledge', section: 'Privacy & Display' },
        'settings_options.interface.spaceCopilotMode': { businessName: 'AI Assistant Mode', section: 'AI Preference' }
      }
    }
  }
}))

const { sortWithHierarchy } = await import('../permission-hierarchy-sorter')

describe('sortWithHierarchy', () => {
  it('sorts by section order for capabilities', () => {
    const keys = [
      'columns.kms',
      'micro_frontends.mediaBar',
      'columns.embeddedApps'
    ]

    const result = sortWithHierarchy({ keys, levelKey: 'capabilities' })

    const kmsIdx = result.indexOf('columns.kms')
    const mediaIdx = result.indexOf('micro_frontends.mediaBar')

    // Dashboard Access items come before Platform Apps
    expect(kmsIdx).toBeLessThan(mediaIdx)
  })

  it('sorts workspacePreferences by section', () => {
    const keys = [
      'settings_options.calls.autoAccept',
      'settings_options.interface.showTranscript',
      'settings_options.interface.spaceCopilotMode'
    ]

    const result = sortWithHierarchy({ keys, levelKey: 'workspacePreferences' })

    const autoAcceptIdx = result.indexOf('settings_options.calls.autoAccept')
    const transcriptIdx = result.indexOf('settings_options.interface.showTranscript')
    const copilotIdx = result.indexOf('settings_options.interface.spaceCopilotMode')

    // Call Preferences first, then Privacy & Display, then AI Preference
    expect(autoAcceptIdx).toBeLessThan(transcriptIdx)
    expect(transcriptIdx).toBeLessThan(copilotIdx)
  })

  it('handles empty keys array', () => {
    expect(sortWithHierarchy({ keys: [], levelKey: 'capabilities' })).toEqual([])
  })

  it('handles unknown level key', () => {
    const result = sortWithHierarchy({ keys: ['a', 'b'], levelKey: 'nonexistent' })
    expect(result).toHaveLength(2)
  })
})
===ENDFILE

===FILE: src/utils/admin/__tests__/permission-level-resolver.test.ts
import { describe, expect, it } from 'vitest'
import { resolvePermissionLevel, resolveLinkedKey, COMPOUND_LEVELS } from '../permission-level-resolver'

describe('resolvePermissionLevel', () => {
  it('passes through non-compound levels unchanged', () => {
    expect(resolvePermissionLevel({ level: 'columns', key: 'kms' })).toEqual({
      actualLevel: 'columns',
      actualKey: 'kms'
    })

    expect(resolvePermissionLevel({ level: 'features', key: 'search.global' })).toEqual({
      actualLevel: 'features',
      actualKey: 'search.global'
    })

    expect(resolvePermissionLevel({ level: 'widgets', key: 'customer.info' })).toEqual({
      actualLevel: 'widgets',
      actualKey: 'customer.info'
    })
  })

  it('resolves capabilities with columns prefix', () => {
    expect(resolvePermissionLevel({ level: 'capabilities', key: 'columns.spaceCopilot' })).toEqual({
      actualLevel: 'columns',
      actualKey: 'spaceCopilot'
    })

    expect(resolvePermissionLevel({ level: 'capabilities', key: 'columns.kms' })).toEqual({
      actualLevel: 'columns',
      actualKey: 'kms'
    })
  })

  it('resolves capabilities with features prefix', () => {
    expect(resolvePermissionLevel({ level: 'capabilities', key: 'features.search.knowledgeBase' })).toEqual({
      actualLevel: 'features',
      actualKey: 'search.knowledgeBase'
    })
  })

  it('resolves capabilities with micro_frontends prefix', () => {
    expect(resolvePermissionLevel({ level: 'capabilities', key: 'micro_frontends.mediaBar' })).toEqual({
      actualLevel: 'micro_frontends',
      actualKey: 'mediaBar'
    })

    expect(resolvePermissionLevel({ level: 'capabilities', key: 'micro_frontends.spaceCopilot' })).toEqual({
      actualLevel: 'micro_frontends',
      actualKey: 'spaceCopilot'
    })
  })

  it('resolves workspacePreferences with widgets prefix', () => {
    expect(resolvePermissionLevel({ level: 'workspacePreferences', key: 'widgets.customer.info' })).toEqual({
      actualLevel: 'widgets',
      actualKey: 'customer.info'
    })
  })

  it('resolves workspacePreferences with settings_tabs prefix', () => {
    expect(resolvePermissionLevel({ level: 'workspacePreferences', key: 'settings_tabs.help' })).toEqual({
      actualLevel: 'settings_tabs',
      actualKey: 'help'
    })
  })

  it('resolves workspacePreferences with settings_options prefix', () => {
    expect(resolvePermissionLevel({ level: 'workspacePreferences', key: 'settings_options.calls.autoAccept' })).toEqual({
      actualLevel: 'settings_options',
      actualKey: 'calls.autoAccept'
    })
  })

  it('handles capabilities key with no dots via fallback', () => {
    const result = resolvePermissionLevel({ level: 'capabilities', key: 'standalone' })
    expect(result.actualLevel).toBe('standalone')
    expect(result.actualKey).toBe('')
  })
})

describe('resolveLinkedKey', () => {
  it('resolves known section prefix (features)', () => {
    expect(resolveLinkedKey('features.search.knowledgeBase')).toEqual({
      actualLevel: 'features',
      actualKey: 'search.knowledgeBase'
    })
  })

  it('resolves known section prefix (micro_frontends)', () => {
    expect(resolveLinkedKey('micro_frontends.spaceCopilot')).toEqual({
      actualLevel: 'micro_frontends',
      actualKey: 'spaceCopilot'
    })
  })

  it('resolves known section prefix (widgets)', () => {
    expect(resolveLinkedKey('widgets.mediaBar.callControls')).toEqual({
      actualLevel: 'widgets',
      actualKey: 'mediaBar.callControls'
    })
  })

  it('falls back to splitting on first dot for unknown prefixes', () => {
    expect(resolveLinkedKey('unknown.section.key')).toEqual({
      actualLevel: 'unknown',
      actualKey: 'section.key'
    })
  })
})

describe('COMPOUND_LEVELS', () => {
  it('defines capabilities sections', () => {
    expect(COMPOUND_LEVELS.capabilities).toEqual(['columns', 'features', 'micro_frontends'])
  })

  it('defines workspacePreferences sections', () => {
    expect(COMPOUND_LEVELS.workspacePreferences).toEqual(['widgets', 'settings_tabs', 'settings_options'])
  })
})
===ENDFILE

===FILE: src/utils/admin/notice-validators.ts
import type { AdGroup } from '../../types/features/ad-group-config'

/** Checks if a string value is non-null, non-empty, and not just whitespace. */
export function hasValue({ value }: { value?: string | null }): boolean {
  return Boolean(value && value.trim().length > 0)
}

/** Returns true if the AD group has both a logical name and a role name assigned. */
export function isConfiguredGroup({ group }: { group: AdGroup }): boolean {
  return (
    hasValue({ value: group.logicalName }) &&
    hasValue({ value: group.roleName })
  )
}

/** Validates that the end date is after the start date. Returns true if either date is missing. */
export function isEndDateValid({ startAt, endAt }: { startAt?: string; endAt?: string }): boolean {
  if (!startAt || !endAt) {
    return true
  }
  const start = new Date(startAt)
  const end = new Date(endAt)
  return end > start
}

/** Validates that both title and message are present. Returns {valid, error} result. */
export function validateNoticeForm({ title, message }: { title?: string; message?: string }): { valid: boolean; error?: string } {
  if (!title || !message) {
    return {
      valid: false,
      error: 'titleMessageRequired'
    }
  }

  return { valid: true }
}
===ENDFILE

===FILE: src/utils/admin/permission-hierarchy-sorter.ts
import { businessRelevantToggles } from '../../components/admin/business-relevant-toggles'

/**
 * Sorts permission keys so that parent toggles appear before their children,
 * grouped by section order. Used to render permission panels hierarchically.
 * @param keys - Flat list of permission keys to sort
 * @param levelKey - Permission level identifier for looking up toggle config
 * @returns Sorted array with parents immediately followed by their children
 */
export function sortWithHierarchy({ keys, levelKey }: { keys: string[]; levelKey: string }): string[] {
  const sorted: string[] = []
  const childrenMap: Record<string, string[]> = {}

  keys.forEach(key => {
    const config = businessRelevantToggles[levelKey]?.toggles[key]
    const parentKey = config?.parent
    if (parentKey) {
      if (!childrenMap[parentKey]) {
        childrenMap[parentKey] = []
      }
      childrenMap[parentKey].push(key)
    }
  })

  const topLevelKeys = keys.filter(key => {
    const config = businessRelevantToggles[levelKey]?.toggles[key]
    return !config?.parent
  })

  // Sort by section order (preserving first-appearance order of sections)
  const sectionOrder: string[] = []
  topLevelKeys.forEach(key => {
    const section = businessRelevantToggles[levelKey]?.toggles[key]?.section || ''
    if (!sectionOrder.includes(section)) {
      sectionOrder.push(section)
    }
  })

  topLevelKeys.sort((a, b) => {
    const sectionA = businessRelevantToggles[levelKey]?.toggles[a]?.section || ''
    const sectionB = businessRelevantToggles[levelKey]?.toggles[b]?.section || ''
    return sectionOrder.indexOf(sectionA) - sectionOrder.indexOf(sectionB)
  })

  topLevelKeys.forEach(key => {
    sorted.push(key)
    if (childrenMap[key]) {
      sorted.push(...childrenMap[key])
    }
  })

  return sorted
}
===ENDFILE

===FILE: src/utils/admin/permission-level-resolver.ts
/**
 * Permission Level Resolver - Shared utility for resolving actual permission levels
 * Handles compound UI levels (capabilities, workspacePreferences) that merge multiple template sections
 */

interface ResolvedPermissionLevel {
  actualLevel: string
  actualKey: string
}

/**
 * Compound levels map a single UI section to multiple template sections.
 * The key prefix in the permission key determines which template section it belongs to.
 */
const COMPOUND_LEVELS: Record<string, string[]> = {
  capabilities: ['columns', 'features', 'micro_frontends'],
  workspacePreferences: ['widgets', 'settings_tabs', 'settings_options']
}

/**
 * Resolve the actual permission level and key from display level and key.
 * For compound levels (capabilities, workspacePreferences), the key prefix determines the actual level.
 *
 * @example
 * resolvePermissionLevel({ level: 'capabilities', key: 'columns.spaceCopilot' })
 * // => { actualLevel: 'columns', actualKey: 'spaceCopilot' }
 *
 * resolvePermissionLevel({ level: 'capabilities', key: 'micro_frontends.mediaBar' })
 * // => { actualLevel: 'micro_frontends', actualKey: 'mediaBar' }
 *
 * resolvePermissionLevel({ level: 'workspacePreferences', key: 'settings_tabs.help' })
 * // => { actualLevel: 'settings_tabs', actualKey: 'help' }
 *
 * resolvePermissionLevel({ level: 'widgets', key: 'customer.info' })
 * // => { actualLevel: 'widgets', actualKey: 'customer.info' }
 */
function findMatchingPrefix(key: string, prefixes: string[]): ResolvedPermissionLevel | null {
  const match = prefixes.find(prefix => key.startsWith(prefix + '.'))
  return match ? { actualLevel: match, actualKey: key.slice(match.length + 1) } : null
}

function splitOnFirstDot(key: string): ResolvedPermissionLevel {
  const [prefix, ...rest] = key.split('.')
  return { actualLevel: prefix, actualKey: rest.join('.') }
}

export function resolvePermissionLevel({
  level,
  key
}: {
  level: string
  key: string
}): ResolvedPermissionLevel {
  const knownPrefixes = COMPOUND_LEVELS[level]
  if (!knownPrefixes) return { actualLevel: level, actualKey: key }
  return findMatchingPrefix(key, knownPrefixes) ?? splitOnFirstDot(key)
}

/**
 * Resolve a linked key string (e.g., 'micro_frontends.spaceCopilot') into its
 * actual template section and key. Uses COMPOUND_LEVELS to match known section
 * prefixes, falling back to splitting on the first dot.
 */
export function resolveLinkedKey(linkedKey: string): { actualLevel: string; actualKey: string } {
  const allSections = Object.values(COMPOUND_LEVELS).flat()
  return findMatchingPrefix(linkedKey, allSections) ?? splitOnFirstDot(linkedKey)
}

export { COMPOUND_LEVELS }
===ENDFILE

===FILE: src/utils/api/__tests__/response-handler.test.ts
import { describe, expect, it, vi } from 'vitest'
import { handleApiResponse, handleApiResponseSafe, handleApiResponseWithTransform } from '../response-handler'

function makeResponse(body: unknown, status = 200, headers?: Record<string, string>): Response {
  const responseHeaders = new Headers(headers)
  if (!responseHeaders.has('content-type')) {
    responseHeaders.set('content-type', 'application/json')
  }
  return {
    ok: status >= 200 && status < 300,
    status,
    statusText: status === 200 ? 'OK' : 'Error',
    url: 'http://localhost/papi/v1/test',
    headers: responseHeaders,
    json: () => Promise.resolve(body),
    text: () => Promise.resolve(typeof body === 'string' ? body : JSON.stringify(body)),
    clone: function () { return { ...this, text: () => Promise.resolve(typeof body === 'string' ? body : JSON.stringify(body)) } as Response }
  } as unknown as Response
}

describe('handleApiResponse', () => {
  it('returns parsed JSON on success', async () => {
    const data = { data: { items: [] } }
    const result = await handleApiResponse<typeof data>({
      response: makeResponse(data),
      context: 'Test'
    })
    expect(result).toEqual(data)
  })

  it('throws on non-ok response', async () => {
    await expect(
      handleApiResponse({ response: makeResponse({}, 500), context: 'Test' })
    ).rejects.toThrow('HTTP 500')
  })

  it('detects HTML responses and throws proxy error', async () => {
    const htmlResponse = {
      ok: true,
      status: 200,
      url: 'http://localhost/papi/v1/test',
      headers: new Headers({ 'content-type': 'text/html' }),
      json: () => { throw new Error('not json') },
      clone: () => ({
        text: () => Promise.resolve('<!DOCTYPE html><html>')
      })
    } as unknown as Response

    await expect(
      handleApiResponse({ response: htmlResponse, context: 'TestContext' })
    ).rejects.toThrow('Expected JSON')
  })

  it('throws generic parse error for non-HTML parse failures', async () => {
    const badResponse = {
      ok: true,
      status: 200,
      url: 'http://localhost/papi/v1/test',
      headers: new Headers({ 'content-type': 'application/json' }),
      json: () => { throw new Error('bad json') },
      clone: () => ({
        text: () => Promise.resolve('not html just garbage')
      })
    } as unknown as Response

    await expect(
      handleApiResponse({ response: badResponse, context: 'ParseTest' })
    ).rejects.toThrow('Failed to parse ParseTest response')
  })
})

describe('handleApiResponseSafe', () => {
  it('returns parsed JSON on success', async () => {
    const data = { result: 'ok' }
    const result = await handleApiResponseSafe<typeof data, { error: string }>({
      response: makeResponse(data),
      errorTransform: (status) => ({ error: `Error ${status}` })
    })
    expect(result).toEqual(data)
  })

  it('returns error result on non-ok response', async () => {
    const result = await handleApiResponseSafe<unknown, { error: string; status: number }>({
      response: makeResponse({}, 404),
      errorTransform: (status, statusText) => ({ error: statusText, status })
    })
    expect(result).toEqual({ error: 'Error', status: 404 })
  })

  it('returns error for HTML response on parse failure', async () => {
    const htmlResponse = {
      ok: true,
      status: 200,
      url: 'http://localhost/test',
      headers: new Headers({ 'content-type': 'text/html' }),
      json: () => { throw new Error('not json') },
      clone: () => ({
        text: () => Promise.resolve('<html>')
      })
    } as unknown as Response

    const result = await handleApiResponseSafe<unknown, { status: number }>({
      response: htmlResponse,
      errorTransform: (status) => ({ status })
    })
    expect(result).toEqual({ status: 502 })
  })

  it('returns JSON_PARSE_ERROR for non-HTML parse failure', async () => {
    const badResponse = {
      ok: true,
      status: 200,
      url: 'http://localhost/test',
      headers: new Headers({ 'content-type': 'application/json' }),
      json: () => { throw new Error('bad') },
      clone: () => ({
        text: () => Promise.resolve('not html')
      })
    } as unknown as Response

    const result = await handleApiResponseSafe<unknown, { status: number }>({
      response: badResponse,
      errorTransform: (status) => ({ status })
    })
    expect(result).toEqual({ status: 500 })
  })
})

describe('handleApiResponseWithTransform', () => {
  it('returns parsed JSON without transform', async () => {
    const data = { items: [1, 2] }
    const result = await handleApiResponseWithTransform<typeof data>({
      response: makeResponse(data),
      errorMessage: 'Failed'
    })
    expect(result).toEqual(data)
  })

  it('applies transform function', async () => {
    const data = { items: [1, 2, 3] }
    const result = await handleApiResponseWithTransform<typeof data, number>({
      response: makeResponse(data),
      errorMessage: 'Failed',
      transform: (d) => d?.items.length ?? 0
    })
    expect(result).toBe(3)
  })

  it('throws with error text on non-ok response', async () => {
    const response = {
      ok: false,
      status: 400,
      text: () => Promise.resolve('Bad request body')
    } as unknown as Response

    await expect(
      handleApiResponseWithTransform({
        response,
        errorMessage: 'Failed to fetch'
      })
    ).rejects.toThrow('Failed to fetch (400): Bad request body')
  })

  it('handles null data with transform', async () => {
    const badJsonResponse = {
      ok: true,
      status: 200,
      json: () => { throw new Error('parse error') }
    } as unknown as Response

    const result = await handleApiResponseWithTransform<unknown, string>({
      response: badJsonResponse,
      errorMessage: 'Failed',
      transform: (d) => d === null ? 'fallback' : 'data'
    })
    expect(result).toBe('fallback')
  })
})
===ENDFILE

===FILE: src/utils/api/response-handler-helpers.ts
/**
 * Response Handler Helpers - Low-level utilities for parsing and inspecting API responses.
 */

/* eslint-disable no-console */

/**
 * Parse JSON with fallback to null on error
 * @param response Fetch response object
 * @returns Parsed JSON or null on parse failure
 */
export async function parseJsonSafe<T>(response: Response): Promise<T | null> {
  try {
    return await response.json() as T
  } catch {
    return null
  }
}

export function isLikelyHtmlResponse(contentType: string, bodyPreview: string): boolean {
  const normalizedType = contentType.toLowerCase()
  const normalizedPreview = bodyPreview.trim().toLowerCase()

  return normalizedType.includes('text/html')
    || normalizedPreview.startsWith('<!doctype')
    || normalizedPreview.startsWith('<html')
}

export function createNonJsonResponseError(context: string, response: Response): Error {
  return new Error(
    `[${context}] Expected JSON from ${response.url}, but received HTML. `
    + 'Check Vite /papi proxy configuration (VITE_PAPI_PROXY_TARGET).'
  )
}

export async function getBodyPreview(responseCopy: Response | null): Promise<string> {
  if (!responseCopy) return ''
  return (await responseCopy.text().catch(() => '')).slice(0, 120)
}

export function cloneResponseSafe(response: Response): Response | null {
  return typeof response.clone === 'function' ? response.clone() : null
}
===ENDFILE

===FILE: src/utils/api/response-handler.ts
/**
 * API Response Handler - Shared utilities for handling API responses
 * Eliminates duplicate error handling and JSON parsing across services
 */

/* eslint-disable no-console */

import {
  parseJsonSafe,
  isLikelyHtmlResponse,
  createNonJsonResponseError,
  getBodyPreview,
  cloneResponseSafe
} from './response-handler-helpers'

/** Checks whether a failed JSON parse is due to an HTML response (proxy error). */
async function detectHtmlParseFailure(
  response: Response,
  responseCopy: Response
): Promise<{ isHtml: boolean; contentType: string; bodyPreview: string }> {
  const contentType = response.headers.get('content-type') ?? ''
  const bodyPreview = await getBodyPreview(responseCopy)
  return { isHtml: isLikelyHtmlResponse(contentType, bodyPreview), contentType, bodyPreview }
}

/**
 * Handle API response with standard error checking and JSON parsing
 * @param response Fetch response object
 * @param context Context for error logging (e.g., 'AdminService.getAllAdGroups')
 * @returns Parsed JSON response
 * @throws Error if response not ok or JSON parsing fails
 */
export async function handleApiResponse<T>({
  response,
  context
}: {
  response: Response
  context: string
}): Promise<T> {
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
  }

  const responseCopy = cloneResponseSafe(response)

  try {
    return await response.json() as T
  } catch (error) {
    const { isHtml, contentType, bodyPreview } = await detectHtmlParseFailure(response, responseCopy)
    if (isHtml) {
      const proxyError = createNonJsonResponseError(context, response)
      console.error(proxyError.message, { status: response.status, contentType, bodyPreview })
      throw proxyError
    }
    console.error(`[${context}] Failed to parse response:`, error)
    throw new Error(`Failed to parse ${context} response`)
  }
}

/**
 * Handle API response with custom error result type (for methods that don't throw)
 * @param response Fetch response object
 * @param errorTransform Function to transform error into custom result type
 * @returns Parsed JSON response or transformed error
 */
export async function handleApiResponseSafe<T, E>({
  response,
  errorTransform
}: {
  response: Response
  errorTransform: (status: number, statusText: string, errorData?: Record<string, unknown>) => E
}): Promise<T | E> {
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}))
    return errorTransform(response.status, response.statusText, errorData)
  }

  const responseCopy = cloneResponseSafe(response)

  try {
    return await response.json() as T
  } catch {
    const { isHtml, contentType, bodyPreview } = await detectHtmlParseFailure(response, responseCopy)
    if (isHtml) {
      return errorTransform(502, 'NON_JSON_RESPONSE', {
        message: createNonJsonResponseError('handleApiResponseSafe', response).message,
        contentType, bodyPreview
      })
    }
    return errorTransform(500, 'JSON_PARSE_ERROR', {})
  }
}

/**
 * Handle API response with text-based error messages and optional transformation
 * Used for search/query endpoints that return text errors instead of JSON
 * @param response Fetch response object
 * @param errorMessage Error message prefix (e.g., 'Failed to get popular apps')
 * @param transform Optional transformation function to apply to parsed data
 * @returns Parsed and optionally transformed response
 * @throws Error with text-based error message if response not ok
 */
export async function handleApiResponseWithTransform<TInput, TOutput = TInput>({
  response,
  errorMessage,
  transform
}: {
  response: Response
  errorMessage: string
  transform?: (data: TInput | null) => TOutput
}): Promise<TOutput> {
  if (!response.ok) {
    const errorText = await response.text().catch(() => 'Unknown error')
    throw new Error(`${errorMessage} (${response.status}): ${errorText}`)
  }

  const data = await parseJsonSafe<TInput>(response)

  if (transform) {
    return transform(data)
  }

  return data as unknown as TOutput
}
===ENDFILE

===FILE: src/utils/auth/__tests__/auth-token-manager-extra.test.ts
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'

vi.mock('@/utils/core/debug', () => ({
  createLogger: () => ({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  })
}))

vi.mock('@/utils/core/error-tracking', () => ({
  logErrorToTracking: vi.fn()
}))

import {
  setAuthToken,
  getAuthToken,
  clearAuthToken,
  hydrateAuthTokenFromLegacyStorage,
  isSessionStorageAvailable
} from '../auth-token-manager'

describe('auth-token-manager - extended coverage', () => {
  beforeEach(() => {
    clearAuthToken()
    sessionStorage.clear()
    localStorage.clear()
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  it('setAuthToken stores in sessionStorage', () => {
    setAuthToken('test-token-123')
    expect(sessionStorage.getItem('ccaas-session-token')).toBe('test-token-123')
  })

  it('getAuthToken returns from memory first', () => {
    setAuthToken('memory-token')
    expect(getAuthToken()).toBe('memory-token')
  })

  it('getAuthToken falls back to sessionStorage', () => {
    sessionStorage.setItem('ccaas-session-token', 'stored-token')
    clearAuthToken()
    // Clear in-memory only, not sessionStorage
    const result = getAuthToken()
    // getAuthToken should find the stored token
    expect(result).toBeDefined()
  })

  it('getAuthToken returns null when no token exists', () => {
    clearAuthToken()
    sessionStorage.removeItem('ccaas-session-token')
    expect(getAuthToken()).toBeNull()
  })

  it('clearAuthToken removes from both memory and storage', () => {
    setAuthToken('to-be-cleared')
    clearAuthToken()
    expect(getAuthToken()).toBeNull()
    expect(sessionStorage.getItem('ccaas-session-token')).toBeNull()
  })

  it('hydrateAuthTokenFromLegacyStorage migrates from localStorage', () => {
    localStorage.setItem('authToken', 'legacy-token')
    hydrateAuthTokenFromLegacyStorage()
    expect(getAuthToken()).toBe('legacy-token')
    expect(localStorage.getItem('authToken')).toBeNull()
  })

  it('hydrateAuthTokenFromLegacyStorage does nothing when no legacy token', () => {
    hydrateAuthTokenFromLegacyStorage()
    expect(getAuthToken()).toBeNull()
  })

  it('isSessionStorageAvailable returns true in browser', () => {
    expect(isSessionStorageAvailable()).toBe(true)
  })

  it('handles sessionStorage write errors gracefully', () => {
    const original = globalThis.sessionStorage.setItem
    vi.spyOn(globalThis.sessionStorage, 'setItem').mockImplementation(() => {
      throw new Error('QuotaExceeded')
    })
    // Should not throw
    expect(() => setAuthToken('will-fail')).not.toThrow()
    vi.spyOn(globalThis.sessionStorage, 'setItem').mockRestore()
  })

  it('handles sessionStorage read errors gracefully', () => {
    vi.spyOn(globalThis.sessionStorage, 'getItem').mockImplementation(() => {
      throw new Error('SecurityError')
    })
    clearAuthToken()
    const result = getAuthToken()
    expect(result).toBeNull()
    vi.spyOn(globalThis.sessionStorage, 'getItem').mockRestore()
  })

  it('handles sessionStorage removeItem errors gracefully', () => {
    vi.spyOn(globalThis.sessionStorage, 'removeItem').mockImplementation(() => {
      throw new Error('SecurityError')
    })
    // Should not throw
    expect(() => clearAuthToken()).not.toThrow()
    vi.spyOn(globalThis.sessionStorage, 'removeItem').mockRestore()
  })
})
===ENDFILE

===FILE: src/utils/auth/__tests__/auth-token-manager.test.ts
// @vitest-environment jsdom
import { beforeEach, describe, expect, it, vi } from 'vitest'

vi.mock('@/utils/core/debug', () => ({
  createLogger: () => ({
    trace: vi.fn(),
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  })
}))

vi.mock('@/utils/core/error-tracking', () => ({
  logErrorToTracking: vi.fn()
}))

const {
  setAuthToken,
  getAuthToken,
  clearAuthToken,
  hydrateAuthTokenFromLegacyStorage,
  isSessionStorageAvailable
} = await import('../auth-token-manager')

describe('auth-token-manager', () => {
  beforeEach(() => {
    clearAuthToken()
    vi.clearAllMocks()
    window.sessionStorage.clear()
    window.localStorage.clear()
  })

  describe('setAuthToken / getAuthToken', () => {
    it('stores and retrieves token from memory', () => {
      setAuthToken('my-token')
      expect(getAuthToken()).toBe('my-token')
    })

    it('persists token to sessionStorage', () => {
      setAuthToken('persisted-token')
      expect(window.sessionStorage.getItem('ccaas-session-token')).toBe('persisted-token')
    })

    it('falls back to sessionStorage when in-memory token is absent', () => {
      // Directly set sessionStorage (bypassing setAuthToken so in-memory stays null)
      clearAuthToken()
      window.sessionStorage.setItem('ccaas-session-token', 'stored-token')

      const token = getAuthToken()
      expect(token).toBe('stored-token')
    })
  })

  describe('clearAuthToken', () => {
    it('removes token from memory and storage', () => {
      setAuthToken('to-clear')
      clearAuthToken()
      expect(getAuthToken()).toBeNull()
      expect(window.sessionStorage.getItem('ccaas-session-token')).toBeNull()
    })
  })

  describe('hydrateAuthTokenFromLegacyStorage', () => {
    it('migrates token from localStorage to sessionStorage', () => {
      window.localStorage.setItem('authToken', 'legacy-token')

      hydrateAuthTokenFromLegacyStorage()

      expect(getAuthToken()).toBe('legacy-token')
      expect(window.localStorage.getItem('authToken')).toBeNull()
    })

    it('does nothing when no legacy token exists', () => {
      hydrateAuthTokenFromLegacyStorage()
      expect(getAuthToken()).toBeNull()
    })

    it('handles localStorage error gracefully', () => {
      const originalGetItem = window.localStorage.getItem
      window.localStorage.getItem = () => { throw new Error('localStorage blocked') }

      // Should not throw
      hydrateAuthTokenFromLegacyStorage()
      expect(getAuthToken()).toBeNull()

      window.localStorage.getItem = originalGetItem
    })
  })

  describe('isSessionStorageAvailable', () => {
    it('returns true in test environment', () => {
      expect(isSessionStorageAvailable()).toBe(true)
    })

    it('returns false when sessionStorage throws', () => {
      const setItemSpy = vi.spyOn(Storage.prototype, 'setItem').mockImplementation(() => {
        throw new Error('storage blocked')
      })

      expect(isSessionStorageAvailable()).toBe(false)

      setItemSpy.mockRestore()
    })
  })

  describe('sessionStorage error handling', () => {
    it('handles sessionStorage.getItem error in readFromSessionStorage', () => {
      clearAuthToken()
      const originalGetItem = window.sessionStorage.getItem
      window.sessionStorage.getItem = () => { throw new Error('read blocked') }

      // getAuthToken calls readFromSessionStorage when in-memory is null
      const token = getAuthToken()
      expect(token).toBeNull()

      window.sessionStorage.getItem = originalGetItem
    })

    it('handles sessionStorage.setItem error in writeToSessionStorage', () => {
      const originalSetItem = window.sessionStorage.setItem
      window.sessionStorage.setItem = () => { throw new Error('write blocked') }

      // setAuthToken calls writeToSessionStorage which should catch the error
      setAuthToken('test-token')
      // Token should still be in memory even if storage write fails
      expect(getAuthToken()).toBe('test-token')

      window.sessionStorage.setItem = originalSetItem
    })

    it('handles sessionStorage.removeItem error in clearAuthToken', () => {
      setAuthToken('some-token')
      const originalRemoveItem = window.sessionStorage.removeItem
      window.sessionStorage.removeItem = () => { throw new Error('remove blocked') }

      // clearAuthToken calls writeToSessionStorage(null) which should catch
      clearAuthToken()
      expect(getAuthToken()).toBeNull()

      window.sessionStorage.removeItem = originalRemoveItem
    })
  })
})
===ENDFILE

===FILE: src/utils/auth/auth-token-manager.ts
import { createLogger } from '@/utils/core/debug'
import { logErrorToTracking } from '@/utils/core/error-tracking'

const TOKEN_STORAGE_KEY = 'ccaas-session-token'

let inMemoryToken: string | null = null

const logger = createLogger('AUTH_TOKEN_MANAGER')

function isBrowserEnvironment(): boolean {
  return globalThis.window !== undefined
}

function toErrorMessage(error: unknown): string {
  return error instanceof Error ? error.message : String(error)
}

function readFromSessionStorage(): string | null {
  if (!isBrowserEnvironment()) return null

  try {
    return globalThis.sessionStorage.getItem(TOKEN_STORAGE_KEY)
  } catch (error) {
    logger.warn('SessionStorage read failed', { error, key: TOKEN_STORAGE_KEY })
    logErrorToTracking('SESSION_STORAGE_READ_FAILED', { error: toErrorMessage(error), key: TOKEN_STORAGE_KEY })
    return null
  }
}

function writeToSessionStorage(token: string | null): void {
  if (!isBrowserEnvironment()) return

  try {
    const action = token
      ? () => globalThis.sessionStorage.setItem(TOKEN_STORAGE_KEY, token)
      : () => globalThis.sessionStorage.removeItem(TOKEN_STORAGE_KEY)
    action()
  } catch (error) {
    logger.warn('SessionStorage write failed', { error, hasToken: Boolean(token) })
    logErrorToTracking('SESSION_STORAGE_WRITE_FAILED', { error: toErrorMessage(error), hasToken: Boolean(token) })
  }
}

/** Stores the auth token in memory and persists it to session storage. */
export function setAuthToken(token: string): void {
  inMemoryToken = token
  writeToSessionStorage(token)
}

/** Returns the current auth token from memory, falling back to session storage. */
export function getAuthToken(): string | null {
  if (inMemoryToken) return inMemoryToken
  inMemoryToken = readFromSessionStorage()
  return inMemoryToken
}

/** Clears the auth token from both in-memory cache and session storage. */
export function clearAuthToken(): void {
  inMemoryToken = null
  writeToSessionStorage(null)
}

/** Migrates auth token from legacy localStorage key ('authToken') to session storage. */
export function hydrateAuthTokenFromLegacyStorage(): void {
  if (!isBrowserEnvironment()) return

  try {
    const legacyToken = globalThis.localStorage.getItem('authToken')
    if (!legacyToken) return
    setAuthToken(legacyToken)
    globalThis.localStorage.removeItem('authToken')
  } catch (error) {
    logger.warn('Legacy token migration failed', { error })
  }
}

/** Probes whether session storage is available and writable in the current environment. */
export function isSessionStorageAvailable(): boolean {
  if (!isBrowserEnvironment()) return false

  try {
    const probeKey = '__session_probe__'
    globalThis.sessionStorage.setItem(probeKey, 'ok')
    globalThis.sessionStorage.removeItem(probeKey)
    return true
  } catch (error) {
    logger.warn('SessionStorage availability check failed', { error })
    return false
  }
}
===ENDFILE

===FILE: src/utils/core/__tests__/debug.test.ts
import { describe, expect, it, vi } from 'vitest'
import { createLogger } from '../debug'

describe('createLogger', () => {
  it('creates a logger with all log level methods', () => {
    const logger = createLogger('TestContext')
    expect(logger).toHaveProperty('trace')
    expect(logger).toHaveProperty('debug')
    expect(logger).toHaveProperty('info')
    expect(logger).toHaveProperty('warn')
    expect(logger).toHaveProperty('error')
  })

  it('logs messages with context prefix', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    const logger = createLogger('MyModule')

    logger.error('something went wrong')

    expect(spy).toHaveBeenCalledTimes(1)
    const loggedMessage = spy.mock.calls[0][0] as string
    expect(loggedMessage).toContain('MyModule')
    expect(loggedMessage).toContain('ERROR')
    expect(loggedMessage).toContain('something went wrong')

    spy.mockRestore()
  })

  it('logs messages with data when provided', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    const logger = createLogger('TestCtx')

    logger.error('err msg', { detail: 'extra' })

    expect(spy).toHaveBeenCalledTimes(1)
    expect(spy.mock.calls[0]).toHaveLength(2)
    expect(spy.mock.calls[0][1]).toEqual({ detail: 'extra' })

    spy.mockRestore()
  })

  it('uses default context when no argument provided', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    const logger = createLogger()

    logger.error('test')

    const loggedMessage = spy.mock.calls[0][0] as string
    expect(loggedMessage).toContain('agent-frontend')

    spy.mockRestore()
  })

  it('calls warn method on console.warn', () => {
    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {})
    const logger = createLogger('WarnTest')

    logger.warn('warning message')

    expect(spy).toHaveBeenCalledTimes(1)
    const loggedMessage = spy.mock.calls[0][0] as string
    expect(loggedMessage).toContain('WARN')

    spy.mockRestore()
  })

  it('calls info method on console.info', () => {
    const spy = vi.spyOn(console, 'info').mockImplementation(() => {})
    const logger = createLogger('InfoTest')

    logger.info('info message')

    expect(spy).toHaveBeenCalledTimes(1)
    const loggedMessage = spy.mock.calls[0][0] as string
    expect(loggedMessage).toContain('INFO')

    spy.mockRestore()
  })

  it('calls debug method on console.debug', () => {
    const spy = vi.spyOn(console, 'debug').mockImplementation(() => {})
    const logger = createLogger('DebugTest')

    logger.debug('debug message')

    expect(spy).toHaveBeenCalled()
    const loggedMessage = spy.mock.calls[0][0] as string
    expect(loggedMessage).toContain('DEBUG')
    expect(loggedMessage).toContain('DebugTest')

    spy.mockRestore()
  })

  it('trace method is callable (may be filtered by log level)', () => {
    const spy = vi.spyOn(console, 'debug').mockImplementation(() => {})
    const logger = createLogger('TraceTest')

    // In test mode, log level is DEBUG, so TRACE (level 0) may be filtered
    // since TRACE < DEBUG. This just verifies the method exists and doesn't throw.
    expect(() => logger.trace('trace message')).not.toThrow()

    spy.mockRestore()
  })

  it('includes timestamp in log output', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    const logger = createLogger('TimestampTest')

    logger.error('msg')

    const loggedMessage = spy.mock.calls[0][0] as string
    // ISO timestamp format check
    expect(loggedMessage).toMatch(/\[\d{4}-\d{2}-\d{2}T/)

    spy.mockRestore()
  })

  it('debug logs with data', () => {
    const spy = vi.spyOn(console, 'debug').mockImplementation(() => {})
    const logger = createLogger('DataTest')

    logger.debug('with data', { key: 'value' })

    expect(spy.mock.calls[0]).toHaveLength(2)
    expect(spy.mock.calls[0][1]).toEqual({ key: 'value' })

    spy.mockRestore()
  })

  it('warn logs with data', () => {
    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {})
    const logger = createLogger('WarnDataTest')

    logger.warn('warning with data', { details: 123 })

    expect(spy.mock.calls[0]).toHaveLength(2)
    expect(spy.mock.calls[0][1]).toEqual({ details: 123 })

    spy.mockRestore()
  })

  it('info logs with data', () => {
    const spy = vi.spyOn(console, 'info').mockImplementation(() => {})
    const logger = createLogger('InfoDataTest')

    logger.info('info with data', [1, 2, 3])

    expect(spy.mock.calls[0]).toHaveLength(2)
    expect(spy.mock.calls[0][1]).toEqual([1, 2, 3])

    spy.mockRestore()
  })

  it('trace logs with data does not throw', () => {
    const spy = vi.spyOn(console, 'debug').mockImplementation(() => {})
    const logger = createLogger('TraceDataTest')

    // In test mode TRACE is below the log level threshold, so nothing is emitted
    expect(() => logger.trace('trace with data', { nested: true })).not.toThrow()

    spy.mockRestore()
  })

  it('logs without data produce single argument call', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    const logger = createLogger('SingleArg')

    logger.error('no data')

    expect(spy.mock.calls[0]).toHaveLength(1)

    spy.mockRestore()
  })
})
===ENDFILE

===FILE: src/utils/core/__tests__/error-tracking-extra.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { logErrorToTracking } from '../error-tracking'

describe('logErrorToTracking - extended coverage', () => {
  beforeEach(() => {
    vi.restoreAllMocks()
  })

  it('calls error tracking service when available', () => {
    const mockLogError = vi.fn()
    const globalAny = globalThis as any
    globalAny.errorTrackingService = { logError: mockLogError }

    logErrorToTracking('TEST_EVENT', { key: 'value' })
    expect(mockLogError).toHaveBeenCalledWith('TEST_EVENT', { key: 'value' })

    delete globalAny.errorTrackingService
  })

  it('does nothing when tracking service has no logError', () => {
    const globalAny = globalThis as any
    globalAny.errorTrackingService = {}

    // Should not throw
    expect(() => logErrorToTracking('TEST_EVENT', { key: 'value' })).not.toThrow()

    delete globalAny.errorTrackingService
  })

  it('does nothing when no tracking service exists', () => {
    // Should not throw
    expect(() => logErrorToTracking('NO_SERVICE', { test: true })).not.toThrow()
  })
})
===ENDFILE

===FILE: src/utils/core/__tests__/error-tracking.test.ts
// @vitest-environment jsdom
import { beforeEach, describe, expect, it, vi } from 'vitest'
import { logErrorToTracking } from '../error-tracking'

describe('logErrorToTracking', () => {
  const windowWithTracking = window as unknown as Record<string, unknown>

  beforeEach(() => {
    // Clean up any mock service
    delete windowWithTracking.errorTrackingService
  })

  it('calls service logError when available', () => {
    const logError = vi.fn()
    windowWithTracking.errorTrackingService = { logError }

    logErrorToTracking('TEST_ERROR', { key: 'value' })

    expect(logError).toHaveBeenCalledWith('TEST_ERROR', { key: 'value' })
  })

  it('does nothing when service is not available', () => {
    // No error tracking service on window
    expect(() => logErrorToTracking('TEST', {})).not.toThrow()
  })

  it('does nothing when logError method missing', () => {
    windowWithTracking.errorTrackingService = {}
    expect(() => logErrorToTracking('TEST', {})).not.toThrow()
  })
})
===ENDFILE

===FILE: src/utils/core/__tests__/log-level-extra.test.ts
import { describe, it, expect } from 'vitest'
import { parseLevel, LogLevel, LEVEL_NAME, LEVEL_TO_CONSOLE } from '../log-level'

describe('parseLevel - extended coverage', () => {
  it('parses trace level', () => {
    expect(parseLevel('trace')).toBe(LogLevel.TRACE)
  })

  it('parses debug level', () => {
    expect(parseLevel('debug')).toBe(LogLevel.DEBUG)
  })

  it('parses info level', () => {
    expect(parseLevel('info')).toBe(LogLevel.INFO)
  })

  it('parses warn level', () => {
    expect(parseLevel('warn')).toBe(LogLevel.WARN)
  })

  it('parses warning level', () => {
    expect(parseLevel('warning')).toBe(LogLevel.WARN)
  })

  it('parses error level', () => {
    expect(parseLevel('error')).toBe(LogLevel.ERROR)
  })

  it('returns INFO for unknown level', () => {
    expect(parseLevel('unknown')).toBe(LogLevel.INFO)
  })

  it('returns INFO for null', () => {
    expect(parseLevel(null)).toBe(LogLevel.INFO)
  })

  it('returns INFO for undefined', () => {
    expect(parseLevel(undefined)).toBe(LogLevel.INFO)
  })

  it('returns INFO for empty string', () => {
    expect(parseLevel('')).toBe(LogLevel.INFO)
  })

  it('returns INFO for non-string', () => {
    expect(parseLevel(42)).toBe(LogLevel.INFO)
  })

  it('is case insensitive', () => {
    expect(parseLevel('TRACE')).toBe(LogLevel.TRACE)
    expect(parseLevel('Debug')).toBe(LogLevel.DEBUG)
    expect(parseLevel('ERROR')).toBe(LogLevel.ERROR)
  })
})

describe('LEVEL_NAME', () => {
  it('maps all log levels to names', () => {
    expect(LEVEL_NAME[LogLevel.TRACE]).toBe('TRACE')
    expect(LEVEL_NAME[LogLevel.DEBUG]).toBe('DEBUG')
    expect(LEVEL_NAME[LogLevel.INFO]).toBe('INFO')
    expect(LEVEL_NAME[LogLevel.WARN]).toBe('WARN')
    expect(LEVEL_NAME[LogLevel.ERROR]).toBe('ERROR')
  })
})

describe('LEVEL_TO_CONSOLE', () => {
  it('maps log levels to console methods', () => {
    expect(LEVEL_TO_CONSOLE[LogLevel.TRACE]).toBe('debug')
    expect(LEVEL_TO_CONSOLE[LogLevel.DEBUG]).toBe('debug')
    expect(LEVEL_TO_CONSOLE[LogLevel.INFO]).toBe('info')
    expect(LEVEL_TO_CONSOLE[LogLevel.WARN]).toBe('warn')
    expect(LEVEL_TO_CONSOLE[LogLevel.ERROR]).toBe('error')
  })
})
===ENDFILE

===FILE: src/utils/core/__tests__/log-level.test.ts
import { describe, it, expect } from 'vitest'
import { LogLevel, LEVEL_TO_CONSOLE, LEVEL_NAME, parseLevel, resolveLogLevel } from '../log-level'

describe('LogLevel enum', () => {
  it('has TRACE as 0', () => {
    expect(LogLevel.TRACE).toBe(0)
  })

  it('has DEBUG as 1', () => {
    expect(LogLevel.DEBUG).toBe(1)
  })

  it('has INFO as 2', () => {
    expect(LogLevel.INFO).toBe(2)
  })

  it('has WARN as 3', () => {
    expect(LogLevel.WARN).toBe(3)
  })

  it('has ERROR as 4', () => {
    expect(LogLevel.ERROR).toBe(4)
  })
})

describe('LEVEL_TO_CONSOLE', () => {
  it('maps TRACE to debug', () => {
    expect(LEVEL_TO_CONSOLE[LogLevel.TRACE]).toBe('debug')
  })

  it('maps DEBUG to debug', () => {
    expect(LEVEL_TO_CONSOLE[LogLevel.DEBUG]).toBe('debug')
  })

  it('maps INFO to info', () => {
    expect(LEVEL_TO_CONSOLE[LogLevel.INFO]).toBe('info')
  })

  it('maps WARN to warn', () => {
    expect(LEVEL_TO_CONSOLE[LogLevel.WARN]).toBe('warn')
  })

  it('maps ERROR to error', () => {
    expect(LEVEL_TO_CONSOLE[LogLevel.ERROR]).toBe('error')
  })
})

describe('LEVEL_NAME', () => {
  it('maps levels to readable names', () => {
    expect(LEVEL_NAME[LogLevel.TRACE]).toBe('TRACE')
    expect(LEVEL_NAME[LogLevel.DEBUG]).toBe('DEBUG')
    expect(LEVEL_NAME[LogLevel.INFO]).toBe('INFO')
    expect(LEVEL_NAME[LogLevel.WARN]).toBe('WARN')
    expect(LEVEL_NAME[LogLevel.ERROR]).toBe('ERROR')
  })
})

describe('parseLevel', () => {
  it('returns INFO for null/undefined', () => {
    expect(parseLevel(null)).toBe(LogLevel.INFO)
    expect(parseLevel(undefined)).toBe(LogLevel.INFO)
  })

  it('returns INFO for non-string', () => {
    expect(parseLevel(42)).toBe(LogLevel.INFO)
    expect(parseLevel(true)).toBe(LogLevel.INFO)
  })

  it('parses "trace"', () => {
    expect(parseLevel('trace')).toBe(LogLevel.TRACE)
  })

  it('parses "debug"', () => {
    expect(parseLevel('debug')).toBe(LogLevel.DEBUG)
  })

  it('parses "info"', () => {
    expect(parseLevel('info')).toBe(LogLevel.INFO)
  })

  it('parses "warn"', () => {
    expect(parseLevel('warn')).toBe(LogLevel.WARN)
  })

  it('parses "warning"', () => {
    expect(parseLevel('warning')).toBe(LogLevel.WARN)
  })

  it('parses "error"', () => {
    expect(parseLevel('error')).toBe(LogLevel.ERROR)
  })

  it('returns INFO for unknown string', () => {
    expect(parseLevel('verbose')).toBe(LogLevel.INFO)
  })

  it('is case insensitive', () => {
    expect(parseLevel('DEBUG')).toBe(LogLevel.DEBUG)
    expect(parseLevel('Error')).toBe(LogLevel.ERROR)
    expect(parseLevel('TRACE')).toBe(LogLevel.TRACE)
  })

  it('returns INFO for empty string', () => {
    expect(parseLevel('')).toBe(LogLevel.INFO)
  })
})

describe('resolveLogLevel', () => {
  it('returns a valid LogLevel', () => {
    const level = resolveLogLevel()
    expect(level).toBeGreaterThanOrEqual(LogLevel.TRACE)
    expect(level).toBeLessThanOrEqual(LogLevel.ERROR)
  })

  it('returns DEBUG in test mode', () => {
    // vitest runs in test mode
    expect(resolveLogLevel()).toBe(LogLevel.DEBUG)
  })
})
===ENDFILE

===FILE: src/utils/core/__tests__/log-writer-extra.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'

vi.mock('../log-level', () => ({
  LogLevel: { TRACE: 0, DEBUG: 1, INFO: 2, WARN: 3, ERROR: 4 },
  LEVEL_TO_CONSOLE: {
    0: 'debug',
    1: 'debug',
    2: 'info',
    3: 'warn',
    4: 'error'
  },
  LEVEL_NAME: {
    0: 'TRACE',
    1: 'DEBUG',
    2: 'INFO',
    3: 'WARN',
    4: 'ERROR'
  },
  resolveLogLevel: () => 0 // TRACE - allow all logs
}))

import { log, traceLog, debugLog, infoLog, warnLog, errorLog } from '../log-writer'
import { LogLevel } from '../log-level'

describe('log-writer - extended coverage', () => {
  beforeEach(() => {
    vi.spyOn(console, 'debug').mockImplementation(() => {})
    vi.spyOn(console, 'info').mockImplementation(() => {})
    vi.spyOn(console, 'warn').mockImplementation(() => {})
    vi.spyOn(console, 'error').mockImplementation(() => {})
    vi.spyOn(console, 'log').mockImplementation(() => {})
  })

  it('log writes debug message', () => {
    log(LogLevel.DEBUG, 'TestCtx', 'hello')
    expect(console.debug).toHaveBeenCalled()
  })

  it('log writes info message', () => {
    log(LogLevel.INFO, 'TestCtx', 'info msg')
    expect(console.info).toHaveBeenCalled()
  })

  it('log writes warn message', () => {
    log(LogLevel.WARN, 'TestCtx', 'warning msg')
    expect(console.warn).toHaveBeenCalled()
  })

  it('log writes error message', () => {
    log(LogLevel.ERROR, 'TestCtx', 'error msg')
    expect(console.error).toHaveBeenCalled()
  })

  it('log writes trace message', () => {
    log(LogLevel.TRACE, 'TestCtx', 'trace msg')
    expect(console.debug).toHaveBeenCalled()
  })

  it('log includes data when provided', () => {
    log(LogLevel.INFO, 'TestCtx', 'with data', { key: 'value' })
    expect(console.info).toHaveBeenCalledWith(
      expect.stringContaining('with data'),
      { key: 'value' }
    )
  })

  it('log omits data arg when data is undefined', () => {
    log(LogLevel.INFO, 'TestCtx', 'no data')
    expect(console.info).toHaveBeenCalledWith(
      expect.stringContaining('no data')
    )
  })

  it('traceLog calls log with TRACE level', () => {
    traceLog('Ctx', 'trace message')
    expect(console.debug).toHaveBeenCalled()
  })

  it('debugLog calls log with DEBUG level', () => {
    debugLog('Ctx', 'debug message')
    expect(console.debug).toHaveBeenCalled()
  })

  it('infoLog calls log with INFO level', () => {
    infoLog('Ctx', 'info message')
    expect(console.info).toHaveBeenCalled()
  })

  it('warnLog calls log with WARN level', () => {
    warnLog('Ctx', 'warn message')
    expect(console.warn).toHaveBeenCalled()
  })

  it('errorLog calls log with ERROR level', () => {
    errorLog('Ctx', 'error message')
    expect(console.error).toHaveBeenCalled()
  })

  it('traceLog passes data argument', () => {
    traceLog('Ctx', 'msg', { extra: true })
    expect(console.debug).toHaveBeenCalledWith(
      expect.stringContaining('msg'),
      { extra: true }
    )
  })
})
===ENDFILE

===FILE: src/utils/core/__tests__/log-writer.test.ts
import { describe, it, expect, vi } from 'vitest'
import { LogLevel } from '../log-level'
import { log, traceLog, debugLog, infoLog, warnLog, errorLog } from '../log-writer'

describe('log', () => {
  it('writes to console.error for ERROR level', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    log(LogLevel.ERROR, 'TestCtx', 'error message')
    expect(spy).toHaveBeenCalled()
    spy.mockRestore()
  })

  it('writes to console.warn for WARN level', () => {
    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {})
    log(LogLevel.WARN, 'TestCtx', 'warn message')
    expect(spy).toHaveBeenCalled()
    spy.mockRestore()
  })

  it('writes to console.info for INFO level', () => {
    const spy = vi.spyOn(console, 'info').mockImplementation(() => {})
    log(LogLevel.INFO, 'TestCtx', 'info message')
    expect(spy).toHaveBeenCalled()
    spy.mockRestore()
  })

  it('writes to console.debug for DEBUG level', () => {
    const spy = vi.spyOn(console, 'debug').mockImplementation(() => {})
    log(LogLevel.DEBUG, 'TestCtx', 'debug message')
    expect(spy).toHaveBeenCalled()
    spy.mockRestore()
  })

  it('includes data as second argument when provided', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    log(LogLevel.ERROR, 'Ctx', 'msg', { key: 'val' })
    expect(spy.mock.calls[0]).toHaveLength(2)
    expect(spy.mock.calls[0][1]).toEqual({ key: 'val' })
    spy.mockRestore()
  })

  it('single argument call when no data', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    log(LogLevel.ERROR, 'Ctx', 'msg')
    expect(spy.mock.calls[0]).toHaveLength(1)
    spy.mockRestore()
  })

  it('includes timestamp, level name, and context in output', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    log(LogLevel.ERROR, 'MyModule', 'test msg')
    const output = spy.mock.calls[0][0] as string
    expect(output).toContain('ERROR')
    expect(output).toContain('MyModule')
    expect(output).toContain('test msg')
    expect(output).toMatch(/\[\d{4}-\d{2}-\d{2}T/)
    spy.mockRestore()
  })

  it('does not log TRACE when current level is DEBUG', () => {
    const spy = vi.spyOn(console, 'debug').mockImplementation(() => {})
    log(LogLevel.TRACE, 'Ctx', 'trace msg')
    // In test mode, level is DEBUG (1), TRACE is 0, so it should be filtered
    expect(spy).not.toHaveBeenCalled()
    spy.mockRestore()
  })
})

describe('convenience log functions', () => {
  it('traceLog does not throw', () => {
    expect(() => traceLog('Ctx', 'trace')).not.toThrow()
  })

  it('debugLog calls console.debug', () => {
    const spy = vi.spyOn(console, 'debug').mockImplementation(() => {})
    debugLog('Ctx', 'debug msg')
    expect(spy).toHaveBeenCalled()
    spy.mockRestore()
  })

  it('infoLog calls console.info', () => {
    const spy = vi.spyOn(console, 'info').mockImplementation(() => {})
    infoLog('Ctx', 'info msg')
    expect(spy).toHaveBeenCalled()
    spy.mockRestore()
  })

  it('warnLog calls console.warn', () => {
    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {})
    warnLog('Ctx', 'warn msg')
    expect(spy).toHaveBeenCalled()
    spy.mockRestore()
  })

  it('errorLog calls console.error', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    errorLog('Ctx', 'error msg')
    expect(spy).toHaveBeenCalled()
    spy.mockRestore()
  })

  it('debugLog passes data', () => {
    const spy = vi.spyOn(console, 'debug').mockImplementation(() => {})
    debugLog('Ctx', 'msg', { data: true })
    expect(spy.mock.calls[0]).toHaveLength(2)
    spy.mockRestore()
  })

  it('warnLog passes data', () => {
    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {})
    warnLog('Ctx', 'msg', [1, 2])
    expect(spy.mock.calls[0]).toHaveLength(2)
    spy.mockRestore()
  })
})
===ENDFILE

===FILE: src/utils/core/debug.ts
/* eslint-disable no-console */

/**
 * Debug - Logger factory using split log-level and log-writer modules.
 */

import { traceLog, debugLog, infoLog, warnLog, errorLog } from './log-writer'

// Re-export for consumers
export { LogLevel, parseLevel, resolveLogLevel } from './log-level'
export { log, traceLog, debugLog, infoLog, warnLog, errorLog } from './log-writer'

/**
 * Creates a scoped logger with trace/debug/info/warn/error methods.
 * Log level is resolved from VITE_LOG_LEVEL env var, localStorage, or defaults to DEBUG in dev.
 * @param context - Logger scope name included in all log output (e.g., 'AUTH_TOKEN_MANAGER')
 */
export function createLogger(context = 'agent-frontend') {
  const scope = context

  return {
    trace: (message: string, data?: unknown) => traceLog(scope, message, data),
    debug: (message: string, data?: unknown) => debugLog(scope, message, data),
    info: (message: string, data?: unknown) => infoLog(scope, message, data),
    warn: (message: string, data?: unknown) => warnLog(scope, message, data),
    error: (message: string, data?: unknown) => errorLog(scope, message, data)
  }
}
===ENDFILE

===FILE: src/utils/core/error-tracking.ts
interface ErrorTrackingService {
  logError?: (eventId: string, context?: Record<string, unknown>) => void
}

/**
 * Forwards an error event to the global error tracking service if available.
 * No-op in non-browser environments or when no tracking service is configured.
 * @param eventId - Error event identifier (e.g., 'SESSION_STORAGE_READ_FAILED')
 * @param context - Additional context data for the error event
 */
export function logErrorToTracking(eventId: string, context: Record<string, unknown>): void {
  if (globalThis.window === undefined) {
    return
  }

  const service = (globalThis as typeof globalThis & { errorTrackingService?: ErrorTrackingService }).errorTrackingService
  service?.logError?.(eventId, context)
}
===ENDFILE

===FILE: src/utils/core/log-level.ts
/* eslint-disable no-console */

/**
 * Log Level - Resolution and configuration for the logging framework
 */

// Log levels in ascending verbosity order
export enum LogLevel {
  TRACE = 0,
  DEBUG = 1,
  INFO = 2,
  WARN = 3,
  ERROR = 4
}

export const LEVEL_TO_CONSOLE: Record<LogLevel, keyof Console> = {
  [LogLevel.TRACE]: 'debug',
  [LogLevel.DEBUG]: 'debug',
  [LogLevel.INFO]: 'info',
  [LogLevel.WARN]: 'warn',
  [LogLevel.ERROR]: 'error'
}

export const LEVEL_NAME: Record<LogLevel, string> = {
  [LogLevel.TRACE]: 'TRACE',
  [LogLevel.DEBUG]: 'DEBUG',
  [LogLevel.INFO]: 'INFO',
  [LogLevel.WARN]: 'WARN',
  [LogLevel.ERROR]: 'ERROR'
}

const LEVEL_MAP: Record<string, LogLevel> = {
  trace: LogLevel.TRACE,
  debug: LogLevel.DEBUG,
  info: LogLevel.INFO,
  warn: LogLevel.WARN,
  warning: LogLevel.WARN,
  error: LogLevel.ERROR
}

export function parseLevel(rawLevel: unknown): LogLevel {
  if (!rawLevel || typeof rawLevel !== 'string') return LogLevel.INFO
  return LEVEL_MAP[rawLevel.toLowerCase()] ?? LogLevel.INFO
}

const DEV_MODES = new Set(['development', 'test'])

function getStoredLevel(): string | null | undefined {
  return globalThis.window === undefined ? undefined : globalThis.localStorage?.getItem('AGENT_FRONTEND_LOG_LEVEL')
}

export function resolveLogLevel(): LogLevel {
  try {
    const envLevel = import.meta.env?.VITE_LOG_LEVEL ?? import.meta.env?.VITE_AGENT_FRONTEND_LOG_LEVEL
    const storedLevel = getStoredLevel()
    const resolvedRaw = envLevel ?? storedLevel
    if (resolvedRaw) return parseLevel(resolvedRaw)
    return DEV_MODES.has(import.meta.env?.MODE) ? LogLevel.DEBUG : LogLevel.INFO
  } catch {
    return LogLevel.INFO
  }
}
===ENDFILE

===FILE: src/utils/core/log-writer.ts
/* eslint-disable no-console */

/**
 * Log Writer - Core log output functions
 */

import { LogLevel, LEVEL_TO_CONSOLE, LEVEL_NAME, resolveLogLevel } from './log-level'

const currentLevel = resolveLogLevel()

function shouldLog(level: LogLevel): boolean {
  return level >= currentLevel
}

export function log(level: LogLevel, context: string, message: string, data?: unknown): void {
  if (!shouldLog(level)) {
    return
  }

  const methodName = LEVEL_TO_CONSOLE[level]

  const method = (...args: unknown[]) => {
    switch (methodName) {
      case 'debug':
        console.debug(...args)
        break
      case 'info':
        console.info(...args)
        break
      case 'warn':
        console.warn(...args)
        break
      case 'error':
        console.error(...args)
        break
      default:
        console.log(...args)
        break
    }
  }
  const timestamp = new Date().toISOString()

  if (data === undefined) {
    method(`[${timestamp}] [${LEVEL_NAME[level]}] [${context}] ${message}`)
    return
  }

  method(`[${timestamp}] [${LEVEL_NAME[level]}] [${context}] ${message}`, data)
}

export function traceLog(context: string, message: string, data?: unknown): void {
  log(LogLevel.TRACE, context, message, data)
}

export function debugLog(context: string, message: string, data?: unknown): void {
  log(LogLevel.DEBUG, context, message, data)
}

export function infoLog(context: string, message: string, data?: unknown): void {
  log(LogLevel.INFO, context, message, data)
}

export function warnLog(context: string, message: string, data?: unknown): void {
  log(LogLevel.WARN, context, message, data)
}

export function errorLog(context: string, message: string, data?: unknown): void {
  log(LogLevel.ERROR, context, message, data)
}
===ENDFILE

===FILE: src/utils/formatters/__tests__/layout-merge-guards.test.ts
import { describe, it, expect } from 'vitest'
import { isPermissionMap, isLayoutOverrideRecord } from '../layout-merge-guards'

describe('isPermissionMap', () => {
  it('returns true for valid permission map', () => {
    expect(isPermissionMap({
      key1: { state: 'VISIBLE' },
      key2: { state: 'HIDDEN' }
    })).toBe(true)
  })

  it('returns false for null', () => {
    expect(isPermissionMap(null)).toBe(false)
  })

  it('returns false for undefined', () => {
    expect(isPermissionMap(undefined)).toBe(false)
  })

  it('returns false for array', () => {
    expect(isPermissionMap([{ state: 'VISIBLE' }])).toBe(false)
  })

  it('returns false for string', () => {
    expect(isPermissionMap('string')).toBe(false)
  })

  it('returns false for number', () => {
    expect(isPermissionMap(42)).toBe(false)
  })

  it('returns false when items are not objects', () => {
    expect(isPermissionMap({ key1: 'string' })).toBe(false)
  })

  it('returns false when items are null', () => {
    expect(isPermissionMap({ key1: null })).toBe(false)
  })

  it('returns false when items lack state property', () => {
    expect(isPermissionMap({ key1: { name: 'test' } })).toBe(false)
  })

  it('returns true for empty object', () => {
    expect(isPermissionMap({})).toBe(true)
  })
})

describe('isLayoutOverrideRecord', () => {
  it('returns true for valid override record', () => {
    expect(isLayoutOverrideRecord({
      key1: { action: 'SHOW' },
      key2: { action: 'HIDE' }
    })).toBe(true)
  })

  it('returns false for null', () => {
    expect(isLayoutOverrideRecord(null)).toBe(false)
  })

  it('returns false for undefined', () => {
    expect(isLayoutOverrideRecord(undefined)).toBe(false)
  })

  it('returns false for array', () => {
    expect(isLayoutOverrideRecord([{ action: 'SHOW' }])).toBe(false)
  })

  it('returns false when values are not objects', () => {
    expect(isLayoutOverrideRecord({ key1: 'string' })).toBe(false)
  })

  it('returns false when values are null', () => {
    expect(isLayoutOverrideRecord({ key1: null })).toBe(false)
  })

  it('returns false when values are arrays', () => {
    expect(isLayoutOverrideRecord({ key1: ['a', 'b'] })).toBe(false)
  })

  it('returns true for empty object', () => {
    expect(isLayoutOverrideRecord({})).toBe(true)
  })
})
===ENDFILE

===FILE: src/utils/formatters/__tests__/layout-merge-helpers.test.ts
import { describe, it, expect } from 'vitest'
import {
  toPermissionItem,
  sanitizeOverrideRecord,
  isPermissionMap,
  isLayoutOverrideRecord,
  mergeLayoutWithOverrides,
  mapAssignmentKeyToTemplateKey,
  toOverrides,
  DEFAULT_TEMPLATE
} from '../layout-merge-helpers'
import type { LayoutOverride, PermissionItem } from '../layout-merge-helpers'

describe('layout-merge-helpers', () => {
  describe('toPermissionItem', () => {
    it('returns fallback when override is undefined', () => {
      const fallback: PermissionItem = { state: 'enabled' }
      expect(toPermissionItem(undefined, fallback)).toEqual(fallback)
    })

    it('returns undefined when both override and fallback are undefined', () => {
      expect(toPermissionItem(undefined)).toBeUndefined()
    })

    it('converts enabled override to PermissionItem', () => {
      const result = toPermissionItem({ state: 'enabled' })
      expect(result?.state).toBe('enabled')
    })

    it('converts disabled override to PermissionItem', () => {
      const result = toPermissionItem({ state: 'disabled' })
      expect(result?.state).toBe('disabled')
    })

    it('defaults to enabled when state is not disabled', () => {
      const result = toPermissionItem({})
      expect(result?.state).toBe('enabled')
    })

    it('merges with fallback base', () => {
      const fallback: PermissionItem = { state: 'disabled', extra: 'data' }
      const result = toPermissionItem({ state: 'enabled' }, fallback)
      expect(result?.state).toBe('enabled')
    })
  })

  describe('sanitizeOverrideRecord', () => {
    it('returns empty object for null input', () => {
      expect(sanitizeOverrideRecord(null)).toEqual({})
    })

    it('returns empty object for array input', () => {
      expect(sanitizeOverrideRecord([])).toEqual({})
    })

    it('returns empty object for non-object input', () => {
      expect(sanitizeOverrideRecord('string')).toEqual({})
    })

    it('normalizes valid overrides', () => {
      const overrides = { chat: { state: 'enabled' as const }, kms: { state: 'disabled' as const } }
      const result = sanitizeOverrideRecord(overrides)
      expect(result.chat.state).toBe('enabled')
      expect(result.kms.state).toBe('disabled')
    })
  })

  describe('isPermissionMap', () => {
    it('returns false for null', () => {
      expect(isPermissionMap(null)).toBe(false)
    })

    it('returns false for arrays', () => {
      expect(isPermissionMap([])).toBe(false)
    })

    it('returns true for valid permission map', () => {
      expect(isPermissionMap({ chat: { state: 'enabled' } })).toBe(true)
    })

    it('returns false when item lacks state', () => {
      expect(isPermissionMap({ chat: { other: 'value' } })).toBe(false)
    })

    it('returns true for empty object', () => {
      expect(isPermissionMap({})).toBe(true)
    })
  })

  describe('isLayoutOverrideRecord', () => {
    it('returns false for null', () => {
      expect(isLayoutOverrideRecord(null)).toBe(false)
    })

    it('returns true for valid override record', () => {
      expect(isLayoutOverrideRecord({ chat: { state: 'enabled' } })).toBe(true)
    })

    it('returns false when entries are not objects', () => {
      expect(isLayoutOverrideRecord({ chat: 'string' })).toBe(false)
    })
  })

  describe('mergeLayoutWithOverrides', () => {
    const baseTemplate: Record<string, PermissionItem> = {
      chat: { state: 'enabled' },
      kms: { state: 'enabled' },
      customer: { state: 'enabled' }
    }

    it('returns base template when no overrides', () => {
      expect(mergeLayoutWithOverrides(baseTemplate, undefined)).toEqual(baseTemplate)
    })

    it('returns base template for empty overrides', () => {
      expect(mergeLayoutWithOverrides(baseTemplate, {})).toEqual(baseTemplate)
    })

    it('removes entries with disabled override', () => {
      const overrides: Record<string, LayoutOverride> = { chat: { state: 'disabled' } }
      const result = mergeLayoutWithOverrides(baseTemplate, overrides)
      expect(result.chat).toBeUndefined()
      expect(result.kms.state).toBe('enabled')
    })

    it('inherits from base for inherit override', () => {
      const overrides: Record<string, LayoutOverride> = { chat: { state: 'inherit' } }
      const result = mergeLayoutWithOverrides(baseTemplate, overrides)
      expect(result.chat).toEqual(baseTemplate.chat)
    })

    it('enables entries with enabled override', () => {
      const overrides: Record<string, LayoutOverride> = { newPanel: { state: 'enabled' } }
      const result = mergeLayoutWithOverrides(baseTemplate, overrides)
      expect(result.newPanel.state).toBe('enabled')
    })
  })

  describe('mapAssignmentKeyToTemplateKey', () => {
    it('maps columnAssignments to columns', () => {
      expect(mapAssignmentKeyToTemplateKey('columnAssignments')).toBe('columns')
    })

    it('maps widgetAssignments to widgets', () => {
      expect(mapAssignmentKeyToTemplateKey('widgetAssignments')).toBe('widgets')
    })

    it('maps featureAssignments to features', () => {
      expect(mapAssignmentKeyToTemplateKey('featureAssignments')).toBe('features')
    })

    it('maps settingsTabAssignments to settingsTabs', () => {
      expect(mapAssignmentKeyToTemplateKey('settingsTabAssignments')).toBe('settingsTabs')
    })

    it('maps settingsOptionAssignments to settingsOptions', () => {
      expect(mapAssignmentKeyToTemplateKey('settingsOptionAssignments')).toBe('settingsOptions')
    })

    it('maps microFrontendAssignments to microFrontends', () => {
      expect(mapAssignmentKeyToTemplateKey('microFrontendAssignments')).toBe('microFrontends')
    })
  })

  describe('toOverrides', () => {
    it('returns undefined for undefined input', () => {
      expect(toOverrides(undefined)).toBeUndefined()
    })

    it('converts enabledIndicator true to enabled', () => {
      const result = toOverrides({ chat: { enabledIndicator: true } })
      expect(result?.chat.state).toBe('enabled')
    })

    it('converts enabledIndicator false to disabled', () => {
      const result = toOverrides({ chat: { enabledIndicator: false } })
      expect(result?.chat.state).toBe('disabled')
    })
  })

  describe('DEFAULT_TEMPLATE', () => {
    it('creates template with the given role name', () => {
      const template = DEFAULT_TEMPLATE('voice_agent')
      expect(template.roleName).toBe('voice_agent')
      expect(template.displayName).toBe('voice_agent')
    })

    it('has empty permission sections', () => {
      const template = DEFAULT_TEMPLATE('test')
      expect(template.columns).toEqual({})
      expect(template.widgets).toEqual({})
      expect(template.features).toEqual({})
      expect(template.settingsTabs).toEqual({})
      expect(template.settingsOptions).toEqual({})
      expect(template.microFrontends).toEqual({})
    })
  })
})
===ENDFILE

===FILE: src/utils/formatters/__tests__/layout-merger.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'
import { computeAdGroupLayout } from '../layout-merger'

// Mock apiFetch
vi.mock('../../../services/core/api-client', () => ({
  apiFetch: vi.fn()
}))

import { apiFetch } from '../../../services/core/api-client'

const mockedApiFetch = vi.mocked(apiFetch)

function makeGroup(overrides: Record<string, unknown> = {}) {
  return {
    id: 'g1',
    groupIdentifier: 'CN=test-group',
    isActive: true,
    ...overrides
  }
}

function makeTemplate(overrides: Record<string, unknown> = {}) {
  return {
    roleName: 'voice_agent',
    displayName: 'Voice Agent',
    columns: {
      chat: { state: 'enabled' as const },
      kms: { state: 'enabled' as const },
      customer: { state: 'disabled' as const }
    },
    widgets: {},
    features: {},
    settingsTabs: {},
    settingsOptions: {},
    microFrontends: {},
    ...overrides
  }
}

describe('computeAdGroupLayout', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('returns the base template when group has no overrides', async () => {
    mockedApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: { roleName: 'voice_agent' } })
    } as Response)

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(makeGroup({ roleName: 'voice_agent' }), fetchTemplate)

    expect(result.roleName).toBe('voice_agent')
    expect(result.columns).toEqual(template.columns)
    expect(fetchTemplate).toHaveBeenCalledWith('voice_agent')
  })

  it('merges column assignment overrides with base template', async () => {
    mockedApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: {
          roleName: 'voice_agent',
          currentConfig: {
            permissionChanges: {
              columnPermissions: {
                customer: { enabledIndicator: true },
                chat: { enabledIndicator: false }
              }
            }
          }
        }
      })
    } as Response)

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(makeGroup({ roleName: 'voice_agent' }), fetchTemplate)

    // customer was disabled in template, overridden to enabled
    expect(result.columns.customer).toBeDefined()
    // chat was enabled in template, overridden to disabled
    expect(result.columns.chat).toBeUndefined()
    // kms not overridden, stays from template
    expect(result.columns.kms).toEqual({ state: 'enabled' })
  })

  it('falls back to group data when API lookup fails', async () => {
    mockedApiFetch.mockRejectedValue(new Error('Network error'))

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({
        roleName: 'voice_agent',
        columnAssignments: { kms: { state: 'disabled' } }
      }),
      fetchTemplate
    )

    expect(result.roleName).toBe('voice_agent')
    // kms should be removed since override state is 'disabled'
    expect(result.columns.kms).toBeUndefined()
  })

  it('falls back to group data when API returns non-ok response', async () => {
    mockedApiFetch.mockResolvedValue({
      ok: false,
      json: () => Promise.resolve({})
    } as Response)

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({ roleName: 'voice_agent' }),
      fetchTemplate
    )

    // Falls back to group (which has no assignments), so template columns are inherited
    expect(result.roleName).toBe('voice_agent')
    expect(fetchTemplate).toHaveBeenCalledWith('voice_agent')
  })

  it('uses default empty template when no fetchRoleTemplate is provided', async () => {
    mockedApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: { roleName: 'chat_agent' } })
    } as Response)

    const result = await computeAdGroupLayout(makeGroup({ roleName: 'chat_agent' }))

    expect(result.roleName).toBe('chat_agent')
    expect(result.columns).toEqual({})
  })

  it('handles inherit state by keeping base template value', async () => {
    mockedApiFetch.mockRejectedValue(new Error('skip'))

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({
        roleName: 'voice_agent',
        columnAssignments: { chat: { state: 'inherit' } }
      }),
      fetchTemplate
    )

    // inherit means keep the template value
    expect(result.columns.chat).toEqual({ state: 'enabled' })
  })

  it('handles enabled state by merging override properties', async () => {
    mockedApiFetch.mockRejectedValue(new Error('skip'))

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({
        roleName: 'voice_agent',
        columnAssignments: { customer: { state: 'enabled', customProp: true } }
      }),
      fetchTemplate
    )

    expect(result.columns.customer).toEqual({
      state: 'enabled',
      customProp: true
    })
  })

  it('uses logicalName as displayName when available', async () => {
    mockedApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: {
          roleName: 'voice_agent',
          logicalName: 'Custom Group Name'
        }
      })
    } as Response)

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({ roleName: 'voice_agent', logicalName: 'Custom Group Name' }),
      fetchTemplate
    )

    expect(result.displayName).toBe('Custom Group Name')
  })

  it('copies unprocessed template properties to merged layout', async () => {
    mockedApiFetch.mockRejectedValue(new Error('skip'))

    const template = makeTemplate({ customProp: 'value' })
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({ roleName: 'voice_agent' }),
      fetchTemplate
    )

    expect(result.customProp).toBe('value')
  })

  it('defaults to voice_agent when group has no roleName', async () => {
    mockedApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: {} })
    } as Response)

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    await computeAdGroupLayout(makeGroup(), fetchTemplate)

    expect(fetchTemplate).toHaveBeenCalledWith('voice_agent')
  })

  it('processes widget assignments alongside column assignments', async () => {
    mockedApiFetch.mockRejectedValue(new Error('skip'))

    const template = makeTemplate({
      widgets: { sentiment: { state: 'enabled' } }
    })
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({
        roleName: 'voice_agent',
        widgetAssignments: { sentiment: { state: 'disabled' } }
      }),
      fetchTemplate
    )

    expect(result.widgets.sentiment).toBeUndefined()
  })
})
===ENDFILE

===FILE: src/utils/formatters/layout-merge-converters.ts
/**
 * Layout Merge Converters - Functions for converting between PAPI and internal formats
 *
 * Re-exports from layout-merge-override-helpers for reduced per-file complexity.
 */

import type { RoleTemplate } from './layout-merge-types';

export {
  toPermissionItem,
  sanitizeOverrideRecord,
  mapAssignmentKeyToTemplateKey,
  toOverrides,
  mergeLayoutWithOverrides
} from './layout-merge-override-helpers';

/** Creates an empty role template with no permissions for the given role name. */
export const DEFAULT_TEMPLATE = (roleName: string): RoleTemplate => ({
  roleName,
  displayName: roleName,
  columns: {},
  widgets: {},
  features: {},
  settingsTabs: {},
  settingsOptions: {},
  microFrontends: {}
});
===ENDFILE

===FILE: src/utils/formatters/layout-merge-guards.ts
/**
 * Layout Merge Guards - Type guards for permission and override validation
 */

import type { PermissionItem, LayoutOverride } from './layout-merge-types';

/** Type guard that checks if a value is a valid Record<string, PermissionItem>. */
export function isPermissionMap(value: unknown): value is Record<string, PermissionItem> {
  if (typeof value !== 'object' || value === null || Array.isArray(value)) {
    return false;
  }

  return Object.values(value).every(item => {
    if (typeof item !== 'object' || item === null) {
      return false;
    }
    return 'state' in item && (item as PermissionItem).state !== undefined;
  });
}

/** Type guard that checks if a value is a valid Record<string, LayoutOverride>. */
export function isLayoutOverrideRecord(value: unknown): value is Record<string, LayoutOverride> {
  if (typeof value !== 'object' || value === null || Array.isArray(value)) {
    return false;
  }

  return Object.values(value).every(entry => typeof entry === 'object' && entry !== null && !Array.isArray(entry));
}
===ENDFILE

===FILE: src/utils/formatters/layout-merge-helpers.ts
/**
 * Layout Merge Helpers - Re-exports from split modules for backward compatibility
 */

// Types
export type { LayoutOverride, AdGroup, PermissionItem, RoleTemplate } from './layout-merge-types';

// Type guards
export { isPermissionMap, isLayoutOverrideRecord } from './layout-merge-guards';

// Converters and merge logic
export {
  toPermissionItem,
  sanitizeOverrideRecord,
  mapAssignmentKeyToTemplateKey,
  toOverrides,
  DEFAULT_TEMPLATE,
  mergeLayoutWithOverrides
} from './layout-merge-converters';
===ENDFILE

===FILE: src/utils/formatters/layout-merge-override-helpers.ts
/**
 * Layout Merge Override Helpers - Functions for normalizing and merging permission overrides.
 */

import type { PermissionItem, LayoutOverride } from './layout-merge-types';

/** Converts a layout override to a PermissionItem, merging with an optional fallback base. */
export function toPermissionItem(override: LayoutOverride | undefined, fallback?: PermissionItem): PermissionItem | undefined {
  if (!override) {
    return fallback;
  }

  const base = fallback ? { ...fallback } : {};
  const state = override.state === 'disabled' ? 'disabled' : 'enabled';

  return {
    ...base,
    ...override,
    state
  };
}

/** Normalizes a raw overrides object into a clean Record of PermissionItems, discarding invalid entries. */
export function sanitizeOverrideRecord(overrides: unknown, baseTemplate: Record<string, PermissionItem> = {}): Record<string, PermissionItem> {
  if (typeof overrides !== 'object' || overrides === null || Array.isArray(overrides)) {
    return {};
  }

  return Object.entries(overrides as Record<string, LayoutOverride | undefined>).reduce<Record<string, PermissionItem>>((acc, [key, value]) => {
    const normalized = toPermissionItem(value, baseTemplate[key]);
    if (normalized) {
      acc[key] = normalized;
    }
    return acc;
  }, {});
}

const ASSIGNMENT_TO_TEMPLATE_KEY: Record<string, string> = {
  column: 'columns',
  widget: 'widgets',
  feature: 'features',
  settingsTab: 'settingsTabs',
  settingsOption: 'settingsOptions',
  microFrontend: 'microFrontends'
}

/** Maps an AD group assignment key (e.g., 'columnAssignments') to its role template key ('columns'). */
export function mapAssignmentKeyToTemplateKey(assignmentKey: string): string {
  const stripped = assignmentKey.replace(/Assignments$/, '')
  return ASSIGNMENT_TO_TEMPLATE_KEY[stripped] ?? stripped
}

/** Converts PAPI permission objects (with enabledIndicator) to LayoutOverride records. */
export function toOverrides(permissions: Record<string, unknown> | undefined): Record<string, LayoutOverride> | undefined {
  if (!permissions) return undefined;
  return Object.fromEntries(
    Object.entries(permissions).map(([key, value]) => {
      const enabled = Boolean((value as { enabledIndicator?: boolean })?.enabledIndicator);
      return [key, { state: enabled ? 'enabled' : 'disabled' as const }];
    })
  );
}

/**
 * Merges AD group overrides into a base role template permission section.
 * Handles enabled/disabled/inherit override states.
 */
export function mergeLayoutWithOverrides(
  baseTemplate: Record<string, PermissionItem>,
  overrides: Record<string, LayoutOverride> | undefined
): Record<string, PermissionItem> {
  if (!overrides || Object.keys(overrides).length === 0) {
    return baseTemplate;
  }

  const merged: Record<string, PermissionItem> = { ...baseTemplate };

  Object.entries(overrides).forEach(([key, override]) => {
    const current = override || {};
    switch (current.state) {
      case 'disabled': {
        delete merged[key];
        break;
      }
      case 'inherit': {
        merged[key] = baseTemplate[key];
        break;
      }
      case 'enabled':
      default: {
        const normalized = toPermissionItem(current, baseTemplate[key]);
        if (normalized) {
          merged[key] = normalized;
        }
      }
    }
  });

  return merged;
}
===ENDFILE

===FILE: src/utils/formatters/layout-merge-types.ts
/**
 * Layout Merge Types - Type definitions for permission merging
 */

export interface LayoutOverride {
  state?: 'enabled' | 'disabled' | 'inherit';
  [key: string]: unknown;
}

export interface AdGroup {
  id: string;
  groupIdentifier: string;
  logicalName?: string;
  roleName?: string;
  market?: string;
  region?: string;
  businessUnit?: string;
  country?: string;
  isActive: boolean;
  columnAssignments?: Record<string, LayoutOverride>;
  widgetAssignments?: Record<string, LayoutOverride>;
  featureAssignments?: Record<string, LayoutOverride>;
  settingsTabAssignments?: Record<string, LayoutOverride>;
  settingsOptionAssignments?: Record<string, LayoutOverride>;
  microFrontendAssignments?: Record<string, LayoutOverride>;
  [key: string]: unknown;
}

export interface PermissionItem {
  state: 'enabled' | 'disabled';
  [key: string]: unknown;
}

export interface RoleTemplate {
  roleName: string;
  displayName: string;
  columns: Record<string, PermissionItem>;
  widgets: Record<string, PermissionItem>;
  features: Record<string, PermissionItem>;
  settingsTabs: Record<string, PermissionItem>;
  settingsOptions: Record<string, PermissionItem>;
  microFrontends: Record<string, PermissionItem>;
  [key: string]: unknown;
}
===ENDFILE

===FILE: src/utils/formatters/layout-merger-helpers.ts
/**
 * Layout Merger Helpers - Internal functions for fetching and merging AD group configs.
 */

import { apiFetch } from '../../services/core/api-client'
import {
  type AdGroup,
  type RoleTemplate,
  type LayoutOverride,
  toOverrides,
  isPermissionMap,
  isLayoutOverrideRecord,
  mergeLayoutWithOverrides,
  sanitizeOverrideRecord,
  mapAssignmentKeyToTemplateKey
} from './layout-merge-helpers'

export async function fetchCurrentGroupConfig(group: AdGroup): Promise<AdGroup> {
  try {
    const groupResponse = await apiFetch('/papi/v1/ad-groups/lookup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ data: { groupIdentifier: group.groupIdentifier } })
    });

    if (!groupResponse.ok) return group;

    const raw = await groupResponse.json() as { data?: Record<string, unknown> };
    const data = raw.data;
    if (!data) return group;

    const permissionChanges = (data.currentConfig as Record<string, unknown> | undefined)
      ?.permissionChanges as Record<string, unknown> | undefined;

    return {
      ...group,
      roleName: (data.roleName as string | undefined) ?? group.roleName,
      logicalName: (data.logicalName as string | undefined) ?? group.logicalName,
      columnAssignments: toOverrides(permissionChanges?.columnPermissions as Record<string, unknown> | undefined),
      widgetAssignments: toOverrides(permissionChanges?.widgetPermissions as Record<string, unknown> | undefined)
    };
  } catch {
    return group;
  }
}

function applyOverrideOnly(mergedLayout: RoleTemplate, templateKey: string, overrideRecord: Record<string, LayoutOverride>): void {
  const sanitized = sanitizeOverrideRecord(overrideRecord)
  if (Object.keys(sanitized).length > 0) mergedLayout[templateKey] = sanitized
}

export function mergeOneAssignment(
  mergedLayout: RoleTemplate,
  templateKey: string,
  baseValue: unknown,
  overrides: unknown
): void {
  const basePermissionMap = isPermissionMap(baseValue) ? baseValue : undefined
  const overrideRecord = isLayoutOverrideRecord(overrides) ? overrides as Record<string, LayoutOverride> : undefined

  if (basePermissionMap) { mergedLayout[templateKey] = mergeLayoutWithOverrides(basePermissionMap, overrideRecord); return }
  if (overrideRecord) applyOverrideOnly(mergedLayout, templateKey, overrideRecord)
}

export function mergeAssignments(mergedLayout: RoleTemplate, baseTemplate: RoleTemplate, groupConfig: AdGroup): void {
  const assignmentKeys = Object.keys(groupConfig).filter(key => key.endsWith('Assignments'))

  for (const assignmentKey of assignmentKeys) {
    const templateKey = mapAssignmentKeyToTemplateKey(assignmentKey)
    mergeOneAssignment(mergedLayout, templateKey, baseTemplate[templateKey], groupConfig[assignmentKey])
  }

  for (const key of Object.keys(baseTemplate)) {
    mergedLayout[key] ??= baseTemplate[key]
  }
}
===ENDFILE

===FILE: src/utils/formatters/layout-merger.ts
/**
 * Universal Layout Merger Utility
 * Automatically handles any layout structure without hardcoding specific properties
 * Zero maintenance required when new features are added
 */

import {
  type AdGroup,
  type RoleTemplate,
  DEFAULT_TEMPLATE
} from './layout-merge-helpers'
import { fetchCurrentGroupConfig, mergeAssignments } from './layout-merger-helpers'

/**
 * Computes the final layout for an AD group by merging role template with overrides
 * Automatically discovers and processes all assignment properties
 */
export async function computeAdGroupLayout(
  group: AdGroup,
  fetchRoleTemplate?: (roleName: string) => Promise<RoleTemplate>
): Promise<RoleTemplate> {
  const currentGroupConfig = await fetchCurrentGroupConfig(group);
  const fetcher = fetchRoleTemplate || (async (roleName: string) => DEFAULT_TEMPLATE(roleName));
  const baseTemplate = await fetcher(currentGroupConfig.roleName || 'voice_agent');

  const mergedLayout: RoleTemplate = {
    ...DEFAULT_TEMPLATE(currentGroupConfig.roleName || baseTemplate.roleName),
    displayName: currentGroupConfig.logicalName || baseTemplate.displayName
  };

  mergeAssignments(mergedLayout, baseTemplate, currentGroupConfig);
  return mergedLayout;
}
===ENDFILE

===FILE: src/vite-env.d.ts
/// <reference types="vite/client" />
===ENDFILE

===FILE: tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  important: '.admin-mfe-root',
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px'
      }
    },
    fontFamily: {
      sans: ['Segoe UI', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Helvetica Neue', 'Arial', 'sans-serif'],
      mono: ['Segoe UI Mono', 'Consolas', 'monospace'],
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
===ENDFILE

===FILE: tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "jsx": "react-jsx",
    "moduleResolution": "Bundler",
    "strict": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "declaration": true,
    "emitDeclarationOnly": false,
    "outDir": "dist",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}
===ENDFILE

===FILE: tsconfig.sonar.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "jsx": "react-jsx",
    "moduleResolution": "node16",
    "strict": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "noEmit": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.tsx"]
}
===ENDFILE

===FILE: vite.config.ts
import { defineConfig, loadEnv } from 'vite'
import react from '@vitejs/plugin-react'
import federation from '@originjs/vite-plugin-federation'
import path from 'path'

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), '')
  const papiProxyTarget = env.VITE_PAPI_PROXY_TARGET || 'http://localhost:8095'

  return {
    plugins: [
      react(),
      federation({
        name: 'adminMfeRemote',
        filename: 'remoteEntry.js',
        exposes: {
          './AdminMFE': './src/AdminMFE.tsx',
        },
        shared: {
          react: { singleton: true, eager: true, requiredVersion: '^19.2.0' },
          'react-dom': { singleton: true, eager: true, requiredVersion: '^19.2.0' },
          'react/jsx-runtime': { singleton: true, eager: true, requiredVersion: '^19.2.0' }
        }
      })
    ],
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
      },
    },
    server: {
      port: 5185,
      cors: true,
      host: true,
      proxy: {
        '/papi': {
          target: papiProxyTarget,
          changeOrigin: true,
          secure: false
        }
      }
    },
    preview: {
      port: 5185,
      cors: true,
      host: true,
      proxy: {
        '/papi': {
          target: papiProxyTarget,
          changeOrigin: true,
          secure: false
        }
      }
    },
    test: {
      environment: 'jsdom',
      globals: true,
      setupFiles: ['./src/test-setup.ts'],
      coverage: {
        provider: 'v8',
        reporter: ['text', 'lcov'],
        reportsDirectory: './coverage',
      },
    },
    build: {
      outDir: 'dist',
      target: 'esnext',
      minify: false,
      cssCodeSplit: false,
      modulePreload: false,
      rollupOptions: {
        external: [],
      },
    },
  }
})
===ENDFILE

