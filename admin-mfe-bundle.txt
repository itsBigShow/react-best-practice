# CCaaS Admin MFE - Source Bundle
# Generated: 2026-02-11 18:29:54
# Total files: 207
# Categories: 93 TypeScript, 99 React (TSX), 1 CSS, 5 Config, 4 Docs, 5 Other
# Note: node_modules and dist NOT included - run 'npm install && npm run build' after extraction
===FILE: ./.env.example
VITE_PAPI_PROXY_TARGET=http://localhost:8095
===ENDFILE
===FILE: ./.scannerwork/report-task.txt
projectKey=ccaas-admin-mfe
serverUrl=http://localhost:9000
serverVersion=26.2.0.119303
dashboardUrl=http://localhost:9000/dashboard?id=ccaas-admin-mfe
ceTaskId=33b132ab-bf4d-4a72-bd79-849eac176dc1
ceTaskUrl=http://localhost:9000/api/ce/task?id=33b132ab-bf4d-4a72-bd79-849eac176dc1
===ENDFILE
===FILE: ./CLAUDE.md
# CLAUDE.md - ccaas-admin-mfe

## Overview
Admin panel micro frontend (MFE). Port **5185**. Loaded into agent-frontend via Vite Module Federation. Provides administrative functionality for managing Role Templates, AD Groups, Pending Approvals, and System Notices. React 19 + Vite + TypeScript + Radix UI + Zustand.

## Commands
```bash
npm run dev                              # Dev server (no remoteEntry.js)
npm run build && npm run preview -- --port 5185  # REQUIRED for Module Federation
npm run type-check                       # TypeScript validation
```

## CRITICAL
**Must use `npm run preview`** (not dev) to serve `remoteEntry.js`. The agent-frontend loads this MFE at `http://localhost:5185/assets/remoteEntry.js`.

## Module Federation
- **Remote Name:** `adminMfeRemote`
- **Exposed Modules:**
  - `./AdminMFE` - Main admin panel component

## Props Interface
```typescript
interface AdminMFEProps {
  authToken: string           // JWT token for API calls
  permissions?: AdminPermissions // User's admin permissions
  onNavigate?: (path: string) => void // Navigation callback to host
  onError?: (error: ErrorInfo) => void // Error reporting to host
}
```

## Communication
Props-based communication with host app (preferred over postMessage for Module Federation MFEs).

## Admin Views
1. **Role Templates** - View and preview role configurations
2. **AD Groups** - Configure AD group permissions and apps
3. **Pending Approvals** - Maker/Checker approval workflow
4. **System Notices** - Create and manage system notices

## Rules
- Keep MFE self-contained; minimize shared dependencies
- Test by loading in agent-frontend, not standalone
- Follow Maker/Checker workflow for all configuration changes
- Use `adm-` Tailwind prefix for all CSS classes
===ENDFILE
===FILE: ./README.md
# CCaaS Admin MFE

Admin panel micro frontend for the CCaaS Platform. Provides administrative functionality for managing Role Templates, AD Groups, Pending Approvals, and System Notices.

## Quick Start

```bash
# Install dependencies
npm install

# Configure API proxy target for local development
cp .env.example .env

# Development (standalone testing)
npm run dev

# Build and preview (required for Module Federation)
npm run build && npm run preview
```

## Local API Proxy

Admin MFE calls PAPI endpoints under `/papi/*`. In standalone development, Vite must proxy these calls to the API gateway:

- `VITE_PAPI_PROXY_TARGET` (default in `.env.example`): `http://localhost:8095`

If proxying is not configured, `/papi/*` may return the app HTML (`<!DOCTYPE html>`) instead of JSON, causing empty states and parse errors.

## Module Federation

This MFE is loaded into the main agent-frontend via Vite Module Federation.

- **Port:** 5185
- **Remote Entry:** `http://localhost:5185/assets/remoteEntry.js`
- **Exposed Module:** `./AdminMFE`

## Features

- **Role Templates Management** - View and preview role configurations
- **AD Groups Configuration** - Configure AD group permissions and apps
- **Pending Approvals** - Maker/Checker approval workflow
- **System Notices** - Create and manage system notices

## Tech Stack

- React 19
- Vite 6
- TypeScript
- Tailwind CSS (with `adm-` prefix)
- Radix UI
- Zustand (state management)
- i18next (internationalization)

## Integration

To integrate with the host application, add to the federation config:

```typescript
// In host app vite.config.ts
remotes: {
  adminMfeRemote: 'http://localhost:5185/assets/remoteEntry.js'
}
```

Then import and use:

```tsx
const AdminMFE = React.lazy(() => import('adminMfeRemote/AdminMFE'))

<Suspense fallback={<Loading />}>
  <AdminMFE 
    authToken={token}
    language="en"
    permissions={userPermissions}
  />
</Suspense>
```

Detailed host integration guide:

- `docs/HOST_APP_INTEGRATION.md`
- `docs/API_INTEGRATION.md` (request/response contracts and data mapping)
===ENDFILE
===FILE: ./docs/API_INTEGRATION.md
# API Integration Guide (Request/Response)

This document describes how `ccaas-admin-mfe` integrates with backend APIs, including request/response envelopes and frontend mapping behavior.

## 1. Runtime Flow

1. UI hooks/components call service methods in `src/services/api/*`.
2. Services call `apiFetch` / `apiFetchJson` from `src/services/core/api-client.ts`.
3. Requests go to relative paths (`/papi/*`) and are routed by Vite proxy in standalone mode.
4. Responses are transformed to frontend types (for example: `marketCode -> market`, `enabledIndicator -> { state: 'enabled' | 'disabled' }`).

## 2. Auth and Proxy

Source: `src/services/core/api-client.ts`

- `getAuthToken()` is required unless `skipAuth` is set.
- Token is sent in two places:
  - Header: `AMToken`
  - Cookie: `AMToken=<token>; path=/; SameSite=Lax`
- `credentials: 'include'` is always enabled.
- `401` responses clear the stored token.

Standalone dev proxy:

- Env var: `VITE_PAPI_PROXY_TARGET`
- Default: `http://localhost:8095`
- If proxy is wrong, `/papi/*` can return HTML instead of JSON.

## 3. Common Envelope Patterns

Most endpoints use:

- Request body: `{ "data": { ... } }`
- Response body: `{ "data": { ... } }`

List endpoints often add pagination:

- `meta.pagination.offset`
- `meta.pagination.limit`
- `meta.pagination.total`
- `meta.pagination.hasMore`

## 4. Service-to-Endpoint Map

### 4.1 AD Group and Notice APIs

Source: `src/services/api/admin.service.ts`

#### `getAllAdGroups()`
- Method: `GET /papi/v1/ad-groups`
- Expected response:
```json
{
  "data": {
    "items": [
      {
        "groupIdentifier": "CN=Chat_Agent_AMER,OU=Agents,OU=Groups,DC=hsbc,DC=com",
        "logicalName": "Chat Agent AMER",
        "roleName": "chat_agent",
        "marketCode": "US",
        "regionCode": "AMER",
        "countryCode": "US",
        "businessUnitName": "Retail Banking",
        "activeIndicator": true,
        "userAccessCode": "MAKER",
        "pendingChangeIndicator": false,
        "versionNumber": 3,
        "userCountNumber": 15,
        "updatedAtDatetime": "2026-02-10T12:00:00Z",
        "currentConfig": {
          "permissionChanges": {
            "columnPermissions": {
              "chat": { "enabledIndicator": true }
            }
          }
        }
      }
    ]
  }
}
```
- Frontend mapping:
  - `marketCode -> market`
  - `regionCode -> region`
  - `countryCode -> country`
  - `activeIndicator -> isActive`
  - `userAccessCode -> accessLevel`
  - `userCountNumber -> userCount`
  - Permission blocks map to `{ state: 'enabled' | 'disabled' }`

#### `lookupAdGroup(groupIdentifier)`
- Method: `POST /papi/v1/ad-groups/lookup`
- Request:
```json
{
  "data": {
    "groupIdentifier": "CN=Chat_Agent_AMER,OU=Agents,OU=Groups,DC=hsbc,DC=com"
  }
}
```
- Expected response:
```json
{
  "data": {
    "groupIdentifier": "CN=Chat_Agent_AMER,OU=Agents,OU=Groups,DC=hsbc,DC=com",
    "logicalName": "Chat Agent AMER"
  }
}
```

#### `searchAdGroups(search, limit)`
- Method: `GET /papi/v1/ad-groups?search=<term>&limit=<n>`
- Expected response: same shape as `getAllAdGroups()`.

#### `updateAdGroup(groupIdentifier, updateData)`
- Method: `POST /papi/v1/ad-group-configs`
- Request:
```json
{
  "data": {
    "targetGroupIdentifier": "CN=Chat_Agent_AMER,OU=Agents,OU=Groups,DC=hsbc,DC=com",
    "proposedState": {
      "logicalName": "Chat Agent AMER Updated",
      "activeIndicator": true
    },
    "configVersionNumber": 3
  }
}
```
- Notes:
  - If `updateData.isActive` is provided, service converts it to `activeIndicator`.
  - `undefined` fields are removed from `proposedState`.

#### `copyAdGroupConfiguration(source, target, options)`
- Method: `POST /papi/v1/ad-group-configuration-copies`
- Request:
```json
{
  "data": {
    "sourceGroupIdentifier": "CN=Source,OU=Groups,DC=hsbc,DC=com",
    "targetGroupIdentifier": "CN=Target,OU=Groups,DC=hsbc,DC=com",
    "copyOptions": {
      "copyRoleAndPermissionsFlag": true,
      "copyBusinessInfoFlag": true,
      "copyApplicationsFlag": true,
      "overwriteExistingFlag": false,
      "copyWorkflowModeCode": "SUBMIT_FOR_APPROVAL",
      "functionMismatchPolicyCode": "FAIL_ON_MISMATCH"
    }
  }
}
```
- Expected response:
```json
{
  "data": {
    "copyResult": {
      "successFlag": true,
      "messageText": "Copy submitted",
      "workflowStatusCode": "SUBMITTED_FOR_APPROVAL",
      "pendingChangeIdentifier": "pc-123",
      "criticalIndicator": false,
      "levelTwoApprovalRequiredIndicator": false,
      "unavailableAppFunctionValues": []
    }
  }
}
```

#### Notices (`createNotice`, `listNotices`, `updateNotice`, `updateNoticeStatus`)
- Endpoints:
  - `POST /papi/v1/notices`
  - `GET /papi/v1/notices?statusCode=<STATUS>`
  - `PUT /papi/v1/notices/{noticeId}`
  - `PATCH /papi/v1/notices/{noticeId}/status`
- Request payload mapping (`AdminNoticeRequest -> PAPI`):
  - `title -> titleText`
  - `message -> messageText`
  - `severity -> severityValue`
  - `broadcastToAll -> broadcastToAllFlag`
  - `requiresAcknowledgement -> requiresAckFlag`
  - `targetRoles -> targetRoleValues`
  - `targetAdGroups -> targetAdGroupValues`
  - `startAt -> startAtDate`
  - `endAt -> endAtDate`
  - `createdBy -> createdByText`

Expected notice response item:
```json
{
  "identifier": "notice-001",
  "titleText": "Maintenance Notice",
  "messageText": "System update at 02:00 UTC",
  "severityValue": "INFO",
  "statusCode": "ACTIVE",
  "broadcastToAllFlag": true,
  "targetRoleValues": [],
  "targetAdGroupValues": [],
  "requiresAckFlag": false,
  "startAtDate": "2026-02-10T00:00:00Z",
  "endAtDate": "2026-02-11T00:00:00Z",
  "createdByText": "admin-user",
  "createdAtDate": "2026-02-10T00:00:00Z"
}
```

### 4.2 Approval Workflow APIs

Source: `src/services/api/admin-approval.service.ts`

#### `submitChange(groupId, request)`
- Method: `POST /papi/v1/pending-changes`
- Request sent by service:
```json
{
  "data": {
    "targetGroupIdentifier": "CN=Chat_Agent_AMER,OU=Agents,OU=Groups,DC=hsbc,DC=com",
    "changeDescription": "Configuration update",
    "proposedConfig": {
      "businessInfoChanges": {
        "logicalName": "Chat Agent AMER Updated"
      }
    },
    "changedFields": ["logicalName"],
    "configVersionNumber": 3
  }
}
```
- Response expected:
```json
{
  "data": {
    "pendingChange": {
      "changeIdentifier": "pc-001",
      "statusCode": "PENDING_LEVEL_ONE",
      "isCriticalIndicator": false
    }
  }
}
```
- Special errors:
  - `409 + BERR_20024` -> pending change already exists
  - `409 + BERR_20025` -> version conflict / stale config

#### `directSave(groupId, request)`
- Method: `POST /papi/v1/ad-group-configs`
- Request:
```json
{
  "data": {
    "targetGroupIdentifier": "CN=Chat_Agent_AMER,OU=Agents,OU=Groups,DC=hsbc,DC=com",
    "currentState": {},
    "proposedState": {}
  }
}
```
- Response:
```json
{
  "data": {
    "successIndicator": true,
    "messageText": "Saved"
  }
}
```

#### `listPendingChanges(filters)`
- Method: `GET /papi/v1/pending-changes`
- Query params used:
  - `statusCode` (mapped from first `filters.status` item if supported)
  - `offset`
  - `limit`
- Response:
```json
{
  "data": {
    "pendingChanges": [
      {
        "changeIdentifier": "pc-001",
        "targetGroupIdentifier": "CN=Group,DC=hsbc,DC=com",
        "targetGroupName": "Group",
        "changeType": "CONFIG_UPDATE",
        "currentConfig": {},
        "proposedConfig": {},
        "isCriticalIndicator": false,
        "statusCode": "PENDING_LEVEL_ONE",
        "createdByText": "maker.user",
        "createdAtDatetime": "2026-02-10T10:00:00Z"
      }
    ]
  },
  "meta": {
    "pagination": {
      "offset": 0,
      "limit": 25,
      "total": 1,
      "hasMore": false
    }
  }
}
```
- Service also:
  - unwraps nested config wrappers (`businessInfoChanges`, `permissionChanges`, etc.)
  - computes `appsChanges` and `functionsChanges` when not provided top-level

#### `getPendingChange(changeId)`
- Method: `GET /papi/v1/pending-changes/{changeId}`
- Response:
```json
{
  "data": {
    "pendingChange": {
      "changeIdentifier": "pc-001",
      "targetGroupIdentifier": "CN=Group,DC=hsbc,DC=com",
      "statusCode": "PENDING_LEVEL_ONE"
    }
  }
}
```

#### `approveChange(changeId, { comment })`
- Method: `POST /papi/v1/change-approvals`
- Request:
```json
{
  "data": {
    "changeIdentifier": "pc-001",
    "commentText": "Looks good"
  }
}
```
- Response:
```json
{
  "data": {
    "approval": {
      "changeIdentifier": "pc-001",
      "statusCode": "APPROVED",
      "messageText": "Approved",
      "approvedAtDatetime": "2026-02-10T10:05:00Z"
    }
  }
}
```

#### `rejectChange(changeId, { rejectionReason })`
- Method: `POST /papi/v1/change-rejections`
- Request:
```json
{
  "data": {
    "changeIdentifier": "pc-001",
    "reasonText": "Insufficient details"
  }
}
```
- Response:
```json
{
  "data": {
    "rejection": {
      "changeIdentifier": "pc-001",
      "statusCode": "REJECTED",
      "messageText": "Rejected",
      "rejectedAtDatetime": "2026-02-10T10:07:00Z"
    }
  }
}
```

#### `cancelChange(changeId)`
- Method: `DELETE /papi/v1/pending-changes/{changeId}`
- Response:
```json
{
  "data": {
    "statusCode": "CANCELLED",
    "messageText": "Pending change cancelled"
  }
}
```

#### `getMyActivity(page, size, timeRange)`
- Method: `GET /papi/v1/my-activity?offset=&limit=&timeRange=`
- Response:
```json
{
  "data": {
    "activityValues": [
      {
        "changeIdentifier": "pc-001",
        "actionCode": "L1_APPROVE",
        "changeType": "CONFIG_UPDATE",
        "targetGroupIdentifier": "CN=Group,DC=hsbc,DC=com",
        "targetGroupName": "Group",
        "isCriticalIndicator": false,
        "createdAtDatetime": "2026-02-10T10:05:00Z",
        "performedByRoleCode": "CHECKER",
        "completionReasonText": "Approved"
      }
    ]
  },
  "meta": {
    "pagination": {
      "offset": 0,
      "limit": 25,
      "total": 1,
      "hasMore": false
    }
  }
}
```

### 4.3 Reference Data APIs

Source: `src/services/api/reference-data.service.ts`

- `GET /papi/v1/regions` -> `{ data: { regions: [...] } }`
- `GET /papi/v1/business-units` -> `{ data: { businessUnits: [...] } }`
- `GET /papi/v1/countries` -> `{ data: { countries: [...] } }`
- `GET /papi/v1/regions-countries/{regionCode}` -> `{ data: { countries: [...] } }`
- `GET /papi/v1/markets` -> `{ data: { markets: [...] } }`
- `GET /papi/v1/regions-markets/{regionCode}` -> `{ data: { markets: [...] } }`

Normalization rule:

- Service accepts both canonical and alternate backend field names:
  - `displayOrder` or `displayOrderNumber`
  - `isActive` or `isActiveFlag`

### 4.4 Role Template APIs

Source: `src/services/api/role-template.service.ts`

#### List templates
- `GET /papi/v1/role-layout-templates`
- Response:
```json
{
  "data": {
    "roleLayoutTemplates": [
      {
        "roleNameCode": "voice_agent",
        "roleDisplayName": "Voice Agent"
      }
    ]
  }
}
```

#### Template by role
- `GET /papi/v1/role-layout-templates/{roleNameCode}`
- Response:
```json
{
  "data": {
    "roleNameCode": "voice_agent",
    "roleDisplayName": "Voice Agent",
    "columns": {
      "chat": { "stateText": "disabled" }
    },
    "widgets": {
      "timer": { "stateText": "enabled" }
    },
    "features": {},
    "settingsTabs": {},
    "settingsOptions": {},
    "microFrontends": {}
  }
}
```

Frontend mapping in `use-ad-group-form`:

- `stateText` is normalized to lowercase.
- Only `'enabled'` maps to enabled.
- Any other value maps to disabled.

## 5. Error Handling Strategy

### `apiFetchJson`
- Throws on non-2xx.
- Error message comes from raw response text when available.

### `handleApiResponse`
Source: `src/utils/api/response-handler.ts`

- Throws on non-2xx.
- Detects HTML/non-JSON responses and throws a proxy-specific hint:
  - "Expected JSON ... Check Vite /papi proxy configuration (VITE_PAPI_PROXY_TARGET)."

### Approval-specific errors
Source: `src/services/api/admin-approval.service.ts`

- Submit conflict handling:
  - `BERR_20024`: existing pending change
  - `BERR_20025`: concurrent update/version mismatch
- Approve `403` with self-approval text is normalized to a clear message.

### 4.5 Embedded Apps APIs

Source: `src/hooks/api/use-embedded-apps-api.ts`

#### `fetchAllEmbeddedApps()`
- Method: `GET /papi/v1/embedded-apps`
- Response:
```json
{
  "data": {
    "embeddedApps": [
      {
        "appKey": "money-transfer",
        "titleText": "Money Transfer",
        "description": "Transfer funds between accounts",
        "categoryText": "Banking",
        "baseUrlText": "https://app.example.com/money-transfer",
        "loadingStrategyText": "lazy",
        "primaryKeywordValues": ["transfer", "send"],
        "secondaryKeywordValues": ["wire", "payment"],
        "mfeConfig": {},
        "regionalUrls": {},
        "isActiveFlag": true,
        "appFunctionValues": ["quick-transfer", "view-transfers"],
        "functionDefinitionMap": {
          "quick-transfer": {
            "displayName": "Quick Transfer",
            "description": "Transfer within same bank",
            "categoryText": "Transfers",
            "searchKeywordValues": ["quick", "fast"],
            "requiresApprovalFlag": false,
            "mfeConfig": {}
          }
        },
        "adGroupAccess": {
          "CN=Group,DC=hsbc,DC=com": {
            "functionValues": ["quick-transfer"],
            "lastModifiedByText": "600021",
            "marketCode": "HK"
          }
        }
      }
    ]
  }
}
```
- Frontend mapping (`transformPapiApp`):
  - `appKey -> appIdentifier`
  - `description -> descriptionText`
  - `categoryText -> categoryName`
  - `baseUrlText -> baseUrlAddress`
  - `loadingStrategyText -> loadingStrategyCode`
  - `primaryKeywordValues -> primaryKeywordsText`
  - `secondaryKeywordValues -> secondaryKeywordsText`
  - `mfeConfig -> mfeConfigObject`
  - `regionalUrls -> regionalUrlsObject`
  - `isActiveFlag -> isActiveIndicator`
  - `functionDefinitionMap -> functionDefinitionsObject`
  - `adGroupAccess -> adGroupAccessObject`
  - `appFunctionValues -> appFunctionKeys`
- Nested `adGroupAccess` entries use `functionValues` (not `functionKeys`).

#### `fetchAssignedApps(groupIdentifier)`
- Method: `POST /papi/v1/embedded-apps-ad-groups`
- Request:
```json
{
  "data": {
    "groupIdentifier": "CN=Group,DC=hsbc,DC=com"
  }
}
```
- Response: same shape as `fetchAllEmbeddedApps`, filtered to assigned apps.
- Returns `[]` on `404` (no apps assigned yet).

#### `saveAppAssignment(appKey, ...)`
- Method: `PUT /papi/v1/embedded-apps-ad-groups/{appKey}`
- Request:
```json
{
  "data": {
    "groupIdentifier": "CN=Group,DC=hsbc,DC=com",
    "functionValues": ["quick-transfer", "view-transfers"],
    "defaultFunctionText": "quick-transfer"
  }
}
```
- Empty `functionValues` array removes the app assignment.

### 4.6 Pending Change Proposed State Formats

Two formats exist for app changes stored in `proposedConfig`:

**Copy/direct-save format** (from `POST /papi/v1/ad-group-configuration-copies`):
```json
{
  "applications": [
    {
      "appKey": "money-transfer",
      "assignedIndicator": true,
      "functionKeys": ["quick-transfer", "view-transfers"]
    }
  ]
}
```

**MFE approval format** (from `POST /papi/v1/pending-changes` via admin MFE):
```json
{
  "applicationChanges": [
    { "appCode": "money-transfer", "proposedStateIndicator": true, "currentStateIndicator": false }
  ],
  "appFunctionChanges": [
    { "appCode": "money-transfer", "functionCode": "quick-transfer", "enabledIndicator": true }
  ]
}
```

The `what-changed-diff.tsx` component handles both: copy format via `formatApplicationsArray()` (reads `functionKeys`), MFE format via structured `appsChanges`/`functionsChanges` props.

## 6. Where Save Actually Routes

Source: `src/hooks/admin/use-config-save.ts`

- If user is allowed direct save and selects direct save:
  - calls `adminApprovalService.directSave(...)`
- Otherwise:
  - calls `adminApprovalService.submitChange(...)`
- Payload includes:
  - business info deltas
  - permission deltas
  - app/function deltas (when staged app changes exist)
===ENDFILE
===FILE: ./docs/HOST_APP_INTEGRATION.md
# Admin MFE Host App Integration

This document explains how a host application should integrate `ccaas-admin-mfe` using Module Federation.

## Remote Contract

Admin MFE exposes:

- Remote name: `adminMfeRemote`
- Exposed module: `./AdminMFE`
- Entry file (local preview): `http://localhost:5185/assets/remoteEntry.js`

Source:

- `vite.config.ts`

## Props Required By AdminMFE

`AdminMFE` accepts:

- `authToken: string` (required)
- `language?: 'en' | 'zh-CN' | 'zh-HK' | 'zh-TW' | 'ar' | 'es' | 'fr' | 'fil' | 'hi' | 'pl' | 'ms'`
- `permissions?: AdminPermissions`
- `currentRole?: string`
- `onNavigate?: (path: string) => void`
- `onError?: (error: { code: string; message: string; context?: Record<string, unknown> }) => void`

Source:

- `src/types/index.ts`

Important behavior:

- If `authToken` is empty, Admin MFE emits `MISSING_AUTH_TOKEN` through `onError`.
- Unsupported `language` emits `INVALID_LANGUAGE`.
- If `permissions` is not passed, Admin MFE defaults all permissions to `false` (no access).

Source:

- `src/AdminMFE.tsx`

## Host Federation Configuration

Example host config:

```ts
// host vite config
federation({
  remotes: {
    adminMfeRemote: 'http://localhost:5185/assets/remoteEntry.js'
  }
})
```

## Host Usage Example

```tsx
import React, { Suspense } from 'react'

const AdminMFE = React.lazy(() => import('adminMfeRemote/AdminMFE'))

export function AdminPage() {
  return (
    <Suspense fallback={<div>Loading admin panel...</div>}>
      <AdminMFE
        authToken={token}
        language="en"
        currentRole="admin"
        permissions={adminPermissions}
        onError={(error) => {
          console.error('[AdminMFE]', error.code, error.message, error.context)
        }}
      />
    </Suspense>
  )
}
```

## API / Auth Expectations

Admin MFE calls backend endpoints under `/papi/*` (relative path).

- It sets `AMToken` header on API calls.
- It also writes `AMToken` cookie for proxy-based routing.

Host/proxy must route `/papi/*` correctly (typically to entitlement PAPI/proxy).

Source:

- `src/services/core/api-client.ts`

## Local Integration Checklist

1. Start admin MFE preview (required for `remoteEntry.js`):
   - `npm run build && npm run preview`
2. Confirm remote entry is reachable:
   - `http://localhost:5185/assets/remoteEntry.js`
3. Ensure host remotes config includes `adminMfeRemote`.
4. Ensure host passes a non-empty `authToken`.
5. Ensure host routes `/papi/*` to a live backend.
6. Open admin surface and confirm no federation or auth errors.

## Troubleshooting

- `Failed to fetch dynamically imported module`:
  - Wrong remote URL, remote not running, or CORS/proxy issue.
- `MISSING_AUTH_TOKEN`:
  - Host passed empty/undefined token.
- Admin loads but shows no views:
  - `permissions` missing or all false.
- `/papi/*` returns HTML/404:
  - Host proxy not forwarding to backend API.
===ENDFILE
===FILE: ./index.html
<!DOCTYPE html>
<html lang="en" class="adm-h-full">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Admin MFE - CCaaS Platform</title>
  </head>
  <body class="adm-h-full adm-m-0">
    <div id="root" class="adm-h-full"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
===ENDFILE
===FILE: ./package-lock.json
{
  "name": "@ccaas/ccaas-admin-mfe",
  "version": "0.1.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "@ccaas/ccaas-admin-mfe",
      "version": "0.1.0",
      "dependencies": {
        "@radix-ui/react-accordion": "^1.2.12",
        "@radix-ui/react-alert-dialog": "^1.1.15",
        "@radix-ui/react-checkbox": "^1.3.3",
        "@radix-ui/react-collapsible": "^1.1.12",
        "@radix-ui/react-dialog": "^1.1.15",
        "@radix-ui/react-dropdown-menu": "^2.1.15",
        "@radix-ui/react-icons": "^1.3.2",
        "@radix-ui/react-label": "^2.1.7",
        "@radix-ui/react-popover": "^1.1.9",
        "@radix-ui/react-scroll-area": "^1.1.0",
        "@radix-ui/react-select": "^2.2.6",
        "@radix-ui/react-separator": "^1.1.7",
        "@radix-ui/react-slot": "^1.2.3",
        "@radix-ui/react-switch": "^1.2.5",
        "@radix-ui/react-tabs": "^1.1.12",
        "@radix-ui/react-toggle": "^1.1.10",
        "@radix-ui/react-toggle-group": "^1.1.11",
        "@radix-ui/react-tooltip": "^1.1.8",
        "@tanstack/react-query": "^5.66.7",
        "class-variance-authority": "^0.7.1",
        "clsx": "^2.1.1",
        "date-fns": "^4.1.0",
        "lucide-react": "^0.542.0",
        "tailwind-merge": "^3.3.1",
        "zustand": "^5.0.8"
      },
      "devDependencies": {
        "@originjs/vite-plugin-federation": "^1.4.1",
        "@testing-library/jest-dom": "^6.9.1",
        "@testing-library/react": "^16.3.2",
        "@testing-library/user-event": "^14.6.1",
        "@types/react": "^19.1.12",
        "@types/react-dom": "^19.1.9",
        "@vitejs/plugin-react": "^4.6.0",
        "@vitest/coverage-v8": "^3.2.4",
        "autoprefixer": "^10.4.14",
        "jsdom": "^28.0.0",
        "postcss": "^8.4.24",
        "react": "19.2.0",
        "react-dom": "19.2.0",
        "tailwindcss": "^3.3.0",
        "tailwindcss-animate": "^1.0.7",
        "typescript": "^5.9.2",
        "vite": "^6.0.0",
        "vitest": "^3.2.4"
      },
      "optionalDependencies": {
        "@rollup/rollup-linux-x64-gnu": "^4.50.0"
      },
      "peerDependencies": {
        "react": "^19.2.0",
        "react-dom": "^19.2.0"
      }
    },
    "node_modules/@acemir/cssom": {
      "version": "0.9.31",
      "resolved": "https://registry.npmjs.org/@acemir/cssom/-/cssom-0.9.31.tgz",
      "integrity": "sha512-ZnR3GSaH+/vJ0YlHau21FjfLYjMpYVIzTD8M8vIEQvIGxeOXyXdzCI140rrCY862p/C/BbzWsjc1dgnM9mkoTA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@adobe/css-tools": {
      "version": "4.4.4",
      "resolved": "https://registry.npmjs.org/@adobe/css-tools/-/css-tools-4.4.4.tgz",
      "integrity": "sha512-Elp+iwUx5rN5+Y8xLt5/GRoG20WGoDCQ/1Fb+1LiGtvwbDavuSk0jhD/eZdckHAuzcDzccnkv+rEjyWfRx18gg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@alloc/quick-lru": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@alloc/quick-lru/-/quick-lru-5.2.0.tgz",
      "integrity": "sha512-UrcABB+4bUrFABwbluTIBErXwvbsU/V7TZWfmbgJfbkwiBuziS9gxdODUyuiecfdGQ85jglMW6juS3+z5TsKLw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@ampproject/remapping": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@asamuzakjp/css-color": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/@asamuzakjp/css-color/-/css-color-4.1.2.tgz",
      "integrity": "sha512-NfBUvBaYgKIuq6E/RBLY1m0IohzNHAYyaJGuTK79Z23uNwmz2jl1mPsC5ZxCCxylinKhT1Amn5oNTlx1wN8cQg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@csstools/css-calc": "^3.0.0",
        "@csstools/css-color-parser": "^4.0.1",
        "@csstools/css-parser-algorithms": "^4.0.0",
        "@csstools/css-tokenizer": "^4.0.0",
        "lru-cache": "^11.2.5"
      }
    },
    "node_modules/@asamuzakjp/css-color/node_modules/lru-cache": {
      "version": "11.2.5",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-11.2.5.tgz",
      "integrity": "sha512-vFrFJkWtJvJnD5hg+hJvVE8Lh/TcMzKnTgCWmtBipwI5yLX/iX+5UB2tfuyODF5E7k9xEzMdYgGqaSb1c0c5Yw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "engines": {
        "node": "20 || >=22"
      }
    },
    "node_modules/@asamuzakjp/dom-selector": {
      "version": "6.7.8",
      "resolved": "https://registry.npmjs.org/@asamuzakjp/dom-selector/-/dom-selector-6.7.8.tgz",
      "integrity": "sha512-stisC1nULNc9oH5lakAj8MH88ZxeGxzyWNDfbdCxvJSJIvDsHNZqYvscGTgy/ysgXWLJPt6K/4t0/GjvtKcFJQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@asamuzakjp/nwsapi": "^2.3.9",
        "bidi-js": "^1.0.3",
        "css-tree": "^3.1.0",
        "is-potential-custom-element-name": "^1.0.1",
        "lru-cache": "^11.2.5"
      }
    },
    "node_modules/@asamuzakjp/dom-selector/node_modules/lru-cache": {
      "version": "11.2.5",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-11.2.5.tgz",
      "integrity": "sha512-vFrFJkWtJvJnD5hg+hJvVE8Lh/TcMzKnTgCWmtBipwI5yLX/iX+5UB2tfuyODF5E7k9xEzMdYgGqaSb1c0c5Yw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "engines": {
        "node": "20 || >=22"
      }
    },
    "node_modules/@asamuzakjp/nwsapi": {
      "version": "2.3.9",
      "resolved": "https://registry.npmjs.org/@asamuzakjp/nwsapi/-/nwsapi-2.3.9.tgz",
      "integrity": "sha512-n8GuYSrI9bF7FFZ/SjhwevlHc8xaVlb/7HmHelnc/PZXBD2ZR49NnN9sMMuDdEGPeeRQ5d0hqlSlEpgCX3Wl0Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@babel/code-frame": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.29.0.tgz",
      "integrity": "sha512-9NhCeYjq9+3uxgdtp20LSiJXJvN0FeCtNGpJxuMFZ1Kv3cWUNb6DOhJwUvcVCzKGR66cw4njwM6hrJLqgOwbcw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.28.5",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.29.0.tgz",
      "integrity": "sha512-T1NCJqT/j9+cn8fvkt7jtwbLBfLC/1y1c7NtCeXFRgzGTsafi68MRv8yzkYSapBnFA6L3U2VSc02ciDzoAJhJg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.29.0.tgz",
      "integrity": "sha512-CGOfOJqWjg2qW/Mb6zNsDm+u5vFQ8DxXfbM09z69p5Z6+mE1ikP2jUXw+j42Pf1XTYED2Rni5f95npYeuwMDQA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.29.0",
        "@babel/generator": "^7.29.0",
        "@babel/helper-compilation-targets": "^7.28.6",
        "@babel/helper-module-transforms": "^7.28.6",
        "@babel/helpers": "^7.28.6",
        "@babel/parser": "^7.29.0",
        "@babel/template": "^7.28.6",
        "@babel/traverse": "^7.29.0",
        "@babel/types": "^7.29.0",
        "@jridgewell/remapping": "^2.3.5",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.29.0.tgz",
      "integrity": "sha512-vSH118/wwM/pLR38g/Sgk05sNtro6TlTJKuiMXDaZqPUfjTFcudpCOt00IhOfj+1BFAX+UFAlzCU+6WXr3GLFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.29.0",
        "@babel/types": "^7.29.0",
        "@jridgewell/gen-mapping": "^0.3.12",
        "@jridgewell/trace-mapping": "^0.3.28",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.28.6.tgz",
      "integrity": "sha512-JYtls3hqi15fcx5GaSNL7SCTJ2MNmjrkHXg4FSpOA/grxK8KwyZ5bubHsCq8FXCkua6xhuaaBit+3b7+VZRfcA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.28.6",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-globals": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.28.6.tgz",
      "integrity": "sha512-l5XkZK7r7wa9LucGw9LwZyyCUscb4x37JWTPz7swwFE/0FMQAGpiWUZn8u9DzkSBWEcK25jmvubfpw2dnAMdbw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.28.6.tgz",
      "integrity": "sha512-67oXFAYr2cDLDVGLXTEABjdBJZ6drElUSI7WKp70NrpyISso3plG9SAGEF6y7zbha/wOzUByWWTJvEDVNIUGcA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.28.6",
        "@babel/helper-validator-identifier": "^7.28.5",
        "@babel/traverse": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.28.6.tgz",
      "integrity": "sha512-S9gzZ/bz83GRysI7gAD4wPT/AI3uCnY+9xn+Mx/KPs2JwHJIz1W8PZkg2cqyt3RNOBM8ejcXhV6y8Og7ly/Dug==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.6.tgz",
      "integrity": "sha512-xOBvwq86HHdB7WUDTfKfT/Vuxh7gElQ+Sfti2Cy6yIWNW05P8iUslOVcZ4/sKbE+/jQaukQAdz/gf3724kYdqw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.29.0.tgz",
      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.29.0"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-self": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.27.1.tgz",
      "integrity": "sha512-6UzkCs+ejGdZ5mFFC/OCUrv028ab2fp1znZmCZjAOBKiBK2jXD1O+BPSfX8X2qjJ75fZBMSnQn3Rq2mrBJK2mw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-source": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.27.1.tgz",
      "integrity": "sha512-zbwoTsBruTeKB9hSq73ha66iFeJHuaFkUbwvqElnygoNbj/jHRsSeokowZFN3CZ64IvEqcmmkVe89OPXc7ldAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.28.6.tgz",
      "integrity": "sha512-05WQkdpL9COIMz4LjTxGpPNCdlpyimKppYNoJ5Di5EUObifl8t4tuLuUBBZEpoLYOmfvIWrsp9fCl0HoPRVTdA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.28.6",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.28.6.tgz",
      "integrity": "sha512-YA6Ma2KsCdGb+WC6UpBVFJGXL58MDA6oyONbjyF/+5sBgxY/dwkhLogbMT2GXXyU84/IhRw/2D1Os1B/giz+BQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.28.6",
        "@babel/parser": "^7.28.6",
        "@babel/types": "^7.28.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.29.0.tgz",
      "integrity": "sha512-4HPiQr0X7+waHfyXPZpWPfWL/J7dcN1mx9gL6WdQVMbPnF3+ZhSMs8tCxN7oHddJE9fhNE7+lxdnlyemKfJRuA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.29.0",
        "@babel/generator": "^7.29.0",
        "@babel/helper-globals": "^7.28.0",
        "@babel/parser": "^7.29.0",
        "@babel/template": "^7.28.6",
        "@babel/types": "^7.29.0",
        "debug": "^4.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.29.0",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.29.0.tgz",
      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@bcoe/v8-coverage": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-1.0.2.tgz",
      "integrity": "sha512-6zABk/ECA/QYSCQ1NGiVwwbQerUCZ+TQbp64Q3AgmfNvurHH0j8TtXa1qbShXA6qqkpAj4V5W8pP6mLe1mcMqA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@csstools/color-helpers": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/@csstools/color-helpers/-/color-helpers-6.0.1.tgz",
      "integrity": "sha512-NmXRccUJMk2AWA5A7e5a//3bCIMyOu2hAtdRYrhPPHjDxINuCwX1w6rnIZ4xjLcp0ayv6h8Pc3X0eJUGiAAXHQ==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT-0",
      "engines": {
        "node": ">=20.19.0"
      }
    },
    "node_modules/@csstools/css-calc": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@csstools/css-calc/-/css-calc-3.0.0.tgz",
      "integrity": "sha512-q4d82GTl8BIlh/dTnVsWmxnbWJeb3kiU8eUH71UxlxnS+WIaALmtzTL8gR15PkYOexMQYVk0CO4qIG93C1IvPA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=20.19.0"
      },
      "peerDependencies": {
        "@csstools/css-parser-algorithms": "^4.0.0",
        "@csstools/css-tokenizer": "^4.0.0"
      }
    },
    "node_modules/@csstools/css-color-parser": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/@csstools/css-color-parser/-/css-color-parser-4.0.1.tgz",
      "integrity": "sha512-vYwO15eRBEkeF6xjAno/KQ61HacNhfQuuU/eGwH67DplL0zD5ZixUa563phQvUelA07yDczIXdtmYojCphKJcw==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "@csstools/color-helpers": "^6.0.1",
        "@csstools/css-calc": "^3.0.0"
      },
      "engines": {
        "node": ">=20.19.0"
      },
      "peerDependencies": {
        "@csstools/css-parser-algorithms": "^4.0.0",
        "@csstools/css-tokenizer": "^4.0.0"
      }
    },
    "node_modules/@csstools/css-parser-algorithms": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/@csstools/css-parser-algorithms/-/css-parser-algorithms-4.0.0.tgz",
      "integrity": "sha512-+B87qS7fIG3L5h3qwJ/IFbjoVoOe/bpOdh9hAjXbvx0o8ImEmUsGXN0inFOnk2ChCFgqkkGFQ+TpM5rbhkKe4w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=20.19.0"
      },
      "peerDependencies": {
        "@csstools/css-tokenizer": "^4.0.0"
      }
    },
    "node_modules/@csstools/css-syntax-patches-for-csstree": {
      "version": "1.0.27",
      "resolved": "https://registry.npmjs.org/@csstools/css-syntax-patches-for-csstree/-/css-syntax-patches-for-csstree-1.0.27.tgz",
      "integrity": "sha512-sxP33Jwg1bviSUXAV43cVYdmjt2TLnLXNqCWl9xmxHawWVjGz/kEbdkr7F9pxJNBN2Mh+dq0crgItbW6tQvyow==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT-0"
    },
    "node_modules/@csstools/css-tokenizer": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/@csstools/css-tokenizer/-/css-tokenizer-4.0.0.tgz",
      "integrity": "sha512-QxULHAm7cNu72w97JUNCBFODFaXpbDg+dP8b/oWFAZ2MTRppA3U00Y2L1HqaS4J6yBqxwa/Y3nMBaxVKbB/NsA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=20.19.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.25.12.tgz",
      "integrity": "sha512-Hhmwd6CInZ3dwpuGTF8fJG6yoWmsToE+vYgD4nytZVxcu1ulHpUQRAB1UJ8+N1Am3Mz4+xOByoQoSZf4D+CpkA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.25.12.tgz",
      "integrity": "sha512-VJ+sKvNA/GE7Ccacc9Cha7bpS8nyzVv0jdVgwNDaR4gDMC/2TTRc33Ip8qrNYUcpkOHUT5OZ0bUcNNVZQ9RLlg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.25.12.tgz",
      "integrity": "sha512-6AAmLG7zwD1Z159jCKPvAxZd4y/VTO0VkprYy+3N2FtJ8+BQWFXU+OxARIwA46c5tdD9SsKGZ/1ocqBS/gAKHg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.25.12.tgz",
      "integrity": "sha512-5jbb+2hhDHx5phYR2By8GTWEzn6I9UqR11Kwf22iKbNpYrsmRB18aX/9ivc5cabcUiAT/wM+YIZ6SG9QO6a8kg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.12.tgz",
      "integrity": "sha512-N3zl+lxHCifgIlcMUP5016ESkeQjLj/959RxxNYIthIg+CQHInujFuXeWbWMgnTo4cp5XVHqFPmpyu9J65C1Yg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.25.12.tgz",
      "integrity": "sha512-HQ9ka4Kx21qHXwtlTUVbKJOAnmG1ipXhdWTmNXiPzPfWKpXqASVcWdnf2bnL73wgjNrFXAa3yYvBSd9pzfEIpA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.25.12.tgz",
      "integrity": "sha512-gA0Bx759+7Jve03K1S0vkOu5Lg/85dou3EseOGUes8flVOGxbhDDh/iZaoek11Y8mtyKPGF3vP8XhnkDEAmzeg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.25.12.tgz",
      "integrity": "sha512-TGbO26Yw2xsHzxtbVFGEXBFH0FRAP7gtcPE7P5yP7wGy7cXK2oO7RyOhL5NLiqTlBh47XhmIUXuGciXEqYFfBQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.25.12.tgz",
      "integrity": "sha512-lPDGyC1JPDou8kGcywY0YILzWlhhnRjdof3UlcoqYmS9El818LLfJJc3PXXgZHrHCAKs/Z2SeZtDJr5MrkxtOw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.25.12.tgz",
      "integrity": "sha512-8bwX7a8FghIgrupcxb4aUmYDLp8pX06rGh5HqDT7bB+8Rdells6mHvrFHHW2JAOPZUbnjUpKTLg6ECyzvas2AQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.25.12.tgz",
      "integrity": "sha512-0y9KrdVnbMM2/vG8KfU0byhUN+EFCny9+8g202gYqSSVMonbsCfLjUO+rCci7pM0WBEtz+oK/PIwHkzxkyharA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.25.12.tgz",
      "integrity": "sha512-h///Lr5a9rib/v1GGqXVGzjL4TMvVTv+s1DPoxQdz7l/AYv6LDSxdIwzxkrPW438oUXiDtwM10o9PmwS/6Z0Ng==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.25.12.tgz",
      "integrity": "sha512-iyRrM1Pzy9GFMDLsXn1iHUm18nhKnNMWscjmp4+hpafcZjrr2WbT//d20xaGljXDBYHqRcl8HnxbX6uaA/eGVw==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.25.12.tgz",
      "integrity": "sha512-9meM/lRXxMi5PSUqEXRCtVjEZBGwB7P/D4yT8UG/mwIdze2aV4Vo6U5gD3+RsoHXKkHCfSxZKzmDssVlRj1QQA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.25.12.tgz",
      "integrity": "sha512-Zr7KR4hgKUpWAwb1f3o5ygT04MzqVrGEGXGLnj15YQDJErYu/BGg+wmFlIDOdJp0PmB0lLvxFIOXZgFRrdjR0w==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.25.12.tgz",
      "integrity": "sha512-MsKncOcgTNvdtiISc/jZs/Zf8d0cl/t3gYWX8J9ubBnVOwlk65UIEEvgBORTiljloIWnBzLs4qhzPkJcitIzIg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.25.12.tgz",
      "integrity": "sha512-uqZMTLr/zR/ed4jIGnwSLkaHmPjOjJvnm6TVVitAa08SLS9Z0VM8wIRx7gWbJB5/J54YuIMInDquWyYvQLZkgw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.25.12.tgz",
      "integrity": "sha512-xXwcTq4GhRM7J9A8Gv5boanHhRa/Q9KLVmcyXHCTaM4wKfIpWkdXiMog/KsnxzJ0A1+nD+zoecuzqPmCRyBGjg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.25.12.tgz",
      "integrity": "sha512-Ld5pTlzPy3YwGec4OuHh1aCVCRvOXdH8DgRjfDy/oumVovmuSzWfnSJg+VtakB9Cm0gxNO9BzWkj6mtO1FMXkQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.25.12.tgz",
      "integrity": "sha512-fF96T6KsBo/pkQI950FARU9apGNTSlZGsv1jZBAlcLL1MLjLNIWPBkj5NlSz8aAzYKg+eNqknrUJ24QBybeR5A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.25.12.tgz",
      "integrity": "sha512-MZyXUkZHjQxUvzK7rN8DJ3SRmrVrke8ZyRusHlP+kuwqTcfWLyqMOE3sScPPyeIXN/mDJIfGXvcMqCgYKekoQw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openharmony-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/openharmony-arm64/-/openharmony-arm64-0.25.12.tgz",
      "integrity": "sha512-rm0YWsqUSRrjncSXGA7Zv78Nbnw4XL6/dzr20cyrQf7ZmRcsovpcRBdhD43Nuk3y7XIoW2OxMVvwuRvk9XdASg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.25.12.tgz",
      "integrity": "sha512-3wGSCDyuTHQUzt0nV7bocDy72r2lI33QL3gkDNGkod22EsYl04sMf0qLb8luNKTOmgF/eDEDP5BFNwoBKH441w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.25.12.tgz",
      "integrity": "sha512-rMmLrur64A7+DKlnSuwqUdRKyd3UE7oPJZmnljqEptesKM8wx9J8gx5u0+9Pq0fQQW8vqeKebwNXdfOyP+8Bsg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.25.12.tgz",
      "integrity": "sha512-HkqnmmBoCbCwxUKKNPBixiWDGCpQGVsrQfJoVGYLPT41XWF8lHuE5N6WhVia2n4o5QK5M4tYr21827fNhi4byQ==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.25.12.tgz",
      "integrity": "sha512-alJC0uCZpTFrSL0CCDjcgleBXPnCrEAhTBILpeAp7M/OFgoqtAetfBzX0xM00MUsVVPpVjlPuMbREqnZCXaTnA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@exodus/bytes": {
      "version": "1.12.0",
      "resolved": "https://registry.npmjs.org/@exodus/bytes/-/bytes-1.12.0.tgz",
      "integrity": "sha512-BuCOHA/EJdPN0qQ5MdgAiJSt9fYDHbghlgrj33gRdy/Yp1/FMCDhU6vJfcKrLC0TPWGSrfH3vYXBQWmFHxlddw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=24.0.0"
      },
      "peerDependencies": {
        "@noble/hashes": "^1.8.0 || ^2.0.0"
      },
      "peerDependenciesMeta": {
        "@noble/hashes": {
          "optional": true
        }
      }
    },
    "node_modules/@floating-ui/core": {
      "version": "1.7.4",
      "resolved": "https://registry.npmjs.org/@floating-ui/core/-/core-1.7.4.tgz",
      "integrity": "sha512-C3HlIdsBxszvm5McXlB8PeOEWfBhcGBTZGkGlWc2U0KFY5IwG5OQEuQ8rq52DZmcHDlPLd+YFBK+cZcytwIFWg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/utils": "^0.2.10"
      }
    },
    "node_modules/@floating-ui/dom": {
      "version": "1.7.5",
      "resolved": "https://registry.npmjs.org/@floating-ui/dom/-/dom-1.7.5.tgz",
      "integrity": "sha512-N0bD2kIPInNHUHehXhMke1rBGs1dwqvC9O9KYMyyjK7iXt7GAhnro7UlcuYcGdS/yYOlq0MAVgrow8IbWJwyqg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/core": "^1.7.4",
        "@floating-ui/utils": "^0.2.10"
      }
    },
    "node_modules/@floating-ui/react-dom": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/@floating-ui/react-dom/-/react-dom-2.1.7.tgz",
      "integrity": "sha512-0tLRojf/1Go2JgEVm+3Frg9A3IW8bJgKgdO0BN5RkF//ufuz2joZM63Npau2ff3J6lUVYgDSNzNkR+aH3IVfjg==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/dom": "^1.7.5"
      },
      "peerDependencies": {
        "react": ">=16.8.0",
        "react-dom": ">=16.8.0"
      }
    },
    "node_modules/@floating-ui/utils": {
      "version": "0.2.10",
      "resolved": "https://registry.npmjs.org/@floating-ui/utils/-/utils-0.2.10.tgz",
      "integrity": "sha512-aGTxbpbg8/b5JfU1HXSrbH3wXZuLPJcNEcZQFMxLs3oSzgtVu6nFPkbbGGUvBcUjKV2YyB9Wxxabo+HEH9tcRQ==",
      "license": "MIT"
    },
    "node_modules/@isaacs/cliui": {
      "version": "8.0.2",
      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "string-width": "^5.1.2",
        "string-width-cjs": "npm:string-width@^4.2.0",
        "strip-ansi": "^7.0.1",
        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
        "wrap-ansi": "^8.1.0",
        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@istanbuljs/schema": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.13",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/remapping": {
      "version": "2.3.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/remapping/-/remapping-2.3.5.tgz",
      "integrity": "sha512-LI9u/+laYG4Ds1TDKSJW2YPrIlcVYOwi2fUC6xB43lueCjgxV4lffOCZCtYFiH6TNOX+tQKXx97T4IKHbhyHEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.31",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "2.0.5",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.5",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@originjs/vite-plugin-federation": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/@originjs/vite-plugin-federation/-/vite-plugin-federation-1.4.1.tgz",
      "integrity": "sha512-Uo08jW5pj1t58OUKuZNkmzcfTN2pqeVuAWCCiKf/75/oll4Efq4cHOqSE1FXMlvwZNGDziNdDyBbQ5IANem3CQ==",
      "dev": true,
      "license": "MulanPSL-2.0",
      "dependencies": {
        "estree-walker": "^3.0.2",
        "magic-string": "^0.27.0"
      },
      "engines": {
        "node": ">=14.0.0",
        "pnpm": ">=7.0.1"
      }
    },
    "node_modules/@pkgjs/parseargs": {
      "version": "0.11.0",
      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
      "dev": true,
      "license": "MIT",
      "optional": true,
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/@radix-ui/number": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/number/-/number-1.1.1.tgz",
      "integrity": "sha512-MkKCwxlXTgz6CFoJx3pCwn07GKp36+aZyu/u2Ln2VrA5DcdyCZkASEDBTd8x5whTQQL5CiYf4prXKLcgQdv29g==",
      "license": "MIT"
    },
    "node_modules/@radix-ui/primitive": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/primitive/-/primitive-1.1.3.tgz",
      "integrity": "sha512-JTF99U/6XIjCBo0wqkU5sK10glYe27MRRsfwoiq5zzOEZLHU3A3KCMa5X/azekYRCJ0HlwI0crAXS/5dEHTzDg==",
      "license": "MIT"
    },
    "node_modules/@radix-ui/react-accordion": {
      "version": "1.2.12",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-accordion/-/react-accordion-1.2.12.tgz",
      "integrity": "sha512-T4nygeh9YE9dLRPhAHSeOZi7HBXo+0kYIPJXayZfvWOWA0+n3dESrZbjfDPUABkUNym6Hd+f2IR113To8D2GPA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-collapsible": "1.1.12",
        "@radix-ui/react-collection": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-alert-dialog": {
      "version": "1.1.15",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-alert-dialog/-/react-alert-dialog-1.1.15.tgz",
      "integrity": "sha512-oTVLkEw5GpdRe29BqJ0LSDFWI3qu0vR1M0mUkOQWDIUnY/QIkLpgDMWuKxP94c2NAC2LGcgVhG1ImF3jkZ5wXw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dialog": "1.1.15",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-alert-dialog/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-arrow": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-arrow/-/react-arrow-1.1.7.tgz",
      "integrity": "sha512-F+M1tLhO+mlQaOWspE8Wstg+z6PwxwRd8oQ8IXceWz92kfAmalTRf0EjrouQeo7QssEPfCn05B4Ihs1K9WQ/7w==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-checkbox": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-checkbox/-/react-checkbox-1.3.3.tgz",
      "integrity": "sha512-wBbpv+NQftHDdG86Qc0pIyXk5IR3tM8Vd0nWLKDcX8nNn4nXFOFwsKuqw2okA/1D/mpaAkmuyndrPJTYDNZtFw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-previous": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-collapsible": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-collapsible/-/react-collapsible-1.1.12.tgz",
      "integrity": "sha512-Uu+mSh4agx2ib1uIGPP4/CKNULyajb3p92LsVXmH2EHVMTfZWpll88XJ0j4W0z3f8NK1eYl1+Mf/szHPmcHzyA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-collection": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-collection/-/react-collection-1.1.7.tgz",
      "integrity": "sha512-Fh9rGN0MoI4ZFUNyfFVNU4y9LUz93u9/0K+yLgA2bwRojxM8JU1DyvvMBabnZPBgMWREAJvU2jjVzq+LrFUglw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-collection/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-compose-refs": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-compose-refs/-/react-compose-refs-1.1.2.tgz",
      "integrity": "sha512-z4eqJvfiNnFMHIIvXP3CY57y2WJs5g2v3X0zm9mEJkrkNv4rDxu+sg9Jh8EkXyeqBkB7SOcboo9dMVqhyrACIg==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-context": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-context/-/react-context-1.1.2.tgz",
      "integrity": "sha512-jCi/QKUM2r1Ju5a3J64TH2A5SpKAgh0LpknyqdQ4m6DCV0xJ2HG1xARRwNGPQfi1SLdLWZ1OJz6F4OMBBNiGJA==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dialog": {
      "version": "1.1.15",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dialog/-/react-dialog-1.1.15.tgz",
      "integrity": "sha512-TCglVRtzlffRNxRMEyR36DGBLJpeusFcgMVD9PZEzAKnUs1lKCgX5u9BmC2Yg+LL9MgZDugFFs1Vl+Jp4t/PGw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-focus-guards": "1.1.3",
        "@radix-ui/react-focus-scope": "1.1.7",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dialog/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-direction": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-direction/-/react-direction-1.1.1.tgz",
      "integrity": "sha512-1UEWRX6jnOA2y4H5WczZ44gOOjTEmlqv1uNW4GAJEO5+bauCBhv8snY65Iw5/VOS/ghKN9gr2KjnLKxrsvoMVw==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dismissable-layer": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dismissable-layer/-/react-dismissable-layer-1.1.11.tgz",
      "integrity": "sha512-Nqcp+t5cTB8BinFkZgXiMJniQH0PsUt2k51FUhbdfeKvc4ACcG2uQniY/8+h1Yv6Kza4Q7lD7PQV0z0oicE0Mg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-escape-keydown": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-dropdown-menu": {
      "version": "2.1.16",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-dropdown-menu/-/react-dropdown-menu-2.1.16.tgz",
      "integrity": "sha512-1PLGQEynI/3OX/ftV54COn+3Sud/Mn8vALg2rWnBLnRaGtJDduNW/22XjlGgPdpcIbiQxjKtb7BkcjP00nqfJw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-menu": "2.1.16",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-focus-guards": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-focus-guards/-/react-focus-guards-1.1.3.tgz",
      "integrity": "sha512-0rFg/Rj2Q62NCm62jZw0QX7a3sz6QCQU0LpZdNrJX8byRGaGVTqbrW9jAoIAHyMQqsNpeZ81YgSizOt5WXq0Pw==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-focus-scope": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-focus-scope/-/react-focus-scope-1.1.7.tgz",
      "integrity": "sha512-t2ODlkXBQyn7jkl6TNaw/MtVEVvIGelJDCG41Okq/KwUsJBwQ4XVZsHAVUkK4mBv3ewiAS3PGuUWuY2BoK4ZUw==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-icons": {
      "version": "1.3.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-icons/-/react-icons-1.3.2.tgz",
      "integrity": "sha512-fyQIhGDhzfc9pK2kH6Pl9c4BDJGfMkPqkyIgYDthyNYoNg3wVhoJMMh19WS4Up/1KMPFVpNsT2q3WmXn2N1m6g==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^16.x || ^17.x || ^18.x || ^19.0.0 || ^19.0.0-rc"
      }
    },
    "node_modules/@radix-ui/react-id": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-id/-/react-id-1.1.1.tgz",
      "integrity": "sha512-kGkGegYIdQsOb4XjsfM97rXsiHaBwco+hFI66oO4s9LU+PLAC5oJ7khdOVFxkhsmlbpUqDAvXw11CluXP+jkHg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-label": {
      "version": "2.1.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-label/-/react-label-2.1.8.tgz",
      "integrity": "sha512-FmXs37I6hSBVDlO4y764TNz1rLgKwjJMQ0EGte6F3Cb3f4bIuHB/iLa/8I9VKkmOy+gNHq8rql3j686ACVV21A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.4"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-label/node_modules/@radix-ui/react-primitive": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-primitive/-/react-primitive-2.1.4.tgz",
      "integrity": "sha512-9hQc4+GNVtJAIEPEqlYqW5RiYdrr8ea5XQ0ZOnD6fgru+83kqT15mq2OCcbe8KnjRZl5vF3ks69AKz3kh1jrhg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-slot": "1.2.4"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-menu": {
      "version": "2.1.16",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-menu/-/react-menu-2.1.16.tgz",
      "integrity": "sha512-72F2T+PLlphrqLcAotYPp0uJMr5SjP5SL01wfEspJbru5Zs5vQaSHb4VB3ZMJPimgHHCHG7gMOeOB9H3Hdmtxg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-collection": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-focus-guards": "1.1.3",
        "@radix-ui/react-focus-scope": "1.1.7",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.8",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-roving-focus": "1.1.11",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-menu/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popover": {
      "version": "1.1.15",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-popover/-/react-popover-1.1.15.tgz",
      "integrity": "sha512-kr0X2+6Yy/vJzLYJUPCZEc8SfQcf+1COFoAqauJm74umQhta9M7lNJHP7QQS3vkvcGLQUbWpMzwrXYwrYztHKA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-focus-guards": "1.1.3",
        "@radix-ui/react-focus-scope": "1.1.7",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.8",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-popper": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-popper/-/react-popper-1.2.8.tgz",
      "integrity": "sha512-0NJQ4LFFUuWkE7Oxf0htBKS6zLkkjBH+hM1uk7Ng705ReR8m/uelduy1DBo0PyBXPKVnBA6YBlU94MBGXrSBCw==",
      "license": "MIT",
      "dependencies": {
        "@floating-ui/react-dom": "^2.0.0",
        "@radix-ui/react-arrow": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-layout-effect": "1.1.1",
        "@radix-ui/react-use-rect": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1",
        "@radix-ui/rect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-portal": {
      "version": "1.1.9",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-portal/-/react-portal-1.1.9.tgz",
      "integrity": "sha512-bpIxvq03if6UNwXZ+HTK71JLh4APvnXntDc6XOX8UVq4XQOVl7lwok0AvIl+b8zgCw3fSaVTZMpAPPagXbKmHQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-presence": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-presence/-/react-presence-1.1.5.tgz",
      "integrity": "sha512-/jfEwNDdQVBCNvjkGit4h6pMOzq8bHkopq458dPt2lMjx+eBQUohZNG9A7DtO/O5ukSbxuaNGXMjHicgwy6rQQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-primitive": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-primitive/-/react-primitive-2.1.3.tgz",
      "integrity": "sha512-m9gTwRkhy2lvCPe6QJp4d3G1TYEUHn/FzJUtq9MjH46an1wJU+GdoGC5VLof8RX8Ft/DlpshApkhswDLZzHIcQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-slot": "1.2.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-primitive/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-roving-focus": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-roving-focus/-/react-roving-focus-1.1.11.tgz",
      "integrity": "sha512-7A6S9jSgm/S+7MdtNDSb+IU859vQqJ/QAtcYQcfFC6W8RS4IxIZDldLR0xqCFZ6DCyrQLjLPsxtTNch5jVA4lA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-collection": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-scroll-area": {
      "version": "1.2.10",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-scroll-area/-/react-scroll-area-1.2.10.tgz",
      "integrity": "sha512-tAXIa1g3sM5CGpVT0uIbUx/U3Gs5N8T52IICuCtObaos1S8fzsrPXG5WObkQN3S6NVl6wKgPhAIiBGbWnvc97A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/number": "1.1.1",
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-select": {
      "version": "2.2.6",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-select/-/react-select-2.2.6.tgz",
      "integrity": "sha512-I30RydO+bnn2PQztvo25tswPH+wFBjehVGtmagkU78yMdwTwVf12wnAOF+AeP8S2N8xD+5UPbGhkUfPyvT+mwQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/number": "1.1.1",
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-collection": "1.1.7",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-focus-guards": "1.1.3",
        "@radix-ui/react-focus-scope": "1.1.7",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.8",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-callback-ref": "1.1.1",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-layout-effect": "1.1.1",
        "@radix-ui/react-use-previous": "1.1.1",
        "@radix-ui/react-visually-hidden": "1.2.3",
        "aria-hidden": "^1.2.4",
        "react-remove-scroll": "^2.6.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-separator": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-separator/-/react-separator-1.1.8.tgz",
      "integrity": "sha512-sDvqVY4itsKwwSMEe0jtKgfTh+72Sy3gPmQpjqcQneqQ4PFmr/1I0YA+2/puilhggCe2gJcx5EBAYFkWkdpa5g==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.4"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-separator/node_modules/@radix-ui/react-primitive": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-primitive/-/react-primitive-2.1.4.tgz",
      "integrity": "sha512-9hQc4+GNVtJAIEPEqlYqW5RiYdrr8ea5XQ0ZOnD6fgru+83kqT15mq2OCcbe8KnjRZl5vF3ks69AKz3kh1jrhg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-slot": "1.2.4"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-slot": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.4.tgz",
      "integrity": "sha512-Jl+bCv8HxKnlTLVrcDE8zTMJ09R9/ukw4qBs/oZClOfoQk/cOTbDn+NceXfV7j09YPVQUryJPHurafcSg6EVKA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-switch": {
      "version": "1.2.6",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-switch/-/react-switch-1.2.6.tgz",
      "integrity": "sha512-bByzr1+ep1zk4VubeEVViV592vu2lHE2BZY5OnzehZqOOgogN80+mNtCqPkhn2gklJqOpxWgPoYTSnhBCqpOXQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-use-previous": "1.1.1",
        "@radix-ui/react-use-size": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-tabs": {
      "version": "1.1.13",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-tabs/-/react-tabs-1.1.13.tgz",
      "integrity": "sha512-7xdcatg7/U+7+Udyoj2zodtI9H/IIopqo+YOIcZOq1nJwXWBZ9p8xiu5llXlekDbZkca79a/fozEYQXIA4sW6A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-roving-focus": "1.1.11",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-toggle": {
      "version": "1.1.10",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-toggle/-/react-toggle-1.1.10.tgz",
      "integrity": "sha512-lS1odchhFTeZv3xwHH31YPObmJn8gOg7Lq12inrr0+BH/l3Tsq32VfjqH1oh80ARM3mlkfMic15n0kg4sD1poQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-toggle-group": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-toggle-group/-/react-toggle-group-1.1.11.tgz",
      "integrity": "sha512-5umnS0T8JQzQT6HbPyO7Hh9dgd82NmS36DQr+X/YJ9ctFNCiiQd6IJAYYZ33LUwm8M+taCz5t2ui29fHZc4Y6Q==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-direction": "1.1.1",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-roving-focus": "1.1.11",
        "@radix-ui/react-toggle": "1.1.10",
        "@radix-ui/react-use-controllable-state": "1.2.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-tooltip": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-tooltip/-/react-tooltip-1.2.8.tgz",
      "integrity": "sha512-tY7sVt1yL9ozIxvmbtN5qtmH2krXcBCfjEiCgKGLqunJHvgvZG2Pcl2oQ3kbcZARb1BGEHdkLzcYGO8ynVlieg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/primitive": "1.1.3",
        "@radix-ui/react-compose-refs": "1.1.2",
        "@radix-ui/react-context": "1.1.2",
        "@radix-ui/react-dismissable-layer": "1.1.11",
        "@radix-ui/react-id": "1.1.1",
        "@radix-ui/react-popper": "1.2.8",
        "@radix-ui/react-portal": "1.1.9",
        "@radix-ui/react-presence": "1.1.5",
        "@radix-ui/react-primitive": "2.1.3",
        "@radix-ui/react-slot": "1.2.3",
        "@radix-ui/react-use-controllable-state": "1.2.2",
        "@radix-ui/react-visually-hidden": "1.2.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-tooltip/node_modules/@radix-ui/react-slot": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-slot/-/react-slot-1.2.3.tgz",
      "integrity": "sha512-aeNmHnBxbi2St0au6VBVC7JXFlhLlOnvIIlePNniyUNAClzmtAUEY8/pBiK3iHjufOlwA+c20/8jngo7xcrg8A==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-compose-refs": "1.1.2"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-callback-ref": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-callback-ref/-/react-use-callback-ref-1.1.1.tgz",
      "integrity": "sha512-FkBMwD+qbGQeMu1cOHnuGB6x4yzPjho8ap5WtbEJ26umhgqVXbhekKUQO+hZEL1vU92a3wHwdp0HAcqAUF5iDg==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-controllable-state": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-controllable-state/-/react-use-controllable-state-1.2.2.tgz",
      "integrity": "sha512-BjasUjixPFdS+NKkypcyyN5Pmg83Olst0+c6vGov0diwTEo6mgdqVR6hxcEgFuh4QrAs7Rc+9KuGJ9TVCj0Zzg==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-effect-event": "0.0.2",
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-effect-event": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-effect-event/-/react-use-effect-event-0.0.2.tgz",
      "integrity": "sha512-Qp8WbZOBe+blgpuUT+lw2xheLP8q0oatc9UpmiemEICxGvFLYmHm9QowVZGHtJlGbS6A6yJ3iViad/2cVjnOiA==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-escape-keydown": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-escape-keydown/-/react-use-escape-keydown-1.1.1.tgz",
      "integrity": "sha512-Il0+boE7w/XebUHyBjroE+DbByORGR9KKmITzbR7MyQ4akpORYP/ZmbhAr0DG7RmmBqoOnZdy2QlvajJ2QA59g==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-callback-ref": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-layout-effect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-layout-effect/-/react-use-layout-effect-1.1.1.tgz",
      "integrity": "sha512-RbJRS4UWQFkzHTTwVymMTUv8EqYhOp8dOOviLj2ugtTiXRaRQS7GLGxZTLL1jWhMeoSCf5zmcZkqTl9IiYfXcQ==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-previous": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-previous/-/react-use-previous-1.1.1.tgz",
      "integrity": "sha512-2dHfToCj/pzca2Ck724OZ5L0EVrr3eHRNsG/b3xQJLA2hZpVCS99bLAX+hm1IHXDEnzU6by5z/5MIY794/a8NQ==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-rect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-rect/-/react-use-rect-1.1.1.tgz",
      "integrity": "sha512-QTYuDesS0VtuHNNvMh+CjlKJ4LJickCMUAqjlE3+j8w+RlRpwyX3apEQKGFzbZGdo7XNG1tXa+bQqIE7HIXT2w==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/rect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-use-size": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-use-size/-/react-use-size-1.1.1.tgz",
      "integrity": "sha512-ewrXRDTAqAXlkl6t/fkXWNAhFX9I+CkKlw6zjEwk86RSPKwZr3xpBRso655aqYafwtnbpHLj6toFzmd6xdVptQ==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-use-layout-effect": "1.1.1"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/react-visually-hidden": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@radix-ui/react-visually-hidden/-/react-visually-hidden-1.2.3.tgz",
      "integrity": "sha512-pzJq12tEaaIhqjbzpCuv/OypJY/BPavOofm+dbab+MHLajy277+1lLm6JFcGgF5eskJ6mquGirhXY2GD/8u8Ug==",
      "license": "MIT",
      "dependencies": {
        "@radix-ui/react-primitive": "2.1.3"
      },
      "peerDependencies": {
        "@types/react": "*",
        "@types/react-dom": "*",
        "react": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc",
        "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@radix-ui/rect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@radix-ui/rect/-/rect-1.1.1.tgz",
      "integrity": "sha512-HPwpGIzkl28mWyZqG52jiqDJ12waP11Pa1lGoiyUkIEuMLBP0oeK/C89esbXrxsky5we7dfd8U58nm0SgAWpVw==",
      "license": "MIT"
    },
    "node_modules/@rolldown/pluginutils": {
      "version": "1.0.0-beta.27",
      "resolved": "https://registry.npmjs.org/@rolldown/pluginutils/-/pluginutils-1.0.0-beta.27.tgz",
      "integrity": "sha512-+d0F4MKMCbeVUJwG96uQ4SgAznZNSq93I3V+9NHA4OpvqG8mRCpGdKmK8l/dl02h2CCDHwW2FqilnTyDcAnqjA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
      "integrity": "sha512-A6ehUVSiSaaliTxai040ZpZ2zTevHYbvu/lDoeAteHI8QnaosIzm4qwtezfRg1jOYaUmnzLX1AOD6Z+UJjtifg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.57.1.tgz",
      "integrity": "sha512-dQaAddCY9YgkFHZcFNS/606Exo8vcLHwArFZ7vxXq4rigo2bb494/xKMMwRRQW6ug7Js6yXmBZhSBRuBvCCQ3w==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.57.1.tgz",
      "integrity": "sha512-crNPrwJOrRxagUYeMn/DZwqN88SDmwaJ8Cvi/TN1HnWBU7GwknckyosC2gd0IqYRsHDEnXf328o9/HC6OkPgOg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.57.1.tgz",
      "integrity": "sha512-Ji8g8ChVbKrhFtig5QBV7iMaJrGtpHelkB3lsaKzadFBe58gmjfGXAOfI5FV0lYMH8wiqsxKQ1C9B0YTRXVy4w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.57.1.tgz",
      "integrity": "sha512-R+/WwhsjmwodAcz65guCGFRkMb4gKWTcIeLy60JJQbXrJ97BOXHxnkPFrP+YwFlaS0m+uWJTstrUA9o+UchFug==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.57.1.tgz",
      "integrity": "sha512-IEQTCHeiTOnAUC3IDQdzRAGj3jOAYNr9kBguI7MQAAZK3caezRrg0GxAb6Hchg4lxdZEI5Oq3iov/w/hnFWY9Q==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.57.1.tgz",
      "integrity": "sha512-F8sWbhZ7tyuEfsmOxwc2giKDQzN3+kuBLPwwZGyVkLlKGdV1nvnNwYD0fKQ8+XS6hp9nY7B+ZeK01EBUE7aHaw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.57.1.tgz",
      "integrity": "sha512-rGfNUfn0GIeXtBP1wL5MnzSj98+PZe/AXaGBCRmT0ts80lU5CATYGxXukeTX39XBKsxzFpEeK+Mrp9faXOlmrw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.57.1.tgz",
      "integrity": "sha512-MMtej3YHWeg/0klK2Qodf3yrNzz6CGjo2UntLvk2RSPlhzgLvYEB3frRvbEF2wRKh1Z2fDIg9KRPe1fawv7C+g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.57.1.tgz",
      "integrity": "sha512-1a/qhaaOXhqXGpMFMET9VqwZakkljWHLmZOX48R0I/YLbhdxr1m4gtG1Hq7++VhVUmf+L3sTAf9op4JlhQ5u1Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.57.1.tgz",
      "integrity": "sha512-QWO6RQTZ/cqYtJMtxhkRkidoNGXc7ERPbZN7dVW5SdURuLeVU7lwKMpo18XdcmpWYd0qsP1bwKPf7DNSUinhvA==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-musl/-/rollup-linux-loong64-musl-4.57.1.tgz",
      "integrity": "sha512-xpObYIf+8gprgWaPP32xiN5RVTi/s5FCR+XMXSKmhfoJjrpRAjCuuqQXyxUa/eJTdAE6eJ+KDKaoEqjZQxh3Gw==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.57.1.tgz",
      "integrity": "sha512-4BrCgrpZo4hvzMDKRqEaW1zeecScDCR+2nZ86ATLhAoJ5FQ+lbHVD3ttKe74/c7tNT9c6F2viwB3ufwp01Oh2w==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-musl/-/rollup-linux-ppc64-musl-4.57.1.tgz",
      "integrity": "sha512-NOlUuzesGauESAyEYFSe3QTUguL+lvrN1HtwEEsU2rOwdUDeTMJdO5dUYl/2hKf9jWydJrO9OL/XSSf65R5+Xw==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.57.1.tgz",
      "integrity": "sha512-ptA88htVp0AwUUqhVghwDIKlvJMD/fmL/wrQj99PRHFRAG6Z5nbWoWG4o81Nt9FT+IuqUQi+L31ZKAFeJ5Is+A==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.57.1.tgz",
      "integrity": "sha512-S51t7aMMTNdmAMPpBg7OOsTdn4tySRQvklmL3RpDRyknk87+Sp3xaumlatU+ppQ+5raY7sSTcC2beGgvhENfuw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.57.1.tgz",
      "integrity": "sha512-Bl00OFnVFkL82FHbEqy3k5CUCKH6OEJL54KCyx2oqsmZnFTR8IoNqBF+mjQVcRCT5sB6yOvK8A37LNm/kPJiZg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.57.1.tgz",
      "integrity": "sha512-ABca4ceT4N+Tv/GtotnWAeXZUZuM/9AQyCyKYyKnpk4yoA7QIAuBt6Hkgpw8kActYlew2mvckXkvx0FfoInnLg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.57.1.tgz",
      "integrity": "sha512-HFps0JeGtuOR2convgRRkHCekD7j+gdAuXM+/i6kGzQtFhlCtQkpwtNzkNj6QhCDp7DRJ7+qC/1Vg2jt5iSOFw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-openbsd-x64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openbsd-x64/-/rollup-openbsd-x64-4.57.1.tgz",
      "integrity": "sha512-H+hXEv9gdVQuDTgnqD+SQffoWoc0Of59AStSzTEj/feWTBAnSfSD3+Dql1ZruJQxmykT/JVY0dE8Ka7z0DH1hw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ]
    },
    "node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.57.1.tgz",
      "integrity": "sha512-4wYoDpNg6o/oPximyc/NG+mYUejZrCU2q+2w6YZqrAs2UcNUChIZXjtafAiiZSUc7On8v5NyNj34Kzj/Ltk6dQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.57.1.tgz",
      "integrity": "sha512-O54mtsV/6LW3P8qdTcamQmuC990HDfR71lo44oZMZlXU4tzLrbvTii87Ni9opq60ds0YzuAlEr/GNwuNluZyMQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.57.1.tgz",
      "integrity": "sha512-P3dLS+IerxCT/7D2q2FYcRdWRl22dNbrbBEtxdWhXrfIMPP9lQhb5h4Du04mdl5Woq05jVCDPCMF7Ub0NAjIew==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.57.1.tgz",
      "integrity": "sha512-VMBH2eOOaKGtIJYleXsi2B8CPVADrh+TyNxJ4mWPnKfLB/DBUmzW+5m1xUrcwWoMfSLagIRpjUFeW5CO5hyciQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.57.1.tgz",
      "integrity": "sha512-mxRFDdHIWRxg3UfIIAwCm6NzvxG0jDX/wBN6KsQFTvKFqqg9vTrWUE68qEjHt19A5wwx5X5aUi2zuZT7YR0jrA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@tanstack/query-core": {
      "version": "5.90.20",
      "resolved": "https://registry.npmjs.org/@tanstack/query-core/-/query-core-5.90.20.tgz",
      "integrity": "sha512-OMD2HLpNouXEfZJWcKeVKUgQ5n+n3A2JFmBaScpNDUqSrQSjiveC7dKMe53uJUg1nDG16ttFPz2xfilz6i2uVg==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      }
    },
    "node_modules/@tanstack/react-query": {
      "version": "5.90.20",
      "resolved": "https://registry.npmjs.org/@tanstack/react-query/-/react-query-5.90.20.tgz",
      "integrity": "sha512-vXBxa+qeyveVO7OA0jX1z+DeyCA4JKnThKv411jd5SORpBKgkcVnYKCiBgECvADvniBX7tobwBmg01qq9JmMJw==",
      "license": "MIT",
      "dependencies": {
        "@tanstack/query-core": "5.90.20"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/tannerlinsley"
      },
      "peerDependencies": {
        "react": "^18 || ^19"
      }
    },
    "node_modules/@testing-library/dom": {
      "version": "10.4.1",
      "resolved": "https://registry.npmjs.org/@testing-library/dom/-/dom-10.4.1.tgz",
      "integrity": "sha512-o4PXJQidqJl82ckFaXUeoAW+XysPLauYI43Abki5hABd853iMhitooc6znOnczgbTYmEP6U6/y1ZyKAIsvMKGg==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "@babel/code-frame": "^7.10.4",
        "@babel/runtime": "^7.12.5",
        "@types/aria-query": "^5.0.1",
        "aria-query": "5.3.0",
        "dom-accessibility-api": "^0.5.9",
        "lz-string": "^1.5.0",
        "picocolors": "1.1.1",
        "pretty-format": "^27.0.2"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@testing-library/jest-dom": {
      "version": "6.9.1",
      "resolved": "https://registry.npmjs.org/@testing-library/jest-dom/-/jest-dom-6.9.1.tgz",
      "integrity": "sha512-zIcONa+hVtVSSep9UT3jZ5rizo2BsxgyDYU7WFD5eICBE7no3881HGeb/QkGfsJs6JTkY1aQhT7rIPC7e+0nnA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@adobe/css-tools": "^4.4.0",
        "aria-query": "^5.0.0",
        "css.escape": "^1.5.1",
        "dom-accessibility-api": "^0.6.3",
        "picocolors": "^1.1.1",
        "redent": "^3.0.0"
      },
      "engines": {
        "node": ">=14",
        "npm": ">=6",
        "yarn": ">=1"
      }
    },
    "node_modules/@testing-library/jest-dom/node_modules/dom-accessibility-api": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/dom-accessibility-api/-/dom-accessibility-api-0.6.3.tgz",
      "integrity": "sha512-7ZgogeTnjuHbo+ct10G9Ffp0mif17idi0IyWNVA/wcwcm7NPOD/WEHVP3n7n3MhXqxoIYm8d6MuZohYWIZ4T3w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@testing-library/react": {
      "version": "16.3.2",
      "resolved": "https://registry.npmjs.org/@testing-library/react/-/react-16.3.2.tgz",
      "integrity": "sha512-XU5/SytQM+ykqMnAnvB2umaJNIOsLF3PVv//1Ew4CTcpz0/BRyy/af40qqrt7SjKpDdT1saBMc42CUok5gaw+g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.12.5"
      },
      "engines": {
        "node": ">=18"
      },
      "peerDependencies": {
        "@testing-library/dom": "^10.0.0",
        "@types/react": "^18.0.0 || ^19.0.0",
        "@types/react-dom": "^18.0.0 || ^19.0.0",
        "react": "^18.0.0 || ^19.0.0",
        "react-dom": "^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "@types/react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@testing-library/user-event": {
      "version": "14.6.1",
      "resolved": "https://registry.npmjs.org/@testing-library/user-event/-/user-event-14.6.1.tgz",
      "integrity": "sha512-vq7fv0rnt+QTXgPxr5Hjc210p6YKq2kmdziLgnsZGgLJ9e6VAShx1pACLuRjd/AS/sr7phAR58OIIpf0LlmQNw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      },
      "peerDependencies": {
        "@testing-library/dom": ">=7.21.4"
      }
    },
    "node_modules/@types/aria-query": {
      "version": "5.0.4",
      "resolved": "https://registry.npmjs.org/@types/aria-query/-/aria-query-5.0.4.tgz",
      "integrity": "sha512-rfT93uj5s0PRL7EzccGMs3brplhcrghnDoV26NqKhCAS1hVo+WdNsPvE/yb6ilfr5hi2MEk6d5EWJTKdxg8jVw==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.5",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.28.0.tgz",
      "integrity": "sha512-8PvcXf70gTDZBgt9ptxJ8elBeBjcLOAcOtoO/mPJjtji1+CdGbHgm77om1GrsPxsiE+uXIpNSK64UYaIwQXd4Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.2"
      }
    },
    "node_modules/@types/chai": {
      "version": "5.2.3",
      "resolved": "https://registry.npmjs.org/@types/chai/-/chai-5.2.3.tgz",
      "integrity": "sha512-Mw558oeA9fFbv65/y4mHtXDs9bPnFMZAL/jxdPFUpOHHIXX91mcgEHbS5Lahr+pwZFR8A7GQleRWeI6cGFC2UA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/deep-eql": "*",
        "assertion-error": "^2.0.1"
      }
    },
    "node_modules/@types/deep-eql": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/@types/deep-eql/-/deep-eql-4.0.2.tgz",
      "integrity": "sha512-c9h9dVVMigMPc4bwTvC5dxqtqJZwQPePsWjPlpSOnojbor6pGqdk541lfA7AqFQr5pB1BRdq0juY9db81BwyFw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/react": {
      "version": "19.2.11",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.2.11.tgz",
      "integrity": "sha512-tORuanb01iEzWvMGVGv2ZDhYZVeRMrw453DCSAIn/5yvcSVnMoUMTyf33nQJLahYEnv9xqrTNbgz4qY5EfSh0g==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "csstype": "^3.2.2"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.2.3",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.2.3.tgz",
      "integrity": "sha512-jp2L/eY6fn+KgVVQAOqYItbF0VY/YApe5Mz2F0aykSO8gx31bYCZyvSeYxCHKvzHG5eZjc+zyaS5BrBWya2+kQ==",
      "devOptional": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.2.0"
      }
    },
    "node_modules/@vitejs/plugin-react": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-4.7.0.tgz",
      "integrity": "sha512-gUu9hwfWvvEDBBmgtAowQCojwZmJ5mcLn3aufeCsitijs3+f2NsrPtlAWIR6OPiqljl96GVCUbLe0HyqIpVaoA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.28.0",
        "@babel/plugin-transform-react-jsx-self": "^7.27.1",
        "@babel/plugin-transform-react-jsx-source": "^7.27.1",
        "@rolldown/pluginutils": "1.0.0-beta.27",
        "@types/babel__core": "^7.20.5",
        "react-refresh": "^0.17.0"
      },
      "engines": {
        "node": "^14.18.0 || >=16.0.0"
      },
      "peerDependencies": {
        "vite": "^4.2.0 || ^5.0.0 || ^6.0.0 || ^7.0.0"
      }
    },
    "node_modules/@vitest/coverage-v8": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-3.2.4.tgz",
      "integrity": "sha512-EyF9SXU6kS5Ku/U82E259WSnvg6c8KTjppUncuNdm5QHpe17mwREHnjDzozC8x9MZ0xfBUFSaLkRv4TMA75ALQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@ampproject/remapping": "^2.3.0",
        "@bcoe/v8-coverage": "^1.0.2",
        "ast-v8-to-istanbul": "^0.3.3",
        "debug": "^4.4.1",
        "istanbul-lib-coverage": "^3.2.2",
        "istanbul-lib-report": "^3.0.1",
        "istanbul-lib-source-maps": "^5.0.6",
        "istanbul-reports": "^3.1.7",
        "magic-string": "^0.30.17",
        "magicast": "^0.3.5",
        "std-env": "^3.9.0",
        "test-exclude": "^7.0.1",
        "tinyrainbow": "^2.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "@vitest/browser": "3.2.4",
        "vitest": "3.2.4"
      },
      "peerDependenciesMeta": {
        "@vitest/browser": {
          "optional": true
        }
      }
    },
    "node_modules/@vitest/coverage-v8/node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/@vitest/expect": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-3.2.4.tgz",
      "integrity": "sha512-Io0yyORnB6sikFlt8QW5K7slY4OjqNX9jmJQ02QDda8lyM6B5oNgVWoSoKPac8/kgnCUzuHQKrSLtu/uOqqrig==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/chai": "^5.2.2",
        "@vitest/spy": "3.2.4",
        "@vitest/utils": "3.2.4",
        "chai": "^5.2.0",
        "tinyrainbow": "^2.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/mocker": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/mocker/-/mocker-3.2.4.tgz",
      "integrity": "sha512-46ryTE9RZO/rfDd7pEqFl7etuyzekzEhUbTW3BvmeO/BcCMEgq59BKhek3dXDWgAj4oMK6OZi+vRr1wPW6qjEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/spy": "3.2.4",
        "estree-walker": "^3.0.3",
        "magic-string": "^0.30.17"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "msw": "^2.4.9",
        "vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0"
      },
      "peerDependenciesMeta": {
        "msw": {
          "optional": true
        },
        "vite": {
          "optional": true
        }
      }
    },
    "node_modules/@vitest/mocker/node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/@vitest/pretty-format": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/pretty-format/-/pretty-format-3.2.4.tgz",
      "integrity": "sha512-IVNZik8IVRJRTr9fxlitMKeJeXFFFN0JaB9PHPGQ8NKQbGpfjlTx9zO4RefN8gp7eqjNy8nyK3NZmBzOPeIxtA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tinyrainbow": "^2.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/runner": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/runner/-/runner-3.2.4.tgz",
      "integrity": "sha512-oukfKT9Mk41LreEW09vt45f8wx7DordoWUZMYdY/cyAk7w5TWkTRCNZYF7sX7n2wB7jyGAl74OxgwhPgKaqDMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/utils": "3.2.4",
        "pathe": "^2.0.3",
        "strip-literal": "^3.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/snapshot": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/snapshot/-/snapshot-3.2.4.tgz",
      "integrity": "sha512-dEYtS7qQP2CjU27QBC5oUOxLE/v5eLkGqPE0ZKEIDGMs4vKWe7IjgLOeauHsR0D5YuuycGRO5oSRXnwnmA78fQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/pretty-format": "3.2.4",
        "magic-string": "^0.30.17",
        "pathe": "^2.0.3"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/snapshot/node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/@vitest/spy": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/spy/-/spy-3.2.4.tgz",
      "integrity": "sha512-vAfasCOe6AIK70iP5UD11Ac4siNUNJ9i/9PZ3NKx07sG6sUxeag1LWdNrMWeKKYBLlzuK+Gn65Yd5nyL6ds+nw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tinyspy": "^4.0.3"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/utils": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@vitest/utils/-/utils-3.2.4.tgz",
      "integrity": "sha512-fB2V0JFrQSMsCo9HiSq3Ezpdv4iYaXRG1Sx8edX3MwxfyNn83mKiGzOcH+Fkxt4MHxr3y42fQi1oeAInqgX2QA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/pretty-format": "3.2.4",
        "loupe": "^3.1.4",
        "tinyrainbow": "^2.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/agent-base": {
      "version": "7.1.4",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-7.1.4.tgz",
      "integrity": "sha512-MnA+YT8fwfJPgBx3m60MNqakm30XOkyIoH1y6huTQvC0PwZG7ki8NacLBcrPbNoo8vEZy7Jpuk7+jMO+CUovTQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/ansi-regex": {
      "version": "6.2.2",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/ansi-styles": {
      "version": "6.2.3",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/any-promise": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/any-promise/-/any-promise-1.3.0.tgz",
      "integrity": "sha512-7UvmKalWRt1wgjL1RrGxoSJW/0QZFIegpeGvZG9kjp8vrRu55XTHbwnqq2GpXm9uLbcuhxm3IqX9OB4MZR1b2A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/arg": {
      "version": "5.0.2",
      "resolved": "https://registry.npmjs.org/arg/-/arg-5.0.2.tgz",
      "integrity": "sha512-PYjyFOLKQ9y57JvQ6QLo8dAgNqswh8M1RMJYdQduT6xbWSgK36P/Z/v+p888pM69jMMfS8Xd8F6I1kQ/I9HUGg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/aria-hidden": {
      "version": "1.2.6",
      "resolved": "https://registry.npmjs.org/aria-hidden/-/aria-hidden-1.2.6.tgz",
      "integrity": "sha512-ik3ZgC9dY/lYVVM++OISsaYDeg1tb0VtP5uL3ouh1koGOaUMDPpbFIei4JkFimWUFPn90sbMNMXQAIVOlnYKJA==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/aria-query": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/aria-query/-/aria-query-5.3.0.tgz",
      "integrity": "sha512-b0P0sZPKtyu8HkeRAfCq0IfURZK+SuwMjY1UXGBU27wpAiTwQAIlq56IbIO+ytk/JjS1fMR14ee5WBBfKi5J6A==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "dequal": "^2.0.3"
      }
    },
    "node_modules/assertion-error": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-2.0.1.tgz",
      "integrity": "sha512-Izi8RQcffqCeNVgFigKli1ssklIbpHnCYc6AknXGYoB6grJqyeby7jv12JUQgmTAnIDnbck1uxksT4dzN3PWBA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/ast-v8-to-istanbul": {
      "version": "0.3.11",
      "resolved": "https://registry.npmjs.org/ast-v8-to-istanbul/-/ast-v8-to-istanbul-0.3.11.tgz",
      "integrity": "sha512-Qya9fkoofMjCBNVdWINMjB5KZvkYfaO9/anwkWnjxibpWUxo5iHl2sOdP7/uAqaRuUYuoo8rDwnbaaKVFxoUvw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/trace-mapping": "^0.3.31",
        "estree-walker": "^3.0.3",
        "js-tokens": "^10.0.0"
      }
    },
    "node_modules/ast-v8-to-istanbul/node_modules/js-tokens": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-10.0.0.tgz",
      "integrity": "sha512-lM/UBzQmfJRo9ABXbPWemivdCW8V2G8FHaHdypQaIy523snUjog0W71ayWXTjiR+ixeMyVHN2XcpnTd/liPg/Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/autoprefixer": {
      "version": "10.4.24",
      "resolved": "https://registry.npmjs.org/autoprefixer/-/autoprefixer-10.4.24.tgz",
      "integrity": "sha512-uHZg7N9ULTVbutaIsDRoUkoS8/h3bdsmVJYZ5l3wv8Cp/6UIIoRDm90hZ+BwxUj/hGBEzLxdHNSKuFpn8WOyZw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/autoprefixer"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "browserslist": "^4.28.1",
        "caniuse-lite": "^1.0.30001766",
        "fraction.js": "^5.3.4",
        "picocolors": "^1.1.1",
        "postcss-value-parser": "^4.2.0"
      },
      "bin": {
        "autoprefixer": "bin/autoprefixer"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      },
      "peerDependencies": {
        "postcss": "^8.1.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/baseline-browser-mapping": {
      "version": "2.9.19",
      "resolved": "https://registry.npmjs.org/baseline-browser-mapping/-/baseline-browser-mapping-2.9.19.tgz",
      "integrity": "sha512-ipDqC8FrAl/76p2SSWKSI+H9tFwm7vYqXQrItCuiVPt26Km0jS+NzSsBWAaBusvSbQcfJG+JitdMm+wZAgTYqg==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "baseline-browser-mapping": "dist/cli.js"
      }
    },
    "node_modules/bidi-js": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/bidi-js/-/bidi-js-1.0.3.tgz",
      "integrity": "sha512-RKshQI1R3YQ+n9YJz2QQ147P66ELpa1FQEg20Dk8oW9t2KgLbpDLLp9aGZ7y8WHSshDknG0bknqGw5/tyCs5tw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "require-from-string": "^2.0.2"
      }
    },
    "node_modules/binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/brace-expansion": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/browserslist": {
      "version": "4.28.1",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.28.1.tgz",
      "integrity": "sha512-ZC5Bd0LgJXgwGqUknZY/vkUQ04r8NXnJZ3yYi4vDmSiZmC/pdSN0NbNRPxZpbtO4uAfDUAFffO8IZoM3Gj8IkA==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "baseline-browser-mapping": "^2.9.0",
        "caniuse-lite": "^1.0.30001759",
        "electron-to-chromium": "^1.5.263",
        "node-releases": "^2.0.27",
        "update-browserslist-db": "^1.2.0"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/cac": {
      "version": "6.7.14",
      "resolved": "https://registry.npmjs.org/cac/-/cac-6.7.14.tgz",
      "integrity": "sha512-b6Ilus+c3RrdDk+JhLKUAQfzzgLEPy6wcXqS7f/xe1EETvsDP6GORG7SFuOs6cID5YkqchW/LXZbX5bc8j7ZcQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/camelcase-css": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/camelcase-css/-/camelcase-css-2.0.1.tgz",
      "integrity": "sha512-QOSvevhslijgYwRx6Rv7zKdMF8lbRmx+uQGx2+vDc+KI/eBnsy9kit5aj23AgGu3pa4t9AgwbnXWqS+iOY+2aA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001767",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001767.tgz",
      "integrity": "sha512-34+zUAMhSH+r+9eKmYG+k2Rpt8XttfE4yXAjoZvkAPs15xcYQhyBYdalJ65BzivAvGRMViEjy6oKr/S91loekQ==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chai": {
      "version": "5.3.3",
      "resolved": "https://registry.npmjs.org/chai/-/chai-5.3.3.tgz",
      "integrity": "sha512-4zNhdJD/iOjSH0A05ea+Ke6MU5mmpQcbQsSOkgdaUMJ9zTlDTD/GYlwohmIE2u0gaxHYiVHEn1Fw9mZ/ktJWgw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "assertion-error": "^2.0.1",
        "check-error": "^2.1.1",
        "deep-eql": "^5.0.1",
        "loupe": "^3.1.0",
        "pathval": "^2.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/check-error": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/check-error/-/check-error-2.1.3.tgz",
      "integrity": "sha512-PAJdDJusoxnwm1VwW07VWwUN1sl7smmC3OKggvndJFadxxDRyFJBX/ggnu/KE4kQAB7a3Dp8f/YXC1FlUprWmA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 16"
      }
    },
    "node_modules/chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/chokidar/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/class-variance-authority": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/class-variance-authority/-/class-variance-authority-0.7.1.tgz",
      "integrity": "sha512-Ka+9Trutv7G8M6WT6SeiRWz792K5qEqIGEGzXKhAE6xOWAY6pPH8U+9IY3oCMv6kqTmLsv7Xh/2w2RigkePMsg==",
      "license": "Apache-2.0",
      "dependencies": {
        "clsx": "^2.1.1"
      },
      "funding": {
        "url": "https://polar.sh/cva"
      }
    },
    "node_modules/clsx": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz",
      "integrity": "sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/commander": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/commander/-/commander-4.1.1.tgz",
      "integrity": "sha512-NOKm8xhkzAjzFx8B2v5OAHT+u5pRQc2UCa2Vq9jYL/31o2wi9mxBA7LIFs3sV5VSC49z6pEhfbMULvShKj26WA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/css-tree": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/css-tree/-/css-tree-3.1.0.tgz",
      "integrity": "sha512-0eW44TGN5SQXU1mWSkKwFstI/22X2bG1nYzZTYMAWjylYURhse752YgbE4Cx46AC+bAvI+/dYTPRk1LqSUnu6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "mdn-data": "2.12.2",
        "source-map-js": "^1.0.1"
      },
      "engines": {
        "node": "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0"
      }
    },
    "node_modules/css.escape": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/css.escape/-/css.escape-1.5.1.tgz",
      "integrity": "sha512-YUifsXXuknHlUsmlgyY0PKzgPOr7/FjCePfHNt0jxm83wHZi44VDMQ7/fGNkjY3/jV1MC+1CmZbaHzugyeRtpg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cssesc": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/cssesc/-/cssesc-3.0.0.tgz",
      "integrity": "sha512-/Tb/JcjK111nNScGob5MNtsntNM1aCNUDipB/TkwZFhyDrrE47SOx/18wF2bbjgc3ZzCSKW1T5nt5EbFoAz/Vg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "cssesc": "bin/cssesc"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/cssstyle": {
      "version": "5.3.7",
      "resolved": "https://registry.npmjs.org/cssstyle/-/cssstyle-5.3.7.tgz",
      "integrity": "sha512-7D2EPVltRrsTkhpQmksIu+LxeWAIEk6wRDMJ1qljlv+CKHJM+cJLlfhWIzNA44eAsHXSNe3+vO6DW1yCYx8SuQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@asamuzakjp/css-color": "^4.1.1",
        "@csstools/css-syntax-patches-for-csstree": "^1.0.21",
        "css-tree": "^3.1.0",
        "lru-cache": "^11.2.4"
      },
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/cssstyle/node_modules/lru-cache": {
      "version": "11.2.5",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-11.2.5.tgz",
      "integrity": "sha512-vFrFJkWtJvJnD5hg+hJvVE8Lh/TcMzKnTgCWmtBipwI5yLX/iX+5UB2tfuyODF5E7k9xEzMdYgGqaSb1c0c5Yw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "engines": {
        "node": "20 || >=22"
      }
    },
    "node_modules/csstype": {
      "version": "3.2.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.2.3.tgz",
      "integrity": "sha512-z1HGKcYy2xA8AGQfwrn0PAy+PB7X/GSj3UVJW9qKyn43xWa+gl5nXmU4qqLMRzWVLFC8KusUX8T/0kCiOYpAIQ==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/data-urls": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/data-urls/-/data-urls-7.0.0.tgz",
      "integrity": "sha512-23XHcCF+coGYevirZceTVD7NdJOqVn+49IHyxgszm+JIiHLoB2TkmPtsYkNWT1pvRSGkc35L6NHs0yHkN2SumA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "whatwg-mimetype": "^5.0.0",
        "whatwg-url": "^16.0.0"
      },
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=24.0.0"
      }
    },
    "node_modules/data-urls/node_modules/tr46": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-6.0.0.tgz",
      "integrity": "sha512-bLVMLPtstlZ4iMQHpFHTR7GAGj2jxi8Dg0s2h2MafAE4uSWF98FC/3MomU51iQAMf8/qDUbKWf5GxuvvVcXEhw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "punycode": "^2.3.1"
      },
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/data-urls/node_modules/webidl-conversions": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-8.0.1.tgz",
      "integrity": "sha512-BMhLD/Sw+GbJC21C/UgyaZX41nPt8bUTg+jWyDeg7e7YN4xOM05YPSIXceACnXVtqyEw/LMClUQMtMZ+PGGpqQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/data-urls/node_modules/whatwg-url": {
      "version": "16.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-16.0.0.tgz",
      "integrity": "sha512-9CcxtEKsf53UFwkSUZjG+9vydAsFO4lFHBpJUtjBcoJOCJpKnSJNwCw813zrYJHpCJ7sgfbtOe0V5Ku7Pa1XMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@exodus/bytes": "^1.11.0",
        "tr46": "^6.0.0",
        "webidl-conversions": "^8.0.1"
      },
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=24.0.0"
      }
    },
    "node_modules/date-fns": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/date-fns/-/date-fns-4.1.0.tgz",
      "integrity": "sha512-Ukq0owbQXxa/U3EGtsdVBkR1w7KOQ5gIBqdH2hkvknzZPYvBxb/aa6E8L7tmjFtkwZBu3UXBbjIgPo/Ez4xaNg==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/kossnocorp"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/decimal.js": {
      "version": "10.6.0",
      "resolved": "https://registry.npmjs.org/decimal.js/-/decimal.js-10.6.0.tgz",
      "integrity": "sha512-YpgQiITW3JXGntzdUmyUR1V812Hn8T1YVXhCu+wO3OpS4eU9l4YdD3qjyiKdV6mvV29zapkMeD390UVEf2lkUg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/deep-eql": {
      "version": "5.0.2",
      "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-5.0.2.tgz",
      "integrity": "sha512-h5k/5U50IJJFpzfL6nO9jaaumfjO/f2NjK/oYB2Djzm4p9L+3T9qWpZqZ2hAbLPuuYq9wrU08WQyBTL5GbPk5Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/dequal": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/dequal/-/dequal-2.0.3.tgz",
      "integrity": "sha512-0je+qPKHEMohvfRTCEo3CrPG6cAzAYgmzKyxRiYSSDkS6eGJdyVJm7WaYA5ECaAD9wLB2T4EEeymA5aFVcYXCA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/detect-node-es": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/detect-node-es/-/detect-node-es-1.1.0.tgz",
      "integrity": "sha512-ypdmJU/TbBby2Dxibuv7ZLW3Bs1QEmM7nHjEANfohJLvE0XVujisn1qPJcZxg+qDucsr+bP6fLD1rPS3AhJ7EQ==",
      "license": "MIT"
    },
    "node_modules/didyoumean": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/didyoumean/-/didyoumean-1.2.2.tgz",
      "integrity": "sha512-gxtyfqMg7GKyhQmb056K7M3xszy/myH8w+B4RT+QXBQsvAOdc3XymqDDPHx1BgPgsdAA5SIifona89YtRATDzw==",
      "dev": true,
      "license": "Apache-2.0"
    },
    "node_modules/dlv": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/dlv/-/dlv-1.1.3.tgz",
      "integrity": "sha512-+HlytyjlPKnIG8XuRG8WvmBP8xs8P71y+SKKS6ZXWoEgLuePxtDoUEiH7WkdePWrQ5JBpE6aoVqfZfJUQkjXwA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/dom-accessibility-api": {
      "version": "0.5.16",
      "resolved": "https://registry.npmjs.org/dom-accessibility-api/-/dom-accessibility-api-0.5.16.tgz",
      "integrity": "sha512-X7BJ2yElsnOJ30pZF4uIIDfBEVgF4XEBxL9Bxhy6dnrm5hkzqmsWHGTiHqRiITNhMyFLyAiWndIJP7Z1NTteDg==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/eastasianwidth": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.286",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.286.tgz",
      "integrity": "sha512-9tfDXhJ4RKFNerfjdCcZfufu49vg620741MNs26a9+bhLThdB+plgMeou98CAaHu/WATj2iHOOHTp1hWtABj2A==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/emoji-regex": {
      "version": "9.2.2",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/entities": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/entities/-/entities-6.0.1.tgz",
      "integrity": "sha512-aN97NXWF6AWBTahfVOIrB/NShkzi5H7F9r1s9mD3cDj4Ko5f2qhhVoYMibXF7GlLveb/D2ioWay8lxI97Ven3g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.12"
      },
      "funding": {
        "url": "https://github.com/fb55/entities?sponsor=1"
      }
    },
    "node_modules/es-module-lexer": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-1.7.0.tgz",
      "integrity": "sha512-jEQoCwk8hyb2AZziIOLhDqpm5+2ww5uIE6lkO/6jcOCusfk6LhMHpXXfBLXTZ7Ydyt0j4VoUQv6uGNYbdW+kBA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/esbuild": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.25.12.tgz",
      "integrity": "sha512-bbPBYYrtZbkt6Os6FiTLCTFxvq4tt3JKall1vRwshA3fdVztsLAatFaZobhkBC8/BrPetoa0oksYoKXoG4ryJg==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.25.12",
        "@esbuild/android-arm": "0.25.12",
        "@esbuild/android-arm64": "0.25.12",
        "@esbuild/android-x64": "0.25.12",
        "@esbuild/darwin-arm64": "0.25.12",
        "@esbuild/darwin-x64": "0.25.12",
        "@esbuild/freebsd-arm64": "0.25.12",
        "@esbuild/freebsd-x64": "0.25.12",
        "@esbuild/linux-arm": "0.25.12",
        "@esbuild/linux-arm64": "0.25.12",
        "@esbuild/linux-ia32": "0.25.12",
        "@esbuild/linux-loong64": "0.25.12",
        "@esbuild/linux-mips64el": "0.25.12",
        "@esbuild/linux-ppc64": "0.25.12",
        "@esbuild/linux-riscv64": "0.25.12",
        "@esbuild/linux-s390x": "0.25.12",
        "@esbuild/linux-x64": "0.25.12",
        "@esbuild/netbsd-arm64": "0.25.12",
        "@esbuild/netbsd-x64": "0.25.12",
        "@esbuild/openbsd-arm64": "0.25.12",
        "@esbuild/openbsd-x64": "0.25.12",
        "@esbuild/openharmony-arm64": "0.25.12",
        "@esbuild/sunos-x64": "0.25.12",
        "@esbuild/win32-arm64": "0.25.12",
        "@esbuild/win32-ia32": "0.25.12",
        "@esbuild/win32-x64": "0.25.12"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/estree-walker": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/estree-walker/-/estree-walker-3.0.3.tgz",
      "integrity": "sha512-7RUKfXgSMMkzt6ZuXmqapOurLGPPfgj6l9uRZ7lRGolvk0y2yocc35LdcxKC5PQZdn2DMqioAQ2NoWcrTKmm6g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "^1.0.0"
      }
    },
    "node_modules/expect-type": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/expect-type/-/expect-type-1.3.0.tgz",
      "integrity": "sha512-knvyeauYhqjOYvQ66MznSMs83wmHrCycNEN6Ao+2AeYEfxUIkuiVxdEa1qlGEPK+We3n0THiDciYSsCcgW/DoA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/fast-glob": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.3.tgz",
      "integrity": "sha512-7MptL8U0cqcFdzIzwOTHoilX9x5BrNqye7Z/LuC7kCMRio1EMSyqRK3BEAUD7sXRq4iT4AzTVuZdhgQ2TCvYLg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.2",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.8"
      },
      "engines": {
        "node": ">=8.6.0"
      }
    },
    "node_modules/fast-glob/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fastq": {
      "version": "1.20.1",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.20.1.tgz",
      "integrity": "sha512-GGToxJ/w1x32s/D2EKND7kTil4n8OVk/9mycTc4VDza13lOvpUZTGX3mFSCtV9ksdGBVzvsyAVLM6mHFThxXxw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "reusify": "^1.0.4"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/foreground-child": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "cross-spawn": "^7.0.6",
        "signal-exit": "^4.0.1"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/fraction.js": {
      "version": "5.3.4",
      "resolved": "https://registry.npmjs.org/fraction.js/-/fraction.js-5.3.4.tgz",
      "integrity": "sha512-1X1NTtiJphryn/uLQz3whtY6jK3fTqoE3ohKs0tT+Ujr1W59oopxmoEh7Lu5p6vBaPbgoM0bzveAW4Qi5RyWDQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "*"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/rawify"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/get-nonce": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-nonce/-/get-nonce-1.0.1.tgz",
      "integrity": "sha512-FJhYRoDaiatfEkUK8HKlicmu/3SGFD51q3itKDGoSTysQJBnfOcxU5GxnhE1E6soB76MbT0MBtnKJuXyAx+96Q==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/glob": {
      "version": "10.5.0",
      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
      "deprecated": "Old versions of glob are not supported, and contain widely publicized security vulnerabilities, which have been fixed in the current version. Please update. Support for old versions may be purchased (at exorbitant rates) by contacting i@izs.me",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "foreground-child": "^3.1.0",
        "jackspeak": "^3.1.2",
        "minimatch": "^9.0.4",
        "minipass": "^7.1.2",
        "package-json-from-dist": "^1.0.0",
        "path-scurry": "^1.11.1"
      },
      "bin": {
        "glob": "dist/esm/bin.mjs"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/html-encoding-sniffer": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/html-encoding-sniffer/-/html-encoding-sniffer-6.0.0.tgz",
      "integrity": "sha512-CV9TW3Y3f8/wT0BRFc1/KAVQ3TUHiXmaAb6VW9vtiMFf7SLoMd1PdAc4W3KFOFETBJUb90KatHqlsZMWV+R9Gg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@exodus/bytes": "^1.6.0"
      },
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=24.0.0"
      }
    },
    "node_modules/html-escaper": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/http-proxy-agent": {
      "version": "7.0.2",
      "resolved": "https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-7.0.2.tgz",
      "integrity": "sha512-T1gkAiYYDWYx3V5Bmyu7HcfcvL7mUrTWiM6yOfa3PIphViJ/gFPbvidQ+veqSOHci/PxBcDabeUNCzpOODJZig==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.0",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/https-proxy-agent": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-7.0.6.tgz",
      "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.2",
        "debug": "4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/indent-string": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/indent-string/-/indent-string-4.0.0.tgz",
      "integrity": "sha512-EdDDZu4A2OyIK7Lr/2zG+w5jmbuk1DVBnEwREQvBzspBJkCEbRa8GxU1lghYcaGJCnRWibjDXlq779X1/y5xwg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-potential-custom-element-name": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/is-potential-custom-element-name/-/is-potential-custom-element-name-1.0.1.tgz",
      "integrity": "sha512-bCYeRA2rVibKZd+s2625gGnGF/t7DSqDs4dP7CrLA1m7jKWz6pps0LpYLJN8Q64HtmPKJ1hrN3nzPNKFEKOUiQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/istanbul-lib-coverage": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/istanbul-lib-report": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "istanbul-lib-coverage": "^3.0.0",
        "make-dir": "^4.0.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-lib-source-maps": {
      "version": "5.0.6",
      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@jridgewell/trace-mapping": "^0.3.23",
        "debug": "^4.1.1",
        "istanbul-lib-coverage": "^3.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-reports": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "html-escaper": "^2.0.0",
        "istanbul-lib-report": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/jackspeak": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "@isaacs/cliui": "^8.0.2"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      },
      "optionalDependencies": {
        "@pkgjs/parseargs": "^0.11.0"
      }
    },
    "node_modules/jiti": {
      "version": "1.21.7",
      "resolved": "https://registry.npmjs.org/jiti/-/jiti-1.21.7.tgz",
      "integrity": "sha512-/imKNG4EbWNrVjoNC/1H5/9GFy+tqjGBHCaSsN+P2RnPqjsLmv6UD3Ej+Kj8nBWaRAwyk7kK5ZUc+OEatnTR3A==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jiti": "bin/jiti.js"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/jsdom": {
      "version": "28.0.0",
      "resolved": "https://registry.npmjs.org/jsdom/-/jsdom-28.0.0.tgz",
      "integrity": "sha512-KDYJgZ6T2TKdU8yBfYueq5EPG/EylMsBvCaenWMJb2OXmjgczzwveRCoJ+Hgj1lXPDyasvrgneSn4GBuR1hYyA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@acemir/cssom": "^0.9.31",
        "@asamuzakjp/dom-selector": "^6.7.6",
        "@exodus/bytes": "^1.11.0",
        "cssstyle": "^5.3.7",
        "data-urls": "^7.0.0",
        "decimal.js": "^10.6.0",
        "html-encoding-sniffer": "^6.0.0",
        "http-proxy-agent": "^7.0.2",
        "https-proxy-agent": "^7.0.6",
        "is-potential-custom-element-name": "^1.0.1",
        "parse5": "^8.0.0",
        "saxes": "^6.0.0",
        "symbol-tree": "^3.2.4",
        "tough-cookie": "^6.0.0",
        "undici": "^7.20.0",
        "w3c-xmlserializer": "^5.0.0",
        "webidl-conversions": "^8.0.1",
        "whatwg-mimetype": "^5.0.0",
        "whatwg-url": "^16.0.0",
        "xml-name-validator": "^5.0.0"
      },
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=24.0.0"
      },
      "peerDependencies": {
        "canvas": "^3.0.0"
      },
      "peerDependenciesMeta": {
        "canvas": {
          "optional": true
        }
      }
    },
    "node_modules/jsdom/node_modules/tr46": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-6.0.0.tgz",
      "integrity": "sha512-bLVMLPtstlZ4iMQHpFHTR7GAGj2jxi8Dg0s2h2MafAE4uSWF98FC/3MomU51iQAMf8/qDUbKWf5GxuvvVcXEhw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "punycode": "^2.3.1"
      },
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/jsdom/node_modules/webidl-conversions": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-8.0.1.tgz",
      "integrity": "sha512-BMhLD/Sw+GbJC21C/UgyaZX41nPt8bUTg+jWyDeg7e7YN4xOM05YPSIXceACnXVtqyEw/LMClUQMtMZ+PGGpqQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/jsdom/node_modules/whatwg-url": {
      "version": "16.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-16.0.0.tgz",
      "integrity": "sha512-9CcxtEKsf53UFwkSUZjG+9vydAsFO4lFHBpJUtjBcoJOCJpKnSJNwCw813zrYJHpCJ7sgfbtOe0V5Ku7Pa1XMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@exodus/bytes": "^1.11.0",
        "tr46": "^6.0.0",
        "webidl-conversions": "^8.0.1"
      },
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=24.0.0"
      }
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/lilconfig": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/lilconfig/-/lilconfig-3.1.3.tgz",
      "integrity": "sha512-/vlFKAoH5Cgt3Ie+JLhRbwOsCQePABiU3tJ1egGvyQ+33R/vcwM2Zl2QR/LzjsBeItPt3oSVXapn+m4nQDvpzw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/antonk52"
      }
    },
    "node_modules/lines-and-columns": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
      "integrity": "sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/loupe": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/loupe/-/loupe-3.2.1.tgz",
      "integrity": "sha512-CdzqowRJCeLU72bHvWqwRBBlLcMEtIvGrlvef74kMnV2AolS9Y8xUv1I0U/MNAWMhBlKIoyuEgoJ0t/bbwHbLQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/lucide-react": {
      "version": "0.542.0",
      "resolved": "https://registry.npmjs.org/lucide-react/-/lucide-react-0.542.0.tgz",
      "integrity": "sha512-w3hD8/SQB7+lzU2r4VdFyzzOzKnUjTZIF/MQJGSSvni7Llewni4vuViRppfRAa2guOsY5k4jZyxw/i9DQHv+dw==",
      "license": "ISC",
      "peerDependencies": {
        "react": "^16.5.1 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/lz-string": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/lz-string/-/lz-string-1.5.0.tgz",
      "integrity": "sha512-h5bgJWpxJNswbU7qCrV0tIKQCaS3blPDrqKWx+QxzuzL1zGUzij9XCWLrSLsJPu5t+eWA/ycetzYAO5IOMcWAQ==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "bin": {
        "lz-string": "bin/bin.js"
      }
    },
    "node_modules/magic-string": {
      "version": "0.27.0",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.27.0.tgz",
      "integrity": "sha512-8UnnX2PeRAPZuN12svgR9j7M1uWMovg/CEnIwIG0LFkXSJJe4PdfUGiTGl8V9bsBHFUtfVINcSyYxd7q+kx9fA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.4.13"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/magicast": {
      "version": "0.3.5",
      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.25.4",
        "@babel/types": "^7.25.4",
        "source-map-js": "^1.2.0"
      }
    },
    "node_modules/make-dir": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/make-dir/node_modules/semver": {
      "version": "7.7.4",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.4.tgz",
      "integrity": "sha512-vFKC2IEtQnVhpT78h1Yp8wzwrf8CM+MzKMHGJZfBtzhZNycRFnXsHk6E5TxIkkMsgNS7mdX3AGB7x2QM2di4lA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/mdn-data": {
      "version": "2.12.2",
      "resolved": "https://registry.npmjs.org/mdn-data/-/mdn-data-2.12.2.tgz",
      "integrity": "sha512-IEn+pegP1aManZuckezWCO+XZQDplx1366JoVhTpMpBB1sPey/SbveZQUosKiKiGYjg1wH4pMlNgXbCiYgihQA==",
      "dev": true,
      "license": "CC0-1.0"
    },
    "node_modules/merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/micromatch": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "braces": "^3.0.3",
        "picomatch": "^2.3.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/min-indent": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/min-indent/-/min-indent-1.0.1.tgz",
      "integrity": "sha512-I9jwMn07Sy/IwOj3zVkVik2JTvgpaykDZEigL6Rx6N9LbMywwUSMtxET+7lVoDLLd3O3IXwJwvuuns8UB/HeAg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/minimatch": {
      "version": "9.0.5",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
      "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/minipass": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=16 || 14 >=14.17"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/mz": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/mz/-/mz-2.7.0.tgz",
      "integrity": "sha512-z81GNO7nnYMEhrGh9LeymoE4+Yr0Wn5McHIZMK5cfQCl+NDX08sCZgUc9/6MHni9IWuFLm1Z3HTCXu2z9fN62Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "any-promise": "^1.0.0",
        "object-assign": "^4.0.1",
        "thenify-all": "^1.0.0"
      }
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/node-releases": {
      "version": "2.0.27",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.27.tgz",
      "integrity": "sha512-nmh3lCkYZ3grZvqcCH+fjmQ7X+H0OeZgP40OierEaAptX4XofMh5kwNbWh7lBduUzCcV/8kZ+NDLCwm2iorIlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-hash": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/object-hash/-/object-hash-3.0.0.tgz",
      "integrity": "sha512-RSn9F68PjH9HqtltsSnqYC1XXoWe9Bju5+213R98cNGttag9q9yAOTzdbsqvIa7aNm5WffBZFpWYr2aWrklWAw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/package-json-from-dist": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
      "dev": true,
      "license": "BlueOak-1.0.0"
    },
    "node_modules/parse5": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/parse5/-/parse5-8.0.0.tgz",
      "integrity": "sha512-9m4m5GSgXjL4AjumKzq1Fgfp3Z8rsvjRNbnkVwfu2ImRqE5D0LnY2QfDen18FSY9C573YU5XxSapdHZTZ2WolA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "entities": "^6.0.0"
      },
      "funding": {
        "url": "https://github.com/inikulin/parse5?sponsor=1"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/path-scurry": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "lru-cache": "^10.2.0",
        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
      },
      "engines": {
        "node": ">=16 || 14 >=14.18"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/path-scurry/node_modules/lru-cache": {
      "version": "10.4.3",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/pathe": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/pathe/-/pathe-2.0.3.tgz",
      "integrity": "sha512-WUjGcAqP1gQacoQe+OBJsFA7Ld4DyXuUIjZ5cc75cLHvJ7dtNsTugphxIADwspS+AraAUePCKrSVtPLFj/F88w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/pathval": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/pathval/-/pathval-2.0.1.tgz",
      "integrity": "sha512-//nshmD55c46FuFw26xV/xFAaB5HF9Xdap7HJBBnrKdAd6/GxDBaNA1870O79+9ueg61cZLSVc+OaFlfmObYVQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 14.16"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/pify": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/pify/-/pify-2.3.0.tgz",
      "integrity": "sha512-udgsAY+fTnvv7kI7aaxbqwWNb0AHiB0qBO89PZKPkoTmGOgdbrHDKD+0B2X4uTfJ/FT1R09r9gTsjUjNJotuog==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/pirates": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/pirates/-/pirates-4.0.7.tgz",
      "integrity": "sha512-TfySrs/5nm8fQJDcBDuUng3VOUKsd7S+zqvbOTiGXHfxX4wK31ard+hoNuvkicM/2YFzlpDgABOevKSsB4G/FA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/postcss-import": {
      "version": "15.1.0",
      "resolved": "https://registry.npmjs.org/postcss-import/-/postcss-import-15.1.0.tgz",
      "integrity": "sha512-hpr+J05B2FVYUAXHeK1YyI267J/dDDhMU6B6civm8hSY1jYJnBXxzKDKDswzJmtLHryrjhnDjqqp/49t8FALew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "postcss-value-parser": "^4.0.0",
        "read-cache": "^1.0.0",
        "resolve": "^1.1.7"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "peerDependencies": {
        "postcss": "^8.0.0"
      }
    },
    "node_modules/postcss-js": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/postcss-js/-/postcss-js-4.1.0.tgz",
      "integrity": "sha512-oIAOTqgIo7q2EOwbhb8UalYePMvYoIeRY2YKntdpFQXNosSu3vLrniGgmH9OKs/qAkfoj5oB3le/7mINW1LCfw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "camelcase-css": "^2.0.1"
      },
      "engines": {
        "node": "^12 || ^14 || >= 16"
      },
      "peerDependencies": {
        "postcss": "^8.4.21"
      }
    },
    "node_modules/postcss-load-config": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/postcss-load-config/-/postcss-load-config-6.0.1.tgz",
      "integrity": "sha512-oPtTM4oerL+UXmx+93ytZVN82RrlY/wPUV8IeDxFrzIjXOLF1pN+EmKPLbubvKHT2HC20xXsCAH2Z+CKV6Oz/g==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "lilconfig": "^3.1.1"
      },
      "engines": {
        "node": ">= 18"
      },
      "peerDependencies": {
        "jiti": ">=1.21.0",
        "postcss": ">=8.0.9",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        },
        "postcss": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/postcss-nested": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/postcss-nested/-/postcss-nested-6.2.0.tgz",
      "integrity": "sha512-HQbt28KulC5AJzG+cZtj9kvKB93CFCdLvog1WFLf1D+xmMvPGlBstkpTEZfK5+AN9hfJocyBFCNiqyS48bpgzQ==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "postcss-selector-parser": "^6.1.1"
      },
      "engines": {
        "node": ">=12.0"
      },
      "peerDependencies": {
        "postcss": "^8.2.14"
      }
    },
    "node_modules/postcss-selector-parser": {
      "version": "6.1.2",
      "resolved": "https://registry.npmjs.org/postcss-selector-parser/-/postcss-selector-parser-6.1.2.tgz",
      "integrity": "sha512-Q8qQfPiZ+THO/3ZrOrO0cJJKfpYCagtMUkXbnEfmgUjwXg6z/WBeOyS9APBBPCTSiDV+s4SwQGu8yFsiMRIudg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cssesc": "^3.0.0",
        "util-deprecate": "^1.0.2"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/postcss-value-parser": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-4.2.0.tgz",
      "integrity": "sha512-1NNCs6uurfkVbeXG4S8JFT9t19m45ICnif8zWLd5oPSZ50QnwMfK+H3jv408d4jw/7Bttv5axS5IiHoLaVNHeQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/pretty-format": {
      "version": "27.5.1",
      "resolved": "https://registry.npmjs.org/pretty-format/-/pretty-format-27.5.1.tgz",
      "integrity": "sha512-Qb1gy5OrP5+zDf2Bvnzdl3jsTf1qXVMazbvCoKhtKqVs4/YK4ozX4gKQJJVyNe+cajNPn0KoC0MC3FUmaHWEmQ==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "dependencies": {
        "ansi-regex": "^5.0.1",
        "ansi-styles": "^5.0.0",
        "react-is": "^17.0.1"
      },
      "engines": {
        "node": "^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"
      }
    },
    "node_modules/pretty-format/node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/pretty-format/node_modules/ansi-styles": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-5.2.0.tgz",
      "integrity": "sha512-Cxwpt2SfTzTtXcfOlzGEee8O+c+MmUgGrNiBcXnuWxuFJHe6a5Hz7qwhwe5OgaSYI0IJvkLqWX1ASG+cJOkEiA==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/react": {
      "version": "19.2.0",
      "resolved": "https://registry.npmjs.org/react/-/react-19.2.0.tgz",
      "integrity": "sha512-tmbWg6W31tQLeB5cdIBOicJDJRR2KzXsV7uSK9iNfLWQ5bIZfxuPEHp7M8wiHyHnn0DD1i7w3Zmin0FtkrwoCQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.2.0",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.2.0.tgz",
      "integrity": "sha512-UlbRu4cAiGaIewkPyiRGJk0imDN2T3JjieT6spoL2UeSf5od4n5LB/mQ4ejmxhCFT1tYe8IvaFulzynWovsEFQ==",
      "license": "MIT",
      "dependencies": {
        "scheduler": "^0.27.0"
      },
      "peerDependencies": {
        "react": "^19.2.0"
      }
    },
    "node_modules/react-is": {
      "version": "17.0.2",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-17.0.2.tgz",
      "integrity": "sha512-w2GsyukL62IJnlaff/nRegPQR94C/XXamvMWmSHRJ4y7Ts/4ocGRmTHvOs8PSE6pB3dWOrD/nueuU5sduBsQ4w==",
      "dev": true,
      "license": "MIT",
      "peer": true
    },
    "node_modules/react-refresh": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/react-refresh/-/react-refresh-0.17.0.tgz",
      "integrity": "sha512-z6F7K9bV85EfseRCp2bzrpyQ0Gkw1uLoCel9XBVWPg/TjRj94SkJzUTGfOa4bs7iJvBWtQG0Wq7wnI0syw3EBQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-remove-scroll": {
      "version": "2.7.2",
      "resolved": "https://registry.npmjs.org/react-remove-scroll/-/react-remove-scroll-2.7.2.tgz",
      "integrity": "sha512-Iqb9NjCCTt6Hf+vOdNIZGdTiH1QSqr27H/Ek9sv/a97gfueI/5h1s3yRi1nngzMUaOOToin5dI1dXKdXiF+u0Q==",
      "license": "MIT",
      "dependencies": {
        "react-remove-scroll-bar": "^2.3.7",
        "react-style-singleton": "^2.2.3",
        "tslib": "^2.1.0",
        "use-callback-ref": "^1.3.3",
        "use-sidecar": "^1.1.3"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/react-remove-scroll-bar": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/react-remove-scroll-bar/-/react-remove-scroll-bar-2.3.8.tgz",
      "integrity": "sha512-9r+yi9+mgU33AKcj6IbT9oRCO78WriSj6t/cF8DWBZJ9aOGPOTEDvdUDz1FwKim7QXWwmHqtdHnRJfhAxEG46Q==",
      "license": "MIT",
      "dependencies": {
        "react-style-singleton": "^2.2.2",
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/react-style-singleton": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/react-style-singleton/-/react-style-singleton-2.2.3.tgz",
      "integrity": "sha512-b6jSvxvVnyptAiLjbkWLE/lOnR4lfTtDAl+eUC7RZy+QQWc6wRzIV2CE6xBuMmDxc2qIihtDCZD5NPOFl7fRBQ==",
      "license": "MIT",
      "dependencies": {
        "get-nonce": "^1.0.0",
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/read-cache": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/read-cache/-/read-cache-1.0.0.tgz",
      "integrity": "sha512-Owdv/Ft7IjOgm/i0xvNDZ1LrRANRfew4b2prF3OWMQLxLfu3bS8FVhCsrSCMK4lR56Y9ya+AThoTpDCTxCmpRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "pify": "^2.3.0"
      }
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/redent": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/redent/-/redent-3.0.0.tgz",
      "integrity": "sha512-6tDA8g98We0zd0GvVeMT9arEOnTw9qM03L9cJXaCjrip1OO764RDBLBfrB4cwzNGDj5OA5ioymC9GkizgWJDUg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "indent-string": "^4.0.0",
        "strip-indent": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/require-from-string": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
      "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/resolve": {
      "version": "1.22.11",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.11.tgz",
      "integrity": "sha512-RfqAvLnMl313r7c9oclB1HhUEAezcpLjz95wFH4LVuhk9JF/r22qmVP9AMmOU4vMX7Q8pN8jwNg/CSpdFnMjTQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.1",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/reusify": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.1.0.tgz",
      "integrity": "sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "iojs": ">=1.0.0",
        "node": ">=0.10.0"
      }
    },
    "node_modules/rollup": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.57.1.tgz",
      "integrity": "sha512-oQL6lgK3e2QZeQ7gcgIkS2YZPg5slw37hYufJ3edKlfQSGGm8ICoxswK15ntSzF/a8+h7ekRy7k7oWc3BQ7y8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.57.1",
        "@rollup/rollup-android-arm64": "4.57.1",
        "@rollup/rollup-darwin-arm64": "4.57.1",
        "@rollup/rollup-darwin-x64": "4.57.1",
        "@rollup/rollup-freebsd-arm64": "4.57.1",
        "@rollup/rollup-freebsd-x64": "4.57.1",
        "@rollup/rollup-linux-arm-gnueabihf": "4.57.1",
        "@rollup/rollup-linux-arm-musleabihf": "4.57.1",
        "@rollup/rollup-linux-arm64-gnu": "4.57.1",
        "@rollup/rollup-linux-arm64-musl": "4.57.1",
        "@rollup/rollup-linux-loong64-gnu": "4.57.1",
        "@rollup/rollup-linux-loong64-musl": "4.57.1",
        "@rollup/rollup-linux-ppc64-gnu": "4.57.1",
        "@rollup/rollup-linux-ppc64-musl": "4.57.1",
        "@rollup/rollup-linux-riscv64-gnu": "4.57.1",
        "@rollup/rollup-linux-riscv64-musl": "4.57.1",
        "@rollup/rollup-linux-s390x-gnu": "4.57.1",
        "@rollup/rollup-linux-x64-gnu": "4.57.1",
        "@rollup/rollup-linux-x64-musl": "4.57.1",
        "@rollup/rollup-openbsd-x64": "4.57.1",
        "@rollup/rollup-openharmony-arm64": "4.57.1",
        "@rollup/rollup-win32-arm64-msvc": "4.57.1",
        "@rollup/rollup-win32-ia32-msvc": "4.57.1",
        "@rollup/rollup-win32-x64-gnu": "4.57.1",
        "@rollup/rollup-win32-x64-msvc": "4.57.1",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "queue-microtask": "^1.2.2"
      }
    },
    "node_modules/saxes": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/saxes/-/saxes-6.0.0.tgz",
      "integrity": "sha512-xAg7SOnEhrm5zI3puOOKyy1OMcMlIJZYNJY7xLBwSze0UjhPLnWfj2GF2EpT0jmzaJKIWKHLsaSSajf35bcYnA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "xmlchars": "^2.2.0"
      },
      "engines": {
        "node": ">=v12.22.7"
      }
    },
    "node_modules/scheduler": {
      "version": "0.27.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.27.0.tgz",
      "integrity": "sha512-eNv+WrVbKu1f3vbYJT/xtiF5syA5HPIMtf9IgY/nKg0sWqzAUEvqY/xm7OcZc/qafLx/iO9FgOmeSAp4v5ti/Q==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/siginfo": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/siginfo/-/siginfo-2.0.0.tgz",
      "integrity": "sha512-ybx0WO1/8bSBLEWXZvEd7gMW3Sn3JFlW3TvX1nREbDLRNQNaeNN8WK0meBwPdAaOI7TtRRRJn/Es1zhrrCHu7g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/signal-exit": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/stackback": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/stackback/-/stackback-0.0.2.tgz",
      "integrity": "sha512-1XMJE5fQo1jGH6Y/7ebnwPOBEkIEnT4QF32d5R1+VXdXveM0IBMJt8zfaxX1P3QhVwrYe+576+jkANtSS2mBbw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/std-env": {
      "version": "3.10.0",
      "resolved": "https://registry.npmjs.org/std-env/-/std-env-3.10.0.tgz",
      "integrity": "sha512-5GS12FdOZNliM5mAOxFRg7Ir0pWz8MdpYm6AY6VPkGpbA7ZzmbzNcBJQ0GPvvyWgcY7QAhCgf9Uy89I03faLkg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/string-width": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eastasianwidth": "^0.2.0",
        "emoji-regex": "^9.2.2",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/string-width-cjs": {
      "name": "string-width",
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/string-width-cjs/node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/string-width-cjs/node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/string-width-cjs/node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/strip-ansi-cjs": {
      "name": "strip-ansi",
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi-cjs/node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-indent": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/strip-indent/-/strip-indent-3.0.0.tgz",
      "integrity": "sha512-laJTa3Jb+VQpaC6DseHhF7dXVqHTfJPCRDaEbid/drOhgitgYku/letMUqOXFoWV0zIIUbjpdH2t+tYj4bQMRQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "min-indent": "^1.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-literal": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/strip-literal/-/strip-literal-3.1.0.tgz",
      "integrity": "sha512-8r3mkIM/2+PpjHoOtiAW8Rg3jJLHaV7xPwG+YRGrv6FP0wwk/toTpATxWYOW0BKdWwl82VT2tFYi5DlROa0Mxg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "js-tokens": "^9.0.1"
      },
      "funding": {
        "url": "https://github.com/sponsors/antfu"
      }
    },
    "node_modules/strip-literal/node_modules/js-tokens": {
      "version": "9.0.1",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-9.0.1.tgz",
      "integrity": "sha512-mxa9E9ITFOt0ban3j6L5MpjwegGz6lBQmM1IJkWeBZGcMxto50+eWdjC/52xDbS2vy0k7vIMK0Fe2wfL9OQSpQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/sucrase": {
      "version": "3.35.1",
      "resolved": "https://registry.npmjs.org/sucrase/-/sucrase-3.35.1.tgz",
      "integrity": "sha512-DhuTmvZWux4H1UOnWMB3sk0sbaCVOoQZjv8u1rDoTV0HTdGem9hkAZtl4JZy8P2z4Bg0nT+YMeOFyVr4zcG5Tw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.2",
        "commander": "^4.0.0",
        "lines-and-columns": "^1.1.6",
        "mz": "^2.7.0",
        "pirates": "^4.0.1",
        "tinyglobby": "^0.2.11",
        "ts-interface-checker": "^0.1.9"
      },
      "bin": {
        "sucrase": "bin/sucrase",
        "sucrase-node": "bin/sucrase-node"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/symbol-tree": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/symbol-tree/-/symbol-tree-3.2.4.tgz",
      "integrity": "sha512-9QNk5KwDF+Bvz+PyObkmSYjI5ksVUYtjW7AU22r2NKcfLJcXp96hkDWU3+XndOsUb+AQ9QhfzfCT2O+CNWT5Tw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tailwind-merge": {
      "version": "3.4.0",
      "resolved": "https://registry.npmjs.org/tailwind-merge/-/tailwind-merge-3.4.0.tgz",
      "integrity": "sha512-uSaO4gnW+b3Y2aWoWfFpX62vn2sR3skfhbjsEnaBI81WD1wBLlHZe5sWf0AqjksNdYTbGBEd0UasQMT3SNV15g==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/dcastil"
      }
    },
    "node_modules/tailwindcss": {
      "version": "3.4.19",
      "resolved": "https://registry.npmjs.org/tailwindcss/-/tailwindcss-3.4.19.tgz",
      "integrity": "sha512-3ofp+LL8E+pK/JuPLPggVAIaEuhvIz4qNcf3nA1Xn2o/7fb7s/TYpHhwGDv1ZU3PkBluUVaF8PyCHcm48cKLWQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@alloc/quick-lru": "^5.2.0",
        "arg": "^5.0.2",
        "chokidar": "^3.6.0",
        "didyoumean": "^1.2.2",
        "dlv": "^1.1.3",
        "fast-glob": "^3.3.2",
        "glob-parent": "^6.0.2",
        "is-glob": "^4.0.3",
        "jiti": "^1.21.7",
        "lilconfig": "^3.1.3",
        "micromatch": "^4.0.8",
        "normalize-path": "^3.0.0",
        "object-hash": "^3.0.0",
        "picocolors": "^1.1.1",
        "postcss": "^8.4.47",
        "postcss-import": "^15.1.0",
        "postcss-js": "^4.0.1",
        "postcss-load-config": "^4.0.2 || ^5.0 || ^6.0",
        "postcss-nested": "^6.2.0",
        "postcss-selector-parser": "^6.1.2",
        "resolve": "^1.22.8",
        "sucrase": "^3.35.0"
      },
      "bin": {
        "tailwind": "lib/cli.js",
        "tailwindcss": "lib/cli.js"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/tailwindcss-animate": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/tailwindcss-animate/-/tailwindcss-animate-1.0.7.tgz",
      "integrity": "sha512-bl6mpH3T7I3UFxuvDEXLxy/VuFxBk5bbzplh7tXI68mwMokNYd1t9qPBHlnyTwfa4JGC4zP516I1hYYtQ/vspA==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "tailwindcss": ">=3.0.0 || insiders"
      }
    },
    "node_modules/test-exclude": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "@istanbuljs/schema": "^0.1.2",
        "glob": "^10.4.1",
        "minimatch": "^9.0.4"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/thenify": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/thenify/-/thenify-3.3.1.tgz",
      "integrity": "sha512-RVZSIV5IG10Hk3enotrhvz0T9em6cyHBLkH/YAZuKqd8hRkKhSfCGIcP2KUY0EPxndzANBmNllzWPwak+bheSw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "any-promise": "^1.0.0"
      }
    },
    "node_modules/thenify-all": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/thenify-all/-/thenify-all-1.6.0.tgz",
      "integrity": "sha512-RNxQH/qI8/t3thXJDwcstUO4zeqo64+Uy/+sNVRBx4Xn2OX+OZ9oP+iJnNFqplFra2ZUVeKCSa2oVWi3T4uVmA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "thenify": ">= 3.1.0 < 4"
      },
      "engines": {
        "node": ">=0.8"
      }
    },
    "node_modules/tinybench": {
      "version": "2.9.0",
      "resolved": "https://registry.npmjs.org/tinybench/-/tinybench-2.9.0.tgz",
      "integrity": "sha512-0+DUvqWMValLmha6lr4kD8iAMK1HzV0/aKnCtWb9v9641TnP/MFb7Pc2bxoxQjTXAErryXVgUOfv2YqNllqGeg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinyexec": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/tinyexec/-/tinyexec-0.3.2.tgz",
      "integrity": "sha512-KQQR9yN7R5+OSwaK0XQoj22pwHoTlgYqmUscPYoknOoWCWfj/5/ABTMRi69FrKU5ffPVh5QcFikpWJI/P1ocHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinyglobby": {
      "version": "0.2.15",
      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.15.tgz",
      "integrity": "sha512-j2Zq4NyQYG5XMST4cbs02Ak8iJUdxRM0XI5QyxXuZOzKOINmWurp3smXu3y5wDcJrptwpSjgXHzIQxR0omXljQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/SuperchupuDev"
      }
    },
    "node_modules/tinyglobby/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/tinyglobby/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/tinypool": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/tinypool/-/tinypool-1.1.1.tgz",
      "integrity": "sha512-Zba82s87IFq9A9XmjiX5uZA/ARWDrB03OHlq+Vw1fSdt0I+4/Kutwy8BP4Y/y/aORMo61FQ0vIb5j44vSo5Pkg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      }
    },
    "node_modules/tinyrainbow": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/tinyrainbow/-/tinyrainbow-2.0.0.tgz",
      "integrity": "sha512-op4nsTR47R6p0vMUUoYl/a+ljLFVtlfaXkLQmqfLR1qHma1h/ysYk4hEXZ880bf2CYgTskvTa/e196Vd5dDQXw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/tinyspy": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/tinyspy/-/tinyspy-4.0.4.tgz",
      "integrity": "sha512-azl+t0z7pw/z958Gy9svOTuzqIk6xq+NSheJzn5MMWtWTFywIacg2wUlzKFGtt3cthx0r2SxMK0yzJOR0IES7Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/tldts": {
      "version": "7.0.23",
      "resolved": "https://registry.npmjs.org/tldts/-/tldts-7.0.23.tgz",
      "integrity": "sha512-ASdhgQIBSay0R/eXggAkQ53G4nTJqTXqC2kbaBbdDwM7SkjyZyO0OaaN1/FH7U/yCeqOHDwFO5j8+Os/IS1dXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tldts-core": "^7.0.23"
      },
      "bin": {
        "tldts": "bin/cli.js"
      }
    },
    "node_modules/tldts-core": {
      "version": "7.0.23",
      "resolved": "https://registry.npmjs.org/tldts-core/-/tldts-core-7.0.23.tgz",
      "integrity": "sha512-0g9vrtDQLrNIiCj22HSe9d4mLVG3g5ph5DZ8zCKBr4OtrspmNB6ss7hVyzArAeE88ceZocIEGkyW1Ime7fxPtQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/tough-cookie": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-6.0.0.tgz",
      "integrity": "sha512-kXuRi1mtaKMrsLUxz3sQYvVl37B0Ns6MzfrtV5DvJceE9bPyspOqk9xxv7XbZWcfLWbFmm997vl83qUWVJA64w==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "tldts": "^7.0.5"
      },
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/ts-interface-checker": {
      "version": "0.1.13",
      "resolved": "https://registry.npmjs.org/ts-interface-checker/-/ts-interface-checker-0.1.13.tgz",
      "integrity": "sha512-Y/arvbn+rrz3JCKl9C4kVNfTfSm2/mEp5FSz5EsZSANGPSlQrpRI5M4PKF+mJnE52jOO90PnPSc3Ur3bTQw0gA==",
      "dev": true,
      "license": "Apache-2.0"
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/typescript": {
      "version": "5.9.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
      "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici": {
      "version": "7.21.0",
      "resolved": "https://registry.npmjs.org/undici/-/undici-7.21.0.tgz",
      "integrity": "sha512-Hn2tCQpoDt1wv23a68Ctc8Cr/BHpUSfaPYrkajTXOS9IKpxVRx/X5m1K2YkbK2ipgZgxXSgsUinl3x+2YdSSfg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=20.18.1"
      }
    },
    "node_modules/update-browserslist-db": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.2.3.tgz",
      "integrity": "sha512-Js0m9cx+qOgDxo0eMiFGEueWztz+d4+M3rGlmKPT+T4IS/jP4ylw3Nwpu6cpTTP8R1MAC1kF4VbdLt3ARf209w==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/use-callback-ref": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/use-callback-ref/-/use-callback-ref-1.3.3.tgz",
      "integrity": "sha512-jQL3lRnocaFtu3V00JToYz/4QkNWswxijDaCVNZRiRTO3HQDLsdu1ZtmIUvV4yPp+rvWm5j0y0TG/S61cuijTg==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/use-sidecar": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/use-sidecar/-/use-sidecar-1.1.3.tgz",
      "integrity": "sha512-Fedw0aZvkhynoPYlA5WXrMCAMm+nSWdZt6lzJQ7Ok8S6Q+VsHmHpRWndVRJ8Be0ZbkfPc5LRYH+5XrzXcEeLRQ==",
      "license": "MIT",
      "dependencies": {
        "detect-node-es": "^1.1.0",
        "tslib": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "@types/react": "*",
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/use-sync-external-store": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/use-sync-external-store/-/use-sync-external-store-1.6.0.tgz",
      "integrity": "sha512-Pp6GSwGP/NrPIrxVFAIkOQeyw8lFenOHijQWkUTrDvrF4ALqylP2C/KCkeS9dpUM3KvYRQhna5vt7IL95+ZQ9w==",
      "license": "MIT",
      "optional": true,
      "peer": true,
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/vite": {
      "version": "6.4.1",
      "resolved": "https://registry.npmjs.org/vite/-/vite-6.4.1.tgz",
      "integrity": "sha512-+Oxm7q9hDoLMyJOYfUYBuHQo+dkAloi33apOPP56pzj+vsdJDzr+j1NISE5pyaAuKL4A3UD34qd0lx5+kfKp2g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.25.0",
        "fdir": "^6.4.4",
        "picomatch": "^4.0.2",
        "postcss": "^8.5.3",
        "rollup": "^4.34.9",
        "tinyglobby": "^0.2.13"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || ^20.0.0 || >=22.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || ^20.0.0 || >=22.0.0",
        "jiti": ">=1.21.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.16.0",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "jiti": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/vite-node": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/vite-node/-/vite-node-3.2.4.tgz",
      "integrity": "sha512-EbKSKh+bh1E1IFxeO0pg1n4dvoOTt0UDiXMd/qn++r98+jPO1xtJilvXldeuQ8giIB5IkpjCgMleHMNEsGH6pg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cac": "^6.7.14",
        "debug": "^4.4.1",
        "es-module-lexer": "^1.7.0",
        "pathe": "^2.0.3",
        "vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0"
      },
      "bin": {
        "vite-node": "vite-node.mjs"
      },
      "engines": {
        "node": "^18.0.0 || ^20.0.0 || >=22.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/vite/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/vitest": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/vitest/-/vitest-3.2.4.tgz",
      "integrity": "sha512-LUCP5ev3GURDysTWiP47wRRUpLKMOfPh+yKTx3kVIEiu5KOMeqzpnYNsKyOoVrULivR8tLcks4+lga33Whn90A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/chai": "^5.2.2",
        "@vitest/expect": "3.2.4",
        "@vitest/mocker": "3.2.4",
        "@vitest/pretty-format": "^3.2.4",
        "@vitest/runner": "3.2.4",
        "@vitest/snapshot": "3.2.4",
        "@vitest/spy": "3.2.4",
        "@vitest/utils": "3.2.4",
        "chai": "^5.2.0",
        "debug": "^4.4.1",
        "expect-type": "^1.2.1",
        "magic-string": "^0.30.17",
        "pathe": "^2.0.3",
        "picomatch": "^4.0.2",
        "std-env": "^3.9.0",
        "tinybench": "^2.9.0",
        "tinyexec": "^0.3.2",
        "tinyglobby": "^0.2.14",
        "tinypool": "^1.1.1",
        "tinyrainbow": "^2.0.0",
        "vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0",
        "vite-node": "3.2.4",
        "why-is-node-running": "^2.3.0"
      },
      "bin": {
        "vitest": "vitest.mjs"
      },
      "engines": {
        "node": "^18.0.0 || ^20.0.0 || >=22.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "@edge-runtime/vm": "*",
        "@types/debug": "^4.1.12",
        "@types/node": "^18.0.0 || ^20.0.0 || >=22.0.0",
        "@vitest/browser": "3.2.4",
        "@vitest/ui": "3.2.4",
        "happy-dom": "*",
        "jsdom": "*"
      },
      "peerDependenciesMeta": {
        "@edge-runtime/vm": {
          "optional": true
        },
        "@types/debug": {
          "optional": true
        },
        "@types/node": {
          "optional": true
        },
        "@vitest/browser": {
          "optional": true
        },
        "@vitest/ui": {
          "optional": true
        },
        "happy-dom": {
          "optional": true
        },
        "jsdom": {
          "optional": true
        }
      }
    },
    "node_modules/vitest/node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/vitest/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/w3c-xmlserializer": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/w3c-xmlserializer/-/w3c-xmlserializer-5.0.0.tgz",
      "integrity": "sha512-o8qghlI8NZHU1lLPrpi2+Uq7abh4GGPpYANlalzWxyWteJOCsr/P+oPBA49TOLu5FTZO4d3F9MnWJfiMo4BkmA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "xml-name-validator": "^5.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/whatwg-mimetype": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-mimetype/-/whatwg-mimetype-5.0.0.tgz",
      "integrity": "sha512-sXcNcHOC51uPGF0P/D4NVtrkjSU2fNsm9iog4ZvZJsL3rjoDAzXZhkm2MWt1y+PUdggKAYVoMAIYcs78wJ51Cw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/why-is-node-running": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/why-is-node-running/-/why-is-node-running-2.3.0.tgz",
      "integrity": "sha512-hUrmaWBdVDcxvYqnyh09zunKzROWjbZTiNy8dBEjkS7ehEDQibXJ7XvlmtbwuTclUiIyN+CyXQD4Vmko8fNm8w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "siginfo": "^2.0.0",
        "stackback": "0.0.2"
      },
      "bin": {
        "why-is-node-running": "cli.js"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi": {
      "version": "8.1.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^6.1.0",
        "string-width": "^5.0.1",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs": {
      "name": "wrap-ansi",
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/xml-name-validator": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/xml-name-validator/-/xml-name-validator-5.0.0.tgz",
      "integrity": "sha512-EvGK8EJ3DhaHfbRlETOWAS5pO9MZITeauHKJyb8wyajUfQUenkIg2MvLDTZ4T/TgIcm3HU0TFBgWWboAZ30UHg==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/xmlchars": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/xmlchars/-/xmlchars-2.2.0.tgz",
      "integrity": "sha512-JZnDKK8B0RCDw84FNdDAIpZK+JuJw+s7Lz8nksI7SIuU3UXJJslUthsi+uWBUYOwPFwW7W7PRLRfUKpxjtjFCw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/zustand": {
      "version": "5.0.11",
      "resolved": "https://registry.npmjs.org/zustand/-/zustand-5.0.11.tgz",
      "integrity": "sha512-fdZY+dk7zn/vbWNCYmzZULHRrss0jx5pPFiOuMZ/5HJN6Yv3u+1Wswy/4MpZEkEGhtNH+pwxZB8OKgUBPzYAGg==",
      "license": "MIT",
      "engines": {
        "node": ">=12.20.0"
      },
      "peerDependencies": {
        "@types/react": ">=18.0.0",
        "immer": ">=9.0.6",
        "react": ">=18.0.0",
        "use-sync-external-store": ">=1.2.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "immer": {
          "optional": true
        },
        "react": {
          "optional": true
        },
        "use-sync-external-store": {
          "optional": true
        }
      }
    }
  }
}
===ENDFILE
===FILE: ./package.json
{
  "name": "@ccaas/ccaas-admin-mfe",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "main": "dist/index.esm.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "dev": "vite --port 5185",
    "build": "vite build",
    "preview": "vite preview --port 5185",
    "type-check": "tsc -p tsconfig.json --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "clean": "rm -rf dist .__mf__temp node_modules"
  },
  "peerDependencies": {
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "dependencies": {
    "@radix-ui/react-accordion": "^1.2.12",
    "@radix-ui/react-alert-dialog": "^1.1.15",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-collapsible": "^1.1.12",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-icons": "^1.3.2",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-popover": "^1.1.9",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-toggle": "^1.1.10",
    "@radix-ui/react-toggle-group": "^1.1.11",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@tanstack/react-query": "^5.66.7",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.542.0",
    "tailwind-merge": "^3.3.1",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@originjs/vite-plugin-federation": "^1.4.1",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.2",
    "@testing-library/user-event": "^14.6.1",
    "@types/react": "^19.1.12",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^4.6.0",
    "@vitest/coverage-v8": "^3.2.4",
    "autoprefixer": "^10.4.14",
    "jsdom": "^28.0.0",
    "postcss": "^8.4.24",
    "react": "19.2.0",
    "react-dom": "19.2.0",
    "tailwindcss": "^3.3.0",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5.9.2",
    "vite": "^6.0.0",
    "vitest": "^3.2.4"
  },
  "optionalDependencies": {
    "@rollup/rollup-linux-x64-gnu": "^4.50.0"
  }
}
===ENDFILE
===FILE: ./postcss.config.js
import tailwindcss from 'tailwindcss';
import autoprefixer from 'autoprefixer';

export default {
  plugins: [
    tailwindcss,
    autoprefixer
  ]
};
===ENDFILE
===FILE: ./public/vite.svg
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFBD4F"></stop><stop offset="100%" stop-color="#FF980E"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
===ENDFILE
===FILE: ./src/AdminMFE.tsx
import { useEffect, Component, ErrorInfo as ReactErrorInfo, ReactNode } from 'react'
import { QueryClientProvider } from '@tanstack/react-query'
import { AdminScreen } from './components/admin/admin-screen'
import { ToastProvider } from './hooks/common/use-toast'
import { queryClient } from './lib/query-client'
import { setAuthToken } from './utils/auth/auth-token-manager'
import type { AdminPermissions } from './components/admin/admin-layout'
import type { AdminMFEProps, ErrorInfo as AdminErrorInfo } from './types'
import './index.css'

interface ErrorBoundaryProps {
  children: ReactNode
  onError?: (error: AdminErrorInfo) => void
}

interface ErrorBoundaryState {
  hasError: boolean
  error?: Error
  errorId?: string
}

const defaultPermissions: AdminPermissions = {
  canPreviewDashboards: false,
  canViewRoleTemplates: false,
  canViewAdGroups: false,
  canViewPendingApprovals: false,
  canApproveChanges: false,
  canEditBusinessInfo: false,
  canEditPermissions: false,
  canEditApplications: false,
  canEnableDisableGroups: false,
  canDirectSave: false,
  canViewNotices: false,
  canCreateNotice: false,
  canEditNotice: false,
  canPublishNotice: false,
  canArchiveNotice: false,
  canSaveDraft: false
}

class AdminMFEErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, info: ReactErrorInfo) {
    const errorId = `ADMIN-MFE-${Date.now()}-${Math.random().toString(36).slice(2, 11)}`

    if (this.props.onError) {
      this.props.onError({
        code: 'MFE_RENDER_ERROR',
        message: error.message,
        context: {
          errorId,
          componentStack: info.componentStack,
          stack: error.stack
        }
      })
    }

    this.setState({ hasError: true, error, errorId })
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="p-6 bg-red-50 border border-red-200 rounded-lg text-center">
          <p className="text-red-600 font-medium">Admin Panel temporarily unavailable</p>
          {this.state.errorId ? <p className="text-sm text-gray-500 mt-2">Error ID: {this.state.errorId}</p> : null}
          <button
            onClick={() => window.location.reload()}
            className="mt-4 px-4 py-2 bg-red-600 text-white rounded text-sm hover:bg-red-700"
          >
            Reload Page
          </button>
        </div>
      )
    }

    return this.props.children
  }
}

function AdminMFEInner(props: AdminMFEProps) {
  const {
    authToken,
    permissions,
    currentRole = 'admin',
    onError
  } = props

  useEffect(() => {
    if (!authToken) {
      onError?.({
        code: 'MISSING_AUTH_TOKEN',
        message: 'Admin MFE requires authToken from host'
      })
      return
    }

    setAuthToken(authToken)
  }, [authToken, onError])

  return <AdminScreen permissions={permissions ?? defaultPermissions} currentRole={currentRole} />
}

export function AdminMFE(props: AdminMFEProps) {
  return (
    <AdminMFEErrorBoundary onError={props.onError}>
      <div className="admin-mfe-root h-full w-full">
        <QueryClientProvider client={queryClient}>
          <ToastProvider>
            <AdminMFEInner {...props} />
          </ToastProvider>
        </QueryClientProvider>
      </div>
    </AdminMFEErrorBoundary>
  )
}

export default AdminMFE
===ENDFILE
===FILE: ./src/__tests__/AdminMFE.test.tsx
import { describe, expect, it, vi, beforeEach } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../components/admin/admin-screen', () => ({
  AdminScreen: ({ currentRole }: { currentRole: string }) => (
    <div data-testid="admin-screen" data-role={currentRole}>Admin Screen</div>
  )
}))

vi.mock('../hooks/common/use-toast', () => ({
  ToastProvider: ({ children }: { children: React.ReactNode }) => <div data-testid="toast-provider">{children}</div>
}))

vi.mock('../lib/query-client', () => ({
  queryClient: {
    mount: vi.fn(),
    unmount: vi.fn(),
    getDefaultOptions: () => ({}),
    setDefaultOptions: vi.fn(),
    getQueryCache: () => ({ subscribe: vi.fn(() => vi.fn()), findAll: () => [], notify: vi.fn() }),
    getMutationCache: () => ({ subscribe: vi.fn(() => vi.fn()), findAll: () => [], notify: vi.fn() })
  }
}))

const mockSetAuthToken = vi.fn()
vi.mock('../utils/auth/auth-token-manager', () => ({
  setAuthToken: (...args: unknown[]) => mockSetAuthToken(...args)
}))

vi.mock('../index.css', () => ({}))

vi.mock('@tanstack/react-query', () => ({
  QueryClientProvider: ({ children }: { children: React.ReactNode }) => (
    <div data-testid="query-provider">{children}</div>
  )
}))

import { AdminMFE } from '../AdminMFE'

describe('AdminMFE', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders without crashing', () => {
    render(<AdminMFE authToken="test-token" />)
    expect(screen.getByTestId('admin-screen')).toBeInTheDocument()
  })

  it('wraps content in QueryClientProvider', () => {
    render(<AdminMFE authToken="test-token" />)
    expect(screen.getByTestId('query-provider')).toBeInTheDocument()
  })

  it('wraps content in ToastProvider', () => {
    render(<AdminMFE authToken="test-token" />)
    expect(screen.getByTestId('toast-provider')).toBeInTheDocument()
  })

  it('passes default currentRole', () => {
    render(<AdminMFE authToken="test-token" />)
    expect(screen.getByTestId('admin-screen')).toHaveAttribute('data-role', 'admin')
  })

  it('passes custom currentRole', () => {
    render(<AdminMFE authToken="test-token" currentRole="maker" />)
    expect(screen.getByTestId('admin-screen')).toHaveAttribute('data-role', 'maker')
  })

  it('calls setAuthToken with authToken', () => {
    render(<AdminMFE authToken="my-jwt-token" />)
    expect(mockSetAuthToken).toHaveBeenCalledWith('my-jwt-token')
  })

  it('calls onError for missing authToken', () => {
    const onError = vi.fn()
    render(<AdminMFE authToken="" onError={onError} />)
    expect(onError).toHaveBeenCalledWith(
      expect.objectContaining({ code: 'MISSING_AUTH_TOKEN' })
    )
  })

  it('has admin-mfe-root wrapper class', () => {
    const { container } = render(<AdminMFE authToken="test-token" />)
    expect(container.querySelector('.admin-mfe-root')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/__tests__/admin-layout.test.ts
import { describe, expect, it } from 'vitest'
import { resolveActiveView, resolveAvailableViews, resolveInitialView, type AdminPermissions } from '../admin-layout'

function makePermissions(overrides: Partial<AdminPermissions> = {}): AdminPermissions {
  return {
    canPreviewDashboards: false,
    canViewRoleTemplates: false,
    canViewAdGroups: false,
    canViewPendingApprovals: false,
    canApproveChanges: false,
    canEditBusinessInfo: false,
    canEditPermissions: false,
    canEditApplications: false,
    canEnableDisableGroups: false,
    canDirectSave: false,
    canViewNotices: false,
    canCreateNotice: false,
    canEditNotice: false,
    canPublishNotice: false,
    canArchiveNotice: false,
    canSaveDraft: false,
    ...overrides
  }
}

describe('admin layout view resolution', () => {
  it('returns views in expected order by capability', () => {
    const permissions = makePermissions({
      canViewRoleTemplates: true,
      canViewAdGroups: true,
      canViewPendingApprovals: true,
      canViewNotices: true
    })

    expect(resolveAvailableViews(permissions)).toEqual([
      'ad-groups',
      'pending-approvals',
      'notices'
    ])
  })

  it('returns null when no views are available', () => {
    const views = resolveAvailableViews(makePermissions())
    expect(resolveInitialView(null, views)).toBeNull()
  })

  it('keeps saved view only when still available', () => {
    const views = resolveAvailableViews(makePermissions({ canViewAdGroups: true }))

    expect(resolveInitialView('ad-groups', views)).toBe('ad-groups')
    expect(resolveInitialView('notices', views)).toBe('ad-groups')
  })

  it('falls back to first available view when active view becomes unavailable', () => {
    const views = resolveAvailableViews(makePermissions({ canViewAdGroups: true }))
    expect(resolveActiveView('pending-approvals', views)).toBe('ad-groups')
  })

  it('keeps active view when still available', () => {
    const views = resolveAvailableViews(makePermissions({ canViewNotices: true }))
    expect(resolveActiveView('notices', views)).toBe('notices')
  })
})
===ENDFILE
===FILE: ./src/components/admin/__tests__/admin-layout.test.tsx
import { describe, expect, it, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'
import { resolveAvailableViews, resolveInitialView, resolveActiveView } from '../admin-layout'
import type { AdminPermissions } from '../admin-layout'

vi.mock('../admin-sidebar', () => ({
  AdminSidebar: ({ activeView, onViewChange }: { activeView: string; onViewChange: (v: string) => void }) => (
    <div data-testid="sidebar" data-active={activeView}>
      <button data-testid="nav-notices" onClick={() => onViewChange('notices')}>notices</button>
      <button data-testid="nav-ad-groups" onClick={() => onViewChange('ad-groups')}>ad-groups</button>
    </div>
  )
}))

vi.mock('@/components/common/brand-loader', () => ({
  BrandLoader: () => <div data-testid="brand-loader">Loading...</div>
}))

vi.mock('../ad-groups-view', () => ({
  AdGroupsView: () => <div data-testid="ad-groups-view">AD Groups</div>
}))

vi.mock('../pending-approvals-view/pending-approvals-view', () => ({
  PendingApprovalsView: () => <div data-testid="pending-approvals-view">Pending</div>
}))

vi.mock('../views/notice-management-view', () => ({
  NoticeManagementView: () => <div data-testid="notice-management-view">Notices</div>
}))

const allPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

const noPermissions: AdminPermissions = {
  canPreviewDashboards: false,
  canViewRoleTemplates: false,
  canViewAdGroups: false,
  canViewPendingApprovals: false,
  canApproveChanges: false,
  canEditBusinessInfo: false,
  canEditPermissions: false,
  canEditApplications: false,
  canEnableDisableGroups: false,
  canDirectSave: false,
  canViewNotices: false,
  canCreateNotice: false,
  canEditNotice: false,
  canPublishNotice: false,
  canArchiveNotice: false,
  canSaveDraft: false
}

describe('resolveAvailableViews', () => {
  it('returns all views when all permissions granted', () => {
    const views = resolveAvailableViews(allPermissions)
    expect(views).toEqual(['ad-groups', 'pending-approvals', 'notices'])
  })

  it('returns empty array when no permissions', () => {
    const views = resolveAvailableViews(noPermissions)
    expect(views).toEqual([])
  })

  it('returns only ad-groups when only that permission is set', () => {
    const views = resolveAvailableViews({ ...noPermissions, canViewAdGroups: true })
    expect(views).toEqual(['ad-groups'])
  })

  it('returns only notices when only that permission is set', () => {
    const views = resolveAvailableViews({ ...noPermissions, canViewNotices: true })
    expect(views).toEqual(['notices'])
  })
})

describe('resolveInitialView', () => {
  it('returns saved view if available', () => {
    expect(resolveInitialView('notices', ['ad-groups', 'notices'])).toBe('notices')
  })

  it('returns first available if saved not in list', () => {
    expect(resolveInitialView('notices', ['ad-groups'])).toBe('ad-groups')
  })

  it('returns null if no views available', () => {
    expect(resolveInitialView('notices', [])).toBeNull()
  })

  it('returns first available if saved is null', () => {
    expect(resolveInitialView(null, ['ad-groups', 'notices'])).toBe('ad-groups')
  })
})

describe('resolveActiveView', () => {
  it('returns active view if in available list', () => {
    expect(resolveActiveView('notices', ['ad-groups', 'notices'])).toBe('notices')
  })

  it('returns first available if active not in list', () => {
    expect(resolveActiveView('notices', ['ad-groups'])).toBe('ad-groups')
  })

  it('returns null if no views available', () => {
    expect(resolveActiveView('notices', [])).toBeNull()
  })

  it('returns first available if active is null', () => {
    expect(resolveActiveView(null, ['pending-approvals'])).toBe('pending-approvals')
  })
})

describe('AdminLayout component', () => {
  beforeEach(() => {
    localStorage.clear()
  })

  it('renders no-access message when no permissions', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={noPermissions} currentRole="admin" />)
    expect(screen.getByText('No admin access configured for your account')).toBeInTheDocument()
  })

  it('renders sidebar and main content with permissions', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    expect(screen.getByTestId('sidebar')).toBeInTheDocument()
  })

  it('navigates to a different view on sidebar click', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    fireEvent.click(screen.getByTestId('nav-notices'))
    expect(screen.getByTestId('sidebar')).toHaveAttribute('data-active', 'notices')
  })

  it('persists active view to localStorage', async () => {
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    fireEvent.click(screen.getByTestId('nav-notices'))
    expect(localStorage.getItem('admin-active-view')).toBe('notices')
  })

  it('restores saved view from localStorage', async () => {
    localStorage.setItem('admin-active-view', 'notices')
    const { AdminLayout } = await import('../admin-layout')
    render(<AdminLayout permissions={allPermissions} currentRole="admin" />)
    expect(screen.getByTestId('sidebar')).toHaveAttribute('data-active', 'notices')
  })
})
===ENDFILE
===FILE: ./src/components/admin/__tests__/admin-screen.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../admin-layout', () => ({
  AdminLayout: ({ permissions, currentRole }: Record<string, unknown>) => (
    <div data-testid="admin-layout" data-role={currentRole}>
      {JSON.stringify(permissions)}
    </div>
  )
}))

import { AdminScreen } from '../admin-screen'

describe('AdminScreen', () => {
  const defaultPermissions = {
    canPreviewDashboards: false,
    canViewRoleTemplates: false,
    canViewAdGroups: true,
    canViewPendingApprovals: false,
    canApproveChanges: false,
    canEditBusinessInfo: false,
    canEditPermissions: false,
    canEditApplications: false,
    canEnableDisableGroups: false,
    canDirectSave: false,
    canViewNotices: false,
    canCreateNotice: false,
    canEditNotice: false,
    canPublishNotice: false,
    canArchiveNotice: false,
    canSaveDraft: false
  }

  it('renders AdminLayout with permissions and currentRole', () => {
    render(<AdminScreen permissions={defaultPermissions} currentRole="admin" />)
    const layout = screen.getByTestId('admin-layout')
    expect(layout).toBeInTheDocument()
    expect(layout).toHaveAttribute('data-role', 'admin')
  })

  it('passes permissions to AdminLayout', () => {
    render(<AdminScreen permissions={defaultPermissions} currentRole="maker" />)
    const layout = screen.getByTestId('admin-layout')
    expect(layout.textContent).toContain('"canViewAdGroups":true')
  })
})
===ENDFILE
===FILE: ./src/components/admin/__tests__/admin-sidebar.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../hooks/admin/use-pending-changes', () => ({
  usePendingChangesCount: () => ({ data: { total: 5 } })
}))

vi.mock('../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

vi.mock('lucide-react', () => ({
  Bell: (props: Record<string, unknown>) => <span data-testid="bell-icon" {...props} />,
  ClipboardCheck: (props: Record<string, unknown>) => <span data-testid="clipboard-icon" {...props} />,
  Users: (props: Record<string, unknown>) => <span data-testid="users-icon" {...props} />,
  ChevronLeft: (props: Record<string, unknown>) => <span data-testid="chevron-left-icon" {...props} />,
  ChevronRight: (props: Record<string, unknown>) => <span data-testid="chevron-right-icon" {...props} />
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, className, ...rest }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} className={className as string} {...rest}>{children as React.ReactNode}</button>
  )
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children, ...rest }: Record<string, unknown>) => <span {...rest}>{children as React.ReactNode}</span>
}))

import { AdminSidebar } from '../admin-sidebar'
import type { AdminPermissions } from '../admin-layout'

const allPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

const noPermissions: AdminPermissions = {
  canPreviewDashboards: false,
  canViewRoleTemplates: false,
  canViewAdGroups: false,
  canViewPendingApprovals: false,
  canApproveChanges: false,
  canEditBusinessInfo: false,
  canEditPermissions: false,
  canEditApplications: false,
  canEnableDisableGroups: false,
  canDirectSave: false,
  canViewNotices: false,
  canCreateNotice: false,
  canEditNotice: false,
  canPublishNotice: false,
  canArchiveNotice: false,
  canSaveDraft: false
}

describe('AdminSidebar', () => {
  it('renders navigation landmark', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={allPermissions}
      />
    )
    expect(screen.getByLabelText('Admin navigation')).toBeInTheDocument()
  })

  it('renders all nav items when permissions allow', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={allPermissions}
      />
    )
    expect(screen.getByText('AD Groups')).toBeInTheDocument()
    expect(screen.getByText('Pending Approvals')).toBeInTheDocument()
    expect(screen.getByText('System Notices')).toBeInTheDocument()
  })

  it('renders no nav items when no permissions', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={noPermissions}
      />
    )
    expect(screen.queryByText('AD Groups')).not.toBeInTheDocument()
    expect(screen.queryByText('Pending Approvals')).not.toBeInTheDocument()
    expect(screen.queryByText('System Notices')).not.toBeInTheDocument()
  })

  it('shows only permitted nav items', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={{ ...noPermissions, canViewAdGroups: true }}
      />
    )
    expect(screen.getByText('AD Groups')).toBeInTheDocument()
    expect(screen.queryByText('Pending Approvals')).not.toBeInTheDocument()
  })

  it('shows pending count badge', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={allPermissions}
      />
    )
    expect(screen.getByText('5')).toBeInTheDocument()
  })

  it('calls onViewChange when nav item clicked', () => {
    const onViewChange = vi.fn()
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={onViewChange}
        permissions={allPermissions}
      />
    )
    fireEvent.click(screen.getByText('System Notices'))
    expect(onViewChange).toHaveBeenCalledWith('notices')
  })

  it('renders description text for nav items', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={allPermissions}
      />
    )
    expect(screen.getByText('Manage Permissions')).toBeInTheDocument()
    expect(screen.getByText('Review Changes')).toBeInTheDocument()
    expect(screen.getByText('Broadcast Messages')).toBeInTheDocument()
  })

  it('renders collapse button in desktop mode', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={allPermissions}
        onToggleCollapse={vi.fn()}
      />
    )
    expect(screen.getByLabelText('Collapse navigation')).toBeInTheDocument()
  })

  it('hides descriptions when collapsed', () => {
    render(
      <AdminSidebar
        activeView="ad-groups"
        onViewChange={vi.fn()}
        permissions={allPermissions}
        collapsed
      />
    )
    expect(screen.queryByText('Manage Permissions')).not.toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/__tests__/app-card.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  CheckCircle: (p: Record<string, unknown>) => <span data-testid="check-circle" {...p} />,
  Package: (p: Record<string, unknown>) => <span data-testid="package" {...p} />
}))

vi.mock('../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

vi.mock('../../ui/card', () => ({
  Card: ({ children, onClick, className }: any) => <div data-testid="card" className={className} onClick={onClick}>{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children }: any) => <span data-testid="badge">{children}</span>
}))

import { AppCard } from '../app-card'

const baseApp = {
  appIdentifier: 'app-1',
  titleText: 'Test App',
  descriptionText: 'Test description',
  categoryName: 'Category A',
  isAssignedIndicator: false,
  assignedFunctionKeys: [] as string[],
}

describe('AppCard', () => {
  it('renders app title and description', () => {
    render(<AppCard app={baseApp as any} selected={false} onClick={vi.fn()} />)
    expect(screen.getByText('Test App')).toBeInTheDocument()
    expect(screen.getByText('Test description')).toBeInTheDocument()
  })

  it('renders category badge', () => {
    render(<AppCard app={baseApp as any} selected={false} onClick={vi.fn()} />)
    expect(screen.getByText('Category A')).toBeInTheDocument()
  })

  it('calls onClick when clicked', () => {
    const onClick = vi.fn()
    render(<AppCard app={baseApp as any} selected={false} onClick={onClick} />)
    fireEvent.click(screen.getByTestId('card'))
    expect(onClick).toHaveBeenCalled()
  })

  it('shows check icon when assigned', () => {
    const assigned = { ...baseApp, isAssignedIndicator: true, assignedFunctionKeys: ['f1', 'f2'] }
    render(<AppCard app={assigned as any} selected={false} onClick={vi.fn()} />)
    expect(screen.getByTestId('check-circle')).toBeInTheDocument()
  })

  it('shows function count badge when assigned', () => {
    const assigned = { ...baseApp, isAssignedIndicator: true, assignedFunctionKeys: ['f1', 'f2'] }
    render(<AppCard app={assigned as any} selected={false} onClick={vi.fn()} />)
    expect(screen.getByText('2 features')).toBeInTheDocument()
  })

  it('does not show check icon when not assigned', () => {
    render(<AppCard app={baseApp as any} selected={false} onClick={vi.fn()} />)
    expect(screen.queryByTestId('check-circle')).not.toBeInTheDocument()
  })

  it('applies selected styles', () => {
    render(<AppCard app={baseApp as any} selected={true} onClick={vi.fn()} />)
    const card = screen.getByTestId('card')
    expect(card.className).toContain('border-blue-500')
  })
})
===ENDFILE
===FILE: ./src/components/admin/__tests__/bulk-operations-toolbar.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../lib/utils', () => ({
  cn: (...a: unknown[]) => a.filter(Boolean).join(' ')
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled, variant, size, className }: any) => (
    <button onClick={onClick} disabled={disabled} data-variant={variant} className={className}>{children}</button>
  )
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('../../ui/checkbox', () => ({
  Checkbox: ({ id, checked, onCheckedChange }: any) => (
    <input type="checkbox" data-testid={`checkbox-${id}`} checked={checked} onChange={(e: any) => onCheckedChange?.(e.target.checked)} />
  )
}))

vi.mock('../../ui/label', () => ({
  Label: ({ children, htmlFor }: any) => <label htmlFor={htmlFor}>{children}</label>
}))

vi.mock('../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="confirm-dialog">{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))

vi.mock('../../ui/select', () => ({
  Select: ({ children }: any) => <div>{children}</div>,
  SelectContent: ({ children }: any) => <div>{children}</div>,
  SelectItem: ({ children }: any) => <div>{children}</div>,
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: () => <span />
}))

vi.mock('../copy-source-selection-modal', () => ({
  CopySourceSelectionModal: ({ open }: any) =>
    open ? <div data-testid="copy-modal">Copy Modal</div> : null
}))

vi.mock('lucide-react', () => ({
  Copy: (p: any) => <span data-testid="copy-icon" {...p} />,
  CheckSquare: (p: any) => <span data-testid="check-square" {...p} />,
  Square: (p: any) => <span data-testid="square" {...p} />,
  MinusSquare: (p: any) => <span data-testid="minus-square" {...p} />,
  X: (p: any) => <span data-testid="x-icon" {...p} />
}))

import { BulkOperationsToolbar } from '../bulk-operations-toolbar'

describe('BulkOperationsToolbar', () => {
  const defaultProps = {
    selectedCount: 3,
    selectedVisibleCount: 3,
    totalCount: 10,
    visibleCount: 8,
    selectedGroups: ['g1', 'g2', 'g3'],
    allAdGroups: [
      { id: 'g1', groupIdentifier: 'CN=g1', logicalName: 'Group 1' },
      { id: 'g2', groupIdentifier: 'CN=g2', logicalName: 'Group 2' },
      { id: 'g3', groupIdentifier: 'CN=g3', logicalName: 'Group 3' }
    ] as any[],
    onSelectAll: vi.fn(),
    onDeselectAll: vi.fn(),
    onCopyFrom: vi.fn(),
    onSearchAdGroups: vi.fn(),
    isLookupLoading: false
  }

  it('renders nothing when no groups selected', () => {
    const { container } = render(
      <BulkOperationsToolbar {...defaultProps} selectedCount={0} />
    )
    expect(container.innerHTML).toBe('')
  })

  it('renders toolbar with selection count', () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    expect(screen.getByText(/3 selected/)).toBeInTheDocument()
  })

  it('renders clear selection button', () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    expect(screen.getByText('Clear selection')).toBeInTheDocument()
  })

  it('calls onDeselectAll when clear selection clicked', () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    fireEvent.click(screen.getByText('Clear selection'))
    expect(defaultProps.onDeselectAll).toHaveBeenCalled()
  })

  it('renders copy from another group button', () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    expect(screen.getByText('Copy From Another Group')).toBeInTheDocument()
  })

  it('opens copy modal on button click', () => {
    render(<BulkOperationsToolbar {...defaultProps} />)
    expect(screen.queryByTestId('copy-modal')).not.toBeInTheDocument()
    fireEvent.click(screen.getByText('Copy From Another Group'))
    expect(screen.getByTestId('copy-modal')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/__tests__/business-relevant-toggles.test.ts
import { describe, expect, it } from 'vitest'
import { businessRelevantToggles, isToggleBusinessRelevant } from '../business-relevant-toggles'

describe('businessRelevantToggles', () => {
  it('has capabilities section with correct title', () => {
    expect(businessRelevantToggles.capabilities.title).toBe('Access Controls')
  })

  it('has workspacePreferences section with correct title', () => {
    expect(businessRelevantToggles.workspacePreferences.title).toBe('Workspace & Preferences')
  })

  it('capabilities has exactly 5 toggles', () => {
    expect(Object.keys(businessRelevantToggles.capabilities.toggles).length).toBe(5)
  })

  it('workspacePreferences has exactly 5 toggles', () => {
    expect(Object.keys(businessRelevantToggles.workspacePreferences.toggles).length).toBe(5)
  })

  it('capabilities contains the correct 5 toggle keys', () => {
    const keys = Object.keys(businessRelevantToggles.capabilities.toggles)
    expect(keys).toEqual([
      'columns.kms',
      'columns.embeddedApps',
      'columns.spaceCopilot',
      'columns.chat',
      'micro_frontends.mediaBar'
    ])
  })

  it('workspacePreferences contains the correct 5 toggle keys', () => {
    const keys = Object.keys(businessRelevantToggles.workspacePreferences.toggles)
    expect(keys).toEqual([
      'settings_options.calls.autoAccept',
      'settings_options.calls.doNotDisturb.duration',
      'settings_options.interface.showTranscript',
      'settings_options.interface.autoCloseKnowledgeOnCallEnd',
      'settings_options.interface.spaceCopilotMode'
    ])
  })

  it('has linkedKeys on Knowledge Base toggle', () => {
    const toggle = businessRelevantToggles.capabilities.toggles['columns.kms']
    expect(toggle.linkedKeys).toEqual(['features.search.knowledgeBase'])
  })

  it('has linkedKeys on Banking Applications toggle', () => {
    const toggle = businessRelevantToggles.capabilities.toggles['columns.embeddedApps']
    expect(toggle.linkedKeys).toEqual(['features.search.embeddedApps'])
  })

  it('has linkedKeys on AI Assistant toggle', () => {
    const toggle = businessRelevantToggles.capabilities.toggles['columns.spaceCopilot']
    expect(toggle.linkedKeys).toEqual(['micro_frontends.spaceCopilot'])
  })

  it('has linkedKeys on Media Controls toggle', () => {
    const toggle = businessRelevantToggles.capabilities.toggles['micro_frontends.mediaBar']
    expect(toggle.linkedKeys).toEqual(['widgets.mediaBar.callControls'])
  })

  it('Chat Interface has no linkedKeys', () => {
    const toggle = businessRelevantToggles.capabilities.toggles['columns.chat']
    expect(toggle.linkedKeys).toBeUndefined()
  })

  it('workspacePreferences toggles have no linkedKeys', () => {
    const toggles = businessRelevantToggles.workspacePreferences.toggles
    Object.values(toggles).forEach(toggle => {
      expect(toggle.linkedKeys).toBeUndefined()
    })
  })

  it('has no duplicate toggle keys across capabilities and workspacePreferences', () => {
    const capKeys = Object.keys(businessRelevantToggles.capabilities.toggles)
    const wpKeys = Object.keys(businessRelevantToggles.workspacePreferences.toggles)
    const allKeys = [...capKeys, ...wpKeys]
    expect(new Set(allKeys).size).toBe(allKeys.length)
  })

  it('capabilities toggles have section properties', () => {
    const toggles = businessRelevantToggles.capabilities.toggles
    expect(toggles['columns.kms'].section).toBe('Dashboard Access')
    expect(toggles['micro_frontends.mediaBar'].section).toBe('Platform Apps')
  })

  it('workspacePreferences toggles have section properties', () => {
    const toggles = businessRelevantToggles.workspacePreferences.toggles
    expect(toggles['settings_options.calls.autoAccept'].section).toBe('Call Preferences')
    expect(toggles['settings_options.interface.showTranscript'].section).toBe('Privacy & Display')
    expect(toggles['settings_options.interface.spaceCopilotMode'].section).toBe('AI Preference')
  })

  it('includes autoCloseKnowledgeOnCallEnd setting', () => {
    const toggle = businessRelevantToggles.workspacePreferences.toggles['settings_options.interface.autoCloseKnowledgeOnCallEnd']
    expect(toggle.visible).toBe(true)
    expect(toggle.businessName).toBe('Auto-Close Knowledge')
  })

  it('has admin views section', () => {
    expect(businessRelevantToggles.adminViews).toBeDefined()
    expect(businessRelevantToggles.adminViews.toggles['admin.roleTemplatesView'].visible).toBe(true)
  })

  it('has admin actions section', () => {
    expect(businessRelevantToggles.adminActions).toBeDefined()
    expect(businessRelevantToggles.adminActions.toggles['admin.editPermissions'].visible).toBe(true)
  })

  it('does not have standalone legacy sections', () => {
    expect(businessRelevantToggles['columns']).toBeUndefined()
    expect(businessRelevantToggles['features']).toBeUndefined()
    expect(businessRelevantToggles['widgets']).toBeUndefined()
    expect(businessRelevantToggles['settings_tabs']).toBeUndefined()
    expect(businessRelevantToggles['settings_options']).toBeUndefined()
    expect(businessRelevantToggles['micro_frontends']).toBeUndefined()
  })
})

describe('isToggleBusinessRelevant', () => {
  it('returns true for visible capabilities toggles', () => {
    expect(isToggleBusinessRelevant('capabilities', 'columns.kms')).toBe(true)
    expect(isToggleBusinessRelevant('capabilities', 'micro_frontends.mediaBar')).toBe(true)
  })

  it('returns true for visible workspacePreferences toggles', () => {
    expect(isToggleBusinessRelevant('workspacePreferences', 'settings_options.calls.autoAccept')).toBe(true)
    expect(isToggleBusinessRelevant('workspacePreferences', 'settings_options.interface.spaceCopilotMode')).toBe(true)
  })

  it('returns false for removed toggles', () => {
    expect(isToggleBusinessRelevant('workspacePreferences', 'widgets.customer.info')).toBe(false)
    expect(isToggleBusinessRelevant('workspacePreferences', 'settings_tabs.help')).toBe(false)
    expect(isToggleBusinessRelevant('capabilities', 'features.search.knowledgeBase')).toBe(false)
    expect(isToggleBusinessRelevant('capabilities', 'micro_frontends.spaceCopilot')).toBe(false)
  })

  it('returns false for unknown category', () => {
    expect(isToggleBusinessRelevant('nonexistent', 'key')).toBe(false)
  })

  it('returns false for unknown toggle key', () => {
    expect(isToggleBusinessRelevant('capabilities', 'nonexistent.key')).toBe(false)
  })
})
===ENDFILE
===FILE: ./src/components/admin/__tests__/copy-source-selection-modal.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('@/hooks/features/use-business-terminology', () => ({
  useBusinessRoles: () => ({
    voice_agent: { displayName: 'Voice Agent', description: '', category: '' }
  })
}))

vi.mock('../../../utils/admin/notice-validators', () => ({
  isConfiguredGroup: ({ group }: any) => Boolean(group.logicalName && group.roleName)
}))

vi.mock('@/components/common/brand-loader', () => ({
  BrandLoader: ({ message }: any) => <div data-testid="brand-loader">{message}</div>
}))

vi.mock('../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children, className }: any) => <div className={className}>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children, className }: any) => <div className={className}>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children, className }: any) => <h2 className={className}>{children}</h2>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: any) => (
    <button onClick={onClick} disabled={disabled}>{children}</button>
  )
}))

vi.mock('../../ui/input', () => ({
  Input: ({ value, onChange, placeholder, className }: any) => (
    <input data-testid="search-input" value={value} onChange={onChange} placeholder={placeholder} className={className} />
  )
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children }: any) => <span data-testid="badge">{children}</span>
}))

vi.mock('lucide-react', () => ({
  Search: (p: any) => <span data-testid="search-icon" {...p} />,
  Copy: (p: any) => <span data-testid="copy-icon" {...p} />,
  X: (p: any) => <span data-testid="x-icon" {...p} />
}))

import { CopySourceSelectionModal } from '../copy-source-selection-modal'
import type { AdGroup } from '../../../types/features/ad-group-config'

const makeGroup = (id: string, logicalName: string): AdGroup => ({
  id,
  groupIdentifier: `CN=${id}`,
  logicalName,
  roleName: 'voice_agent',
  market: 'UK',
  region: 'EMEA',
  country: 'GB',
  isActive: true
} as any)

describe('CopySourceSelectionModal', () => {
  const baseProps = {
    open: true,
    onOpenChange: vi.fn(),
    adGroups: [makeGroup('g1', 'Group One'), makeGroup('g2', 'Group Two')],
    excludeGroupIds: [] as string[],
    onSelect: vi.fn(),
    isLoading: false
  }

  it('renders dialog with title when open', () => {
    render(<CopySourceSelectionModal {...baseProps} />)
    expect(screen.getByText('Copy Configuration From Another Group')).toBeInTheDocument()
    expect(screen.getByText('Select a source AD group to copy configuration from. The role, permissions, and location metadata will be copied.')).toBeInTheDocument()
  })

  it('does not render when closed', () => {
    render(<CopySourceSelectionModal {...baseProps} open={false} />)
    expect(screen.queryByText('Copy Configuration From Another Group')).not.toBeInTheDocument()
  })

  it('renders filtered group list excluding excluded IDs', () => {
    render(<CopySourceSelectionModal {...baseProps} excludeGroupIds={['g1']} />)
    expect(screen.queryByText('Group One')).not.toBeInTheDocument()
    expect(screen.getByText('Group Two')).toBeInTheDocument()
  })

  it('shows loading state', () => {
    render(<CopySourceSelectionModal {...baseProps} isLoading={true} />)
    expect(screen.getByTestId('brand-loader')).toBeInTheDocument()
  })

  it('shows empty state when no configured groups', () => {
    const unconfigured = [{ id: 'g3', groupIdentifier: 'CN=g3', logicalName: '', roleName: '' } as any]
    render(<CopySourceSelectionModal {...baseProps} adGroups={unconfigured} />)
    expect(screen.getByText('No configured groups available')).toBeInTheDocument()
  })

  it('renders search input', () => {
    render(<CopySourceSelectionModal {...baseProps} />)
    expect(screen.getByTestId('search-input')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/__tests__/function-assignment-panel.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../hooks/admin/use-function-selection', () => ({
  useFunctionSelection: () => ({
    selectedFunctions: ['func-a'],
    defaultFunction: undefined,
    hasChanges: () => false,
    handleFunctionToggle: vi.fn(),
    handleSelectAllFiltered: vi.fn(),
    handleClearSelection: vi.fn(),
    handleReset: vi.fn()
  })
}))

vi.mock('../../ui/card', () => ({
  Card: ({ children, className }: any) => <div data-testid="card" className={className}>{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>,
  CardDescription: ({ children }: any) => <p>{children}</p>,
  CardHeader: ({ children, className }: any) => <div className={className}>{children}</div>,
  CardTitle: ({ children, className }: any) => <h3 className={className}>{children}</h3>
}))

vi.mock('../../ui/checkbox', () => ({
  Checkbox: ({ id, checked, disabled, onCheckedChange }: any) => (
    <input
      type="checkbox"
      data-testid={`checkbox-${id}`}
      checked={checked}
      disabled={disabled}
      onChange={(e: any) => onCheckedChange?.(e.target.checked)}
    />
  )
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled, className, variant }: any) => (
    <button onClick={onClick} disabled={disabled} className={className} data-variant={variant}>{children}</button>
  )
}))

vi.mock('../../ui/label', () => ({
  Label: ({ children, htmlFor, className }: any) => <label htmlFor={htmlFor} className={className}>{children}</label>
}))

vi.mock('../../ui/alert-dialog', () => ({
  AlertDialog: ({ children, open }: any) => open ? <div data-testid="alert-dialog">{children}</div> : null,
  AlertDialogAction: ({ children, onClick }: any) => <button data-testid="alert-action" onClick={onClick}>{children}</button>,
  AlertDialogCancel: ({ children, onClick }: any) => <button data-testid="alert-cancel" onClick={onClick}>{children}</button>,
  AlertDialogContent: ({ children }: any) => <div>{children}</div>,
  AlertDialogDescription: ({ children }: any) => <p>{children}</p>,
  AlertDialogFooter: ({ children }: any) => <div>{children}</div>,
  AlertDialogHeader: ({ children }: any) => <div>{children}</div>,
  AlertDialogTitle: ({ children }: any) => <h4>{children}</h4>
}))

vi.mock('lucide-react', () => ({
  Package: (p: any) => <span data-testid="package-icon" {...p} />,
  Settings: (p: any) => <span data-testid="settings-icon" {...p} />,
  Save: (p: any) => <span data-testid="save-icon" {...p} />,
  X: (p: any) => <span data-testid="x-icon" {...p} />
}))

vi.mock('../../../lib/utils', () => ({
  cn: (...a: unknown[]) => a.filter(Boolean).join(' ')
}))

import { FunctionAssignmentPanel } from '../function-assignment-panel'

const baseApp = {
  appIdentifier: 'app-1',
  titleText: 'Test Application',
  descriptionText: 'A test app description',
  categoryName: 'Banking',
  isAssignedIndicator: false,
  assignedFunctionKeys: [] as string[],
  defaultFunctionKey: undefined,
  functionDefinitionsObject: {
    'func-a': { displayName: 'Function A', description: 'Desc A', categoryText: 'write' },
    'func-b': { displayName: 'Function B', description: 'Desc B', categoryText: 'read' }
  }
}

describe('FunctionAssignmentPanel', () => {
  const defaultProps = {
    app: baseApp as any,
    groupName: 'Test AD Group',
    onSave: vi.fn(),
    isLoading: false
  }

  it('renders app title and description', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('Test Application')).toBeInTheDocument()
    expect(screen.getByText('A test app description')).toBeInTheDocument()
  })

  it('renders available function definitions', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('Function A')).toBeInTheDocument()
    expect(screen.getByText('Function B')).toBeInTheDocument()
  })

  it('shows assigned badge when app is assigned', () => {
    const assignedApp = { ...baseApp, isAssignedIndicator: true, assignedFunctionKeys: ['func-a'] }
    render(<FunctionAssignmentPanel {...defaultProps} app={assignedApp as any} />)
    expect(screen.getByText('Assigned')).toBeInTheDocument()
  })

  it('shows unassign button when app is assigned', () => {
    const assignedApp = { ...baseApp, isAssignedIndicator: true, assignedFunctionKeys: ['func-a'] }
    render(<FunctionAssignmentPanel {...defaultProps} app={assignedApp as any} />)
    expect(screen.getByText('Unassign Application')).toBeInTheDocument()
  })

  it('shows no-changes message when there are no changes', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('Current assignment saved')).toBeInTheDocument()
  })

  it('renders permission filter buttons', () => {
    render(<FunctionAssignmentPanel {...defaultProps} />)
    expect(screen.getByText('All (2)')).toBeInTheDocument()
    expect(screen.getByText('Write (1)')).toBeInTheDocument()
    expect(screen.getByText('Read (1)')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/__tests__/iframe-layout-preview.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  RefreshCw: (p: Record<string, unknown>) => <span data-testid="refresh" {...p} />,
  ExternalLink: (p: Record<string, unknown>) => <span data-testid="external" {...p} />
}))

vi.mock('../../ui/card', () => ({
  Card: ({ children, className }: any) => <div data-testid="card" className={className}>{children}</div>
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: any) => <button onClick={onClick} disabled={disabled}>{children}</button>
}))

vi.mock('../../ui/badge', () => ({
  Badge: ({ children }: any) => <span data-testid="badge">{children}</span>
}))

import { IframeLayoutPreview } from '../iframe-layout-preview'

const mockRole = {
  roleName: 'voice_agent',
  displayName: 'Voice Agent',
  columns: [],
}

describe('IframeLayoutPreview', () => {
  it('renders preview title with role name', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    expect(screen.getByText('Voice Agent Layout Preview')).toBeInTheDocument()
  })

  it('renders iframe with correct title', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    const iframe = document.getElementById('preview-iframe') as HTMLIFrameElement
    expect(iframe).toBeTruthy()
    expect(iframe.title).toBe('Voice Agent Dashboard Preview')
  })

  it('shows ad group badge when provided', () => {
    render(<IframeLayoutPreview role={mockRole as any} adGroup="TestGroup" />)
    expect(screen.getByText('AD Group: TestGroup')).toBeInTheDocument()
  })

  it('renders refresh button', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    expect(screen.getByText('Refresh')).toBeInTheDocument()
  })

  it('renders open in new tab button', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    expect(screen.getByText('Open Full')).toBeInTheDocument()
  })

  it('opens new tab on button click', () => {
    const openSpy = vi.spyOn(window, 'open').mockImplementation(() => null)
    render(<IframeLayoutPreview role={mockRole as any} />)
    fireEvent.click(screen.getByText('Open Full'))
    expect(openSpy).toHaveBeenCalled()
    openSpy.mockRestore()
  })

  it('renders preview description', () => {
    render(<IframeLayoutPreview role={mockRole as any} />)
    expect(screen.getByText(/This preview shows the exact dashboard interface/)).toBeInTheDocument()
    expect(screen.getByText(/Real components with demo data/)).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/__tests__/layout-preview-modal.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  Eye: (p: Record<string, unknown>) => <span data-testid="eye" {...p} />
}))

vi.mock('../iframe-layout-preview', () => ({
  IframeLayoutPreview: ({ role }: any) => <div data-testid="iframe-preview">{role?.roleName}</div>
}))

vi.mock('../../ui/dialog', () => ({
  Dialog: ({ children }: any) => <div data-testid="dialog">{children}</div>,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogTrigger: ({ children }: any) => <div data-testid="trigger">{children}</div>,
}))

vi.mock('../../ui/button', () => ({
  Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>
}))

import { LayoutPreviewModal } from '../layout-preview-modal'

const mockRole = { roleName: 'voice_agent', displayName: 'Voice Agent', columns: [] }

describe('LayoutPreviewModal', () => {
  it('renders trigger with eye icon', () => {
    render(<LayoutPreviewModal role={mockRole as any} />)
    expect(screen.getByTestId('trigger')).toBeInTheDocument()
    expect(screen.getByText('Preview Dashboard')).toBeInTheDocument()
  })

  it('renders custom trigger children', () => {
    render(<LayoutPreviewModal role={mockRole as any}><span>Custom Trigger</span></LayoutPreviewModal>)
    expect(screen.getByText('Custom Trigger')).toBeInTheDocument()
  })

  it('renders dialog container', () => {
    render(<LayoutPreviewModal role={mockRole as any} />)
    expect(screen.getByTestId('dialog')).toBeInTheDocument()
  })

  it('shows preview title', () => {
    render(<LayoutPreviewModal role={mockRole as any} />)
    expect(screen.getByText('Dashboard Layout Preview')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/ad-group-config/__tests__/ad-group-config-modal.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('../../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children, className }: any) => <div data-testid="dialog-content" className={className}>{children}</div>,
  DialogDescription: ({ children, className }: any) => <p className={className}>{children}</p>,
  DialogFooter: ({ children, className }: any) => <div data-testid="dialog-footer" className={className}>{children}</div>,
  DialogHeader: ({ children, className }: any) => <div className={className}>{children}</div>,
  DialogTitle: ({ children, className }: any) => <h2 className={className}>{children}</h2>
}))

vi.mock('../../../ui/button', () => ({
  Button: ({ children, onClick, disabled, variant }: any) => (
    <button onClick={onClick} disabled={disabled} data-variant={variant}>{children}</button>
  )
}))

vi.mock('../../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('../../../ui/tabs', () => ({
  Tabs: ({ children, value }: any) => <div data-testid="tabs" data-value={value}>{children}</div>,
  TabsList: ({ children, className }: any) => <div className={className}>{children}</div>,
  TabsTrigger: ({ children, value }: any) => <button data-testid={`tab-trigger-${value}`}>{children}</button>,
  TabsContent: ({ children, value }: any) => <div data-testid={`tab-content-${value}`}>{children}</div>
}))

vi.mock('lucide-react', () => ({
  Building2: (p: any) => <span data-testid="building-icon" {...p} />,
  Settings: (p: any) => <span data-testid="settings-icon" {...p} />,
  Package: (p: any) => <span data-testid="package-icon" {...p} />,
  AlertTriangle: (p: any) => <span data-testid="alert-icon" {...p} />
}))

const mockUpdateFormData = vi.fn()
const mockSetPendingChanges = vi.fn()
const mockClearStagedAppChanges = vi.fn()

vi.mock('../../../../hooks/admin/use-ad-group-form', () => ({
  useAdGroupForm: () => ({
    formData: { logicalName: 'Test Group', groupIdentifier: 'CN=test', roleName: 'voice_agent' },
    roleTemplate: { name: 'voice_agent', permissions: {} },
    isLoadingRoleTemplate: false,
    permissionOverrides: {},
    pendingChanges: { permissions: {} },
    isLoadingAdGroup: false,
    updateFormData: mockUpdateFormData,
    updatePermissionOverrides: vi.fn(),
    setPendingChanges: mockSetPendingChanges,
    updateAdGroupConfig: vi.fn()
  })
}))

vi.mock('../../../../hooks/admin/use-application-assignment', () => ({
  useApplicationAssignment: () => ({
    selectedApp: null,
    appSearchTerm: '',
    filteredApps: [],
    isLoadingApps: false,
    isSavingAppAssignment: false,
    stagedAppChanges: [],
    setAppSearchTerm: vi.fn(),
    handleAppSelect: vi.fn(),
    handleSaveAppAssignment: vi.fn(),
    clearStagedAppChanges: mockClearStagedAppChanges
  })
}))

vi.mock('../../../../hooks/admin/use-permission-toggle', () => ({
  usePermissionToggle: () => ({
    loadingPermission: null,
    handleTogglePermission: vi.fn()
  })
}))

vi.mock('../../../../hooks/admin/use-config-save', () => ({
  useConfigSave: () => ({
    showSaveDialog: false,
    setShowSaveDialog: vi.fn(),
    handleSaveClick: vi.fn(),
    handleDirectSaveClick: vi.fn(),
    handleConfirmSave: vi.fn(),
    isDirectSave: false
  })
}))

vi.mock('../dialogs/save-confirmation-dialog', () => ({
  SaveConfirmationDialog: () => null
}))

vi.mock('../dialogs/unsaved-changes-dialog', () => ({
  UnsavedChangesDialog: () => null
}))

vi.mock('../../tabs/business-info-tab', () => ({
  BusinessInfoTab: () => <div data-testid="business-info-tab">Business Info</div>
}))

vi.mock('../../tabs/permissions-tab', () => ({
  PermissionsTab: () => <div data-testid="permissions-tab">Permissions</div>
}))

vi.mock('../../tabs/applications-tab', () => ({
  ApplicationsTab: () => <div data-testid="applications-tab">Applications</div>
}))

vi.mock('../utils/permission-helpers', () => ({
  hasUnsavedChanges: () => false,
  isBusinessInfoComplete: () => true
}))

import { AdGroupConfigModal } from '../ad-group-config-modal'

const baseGroup = {
  id: 'g1',
  groupIdentifier: 'CN=test-group',
  logicalName: 'Test Group',
  roleName: 'voice_agent',
  accessLevel: 'MAKER'
} as any

const allPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: false,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

describe('AdGroupConfigModal', () => {
  const defaultProps = {
    group: baseGroup,
    open: true,
    onClose: vi.fn(),
    onSave: vi.fn(),
    permissions: allPermissions
  }

  it('renders dialog with group name when open', () => {
    render(<AdGroupConfigModal {...defaultProps} />)
    expect(screen.getByText('Test Group')).toBeInTheDocument()
    expect(screen.getByText('CN=test-group')).toBeInTheDocument()
  })

  it('does not render when closed', () => {
    render(<AdGroupConfigModal {...defaultProps} open={false} />)
    expect(screen.queryByTestId('dialog')).not.toBeInTheDocument()
  })

  it('renders all three tab triggers when permissions allow', () => {
    render(<AdGroupConfigModal {...defaultProps} />)
    expect(screen.getByTestId('tab-trigger-basic')).toBeInTheDocument()
    expect(screen.getByTestId('tab-trigger-permissions')).toBeInTheDocument()
    expect(screen.getByTestId('tab-trigger-applications')).toBeInTheDocument()
  })

  it('hides tabs when permissions deny access', () => {
    const restricted = {
      ...allPermissions,
      canEditBusinessInfo: false,
      canEditPermissions: false,
      canEditApplications: false
    }
    render(<AdGroupConfigModal {...defaultProps} permissions={restricted} />)
    expect(screen.queryByTestId('tab-trigger-basic')).not.toBeInTheDocument()
    expect(screen.queryByTestId('tab-trigger-permissions')).not.toBeInTheDocument()
    expect(screen.queryByTestId('tab-trigger-applications')).not.toBeInTheDocument()
  })

  it('shows submit for approval button for non-SUPER_ADMIN', () => {
    render(<AdGroupConfigModal {...defaultProps} />)
    expect(screen.getByText('Submit for Approval')).toBeInTheDocument()
  })

  it('shows save changes button for SUPER_ADMIN access level', () => {
    const superGroup = { ...baseGroup, accessLevel: 'SUPER_ADMIN' }
    render(<AdGroupConfigModal {...defaultProps} group={superGroup} />)
    expect(screen.getByText('Save Changes')).toBeInTheDocument()
  })

  it('uses max-viewport dialog sizing classes', () => {
    render(<AdGroupConfigModal {...defaultProps} />)
    const dialogContent = screen.getByTestId('dialog-content')
    expect(dialogContent.className).toContain('!w-screen')
    expect(dialogContent.className).toContain('!max-w-none')
    expect(dialogContent.className).toContain('!h-[100dvh]')
  })
})
===ENDFILE
===FILE: ./src/components/admin/ad-group-config/ad-group-config-modal.tsx
import { useState } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '../../ui/dialog'
import { Button } from '../../ui/button'
import { Badge } from '../../ui/badge'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../../ui/tabs'
import {
  Building2,
  Settings,
  Package,
  AlertTriangle
} from 'lucide-react'

// Import hooks
import { useAdGroupForm } from '../../../hooks/admin/use-ad-group-form'
import { useApplicationAssignment } from '../../../hooks/admin/use-application-assignment'
import { usePermissionToggle } from '../../../hooks/admin/use-permission-toggle'
import { useConfigSave } from '../../../hooks/admin/use-config-save'

// Import components
import { SaveConfirmationDialog } from './dialogs/save-confirmation-dialog'
import { UnsavedChangesDialog } from './dialogs/unsaved-changes-dialog'
import { BusinessInfoTab } from '../tabs/business-info-tab'
import { PermissionsTab } from '../tabs/permissions-tab'
import { ApplicationsTab } from '../tabs/applications-tab'

// Import types and utils
import type { AdGroupConfigModalProps } from '../../../types/features/ad-group-config'
import type { AdminPermissions } from '../admin-layout'
import {
  hasUnsavedChanges,
  isBusinessInfoComplete
} from './utils/permission-helpers'

interface AdGroupConfigModalWithPermissionsProps extends AdGroupConfigModalProps {
  permissions: AdminPermissions
}

function getTabGridClass(visibleCount: number): string {
  if (visibleCount === 3) return 'grid-cols-3'
  if (visibleCount === 2) return 'grid-cols-2'
  return 'grid-cols-1'
}

function getGroupDisplayName(group: { logicalName?: string; groupIdentifier: string }): string {
  return group.logicalName || group.groupIdentifier
}

function ConfigModalTabTriggers({ canEditBusinessInfo, canEditPermissions, canEditApplications, stagedAppChangesCount }: Readonly<{
  canEditBusinessInfo: boolean
  canEditPermissions: boolean
  canEditApplications: boolean
  stagedAppChangesCount: number
}>) {
  return (
    <>
      {canEditBusinessInfo && (
        <TabsTrigger value="basic" className="flex items-center gap-2">
          <Building2 className="h-4 w-4" />
          Business Info
        </TabsTrigger>
      )}
      {canEditPermissions && (
        <TabsTrigger value="permissions" className="flex items-center gap-2">
          <Settings className="h-4 w-4" />
          Permissions
        </TabsTrigger>
      )}
      {canEditApplications && (
        <TabsTrigger value="applications" className="flex items-center gap-2">
          <Package className="h-4 w-4" />
          Applications
          {stagedAppChangesCount > 0 && (
            <Badge variant="secondary" className="bg-orange-100 text-orange-700 text-xs px-1.5 py-0">
              {stagedAppChangesCount}
            </Badge>
          )}
        </TabsTrigger>
      )}
    </>
  )
}

function ConfigModalFooterActions({ isReadOnly, canDirectSave, isBusinessComplete, isLoadingAdGroup, isLoadingRoleTemplate, onClose, onDirectSave, onSubmit }: Readonly<{
  isReadOnly: boolean
  canDirectSave: boolean
  isBusinessComplete: boolean
  isLoadingAdGroup: boolean
  isLoadingRoleTemplate: boolean
  onClose: () => void
  onDirectSave: () => void
  onSubmit: () => void
}>) {
  const isSaveDisabled = isLoadingAdGroup || isLoadingRoleTemplate || !isBusinessComplete
  const saveTitle = !isBusinessComplete ? 'Complete all required business info fields before saving' : undefined
  const submitTitle = !isBusinessComplete ? 'Complete all required business info fields before submitting' : undefined

  return (
    <>
      {isReadOnly && (
        <div className="flex-1 flex items-center">
          <Badge variant="secondary" className="bg-gray-100 text-gray-600 border-gray-300">
            Read-only access
          </Badge>
        </div>
      )}
      <Button variant="outline" onClick={onClose}>
        {isReadOnly ? 'Close' : 'Cancel'}
      </Button>
      {!isReadOnly && (
        canDirectSave ? (
          <Button onClick={onDirectSave} disabled={isSaveDisabled} title={saveTitle}>
            Save Changes
          </Button>
        ) : (
          <Button onClick={onSubmit} disabled={isSaveDisabled} title={submitTitle}>
            Submit for Approval
          </Button>
        )
      )}
    </>
  )
}

export function AdGroupConfigModal({
  group,
  open,
  onClose,
  onSave,
  permissions
}: Readonly<AdGroupConfigModalWithPermissionsProps>) {
  const [activeTab, setActiveTab] = useState('basic')
  const [searchTerm, setSearchTerm] = useState('')
  const [showUnsavedChangesDialog, setShowUnsavedChangesDialog] = useState(false)

  // Extract tab permissions from props (following agent role pattern)
  const { canEditBusinessInfo, canEditPermissions, canEditApplications } = permissions

  // Per-group access level determines save behavior (not global entitlement)
  // SUPER_ADMIN on this specific group = can bypass approval workflow
  const canDirectSave = group.accessLevel === 'SUPER_ADMIN'
  // VIEWER on this specific group = read-only, no editing allowed
  const isReadOnly = group.accessLevel === 'VIEWER'

  // Form and permission management
  const {
    formData,
    roleTemplate,
    isLoadingRoleTemplate,
    permissionOverrides,
    pendingChanges,
    isLoadingAdGroup,
    updateFormData,
    updatePermissionOverrides,
    setPendingChanges,
    updateAdGroupConfig,
  } = useAdGroupForm({ initialGroup: group, open })

  // Application assignment management
  const {
    selectedApp,
    appSearchTerm,
    filteredApps,
    isLoadingApps,
    isSavingAppAssignment,
    stagedAppChanges,
    setAppSearchTerm,
    handleAppSelect,
    handleSaveAppAssignment,
    handleFunctionSelectionChange,
    flushUnsavedFunctions,
    clearStagedAppChanges,
  } = useApplicationAssignment({
    groupIdentifier: group.groupIdentifier,
    groupDisplayName: getGroupDisplayName(group),
    open,
    activeTab,
    canDirectSave
  })

  // Permission toggle management
  const { loadingPermission, handleTogglePermission } = usePermissionToggle({
    roleTemplate,
    permissionOverrides,
    pendingChanges,
    setPendingChanges
  })

  // Save configuration management
  const {
    showSaveDialog,
    setShowSaveDialog,
    handleSaveClick,
    handleDirectSaveClick,
    handleConfirmSave,
    isDirectSave
  } = useConfigSave({
    formData,
    group,
    permissionOverrides,
    pendingChanges,
    stagedAppChanges,
    canDirectSave,
    updateAdGroupConfig,
    updatePermissionOverrides,
    setPendingChanges,
    clearStagedAppChanges,
    flushUnsavedFunctions,
    onSave,
    onClose
  })

  const isBusinessComplete = isBusinessInfoComplete(formData)
  const hasAnyUnsavedChanges = hasUnsavedChanges(pendingChanges) || stagedAppChanges.length > 0

  const handleClose = () => {
    if (hasAnyUnsavedChanges) {
      setShowUnsavedChangesDialog(true)
    } else {
      onClose()
    }
  }

  const handleConfirmClose = () => {
    setPendingChanges({ permissions: {} })
    clearStagedAppChanges()
    setShowUnsavedChangesDialog(false)
    onClose()
  }

  return (
    <>
      <Dialog open={open} onOpenChange={handleClose}>
        <DialogContent className="!h-[100dvh] !max-h-[100dvh] !w-screen !max-w-none min-h-0 flex flex-col rounded-none p-4 sm:p-6">
          <DialogHeader className="shrink-0">
            <DialogTitle className="flex items-center gap-2">
              <Building2 className="h-5 w-5" />
              {isBusinessComplete ? 'Edit AD Group Configuration' : 'Configure AD Group'}
              {hasAnyUnsavedChanges && (
                <Badge variant="secondary" className="bg-orange-100 text-orange-700 border-orange-200">
                  <AlertTriangle className="h-3 w-3 mr-1" />
                  Unsaved Changes
                </Badge>
              )}
            </DialogTitle>
            <DialogDescription className="sr-only">
              Configure business information and permissions for this Active Directory group.
            </DialogDescription>
            <div className="mt-2">
              <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
                <p className="text-sm text-blue-900 font-medium">Active Directory Group</p>
                <p className="text-sm font-medium mt-1">{group.logicalName}</p>
                <p className="text-xs text-gray-600">{group.groupIdentifier}</p>
              </div>
              <p className="text-sm text-gray-600 mt-3">
                Configure business information and permissions for this Active Directory group.
              </p>
            </div>
          </DialogHeader>

          <div className="mt-4 min-h-0 flex-1 overflow-hidden">
            <Tabs value={activeTab} onValueChange={setActiveTab} className="flex h-full min-h-0 flex-col">
              {/* Dynamic grid layout based on visible tabs */}
              <TabsList className={`grid w-full ${getTabGridClass([canEditBusinessInfo, canEditPermissions, canEditApplications].filter(Boolean).length)}`}>
                <ConfigModalTabTriggers
                  canEditBusinessInfo={canEditBusinessInfo}
                  canEditPermissions={canEditPermissions}
                  canEditApplications={canEditApplications}
                  stagedAppChangesCount={stagedAppChanges.length}
                />
              </TabsList>

              <div className="mt-6 min-h-0 flex-1 overflow-hidden">
                {canEditBusinessInfo && (
                  <TabsContent value="basic" className="mt-0 h-full min-h-0 overflow-hidden">
                    <div className="h-full min-h-0 w-full overflow-y-auto pr-2 scrollbar-visible">
                      <BusinessInfoTab
                        formData={formData}
                        pendingChanges={pendingChanges}
                        onFormDataChange={updateFormData}
                        onPendingChangesUpdate={setPendingChanges}
                        isReadOnly={isReadOnly}
                      />
                    </div>
                  </TabsContent>
                )}

                {canEditPermissions && (
                  <TabsContent value="permissions" className="mt-0 h-full min-h-0 overflow-hidden">
                    <div className="h-full min-h-0 w-full overflow-y-auto pr-2 scrollbar-visible">
                      <PermissionsTab
                        formData={formData}
                        roleTemplate={roleTemplate}
                        permissionOverrides={permissionOverrides}
                        pendingChanges={pendingChanges}
                        searchTerm={searchTerm}
                        loadingPermission={loadingPermission}
                        isLoadingTemplate={isLoadingRoleTemplate}
                        onSearchTermChange={setSearchTerm}
                        onTogglePermission={(level, key, value) => handleTogglePermission({ level, key, value })}
                        isReadOnly={isReadOnly}
                      />
                    </div>
                  </TabsContent>
                )}

                {canEditApplications && (
                  <TabsContent value="applications" className="mt-0 h-full min-h-0 overflow-hidden">
                    <div className="h-full min-h-0 w-full overflow-y-auto pr-2 scrollbar-visible">
                      <ApplicationsTab
                        availableApps={filteredApps}
                        selectedApp={selectedApp}
                        appSearchTerm={appSearchTerm}
                        groupDisplayName={getGroupDisplayName(group)}
                        isLoadingApps={isLoadingApps}
                        isSavingAppAssignment={isSavingAppAssignment}
                        onAppSearchTermChange={setAppSearchTerm}
                        onAppSelect={handleAppSelect}
                        onAppSave={handleSaveAppAssignment}
                        onFunctionSelectionChange={handleFunctionSelectionChange}
                        isReadOnly={isReadOnly}
                      />
                    </div>
                  </TabsContent>
                )}
              </div>
            </Tabs>
          </div>

          <DialogFooter className="shrink-0">
            <ConfigModalFooterActions
              isReadOnly={isReadOnly}
              canDirectSave={canDirectSave}
              isBusinessComplete={isBusinessComplete}
              isLoadingAdGroup={isLoadingAdGroup}
              isLoadingRoleTemplate={isLoadingRoleTemplate}
              onClose={handleClose}
              onDirectSave={handleDirectSaveClick}
              onSubmit={handleSaveClick}
            />
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <SaveConfirmationDialog
        open={showSaveDialog}
        onClose={() => setShowSaveDialog(false)}
        onConfirm={handleConfirmSave}
        pendingChanges={pendingChanges}
        groupName={formData.logicalName || 'Unknown Group'}
        isDirectSave={isDirectSave}
      />

      <UnsavedChangesDialog
        open={showUnsavedChangesDialog}
        onClose={() => setShowUnsavedChangesDialog(false)}
        onConfirm={handleConfirmClose}
      />
    </>
  )
}
===ENDFILE
===FILE: ./src/components/admin/ad-group-config/dialogs/__tests__/save-confirmation-dialog.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../ui/alert-dialog', () => ({
  AlertDialog: ({ children, open }: any) => open ? <div data-testid="alert-dialog">{children}</div> : null,
  AlertDialogAction: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>,
  AlertDialogCancel: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>,
  AlertDialogContent: ({ children }: any) => <div>{children}</div>,
  AlertDialogDescription: ({ children }: any) => <div>{children}</div>,
  AlertDialogFooter: ({ children }: any) => <div>{children}</div>,
  AlertDialogHeader: ({ children }: any) => <div>{children}</div>,
  AlertDialogTitle: ({ children }: any) => <h2>{children}</h2>
}))
vi.mock('../../../../ui/badge', () => ({ Badge: ({ children }: any) => <span>{children}</span> }))
vi.mock('lucide-react', () => ({
  CheckCircle: (p: any) => <span {...p} />,
  Building2: (p: any) => <span {...p} />
}))
vi.mock('../../utils/permission-helpers', () => ({
  countPendingChangesByType: () => ({ businessInfoCount: 1, permissionCount: 2, appCount: 0 }),
  summarizePermissionChanges: () => [{ label: 'Enabled', count: 1, items: ['voice'] }]
}))

import { SaveConfirmationDialog } from '../save-confirmation-dialog'

const basePendingChanges = { businessInfo: {}, permissions: {}, apps: {} } as any

describe('SaveConfirmationDialog', () => {
  it('renders nothing when closed', () => {
    const { container } = render(
      <SaveConfirmationDialog open={false} onClose={vi.fn()} onConfirm={vi.fn()} pendingChanges={basePendingChanges} groupName="Test" />
    )
    expect(container.querySelector('[data-testid="alert-dialog"]')).toBeNull()
  })

  it('renders submit for approval title by default', () => {
    render(
      <SaveConfirmationDialog open={true} onClose={vi.fn()} onConfirm={vi.fn()} pendingChanges={basePendingChanges} groupName="Test" />
    )
    expect(screen.getByText('Submit Changes for Approval?')).toBeInTheDocument()
  })

  it('renders direct save title when isDirectSave', () => {
    render(
      <SaveConfirmationDialog open={true} onClose={vi.fn()} onConfirm={vi.fn()} pendingChanges={basePendingChanges} groupName="Test" isDirectSave />
    )
    expect(screen.getByText('Apply Changes Immediately?')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/ad-group-config/dialogs/__tests__/unsaved-changes-dialog.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../ui/alert-dialog', () => ({
  AlertDialog: ({ children, open }: any) => open ? <div data-testid="alert-dialog">{children}</div> : null,
  AlertDialogAction: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>,
  AlertDialogCancel: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button>,
  AlertDialogContent: ({ children }: any) => <div>{children}</div>,
  AlertDialogDescription: ({ children }: any) => <div>{children}</div>,
  AlertDialogFooter: ({ children }: any) => <div>{children}</div>,
  AlertDialogHeader: ({ children }: any) => <div>{children}</div>,
  AlertDialogTitle: ({ children }: any) => <h2>{children}</h2>
}))
vi.mock('lucide-react', () => ({
  AlertTriangle: (p: any) => <span {...p} />
}))

import { UnsavedChangesDialog } from '../unsaved-changes-dialog'

describe('UnsavedChangesDialog', () => {
  it('renders nothing when closed', () => {
    const { container } = render(
      <UnsavedChangesDialog open={false} onClose={vi.fn()} onConfirm={vi.fn()} />
    )
    expect(container.querySelector('[data-testid="alert-dialog"]')).toBeNull()
  })

  it('renders dialog when open', () => {
    render(<UnsavedChangesDialog open={true} onClose={vi.fn()} onConfirm={vi.fn()} />)
    expect(screen.getByTestId('alert-dialog')).toBeInTheDocument()
    expect(screen.getByText('Unsaved Changes')).toBeInTheDocument()
  })

  it('renders continue editing and discard buttons', () => {
    render(<UnsavedChangesDialog open={true} onClose={vi.fn()} onConfirm={vi.fn()} />)
    expect(screen.getByText('Continue Editing')).toBeInTheDocument()
    expect(screen.getByText('Discard Changes')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/ad-group-config/dialogs/save-confirmation-dialog.tsx
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '../../../ui/alert-dialog'
import { Badge } from '../../../ui/badge'
import { CheckCircle, Building2 } from 'lucide-react'
import type { PendingChanges } from '../../../../types/features/ad-group-config'
import { countPendingChangesByType, summarizePermissionChanges } from '../utils/permission-helpers'

function pluralize(count: number, singular: string, plural: string): string {
  return count === 1 ? `${count} ${singular}` : `${count} ${plural}`
}

interface SaveConfirmationDialogProps {
  open: boolean
  onClose: () => void
  onConfirm: () => void
  pendingChanges: PendingChanges
  groupName: string
  isDirectSave?: boolean  // Super Admin direct save (bypasses approval)
}

export function SaveConfirmationDialog({
  open,
  onClose,
  onConfirm,
  pendingChanges,
  groupName,
  isDirectSave = false
}: Readonly<SaveConfirmationDialogProps>) {
  const counts = countPendingChangesByType(pendingChanges)
  const summaries = summarizePermissionChanges(pendingChanges.permissions)

  return (
    <AlertDialog open={open} onOpenChange={onClose}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>{isDirectSave ? 'Apply Changes Immediately?' : 'Submit Changes for Approval?'}</AlertDialogTitle>
          <AlertDialogDescription asChild>
            <div className="space-y-3">
              <p>
                {isDirectSave
                  ? `You are about to apply configuration changes directly to ${groupName}. These changes will take effect immediately without requiring approval.`
                  : `You are about to submit configuration changes for ${groupName} for review.`}
              </p>

              {isDirectSave && (
                <div className="bg-amber-50 border border-amber-200 rounded-lg p-3">
                  <p className="text-sm font-medium text-amber-900">
                    As a Super Admin, you are bypassing the standard approval workflow. Please ensure these changes are correct.
                  </p>
                </div>
              )}

              {counts.businessInfoCount > 0 && (
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
                  <p className="text-sm font-medium text-blue-900 flex items-center gap-2">
                    <Building2 className="h-4 w-4" />
                    {`${pluralize(counts.businessInfoCount, 'business information field', 'business information fields')} will be updated`}
                  </p>
                </div>
              )}

              {counts.permissionCount > 0 && (
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
                  <p className="text-sm font-medium text-blue-900 flex items-center gap-2">
                    <CheckCircle className="h-4 w-4" />
                    {`${pluralize(counts.permissionCount, 'permission change', 'permission changes')} will be submitted`}
                  </p>
                  {summaries.length > 0 && (
                    <div className="mt-2 space-y-1">
                      {summaries.map(summary => (
                        <div key={summary.label} className="text-xs text-blue-900/90">
                          <span className="font-semibold">{summary.label}</span>
                          <span className="ml-1 text-blue-900/70">
                            ({pluralize(summary.count, 'change', 'changes')})
                          </span>
                          <div className="mt-0.5 flex flex-wrap gap-1.5">
                            {summary.items.map(item => (
                              <Badge key={item} variant="secondary" className="text-[11px] capitalize">
                                {item}
                              </Badge>
                            ))}
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}

              {!isDirectSave && (
                <p className="text-sm text-gray-600">
                  A reviewer will need to approve these changes before they take effect.
                </p>
              )}
            </div>
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel onClick={onClose}>Cancel</AlertDialogCancel>
          <AlertDialogAction onClick={onConfirm}>{isDirectSave ? 'Save Changes' : 'Submit for Approval'}</AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  )
}
===ENDFILE
===FILE: ./src/components/admin/ad-group-config/dialogs/unsaved-changes-dialog.tsx
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '../../../ui/alert-dialog'
import { AlertTriangle } from 'lucide-react'

interface UnsavedChangesDialogProps {
  open: boolean
  onClose: () => void
  onConfirm: () => void
}

export function UnsavedChangesDialog({
  open,
  onClose,
  onConfirm
}: Readonly<UnsavedChangesDialogProps>) {
  return (
    <AlertDialog open={open} onOpenChange={onClose}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle className="flex items-center gap-2">
            <AlertTriangle className="h-5 w-5 text-amber-500" />
            Unsaved Changes
          </AlertDialogTitle>
          <AlertDialogDescription asChild>
            <div className="space-y-3">
              <p>
                You have unsaved changes that will be lost if you close this dialog.
              </p>
              <div className="bg-amber-50 border border-amber-200 rounded-lg p-3">
                <p className="text-sm font-medium text-amber-900">
                  Any changes you've made will not be saved.
                </p>
              </div>
              <p className="text-sm text-gray-600">
                Are you sure you want to close without saving?
              </p>
            </div>
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel onClick={onClose}>Continue Editing</AlertDialogCancel>
          <AlertDialogAction
            onClick={onConfirm}
            className="bg-red-600 hover:bg-red-700 focus:ring-red-600"
          >
            Discard Changes
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  )
}
===ENDFILE
===FILE: ./src/components/admin/ad-group-config/utils/__tests__/permission-helpers.test.ts
import { describe, expect, it } from 'vitest'
import {
  hasUnsavedChanges,
  countPendingChangesByType,
  summarizePermissionChanges,
  getTemplateSection,
  convertOverridesToAssignments,
  isBusinessInfoComplete
} from '../permission-helpers'

describe('hasUnsavedChanges', () => {
  it('returns false for empty pending changes', () => {
    expect(hasUnsavedChanges({ permissions: {} })).toBe(false)
  })

  it('returns true when permission changes exist', () => {
    expect(hasUnsavedChanges({
      permissions: { columns: { kms: true } }
    })).toBe(true)
  })

  it('returns true when business info changes exist', () => {
    expect(hasUnsavedChanges({
      permissions: {},
      businessInfo: { logicalName: 'New Name' }
    })).toBe(true)
  })

  it('returns false when permissions levels are empty objects', () => {
    expect(hasUnsavedChanges({
      permissions: { columns: {} }
    })).toBe(false)
  })
})

describe('countPendingChangesByType', () => {
  it('counts zero for empty changes', () => {
    const result = countPendingChangesByType({ permissions: {} })
    expect(result).toEqual({ permissionCount: 0, businessInfoCount: 0, total: 0 })
  })

  it('counts permission changes across levels', () => {
    const result = countPendingChangesByType({
      permissions: {
        columns: { kms: true, chat: false },
        widgets: { 'customer.info': true }
      }
    })
    expect(result.permissionCount).toBe(3)
    expect(result.total).toBe(3)
  })

  it('counts business info changes', () => {
    const result = countPendingChangesByType({
      permissions: {},
      businessInfo: { logicalName: 'X', roleName: 'Y' }
    })
    expect(result.businessInfoCount).toBe(2)
    expect(result.total).toBe(2)
  })
})

describe('summarizePermissionChanges', () => {
  it('returns empty array for no changes', () => {
    expect(summarizePermissionChanges({})).toEqual([])
  })

  it('skips levels with empty changes', () => {
    expect(summarizePermissionChanges({ columns: {} })).toEqual([])
  })

  it('summarizes permission changes with labels', () => {
    const result = summarizePermissionChanges({
      columns: { kms: true },
      widgets: { embeddedApps: false }
    })
    expect(result).toHaveLength(2)
    expect(result[0].count).toBe(1)
    expect(result[1].count).toBe(1)
  })

  it('uses workspacePreferences label', () => {
    const result = summarizePermissionChanges({
      workspacePreferences: { 'widgets.customer.info': true }
    })
    expect(result[0].label).toBe('Workspace & Preferences')
  })
})

describe('getTemplateSection', () => {
  it('returns empty object for null template', () => {
    expect(getTemplateSection(null, 'columns')).toEqual({})
  })

  it('returns the template section', () => {
    const template = {
      roleName: 'voice_agent',
      columns: { kms: { state: 'enabled' } }
    }
    expect(getTemplateSection(template as any, 'columns')).toEqual({ kms: { state: 'enabled' } })
  })

  it('returns empty object for missing section', () => {
    const template = { roleName: 'voice_agent' }
    expect(getTemplateSection(template as any, 'columns')).toEqual({})
  })

  it('returns empty object for non-object section', () => {
    const template = { roleName: 'voice_agent', columns: 'invalid' }
    expect(getTemplateSection(template as any, 'columns')).toEqual({})
  })
})

describe('convertOverridesToAssignments', () => {
  it('returns empty for empty overrides', () => {
    expect(convertOverridesToAssignments({})).toEqual({})
  })

  it('converts direct level overrides', () => {
    const result = convertOverridesToAssignments({
      columns: { kms: true, chat: false }
    })
    expect(result.columnAssignments).toEqual({
      kms: { state: 'enabled' },
      chat: { state: 'disabled' }
    })
  })

  it('converts capabilities with columns prefix', () => {
    const result = convertOverridesToAssignments({
      capabilities: { 'columns.kms': true }
    })
    expect(result.columnAssignments).toEqual({
      kms: { state: 'enabled' }
    })
  })

  it('converts capabilities with features prefix', () => {
    const result = convertOverridesToAssignments({
      capabilities: { 'features.search.knowledgeBase': false }
    })
    expect(result.featureAssignments).toEqual({
      'search.knowledgeBase': { state: 'disabled' }
    })
  })

  it('converts capabilities with micro_frontends prefix', () => {
    const result = convertOverridesToAssignments({
      capabilities: { 'micro_frontends.mediaBar': true }
    })
    expect(result.microFrontendAssignments).toEqual({
      mediaBar: { state: 'enabled' }
    })
  })

  it('converts workspacePreferences with widgets prefix', () => {
    const result = convertOverridesToAssignments({
      workspacePreferences: { 'widgets.customer.info': true }
    })
    expect(result.widgetAssignments).toEqual({
      'customer.info': { state: 'enabled' }
    })
  })

  it('converts workspacePreferences with settings_tabs prefix', () => {
    const result = convertOverridesToAssignments({
      workspacePreferences: { 'settings_tabs.help': false }
    })
    expect(result.settingsTabAssignments).toEqual({
      help: { state: 'disabled' }
    })
  })

  it('converts workspacePreferences with settings_options prefix', () => {
    const result = convertOverridesToAssignments({
      workspacePreferences: { 'settings_options.calls.autoAccept': true }
    })
    expect(result.settingsOptionAssignments).toEqual({
      'calls.autoAccept': { state: 'enabled' }
    })
  })

  it('converts widget overrides', () => {
    const result = convertOverridesToAssignments({
      widgets: { 'customer.info': true }
    })
    expect(result.widgetAssignments).toEqual({
      'customer.info': { state: 'enabled' }
    })
  })

  it('converts all direct level types', () => {
    const result = convertOverridesToAssignments({
      columns: { a: true },
      widgets: { b: true },
      features: { c: true },
      settings_tabs: { d: true },
      settings_options: { e: true },
      micro_frontends: { f: true }
    })
    expect(result.columnAssignments).toBeDefined()
    expect(result.widgetAssignments).toBeDefined()
    expect(result.featureAssignments).toBeDefined()
    expect(result.settingsTabAssignments).toBeDefined()
    expect(result.settingsOptionAssignments).toBeDefined()
    expect(result.microFrontendAssignments).toBeDefined()
  })
})

describe('isBusinessInfoComplete', () => {
  it('returns true when all required fields are present', () => {
    expect(isBusinessInfoComplete({
      id: '1',
      groupIdentifier: 'g1',
      isActive: true,
      logicalName: 'Test',
      roleName: 'voice_agent',
      region: 'EMEA',
      market: 'UK_RETAIL',
      country: 'UK',
      businessUnit: 'WPB'
    } as any)).toBe(true)
  })

  it('returns false when logicalName is missing', () => {
    expect(isBusinessInfoComplete({
      id: '1',
      groupIdentifier: 'g1',
      isActive: true,
      roleName: 'voice_agent',
      region: 'EMEA',
      country: 'UK'
    } as any)).toBe(false)
  })

  it('returns false when region is missing', () => {
    expect(isBusinessInfoComplete({
      id: '1',
      groupIdentifier: 'g1',
      isActive: true,
      logicalName: 'Test',
      roleName: 'voice_agent',
      country: 'UK'
    } as any)).toBe(false)
  })

  it('returns false when market is missing', () => {
    expect(isBusinessInfoComplete({
      id: '1',
      groupIdentifier: 'g1',
      isActive: true,
      logicalName: 'Test',
      roleName: 'voice_agent',
      region: 'EMEA',
      country: 'UK',
      businessUnit: 'WPB'
    } as any)).toBe(false)
  })

  it('returns false when businessUnit is missing', () => {
    expect(isBusinessInfoComplete({
      id: '1',
      groupIdentifier: 'g1',
      isActive: true,
      logicalName: 'Test',
      roleName: 'voice_agent',
      region: 'EMEA',
      market: 'UK_RETAIL',
      country: 'UK'
    } as any)).toBe(false)
  })
})
===ENDFILE
===FILE: ./src/components/admin/ad-group-config/utils/permission-helpers.ts
import type {
  PermissionOverrides,
  PendingChanges,
  RoleTemplate,
  AdGroup,
  PermissionState
} from '../../../../types/features/ad-group-config'

export function hasUnsavedChanges(pendingChanges: PendingChanges): boolean {
  const businessInfoChanged = !!pendingChanges.businessInfo && Object.keys(pendingChanges.businessInfo).length > 0
  const permissionChanges = Object.values(pendingChanges.permissions).some(level => Object.keys(level).length > 0)
  return businessInfoChanged || permissionChanges
}

export function countPendingChangesByType(pendingChanges: PendingChanges): {
  permissionCount: number
  businessInfoCount: number
  total: number
} {
  const permissionCount = Object.values(pendingChanges.permissions).reduce((acc, level) => acc + Object.keys(level).length, 0)
  const businessInfoCount = pendingChanges.businessInfo ? Object.keys(pendingChanges.businessInfo).length : 0
  return {
    permissionCount,
    businessInfoCount,
    total: permissionCount + businessInfoCount
  }
}

const LEVEL_LABELS: Record<string, string> = {
  capabilities: 'Access Controls',
  workspacePreferences: 'Workspace & Preferences',
  columns: 'Dashboard Layout overrides',
  widgets: 'Workspace Tools',
  features: 'Feature Access',
  settings_tabs: 'Settings sections',
  settings_options: 'Settings controls',
  micro_frontends: 'Embedded apps'
}

const TOGGLE_LABEL_OVERRIDES: Record<string, string> = {
  kms: 'Knowledge Base',
  embeddedApps: 'Embedded Apps Panel',
  spaceCopilot: 'Space Copilot',
  chat: 'Conversation Panel'
}

export function summarizePermissionChanges(permissions: PendingChanges['permissions']): { label: string; count: number; items: string[] }[] {
  return Object.entries(permissions)
    .map(([level, changes]) => {
      const keys = Object.keys(changes || {})
      if (keys.length === 0) return null

      const label = LEVEL_LABELS[level] || level
      const items = keys.map(key => formatPermissionLabel(TOGGLE_LABEL_OVERRIDES[key] || key))

      return {
        label,
        count: keys.length,
        items
      }
    })
    .filter((entry): entry is { label: string; count: number; items: string[] } => Boolean(entry))
}

export function getTemplateSection(roleTemplate: RoleTemplate | null, level: string): Record<string, PermissionState> {
  if (!roleTemplate) return {}
  const section = roleTemplate[level as keyof RoleTemplate]
  if (section && typeof section === 'object' && !Array.isArray(section)) {
    return section as Record<string, PermissionState>
  }
  return {}
}

interface AssignmentResult {
  columnAssignments?: Record<string, PermissionState>
  widgetAssignments?: Record<string, PermissionState>
  featureAssignments?: Record<string, PermissionState>
  settingsTabAssignments?: Record<string, PermissionState>
  settingsOptionAssignments?: Record<string, PermissionState>
  microFrontendAssignments?: Record<string, PermissionState>
  [key: string]: Record<string, PermissionState> | undefined
}

function toPermissionState(enabled: boolean): PermissionState {
  return { state: enabled ? 'enabled' : 'disabled' }
}

function applyCapabilityOverrides(
  capabilitiesOverrides: Record<string, boolean>,
  assignments: AssignmentResult
): void {
  for (const [key, enabled] of Object.entries(capabilitiesOverrides)) {
    if (key.startsWith('columns.')) {
      const columnKey = key.replace('columns.', '')
      assignments.columnAssignments ??= {}
      assignments.columnAssignments[columnKey] = toPermissionState(enabled)
    } else if (key.startsWith('features.')) {
      const featureKey = key.replace('features.', '')
      assignments.featureAssignments ??= {}
      assignments.featureAssignments[featureKey] = toPermissionState(enabled)
    } else if (key.startsWith('micro_frontends.')) {
      const mfKey = key.replace('micro_frontends.', '')
      assignments.microFrontendAssignments ??= {}
      assignments.microFrontendAssignments[mfKey] = toPermissionState(enabled)
    }
  }
}

function applyWorkspacePreferencesOverrides(
  overrides: Record<string, boolean>,
  assignments: AssignmentResult
): void {
  for (const [key, enabled] of Object.entries(overrides)) {
    if (key.startsWith('widgets.')) {
      const widgetKey = key.replace('widgets.', '')
      assignments.widgetAssignments ??= {}
      assignments.widgetAssignments[widgetKey] = toPermissionState(enabled)
    } else if (key.startsWith('settings_tabs.')) {
      const tabKey = key.replace('settings_tabs.', '')
      assignments.settingsTabAssignments ??= {}
      assignments.settingsTabAssignments[tabKey] = toPermissionState(enabled)
    } else if (key.startsWith('settings_options.')) {
      const optionKey = key.replace('settings_options.', '')
      assignments.settingsOptionAssignments ??= {}
      assignments.settingsOptionAssignments[optionKey] = toPermissionState(enabled)
    }
  }
}

function applyLevelOverrides(
  overrides: Record<string, boolean>,
  assignmentKey: string,
  assignments: AssignmentResult
): void {
  if (Object.keys(overrides).length === 0) return
  const assignmentBlock = assignments[assignmentKey] ?? {}
  assignments[assignmentKey] = assignmentBlock
  for (const [key, enabled] of Object.entries(overrides)) {
    assignmentBlock[key] = toPermissionState(enabled)
  }
}

const LEVEL_MAPPINGS = [
  { override: 'columns', assignment: 'columnAssignments' },
  { override: 'widgets', assignment: 'widgetAssignments' },
  { override: 'features', assignment: 'featureAssignments' },
  { override: 'settings_tabs', assignment: 'settingsTabAssignments' },
  { override: 'settings_options', assignment: 'settingsOptionAssignments' },
  { override: 'micro_frontends', assignment: 'microFrontendAssignments' }
]

export function convertOverridesToAssignments(
  permissionOverrides: PermissionOverrides
): AssignmentResult {
  const assignments: AssignmentResult = {}

  // Handle capabilities compound level
  const capabilitiesOverrides = permissionOverrides.capabilities || {}
  if (Object.keys(capabilitiesOverrides).length > 0) {
    applyCapabilityOverrides(capabilitiesOverrides, assignments)
  }

  // Handle workspacePreferences compound level
  const workspaceOverrides = permissionOverrides.workspacePreferences || {}
  if (Object.keys(workspaceOverrides).length > 0) {
    applyWorkspacePreferencesOverrides(workspaceOverrides, assignments)
  }

  // Handle direct level overrides (actual template section keys)
  for (const { override, assignment } of LEVEL_MAPPINGS) {
    applyLevelOverrides(permissionOverrides[override] || {}, assignment, assignments)
  }

  return assignments
}

export function isBusinessInfoComplete(formData: AdGroup): boolean {
  return !!(
    formData.logicalName &&
    formData.roleName &&
    formData.region &&
    formData.market &&
    formData.country &&
    formData.businessUnit
  )
}

function formatPermissionLabel(key: string): string {
  return key
    .split('.')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ')
    .replace(/([A-Z])/g, ' $1')
    .trim()
}
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/ad-groups-view.tsx
import { useCallback, useEffect, useState, memo } from 'react'
import { AdGroupConfigModal } from '../ad-group-config/ad-group-config-modal'
import { BulkOperationsToolbar } from '../bulk-operations-toolbar'
import type { AdGroup } from '../../../types/features/ad-group-config'
import type { AdminPermissions } from '../admin-layout'
import { Button } from '../../ui/button'

import { useAdGroupsData } from '../../../hooks/admin/use-ad-groups-data'
import { useAdGroupsSelection } from '../../../hooks/admin/use-ad-groups-selection'
import { useReferenceData } from '../../../hooks/api/use-reference-data'

// Components
import { AdGroupsStatsCards } from './components/ad-groups-stats-cards'
import { AdGroupsFiltersBar } from './components/ad-groups-filters-bar'
import { AdGroupsTable } from './components/ad-groups-table'
import { AdGroupsToggleDialog } from './components/ad-groups-toggle-dialog'
import { ActiveFiltersChips } from './components/active-filters-chips'

interface AdGroupsViewProps {
  permissions: AdminPermissions
}

interface FiltersState {
  search: string
  role: string
  status: string
  market: string
  region: string
  country: string
  businessUnit: string
}

const PAGE_SIZE = 25

function isGroupConfigured(group: AdGroup): boolean {
  return Boolean(group.logicalName && group.roleName && group.region && group.country)
}

function getGroupWithDefaults(group: AdGroup) {
  return {
    ...group,
    logicalName: group.logicalName || '',
    roleName: group.roleName || '',
    market: group.market || '',
    region: group.region || '',
    country: group.country || '',
    businessUnit: group.businessUnit || ''
  }
}

function AdGroupsViewComponent({ permissions }: Readonly<AdGroupsViewProps>) {
  const [selectedGroup, setSelectedGroup] = useState<AdGroup | null>(null)
  const [configModalOpen, setConfigModalOpen] = useState(false)
  const [savingGroupId, setSavingGroupId] = useState<string | null>(null)
  const [currentPage, setCurrentPage] = useState(1)
  const [filters, setFilters] = useState<FiltersState>({
    search: '',
    role: 'all',
    status: 'all',
    market: 'all',
    region: 'all',
    country: 'all',
    businessUnit: 'all'
  })

  const {
    adGroups,
    loading,
    totalCount,
    totalPages,
    summary,
    fetchAdGroups,
    saveScrollPosition,
    restoreScrollPosition,
    tableContainerRef,
    getGroupById
  } = useAdGroupsData()

  const { regions, businessUnits, countries, isLoading: referenceDataLoading } = useReferenceData()

  const buildFetchParams = useCallback((page: number) => ({
    page,
    size: PAGE_SIZE,
    search: filters.search || undefined,
    role: filters.role,
    status: filters.status,
    market: filters.market,
    region: filters.region,
    country: filters.country,
    businessUnit: filters.businessUnit
  }), [filters])

  useEffect(() => {
    let ignore = false
    const params = buildFetchParams(currentPage)
    fetchAdGroups(params).then(() => {
      if (ignore) return
    })
    return () => { ignore = true }
  }, [fetchAdGroups, currentPage, buildFetchParams])

  useEffect(() => {
    setCurrentPage(prev => {
      if (totalPages < 1) {
        return 1
      }
      return prev > totalPages ? totalPages : prev
    })
  }, [totalPages])

  const updateFilter = (key: keyof FiltersState, value: string) => {
    let changed = false
    setFilters(prev => {
      if (prev[key] === value) {
        return prev
      }
      changed = true
      return { ...prev, [key]: value }
    })
    if (changed) {
      setCurrentPage(prev => (prev === 1 ? prev : 1))
    }
  }

  const {
    selectedGroups,
    handleSelectGroup,
    handleSelectAll,
    handleDeselectAll,
    handleSelectGroups,
    handleDeselectGroups,
    handleCopyFrom,
    handleToggleActive,
    confirmToggleActive,
    toggleConfirmOpen,
    setToggleConfirmOpen,
    groupToToggle,
    availableGroupsForSelection,
    searchAdGroups,
    isLookupLoading
  } = useAdGroupsSelection({
    currentGroups: adGroups,
    getGroupById,
    onRefresh: async () => {
      await fetchAdGroups(buildFetchParams(currentPage))
    },
    saveScrollPosition,
    restoreScrollPosition
  })

  const pageStart = totalCount === 0 ? 0 : (currentPage - 1) * PAGE_SIZE + 1
  const pageEnd = totalCount === 0 ? 0 : Math.min(currentPage * PAGE_SIZE, totalCount)
  const activeCount = summary.activeConfigured ?? adGroups.filter(group => group.isActive && isGroupConfigured(group)).length
  const unconfiguredCount = summary.needsConfiguration ?? adGroups.filter(group => !isGroupConfigured(group)).length
  const selectedVisibleCount = adGroups.filter(group => selectedGroups.has(group.id)).length

  const handleConfigureGroup = (group: AdGroup) => {
    setSelectedGroup(group)
    setConfigModalOpen(true)
  }

  const handleConfigSave = async (updatedGroup: AdGroup) => {
    saveScrollPosition()
    setSavingGroupId(updatedGroup.groupIdentifier)
    setConfigModalOpen(false)
    setSelectedGroup(null)
    await fetchAdGroups(buildFetchParams(currentPage))
    restoreScrollPosition()
    setSavingGroupId(null)
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-semibold tracking-tight">Team Access Management</h1>
          <p className="text-muted-foreground">
            Manage team access groups and permissions for your organization
          </p>
        </div>
      </div>

      {/* Stats Cards */}
      <AdGroupsStatsCards
        unconfiguredCount={unconfiguredCount}
        activeCount={activeCount}
        totalCount={totalCount}
      />

      {/* Bulk Operations Toolbar - Shows when items are selected */}
      {selectedGroups.size > 0 && (
        <BulkOperationsToolbar
          selectedCount={selectedGroups.size}
          selectedVisibleCount={selectedVisibleCount}
          totalCount={totalCount}
          visibleCount={adGroups.length}
          selectedGroups={Array.from(selectedGroups)}
          allAdGroups={availableGroupsForSelection}
          onSelectAll={handleSelectAll}
          onDeselectAll={handleDeselectAll}
          onCopyFrom={handleCopyFrom}
          onSearchAdGroups={searchAdGroups}
          isLookupLoading={isLookupLoading}
        />
      )}

      {/* Search and Filters */}
      <div className="space-y-4">
        <AdGroupsFiltersBar
          searchTerm={filters.search}
          onSearchTermChange={(value) => updateFilter('search', value)}
          roleFilter={filters.role}
          onRoleFilterChange={(value) => updateFilter('role', value)}
          statusFilter={filters.status}
          onStatusFilterChange={(value) => updateFilter('status', value)}
          marketFilter={filters.market}
          onMarketFilterChange={(value) => updateFilter('market', value)}
          regionFilter={filters.region}
          onRegionFilterChange={(value) => updateFilter('region', value)}
          countryFilter={filters.country}
          onCountryFilterChange={(value) => updateFilter('country', value)}
          businessUnitFilter={filters.businessUnit}
          onBusinessUnitFilterChange={(value) => updateFilter('businessUnit', value)}
          regions={regions}
          countries={countries}
          businessUnits={businessUnits}
          isLoading={referenceDataLoading}
        />

        {/* Active Filters Chips */}
        <ActiveFiltersChips
          searchTerm={filters.search}
          roleFilter={filters.role}
          statusFilter={filters.status}
          marketFilter={filters.market}
          regionFilter={filters.region}
          countryFilter={filters.country}
          businessUnitFilter={filters.businessUnit}
          onSearchTermChange={(value) => updateFilter('search', value)}
          onRoleFilterChange={(value) => updateFilter('role', value)}
          onStatusFilterChange={(value) => updateFilter('status', value)}
          onMarketFilterChange={(value) => updateFilter('market', value)}
          onRegionFilterChange={(value) => updateFilter('region', value)}
          onCountryFilterChange={(value) => updateFilter('country', value)}
          onBusinessUnitFilterChange={(value) => updateFilter('businessUnit', value)}
          regions={regions}
          countries={countries}
          businessUnits={businessUnits}
        />

        {/* Clear Filters Button removed - chips provide individual removal */}
      </div>

      {/* Table */}
      <AdGroupsTable
        groups={adGroups}
        selectedGroups={selectedGroups}
        loading={loading}
        savingGroupId={savingGroupId}
        onSelectGroup={handleSelectGroup}
        onSelectAll={() => handleSelectGroups(adGroups)}
        onDeselectAll={() => handleDeselectGroups(adGroups.map(group => group.id))}
        onConfigureGroup={handleConfigureGroup}
        onToggleActive={handleToggleActive}
        isConfigured={isGroupConfigured}
        tableContainerRef={tableContainerRef}
        permissions={permissions}
        countries={countries}
      />

      {/* Pagination Controls */}
      {totalPages > 1 && (
        <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
          <span className="text-sm text-muted-foreground">
            {`Showing ${pageStart}-${pageEnd} of ${totalCount} groups`}
          </span>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
              disabled={currentPage === 1}
            >
              Previous
            </Button>
            <span className="text-sm text-muted-foreground">
              {`Page ${currentPage} of ${totalPages}`}
            </span>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
              disabled={currentPage === totalPages}
            >
              Next
            </Button>
          </div>
        </div>
      )}

      {/* Configuration Modal */}
      {selectedGroup && (
        <AdGroupConfigModal
          group={getGroupWithDefaults(selectedGroup)}
          open={configModalOpen}
          onClose={() => {
            setConfigModalOpen(false)
            setSelectedGroup(null)
          }}
          onSave={handleConfigSave}
          permissions={permissions}
        />
      )}

      {/* Toggle Confirmation Dialog */}
      <AdGroupsToggleDialog
        group={groupToToggle}
        open={toggleConfirmOpen}
        onOpenChange={setToggleConfirmOpen}
        onConfirm={confirmToggleActive}
      />
    </div>
  )
}

export const AdGroupsView = memo(AdGroupsViewComponent)
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/components/__tests__/active-filters-chips.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('@/hooks/features/use-business-terminology', () => ({
  useBusinessRoles: () => ({
    voice_agent: { displayName: 'Voice Agent' },
    chat_agent: { displayName: 'Chat Agent' }
  }),
  useBusinessStatus: () => ({
    active: { label: 'Active' },
    disabled: { label: 'Disabled' }
  })
}))

vi.mock('lucide-react', () => ({
  X: () => <span data-testid="x-icon" />
}))

vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children, ...rest }: Record<string, unknown>) => (
    <span data-testid="badge" {...rest}>{children as React.ReactNode}</span>
  )
}))

import { ActiveFiltersChips } from '../active-filters-chips'

const defaultProps = {
  searchTerm: '',
  roleFilter: 'all',
  statusFilter: 'all',
  marketFilter: 'all',
  regionFilter: 'all',
  countryFilter: 'all',
  businessUnitFilter: 'all',
  onSearchTermChange: vi.fn(),
  onRoleFilterChange: vi.fn(),
  onStatusFilterChange: vi.fn(),
  onMarketFilterChange: vi.fn(),
  onRegionFilterChange: vi.fn(),
  onCountryFilterChange: vi.fn(),
  onBusinessUnitFilterChange: vi.fn(),
  regions: [{ regionCode: 'APAC', regionName: 'Asia Pacific', displayOrder: 1, isActive: true }],
  countries: [{ countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true }],
  businessUnits: [{ unitCode: 'WPB', unitName: 'Wealth', description: '', effectiveDate: '', displayOrder: 1, isActive: true }]
}

describe('ActiveFiltersChips', () => {
  it('renders nothing when no filters active', () => {
    const { container } = render(<ActiveFiltersChips {...defaultProps} />)
    expect(container.innerHTML).toBe('')
  })

  it('renders search filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} searchTerm="test" />)
    expect(screen.getByText('Active filters:')).toBeInTheDocument()
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders role filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} roleFilter="voice_agent" />)
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders status filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} statusFilter="active" />)
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders market filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} marketFilter="HK" />)
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders region filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} regionFilter="APAC" />)
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders country filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} countryFilter="HK" />)
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders business unit filter chip', () => {
    render(<ActiveFiltersChips {...defaultProps} businessUnitFilter="WPB" />)
    expect(screen.getAllByTestId('badge').length).toBeGreaterThan(0)
  })

  it('renders multiple chips when multiple filters active', () => {
    render(
      <ActiveFiltersChips
        {...defaultProps}
        searchTerm="test"
        roleFilter="voice_agent"
        statusFilter="active"
      />
    )
    expect(screen.getAllByTestId('badge').length).toBe(3)
  })

  it('calls onSearchTermChange on remove', () => {
    const onSearchTermChange = vi.fn()
    render(
      <ActiveFiltersChips
        {...defaultProps}
        searchTerm="test"
        onSearchTermChange={onSearchTermChange}
      />
    )
    const removeButtons = screen.getAllByRole('button')
    fireEvent.click(removeButtons[0])
    expect(onSearchTermChange).toHaveBeenCalledWith('')
  })

  it('calls onRoleFilterChange on remove', () => {
    const onRoleFilterChange = vi.fn()
    render(
      <ActiveFiltersChips
        {...defaultProps}
        roleFilter="voice_agent"
        onRoleFilterChange={onRoleFilterChange}
      />
    )
    const removeButtons = screen.getAllByRole('button')
    fireEvent.click(removeButtons[0])
    expect(onRoleFilterChange).toHaveBeenCalledWith('all')
  })

  it('resolves region name from code', () => {
    render(<ActiveFiltersChips {...defaultProps} regionFilter="APAC" />)
    const badge = screen.getByTestId('badge')
    expect(badge.textContent).toContain('Asia Pacific')
  })

  it('resolves country name from code', () => {
    render(<ActiveFiltersChips {...defaultProps} countryFilter="HK" />)
    const badge = screen.getByTestId('badge')
    expect(badge.textContent).toContain('Hong Kong')
  })

  it('resolves business unit name from code', () => {
    render(<ActiveFiltersChips {...defaultProps} businessUnitFilter="WPB" />)
    const badge = screen.getByTestId('badge')
    expect(badge.textContent).toContain('Wealth')
  })

  it('falls back to code when name not found', () => {
    render(<ActiveFiltersChips {...defaultProps} regionFilter="UNKNOWN" />)
    const badge = screen.getByTestId('badge')
    expect(badge.textContent).toContain('UNKNOWN')
  })
})
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/components/__tests__/ad-groups-filters-bar.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('@/hooks/features/use-business-terminology', () => ({
  useBusinessRoles: () => ({
    voice_agent: { displayName: 'Voice Agent' },
    chat_agent: { displayName: 'Chat Agent' },
    supervisor: { displayName: 'Supervisor' },
    admin: { displayName: 'Administrator' }
  }),
  useBusinessStatus: () => ({
    active: { label: 'Active' },
    disabled: { label: 'Disabled' },
    needs_setup: { label: 'Needs Setup' }
  })
}))

vi.mock('lucide-react', () => ({
  Search: () => <span data-testid="search-icon" />,
  Filter: () => <span data-testid="filter-icon" />
}))

vi.mock('../advanced-filters-sheet', () => ({
  AdvancedFiltersSheet: () => <div data-testid="advanced-filters" />
}))

vi.mock('../../../../ui/input', () => ({
  Input: ({ value, onChange, placeholder, ...rest }: Record<string, unknown>) => (
    <input
      value={value as string}
      onChange={onChange as React.ChangeEventHandler<HTMLInputElement>}
      placeholder={placeholder as string}
      data-testid="search-input"
      {...rest}
    />
  )
}))

vi.mock('../../../../ui/select', () => ({
  Select: ({ value, onValueChange, children }: Record<string, unknown>) => (
    <div data-testid="select" data-value={value}>
      {(children as React.ReactNode)}
      <button data-testid={`select-change-${value}`} onClick={() => (onValueChange as (v: string) => void)('voice_agent')}>change</button>
    </div>
  ),
  SelectContent: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  SelectItem: ({ children, value }: { children: React.ReactNode; value: string }) => (
    <option value={value}>{children}</option>
  ),
  SelectTrigger: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  SelectValue: ({ placeholder }: { placeholder: string }) => <span>{placeholder}</span>
}))

import { AdGroupsFiltersBar } from '../ad-groups-filters-bar'

const defaultProps = {
  searchTerm: '',
  onSearchTermChange: vi.fn(),
  roleFilter: 'all',
  onRoleFilterChange: vi.fn(),
  statusFilter: 'all',
  onStatusFilterChange: vi.fn(),
  marketFilter: 'all',
  onMarketFilterChange: vi.fn(),
  regionFilter: 'all',
  onRegionFilterChange: vi.fn(),
  countryFilter: 'all',
  onCountryFilterChange: vi.fn(),
  businessUnitFilter: 'all',
  onBusinessUnitFilterChange: vi.fn(),
  regions: [],
  countries: [],
  businessUnits: [],
  isLoading: false
}

describe('AdGroupsFiltersBar', () => {
  it('renders search input', () => {
    render(<AdGroupsFiltersBar {...defaultProps} />)
    expect(screen.getByTestId('search-input')).toBeInTheDocument()
  })

  it('renders search icon', () => {
    render(<AdGroupsFiltersBar {...defaultProps} />)
    expect(screen.getByTestId('search-icon')).toBeInTheDocument()
  })

  it('renders filter icon', () => {
    render(<AdGroupsFiltersBar {...defaultProps} />)
    expect(screen.getByTestId('filter-icon')).toBeInTheDocument()
  })

  it('calls onSearchTermChange on input', () => {
    const onSearchTermChange = vi.fn()
    render(<AdGroupsFiltersBar {...defaultProps} onSearchTermChange={onSearchTermChange} />)
    fireEvent.change(screen.getByTestId('search-input'), { target: { value: 'test' } })
    expect(onSearchTermChange).toHaveBeenCalledWith('test')
  })

  it('renders role filter select options', () => {
    render(<AdGroupsFiltersBar {...defaultProps} />)
    expect(screen.getByText('Voice Agent')).toBeInTheDocument()
    expect(screen.getByText('Chat Agent')).toBeInTheDocument()
    expect(screen.getByText('Supervisor')).toBeInTheDocument()
  })

  it('renders status filter select options', () => {
    render(<AdGroupsFiltersBar {...defaultProps} />)
    expect(screen.getByText('Active')).toBeInTheDocument()
    expect(screen.getByText('Needs Setup')).toBeInTheDocument()
  })

  it('renders advanced filters sheet', () => {
    render(<AdGroupsFiltersBar {...defaultProps} />)
    expect(screen.getByTestId('advanced-filters')).toBeInTheDocument()
  })

  it('displays current search term', () => {
    render(<AdGroupsFiltersBar {...defaultProps} searchTerm="hello" />)
    expect(screen.getByTestId('search-input')).toHaveValue('hello')
  })
})
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/components/__tests__/ad-groups-stats-cards.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  AlertTriangle: () => <span data-testid="alert-icon" />,
  CheckCircle: () => <span data-testid="check-icon" />,
  Users: () => <span data-testid="users-icon" />
}))

vi.mock('../../../../ui/card', () => ({
  Card: ({ children }: { children: React.ReactNode }) => <div data-testid="card">{children}</div>,
  CardHeader: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  CardTitle: ({ children }: { children: React.ReactNode }) => <h3>{children}</h3>,
  CardContent: ({ children }: { children: React.ReactNode }) => <div>{children}</div>
}))

import { AdGroupsStatsCards } from '../ad-groups-stats-cards'

describe('AdGroupsStatsCards', () => {
  it('renders three stat cards', () => {
    render(<AdGroupsStatsCards unconfiguredCount={3} activeCount={10} totalCount={15} />)
    const cards = screen.getAllByTestId('card')
    expect(cards).toHaveLength(3)
  })

  it('displays unconfigured count', () => {
    render(<AdGroupsStatsCards unconfiguredCount={7} activeCount={10} totalCount={20} />)
    expect(screen.getByText('7')).toBeInTheDocument()
  })

  it('displays active count', () => {
    render(<AdGroupsStatsCards unconfiguredCount={3} activeCount={12} totalCount={20} />)
    expect(screen.getByText('12')).toBeInTheDocument()
  })

  it('displays total count', () => {
    render(<AdGroupsStatsCards unconfiguredCount={3} activeCount={10} totalCount={25} />)
    expect(screen.getByText('25')).toBeInTheDocument()
  })

  it('renders stat labels', () => {
    render(<AdGroupsStatsCards unconfiguredCount={0} activeCount={0} totalCount={0} />)
    expect(screen.getByText('Needs Configuration')).toBeInTheDocument()
    expect(screen.getByText('Active Groups')).toBeInTheDocument()
    expect(screen.getByText('Total Groups')).toBeInTheDocument()
  })

  it('renders description text', () => {
    render(<AdGroupsStatsCards unconfiguredCount={0} activeCount={0} totalCount={0} />)
    expect(screen.getByText('Groups requiring setup')).toBeInTheDocument()
    expect(screen.getByText('Configured and active')).toBeInTheDocument()
    expect(screen.getByText('All AD groups')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/components/__tests__/ad-groups-table.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('@/hooks/features/use-business-terminology', () => ({
  useBusinessRoles: () => ({
    voice_agent: { displayName: 'Voice Agent' },
    chat_agent: { displayName: 'Chat Agent' }
  }),
  useBusinessStatus: () => ({
    needs_setup: { label: 'Needs Setup' },
    active: { label: 'Active' },
    disabled: { label: 'Disabled' }
  })
}))

vi.mock('../../../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

vi.mock('@/components/common/brand-loader', () => ({
  BrandLoader: ({ message }: { message: string }) => <div data-testid="loader">{message}</div>
}))

vi.mock('lucide-react', () => ({
  Settings: () => <span data-testid="settings-icon" />,
  Users: () => <span data-testid="users-icon" />,
  MapPin: () => <span data-testid="map-pin" />,
  AlertTriangle: () => <span data-testid="alert-icon" />,
  CheckCircle: () => <span data-testid="check-icon" />,
  PowerOff: () => <span data-testid="power-icon" />,
  ToggleRight: () => <span data-testid="toggle-right" />,
  ToggleLeft: () => <span data-testid="toggle-left" />,
  Shield: () => <span data-testid="shield" />,
  ShieldCheck: () => <span data-testid="shield-check" />,
  ShieldAlert: () => <span data-testid="shield-alert" />,
  Crown: () => <span data-testid="crown" />
}))

vi.mock('../../../../ui/table', () => ({
  Table: ({ children }: { children: React.ReactNode }) => <table>{children}</table>,
  TableBody: ({ children }: { children: React.ReactNode }) => <tbody>{children}</tbody>,
  TableCell: ({ children, colSpan, ...rest }: Record<string, unknown>) => (
    <td colSpan={colSpan as number} {...rest}>{children as React.ReactNode}</td>
  ),
  TableHead: ({ children }: { children: React.ReactNode }) => <th>{children}</th>,
  TableHeader: ({ children }: { children: React.ReactNode }) => <thead>{children}</thead>,
  TableRow: ({ children }: { children: React.ReactNode }) => <tr>{children}</tr>
}))

vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, ...rest }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} {...rest}>{children as React.ReactNode}</button>
  )
}))

vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children }: { children: React.ReactNode }) => <span data-testid="badge">{children}</span>
}))

vi.mock('../../../../ui/checkbox', () => ({
  Checkbox: ({ onCheckedChange, checked, ...rest }: Record<string, unknown>) => (
    <input
      type="checkbox"
      checked={checked as boolean}
      onChange={() => (onCheckedChange as (v: boolean) => void)(!checked)}
      {...rest}
    />
  )
}))

vi.mock('../../../../ui/tooltip', () => ({
  TooltipProvider: ({ children }: { children: React.ReactNode }) => <>{children}</>,
  Tooltip: ({ children }: { children: React.ReactNode }) => <>{children}</>,
  TooltipTrigger: ({ children }: { children: React.ReactNode }) => <>{children}</>,
  TooltipContent: ({ children }: { children: React.ReactNode }) => <span data-testid="tooltip">{children}</span>
}))

import { AdGroupsTable } from '../ad-groups-table'
import type { AdminPermissions } from '../../../admin-layout'

const allPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

const mockGroups = [
  {
    id: 'g1',
    groupIdentifier: 'CN=group1',
    logicalName: 'Group One',
    roleName: 'voice_agent',
    isActive: true,
    country: 'HK',
    region: 'APAC',
    accessLevel: 'MAKER',
    userCount: 42,
    pendingChangeIndicator: false
  },
  {
    id: 'g2',
    groupIdentifier: 'CN=group2',
    logicalName: '',
    roleName: '',
    isActive: false,
    country: '',
    region: '',
    pendingChangeIndicator: true
  }
]

const defaultProps = {
  groups: mockGroups as any,
  selectedGroups: new Set<string>(),
  loading: false,
  savingGroupId: null,
  onSelectGroup: vi.fn(),
  onSelectAll: vi.fn(),
  onDeselectAll: vi.fn(),
  onConfigureGroup: vi.fn(),
  onToggleActive: vi.fn(),
  isConfigured: (g: any) => Boolean(g.logicalName && g.roleName && g.region && g.country),
  tableContainerRef: { current: null },
  permissions: allPermissions,
  countries: [
    { countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true }
  ]
}

describe('AdGroupsTable', () => {
  it('renders table headers', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Team Group')).toBeInTheDocument()
    expect(screen.getByText('Role')).toBeInTheDocument()
    expect(screen.getByText('Status')).toBeInTheDocument()
  })

  it('renders loading state', () => {
    render(<AdGroupsTable {...defaultProps} loading={true} groups={[]} />)
    expect(screen.getByTestId('loader')).toBeInTheDocument()
  })

  it('renders empty state', () => {
    render(<AdGroupsTable {...defaultProps} groups={[]} />)
    expect(screen.getByText('No team groups found')).toBeInTheDocument()
  })

  it('renders group rows', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Group One')).toBeInTheDocument()
    expect(screen.getByText('CN=group1')).toBeInTheDocument()
  })

  it('renders role display name', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Voice Agent')).toBeInTheDocument()
  })

  it('renders country name from code', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Hong Kong')).toBeInTheDocument()
  })

  it('renders "not set" for unconfigured fields', () => {
    render(<AdGroupsTable {...defaultProps} />)
    const notSetElements = screen.getAllByText('Not set')
    expect(notSetElements.length).toBeGreaterThan(0)
  })

  it('renders user count', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('42')).toBeInTheDocument()
  })

  it('renders active badge for configured active group', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Active')).toBeInTheDocument()
  })

  it('renders needs setup badge for unconfigured group', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Needs Setup')).toBeInTheDocument()
  })

  it('renders pending badge', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Pending')).toBeInTheDocument()
  })

  it('calls onSelectGroup when checkbox clicked', () => {
    const onSelectGroup = vi.fn()
    render(<AdGroupsTable {...defaultProps} onSelectGroup={onSelectGroup} />)
    const checkboxes = screen.getAllByRole('checkbox')
    // First checkbox is select-all, rest are per-row
    fireEvent.click(checkboxes[1])
    expect(onSelectGroup).toHaveBeenCalledWith('g1')
  })

  it('calls onSelectAll when header checkbox clicked', () => {
    const onSelectAll = vi.fn()
    render(<AdGroupsTable {...defaultProps} onSelectAll={onSelectAll} />)
    const checkboxes = screen.getAllByRole('checkbox')
    fireEvent.click(checkboxes[0])
    expect(onSelectAll).toHaveBeenCalled()
  })

  it('calls onConfigureGroup when configure button clicked', () => {
    const onConfigureGroup = vi.fn()
    render(<AdGroupsTable {...defaultProps} onConfigureGroup={onConfigureGroup} />)
    const settingsIcons = screen.getAllByTestId('settings-icon')
    // Click the button wrapping the first settings icon
    fireEvent.click(settingsIcons[0].closest('button')!)
    expect(onConfigureGroup).toHaveBeenCalledWith(mockGroups[0])
  })

  it('calls onToggleActive when toggle button clicked', () => {
    const onToggleActive = vi.fn()
    render(<AdGroupsTable {...defaultProps} onToggleActive={onToggleActive} />)
    // The toggle button has ToggleRight icon for active group
    const toggleIcon = screen.getByTestId('toggle-right')
    fireEvent.click(toggleIcon.closest('button')!)
    expect(onToggleActive).toHaveBeenCalledWith(mockGroups[0])
  })

  it('renders access level badge', () => {
    render(<AdGroupsTable {...defaultProps} />)
    // MAKER access level renders with shield-alert icon
    expect(screen.getByTestId('shield-alert')).toBeInTheDocument()
  })

  it('hides toggle button without permission', () => {
    render(
      <AdGroupsTable
        {...defaultProps}
        permissions={{ ...allPermissions, canEnableDisableGroups: false }}
      />
    )
    expect(screen.queryByTestId('toggle-right')).not.toBeInTheDocument()
  })

  it('hides configure button without edit permissions', () => {
    render(
      <AdGroupsTable
        {...defaultProps}
        permissions={{
          ...allPermissions,
          canEditBusinessInfo: false,
          canEditPermissions: false,
          canEditApplications: false
        }}
      />
    )
    expect(screen.queryByTestId('settings-icon')).not.toBeInTheDocument()
  })

  it('renders unconfigured group name fallback', () => {
    render(<AdGroupsTable {...defaultProps} />)
    expect(screen.getByText('Unconfigured Group')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/components/__tests__/ad-groups-toggle-dialog.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  ShieldOff: (props: Record<string, unknown>) => <span data-testid="shield-off" {...props} />,
  CheckCircle: (props: Record<string, unknown>) => <span data-testid="check-circle" {...props} />
}))

vi.mock('../../../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

vi.mock('../../../../ui/dialog', () => ({
  Dialog: ({ open, children }: { open: boolean; children: React.ReactNode }) =>
    open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  DialogHeader: ({ children }: { children: React.ReactNode }) => <div>{children}</div>,
  DialogTitle: ({ children, className }: { children: React.ReactNode; className?: string }) =>
    <h2 className={className}>{children}</h2>,
  DialogDescription: ({ children }: { children: React.ReactNode }) => <p>{children}</p>,
  DialogFooter: ({ children }: { children: React.ReactNode }) => <div>{children}</div>
}))

vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, ...rest }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} {...rest}>{children as React.ReactNode}</button>
  )
}))

import { AdGroupsToggleDialog } from '../ad-groups-toggle-dialog'

const activeGroup = {
  id: 'g1',
  groupIdentifier: 'CN=test-group',
  logicalName: 'Test Group',
  isActive: true,
  roleName: 'voice_agent',
  pendingChangeIndicator: false
}

const inactiveGroup = {
  id: 'g2',
  groupIdentifier: 'CN=inactive-group',
  logicalName: 'Inactive Group',
  isActive: false,
  roleName: 'chat_agent',
  pendingChangeIndicator: false
}

describe('AdGroupsToggleDialog', () => {
  it('renders nothing when group is null', () => {
    const { container } = render(
      <AdGroupsToggleDialog
        group={null}
        open={true}
        onOpenChange={vi.fn()}
        onConfirm={vi.fn()}
      />
    )
    expect(container.innerHTML).toBe('')
  })

  it('renders nothing when closed', () => {
    const { container } = render(
      <AdGroupsToggleDialog
        group={activeGroup as any}
        open={false}
        onOpenChange={vi.fn()}
        onConfirm={vi.fn()}
      />
    )
    expect(container.querySelector('[data-testid="dialog"]')).not.toBeInTheDocument()
  })

  it('shows disable dialog for active group', () => {
    render(
      <AdGroupsToggleDialog
        group={activeGroup as any}
        open={true}
        onOpenChange={vi.fn()}
        onConfirm={vi.fn()}
      />
    )
    expect(screen.getByTestId('shield-off')).toBeInTheDocument()
    expect(screen.getByText('This will prevent users in this group from accessing the system.')).toBeInTheDocument()
  })

  it('shows enable dialog for inactive group', () => {
    render(
      <AdGroupsToggleDialog
        group={inactiveGroup as any}
        open={true}
        onOpenChange={vi.fn()}
        onConfirm={vi.fn()}
      />
    )
    expect(screen.getByTestId('check-circle')).toBeInTheDocument()
    expect(screen.getByText('This will allow users in this group to access the system.')).toBeInTheDocument()
  })

  it('calls onConfirm when confirm button clicked', () => {
    const onConfirm = vi.fn()
    render(
      <AdGroupsToggleDialog
        group={activeGroup as any}
        open={true}
        onOpenChange={vi.fn()}
        onConfirm={onConfirm}
      />
    )
    // Find the button with disable text (last one since there are two buttons)
    const buttons = screen.getAllByRole('button')
    const confirmBtn = buttons.find(btn => btn.textContent === 'Disable Group')
    fireEvent.click(confirmBtn!)
    expect(onConfirm).toHaveBeenCalled()
  })

  it('calls onOpenChange when cancel button clicked', () => {
    const onOpenChange = vi.fn()
    render(
      <AdGroupsToggleDialog
        group={activeGroup as any}
        open={true}
        onOpenChange={onOpenChange}
        onConfirm={vi.fn()}
      />
    )
    fireEvent.click(screen.getByText('Cancel'))
    expect(onOpenChange).toHaveBeenCalledWith(false)
  })
})
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/components/__tests__/advanced-filters-sheet.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../ui/sheet', () => ({
  Sheet: ({ children }: any) => <div data-testid="sheet">{children}</div>,
  SheetContent: ({ children }: any) => <div data-testid="sheet-content">{children}</div>,
  SheetHeader: ({ children }: any) => <div>{children}</div>,
  SheetTitle: ({ children }: any) => <h2>{children}</h2>,
  SheetTrigger: ({ children }: any) => <div data-testid="sheet-trigger">{children}</div>,
  SheetFooter: ({ children }: any) => <div>{children}</div>
}))
vi.mock('../../../../ui/select', () => ({
  Select: ({ children }: any) => <div>{children}</div>,
  SelectContent: ({ children }: any) => <div>{children}</div>,
  SelectItem: ({ children, value }: any) => <div data-testid={`select-item-${value}`}>{children}</div>,
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: ({ placeholder }: any) => <span>{placeholder}</span>
}))
vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: any) => (
    <button onClick={onClick} disabled={disabled}>{children}</button>
  )
}))
vi.mock('../../../../ui/badge', () => ({ Badge: ({ children }: any) => <span data-testid="badge">{children}</span> }))
vi.mock('lucide-react', () => ({
  SlidersHorizontal: (p: any) => <span {...p} />,
  X: (p: any) => <span {...p} />
}))
vi.mock('@/hooks/features/use-business-terminology', () => ({
  getBusinessField: (field: string) => field
}))

import { AdvancedFiltersSheet } from '../advanced-filters-sheet'

describe('AdvancedFiltersSheet', () => {
  const baseProps = {
    marketFilter: 'all',
    onMarketFilterChange: vi.fn(),
    regionFilter: 'all',
    onRegionFilterChange: vi.fn(),
    countryFilter: 'all',
    onCountryFilterChange: vi.fn(),
    businessUnitFilter: 'all',
    onBusinessUnitFilterChange: vi.fn(),
    onClearAll: vi.fn(),
    regions: [
      { regionCode: 'EMEA', regionName: 'Europe, Middle East & Africa' },
      { regionCode: 'APAC', regionName: 'Asia Pacific' }
    ] as any[],
    countries: [
      { countryCode: 'GB', countryName: 'United Kingdom' }
    ] as any[],
    businessUnits: [
      { unitCode: 'WPB', unitName: 'Wealth & Personal Banking' }
    ] as any[],
    isLoading: false
  }

  it('renders sheet trigger with filter label', () => {
    render(<AdvancedFiltersSheet {...baseProps} />)
    expect(screen.getByTestId('sheet-trigger')).toBeInTheDocument()
    expect(screen.getByText('More Filters')).toBeInTheDocument()
  })

  it('renders filter title', () => {
    render(<AdvancedFiltersSheet {...baseProps} />)
    expect(screen.getByText('Advanced Filters')).toBeInTheDocument()
  })

  it('renders filter section labels', () => {
    render(<AdvancedFiltersSheet {...baseProps} />)
    // Multiple elements may have the label text (one as label, one could be in chips)
    expect(screen.getAllByText('Region').length).toBeGreaterThan(0)
    expect(screen.getAllByText('Country').length).toBeGreaterThan(0)
    expect(screen.getAllByText('Department').length).toBeGreaterThan(0)
  })

  it('shows active filter count badge when filters are set', () => {
    render(<AdvancedFiltersSheet {...baseProps} regionFilter="EMEA" />)
    const badges = screen.getAllByTestId('badge')
    const countBadge = badges.find(b => b.textContent === '1')
    expect(countBadge).toBeTruthy()
  })

  it('shows active filters section when filters selected', () => {
    render(<AdvancedFiltersSheet {...baseProps} regionFilter="EMEA" countryFilter="GB" />)
    expect(screen.getByText('Active Filters')).toBeInTheDocument()
  })

  it('hides active filters section when all filters are default', () => {
    render(<AdvancedFiltersSheet {...baseProps} />)
    expect(screen.queryByText('Active Filters')).not.toBeInTheDocument()
  })

  it('disables clear all button when no filters active', () => {
    render(<AdvancedFiltersSheet {...baseProps} />)
    const clearBtn = screen.getByText('Clear All')
    expect(clearBtn).toBeDisabled()
  })

  it('enables clear all button when filters active', () => {
    render(<AdvancedFiltersSheet {...baseProps} regionFilter="EMEA" />)
    const clearBtn = screen.getByText('Clear All')
    expect(clearBtn).not.toBeDisabled()
  })
})
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/components/active-filters-chips.tsx
import { Badge } from '../../../ui/badge'
import { X } from 'lucide-react'
import { useBusinessRoles, useBusinessStatus } from '@/hooks/features/use-business-terminology'
import type { RegionDto, BusinessUnitDto, CountryDto } from '@/services/api/reference-data.service'

interface ActiveFiltersChipsProps {
  searchTerm: string
  roleFilter: string
  statusFilter: string
  marketFilter: string
  regionFilter: string
  countryFilter: string
  businessUnitFilter: string
  onSearchTermChange: (value: string) => void
  onRoleFilterChange: (value: string) => void
  onStatusFilterChange: (value: string) => void
  onMarketFilterChange: (value: string) => void
  onRegionFilterChange: (value: string) => void
  onCountryFilterChange: (value: string) => void
  onBusinessUnitFilterChange: (value: string) => void
  regions: RegionDto[]
  countries: CountryDto[]
  businessUnits: BusinessUnitDto[]
}

export function ActiveFiltersChips({
  searchTerm,
  roleFilter,
  statusFilter,
  marketFilter,
  regionFilter,
  countryFilter,
  businessUnitFilter,
  onSearchTermChange,
  onRoleFilterChange,
  onStatusFilterChange,
  onMarketFilterChange,
  onRegionFilterChange,
  onCountryFilterChange,
  onBusinessUnitFilterChange,

  regions,
  countries,
  businessUnits
}: Readonly<ActiveFiltersChipsProps>) {
  const businessRoles = useBusinessRoles()
  const businessStatus = useBusinessStatus()

  const getRegionName = (code: string) => regions.find(r => r.regionCode === code)?.regionName || code
  const getCountryName = (code: string) => countries.find(c => c.countryCode === code)?.countryName || code
  const getBusinessUnitName = (code: string) => businessUnits.find(u => u.unitCode === code)?.unitName || code

  const filterDefinitions: Array<{ value: string; check: string; label: string; onRemove: () => void }> = [
    { value: searchTerm, check: '', label: `Search: "${searchTerm}"`, onRemove: () => onSearchTermChange('') },
    { value: roleFilter, check: 'all', label: `Role: ${businessRoles[roleFilter]?.displayName || roleFilter}`, onRemove: () => onRoleFilterChange('all') },
    { value: statusFilter, check: 'all', label: `Status: ${businessStatus[statusFilter]?.label || statusFilter}`, onRemove: () => onStatusFilterChange('all') },
    { value: marketFilter, check: 'all', label: `Market: ${marketFilter}`, onRemove: () => onMarketFilterChange('all') },
    { value: regionFilter, check: 'all', label: `Region: ${getRegionName(regionFilter)}`, onRemove: () => onRegionFilterChange('all') },
    { value: countryFilter, check: 'all', label: `Country: ${getCountryName(countryFilter)}`, onRemove: () => onCountryFilterChange('all') },
    { value: businessUnitFilter, check: 'all', label: `Department: ${getBusinessUnitName(businessUnitFilter)}`, onRemove: () => onBusinessUnitFilterChange('all') }
  ]

  const activeFilters = filterDefinitions.filter(f =>
    f.check === '' ? Boolean(f.value) : f.value !== f.check
  )

  if (activeFilters.length === 0) {
    return null
  }

  return (
    <div className="flex flex-wrap items-center gap-2">
      <span className="text-sm text-muted-foreground">Active filters:</span>
      {activeFilters.map((filter) => (
        <Badge key={filter.label} variant="secondary" className="gap-1.5 pr-1">
          <span className="text-xs">{filter.label}</span>
          <button
            onClick={filter.onRemove}
            className="ml-1 hover:text-destructive transition-colors"
            aria-label={`Remove filter: ${filter.label}`}
          >
            <X className="h-3 w-3" />
          </button>
        </Badge>
      ))}
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/components/ad-groups-filters-bar.tsx
import { Input } from '../../../ui/input'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../../../ui/select'
import { Search, Filter } from 'lucide-react'
import { useBusinessRoles, useBusinessStatus } from '@/hooks/features/use-business-terminology'
import { AdvancedFiltersSheet } from './advanced-filters-sheet'
import type { RegionDto, BusinessUnitDto, CountryDto } from '@/services/api/reference-data.service'

interface AdGroupsFiltersBarProps {
  searchTerm: string
  onSearchTermChange: (value: string) => void
  roleFilter: string
  onRoleFilterChange: (value: string) => void
  statusFilter: string
  onStatusFilterChange: (value: string) => void
  marketFilter: string
  onMarketFilterChange: (value: string) => void
  regionFilter: string
  onRegionFilterChange: (value: string) => void
  countryFilter: string
  onCountryFilterChange: (value: string) => void
  businessUnitFilter: string
  onBusinessUnitFilterChange: (value: string) => void
  regions: RegionDto[]
  countries: CountryDto[]
  businessUnits: BusinessUnitDto[]
  isLoading: boolean
}

export function AdGroupsFiltersBar({
  searchTerm,
  onSearchTermChange,
  roleFilter,
  onRoleFilterChange,
  statusFilter,
  onStatusFilterChange,
  marketFilter,
  onMarketFilterChange,
  regionFilter,
  onRegionFilterChange,
  countryFilter,
  onCountryFilterChange,
  businessUnitFilter,
  onBusinessUnitFilterChange,
  regions,
  countries,
  businessUnits,
  isLoading
}: Readonly<AdGroupsFiltersBarProps>) {
  const businessRoles = useBusinessRoles()
  const businessStatus = useBusinessStatus()

  const handleClearAdvancedFilters = () => {
    onMarketFilterChange('all')
    onRegionFilterChange('all')
    onCountryFilterChange('all')
    onBusinessUnitFilterChange('all')
  }

  return (
    <div className="flex flex-col space-y-4 md:flex-row md:items-center md:space-y-0 md:space-x-4">
      <div className="relative w-48 focus-within:w-96 flex-shrink-0 transition-all duration-300">
        <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
        <Input
          placeholder="Search team groups..."
          value={searchTerm}
          onChange={(e) => onSearchTermChange(e.target.value)}
          className="pl-8 w-full
                     transition-all duration-300 ease-in-out
                     focus:shadow-lg focus:z-10 focus:border-primary"
        />
      </div>

      <div className="flex items-center space-x-2">
        <Filter className="h-4 w-4 text-muted-foreground" />

        <Select value={roleFilter} onValueChange={onRoleFilterChange}>
          <SelectTrigger className="w-40">
            <SelectValue placeholder="All Roles" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Roles</SelectItem>
            <SelectItem value="voice_agent">{businessRoles['voice_agent']?.displayName || 'Voice Agent'}</SelectItem>
            <SelectItem value="chat_agent">{businessRoles['chat_agent']?.displayName || 'Chat Agent'}</SelectItem>
            <SelectItem value="supervisor">{businessRoles['supervisor']?.displayName || 'Supervisor'}</SelectItem>
            <SelectItem value="admin">{businessRoles['admin']?.displayName || 'Administrator'}</SelectItem>
          </SelectContent>
        </Select>

        <Select value={statusFilter} onValueChange={onStatusFilterChange}>
          <SelectTrigger className="w-40">
            <SelectValue placeholder="All Status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Status</SelectItem>
            <SelectItem value="active">{businessStatus['active']?.label || 'Active'}</SelectItem>
            <SelectItem value="inactive">{businessStatus['disabled']?.label || 'Inactive'}</SelectItem>
            <SelectItem value="needs_setup">{businessStatus['needs_setup']?.label || 'Needs Setup'}</SelectItem>
          </SelectContent>
        </Select>

        <AdvancedFiltersSheet
          marketFilter={marketFilter}
          onMarketFilterChange={onMarketFilterChange}
          regionFilter={regionFilter}
          onRegionFilterChange={onRegionFilterChange}
          countryFilter={countryFilter}
          onCountryFilterChange={onCountryFilterChange}
          businessUnitFilter={businessUnitFilter}
          onBusinessUnitFilterChange={onBusinessUnitFilterChange}
          onClearAll={handleClearAdvancedFilters}
          regions={regions}
          countries={countries}
          businessUnits={businessUnits}
          isLoading={isLoading}
        />
      </div>
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/components/ad-groups-stats-cards.tsx
import { Card, CardContent, CardHeader, CardTitle } from '../../../ui/card'
import { AlertTriangle, CheckCircle, Users } from 'lucide-react'

interface AdGroupsStatsCardsProps {
  unconfiguredCount: number
  activeCount: number
  totalCount: number
}

export function AdGroupsStatsCards({ unconfiguredCount, activeCount, totalCount }: Readonly<AdGroupsStatsCardsProps>) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle as="div" className="text-sm font-medium">Needs Configuration</CardTitle>
          <AlertTriangle className="h-4 w-4 text-orange-600" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-orange-700">{unconfiguredCount}</div>
          <p className="text-xs text-muted-foreground">Groups requiring setup</p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle as="div" className="text-sm font-medium">Active Groups</CardTitle>
          <CheckCircle className="h-4 w-4 text-emerald-600" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-emerald-700">{activeCount}</div>
          <p className="text-xs text-muted-foreground">Configured and active</p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle as="div" className="text-sm font-medium">Total Groups</CardTitle>
          <Users className="h-4 w-4 text-slate-600" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-slate-700">{totalCount}</div>
          <p className="text-xs text-muted-foreground">All AD groups</p>
        </CardContent>
      </Card>
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/components/ad-groups-table.tsx
import { memo, useMemo } from 'react'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '../../../ui/table'
import { Button } from '../../../ui/button'
import { Badge } from '../../../ui/badge'
import { Checkbox } from '../../../ui/checkbox'
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '../../../ui/tooltip'
import {
  Settings,
  Users,
  MapPin,
  AlertTriangle,
  CheckCircle,
  PowerOff,
  ToggleRight,
  ToggleLeft,
  Shield,
  ShieldCheck,
  ShieldAlert,
  Crown
} from 'lucide-react'
import { cn } from '../../../../lib/utils'
import { useBusinessRoles, useBusinessStatus } from '@/hooks/features/use-business-terminology'
import type { AdGroup } from '../../../../types/features/ad-group-config'
import type { AdminPermissions } from '../../admin-layout'
import type { CountryDto } from '@/services/api/reference-data.service'
import { BrandLoader } from '@/components/common/brand-loader'

const ACCESS_LEVEL_STYLES: Record<string, string> = {
  SUPER_ADMIN: 'bg-purple-50 text-purple-700 border-purple-200',
  CHECKER: 'bg-blue-50 text-blue-700 border-blue-200',
  MAKER: 'bg-amber-50 text-amber-700 border-amber-200',
  VIEWER: 'bg-gray-50 text-gray-600 border-gray-200'
}

const ACCESS_LEVEL_ICONS: Record<string, React.ComponentType<{ className?: string }>> = {
  SUPER_ADMIN: Crown,
  CHECKER: ShieldCheck,
  MAKER: ShieldAlert,
  VIEWER: Shield
}

const ACCESS_LEVEL_LABELS: Record<string, string> = {
  super_admin: 'Super Admin',
  checker: 'Checker',
  maker: 'Maker',
  viewer: 'Viewer'
}

function AccessLevelBadge({ accessLevel }: Readonly<{ accessLevel: string }>) {
  const Icon = ACCESS_LEVEL_ICONS[accessLevel]
  return (
    <Badge variant="outline" className={cn("font-medium", ACCESS_LEVEL_STYLES[accessLevel])}>
      {Icon && <Icon className="h-3 w-3 mr-1" />}
      {ACCESS_LEVEL_LABELS[accessLevel.toLowerCase()] || accessLevel}
    </Badge>
  )
}

function GroupStatusBadge({ group, configured, businessStatus }: Readonly<{
  group: AdGroup
  configured: boolean
  businessStatus: Record<string, { label?: string } | undefined>
}>) {
  return (
    <div className="flex items-center gap-2 flex-wrap">
      {!configured && (
        <Badge variant="outline" className="bg-orange-50 text-orange-700 border-orange-200">
          <AlertTriangle className="h-3 w-3 mr-1" />
          {businessStatus['needs_setup']?.label || 'Needs Setup'}
        </Badge>
      )}
      {configured && group.isActive && (
        <Badge variant="outline" className="bg-emerald-50 text-emerald-800 border-emerald-200">
          <CheckCircle className="h-3 w-3 mr-1" />
          {businessStatus['active']?.label || 'Active'}
        </Badge>
      )}
      {configured && !group.isActive && (
        <Badge variant="outline" className="bg-slate-50 text-slate-600 border-slate-200">
          <PowerOff className="h-3 w-3 mr-1" />
          {businessStatus['disabled']?.label || 'Disabled'}
        </Badge>
      )}
      {group.pendingChangeIndicator && (
        <Badge variant="outline" className="bg-yellow-50 text-yellow-700 border-yellow-200">
          Pending
        </Badge>
      )}
    </div>
  )
}

function GroupActionButtons({ group, permissions, configured, canConfigureGroups, onToggleActive, onConfigureGroup }: Readonly<{
  group: AdGroup
  permissions: AdminPermissions
  configured: boolean
  canConfigureGroups: boolean
  onToggleActive: (group: AdGroup) => void
  onConfigureGroup: (group: AdGroup) => void
}>) {
  const groupLabel = group.logicalName || group.groupIdentifier
  return (
    <div className="flex items-center justify-end gap-2 flex-wrap">
      {permissions.canEnableDisableGroups && configured && (
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              variant="outline"
              size="sm"
              onClick={() => onToggleActive(group)}
              className={group.isActive ? 'text-green-600 hover:text-green-700 border-green-200' : 'text-gray-400 hover:text-gray-600 border-gray-200'}
              aria-label={group.isActive ? `Disable ${groupLabel}` : `Enable ${groupLabel}`}
            >
              {group.isActive ? <ToggleRight className="h-4 w-4" /> : <ToggleLeft className="h-4 w-4" />}
            </Button>
          </TooltipTrigger>
          <TooltipContent>
            {group.isActive ? 'Disable Group' : 'Enable Group'}
          </TooltipContent>
        </Tooltip>
      )}
      {canConfigureGroups && (
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              variant="outline"
              size="sm"
              onClick={() => onConfigureGroup(group)}
              aria-label={`Configure ${groupLabel}`}
            >
              <Settings className="h-4 w-4" />
            </Button>
          </TooltipTrigger>
          <TooltipContent>
            Configure AD Group
          </TooltipContent>
        </Tooltip>
      )}
    </div>
  )
}

interface AdGroupsTableProps {
  groups: AdGroup[]
  selectedGroups: Set<string>
  loading: boolean
  savingGroupId: string | null
  onSelectGroup: (groupId: string) => void
  onSelectAll: () => void
  onDeselectAll: () => void
  onConfigureGroup: (group: AdGroup) => void
  onToggleActive: (group: AdGroup) => void
  isConfigured: (group: AdGroup) => boolean
  tableContainerRef: React.RefObject<HTMLDivElement | null>
  permissions: AdminPermissions
  countries: CountryDto[]
}

function AdGroupsTableComponent({
  groups,
  selectedGroups,
  loading,
  savingGroupId,
  onSelectGroup,
  onSelectAll,
  onDeselectAll,
  onConfigureGroup,
  onToggleActive,
  isConfigured,
  tableContainerRef,
  permissions,
  countries
}: Readonly<AdGroupsTableProps>) {
  const businessRoles = useBusinessRoles()
  const businessStatus = useBusinessStatus()

  const countryNameMap = useMemo(() => {
    const map = new Map<string, string>()
    countries.forEach(country => {
      map.set(country.countryCode.toUpperCase(), country.countryName)
    })
    return map
  }, [countries])

  // Check if user can configure groups (requires at least one edit permission)
  const canConfigureGroups = permissions.canEditBusinessInfo ||
                            permissions.canEditPermissions ||
                            permissions.canEditApplications

  const pageGroupIds = groups.map(group => group.id)
  const selectedOnPage = pageGroupIds.filter(id => selectedGroups.has(id))
  const allPageSelected = pageGroupIds.length > 0 && selectedOnPage.length === pageGroupIds.length
  const partiallySelected = selectedOnPage.length > 0 && !allPageSelected

  return (
    <TooltipProvider delayDuration={150}>
      <div ref={tableContainerRef} className="h-[calc(100dvh-22rem)] min-h-[18rem] overflow-hidden rounded-md border shadow-sm sm:min-h-[20rem]">
        <Table className="w-full min-w-[1080px] table-auto xl:table-fixed">
        <TableHeader>
          <TableRow>
            <TableHead className="w-12 py-3 px-4">
              <Checkbox
                checked={(() => {
                  if (allPageSelected) return true
                  return partiallySelected ? 'indeterminate' as const : false
                })()}
                onCheckedChange={(checked) => {
                  if (checked) {
                    onSelectAll()
                  } else {
                    onDeselectAll()
                  }
                }}
                aria-label="Select all AD groups on this page"
              />
            </TableHead>
            <TableHead className="min-w-[280px] py-3 px-4 whitespace-nowrap xl:w-[35%]">Team Group</TableHead>
            <TableHead className="w-36 py-3 px-4 whitespace-nowrap">Role</TableHead>
            <TableHead className="w-44 py-3 px-4 whitespace-nowrap">Location</TableHead>
            <TableHead className="w-36 py-3 px-4 whitespace-nowrap">Access Level</TableHead>
            <TableHead className="w-28 py-3 px-4 text-center whitespace-nowrap">Members</TableHead>
            <TableHead className="w-32 py-3 px-4 whitespace-nowrap">Status</TableHead>
            <TableHead className="w-32 md:w-40 lg:w-44 py-3 px-4 text-right whitespace-nowrap">Manage</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {loading && (
            <TableRow>
              <TableCell colSpan={8} className="h-32">
                <BrandLoader message="Loading team groups..." />
              </TableCell>
            </TableRow>
          )}
          {!loading && groups.length === 0 && (
            <TableRow>
              <TableCell colSpan={8} className="h-24">
                <div className="flex items-center justify-center">
                  <div className="text-sm text-muted-foreground">
                    No team groups found
                  </div>
                </div>
              </TableCell>
            </TableRow>
          )}
          {!loading && groups.length > 0 && (
            groups.map((group) => (
              <TableRow
                key={group.id}
                className={cn(
                  "hover:bg-gray-50 transition-colors [&>td]:align-top",
                  savingGroupId === group.groupIdentifier && "bg-blue-50 animate-pulse"
                )}
              >
                <TableCell className="py-3 px-4">
                  <Checkbox
                    checked={selectedGroups.has(group.id)}
                    onCheckedChange={() => onSelectGroup(group.id)}
                    aria-label={`Select ${group.logicalName || group.groupIdentifier}`}
                  />
                </TableCell>

                <TableCell className="py-3 px-4">
                  <div className="space-y-1.5">
                    <div className="font-medium leading-snug text-gray-900 break-words">
                      {group.logicalName || 'Unconfigured Group'}
                    </div>
                    <div
                      className="max-w-full text-xs text-muted-foreground font-mono break-all sm:break-normal sm:truncate"
                      title={group.groupIdentifier}
                    >
                      {group.groupIdentifier}
                    </div>
                  </div>
                </TableCell>

                <TableCell className="py-3 px-4">
                  {group.roleName ? (
                    <span className="text-sm font-medium text-gray-900 break-words">
                      {businessRoles[group.roleName]?.displayName || group.roleName}
                    </span>
                  ) : (
                    <span className="text-muted-foreground text-sm">Not set</span>
                  )}
                </TableCell>

                <TableCell className="py-3 px-4">
                  {group.country ? (
                    <div className="flex items-center gap-1.5 text-sm text-gray-900">
                      <MapPin className="h-3.5 w-3.5 text-gray-500" />
                      {countryNameMap.get(group.country.toUpperCase()) ?? group.country}
                    </div>
                  ) : (
                    <span className="text-muted-foreground text-sm">Not set</span>
                  )}
                </TableCell>

                <TableCell className="py-3 px-4">
                  {group.accessLevel ? (
                    <AccessLevelBadge accessLevel={group.accessLevel} />
                  ) : (
                    <span className="text-muted-foreground text-sm">Not set</span>
                  )}
                </TableCell>

                <TableCell className="py-3 px-4 text-center">
                  {group.userCount !== undefined ? (
                    <div className="flex items-center justify-center gap-1 text-sm text-gray-900">
                      <Users className="h-3 w-3" />
                      {group.userCount}
                    </div>
                  ) : (
                    <span className="text-muted-foreground text-sm">-</span>
                  )}
                </TableCell>

                <TableCell className="py-3 px-4">
                  <GroupStatusBadge
                    group={group}
                    configured={isConfigured(group)}
                    businessStatus={businessStatus}
                  />
                </TableCell>

                <TableCell className="py-3 px-4 text-right">
                  <GroupActionButtons
                    group={group}
                    permissions={permissions}
                    configured={isConfigured(group)}
                    canConfigureGroups={canConfigureGroups}
                    onToggleActive={onToggleActive}
                    onConfigureGroup={onConfigureGroup}
                  />
                </TableCell>
              </TableRow>
            ))
          )}
        </TableBody>
      </Table>
    </div>
    </TooltipProvider>
  )
}

export const AdGroupsTable = memo(AdGroupsTableComponent)
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/components/ad-groups-toggle-dialog.tsx
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '../../../ui/dialog'
import { Button } from '../../../ui/button'
import { ShieldOff, CheckCircle } from 'lucide-react'
import type { AdGroup } from '../../../../types/features/ad-group-config'

interface AdGroupsToggleDialogProps {
  group: AdGroup | null
  open: boolean
  onOpenChange: (open: boolean) => void
  onConfirm: () => void
}

export function AdGroupsToggleDialog({ group, open, onOpenChange, onConfirm }: Readonly<AdGroupsToggleDialogProps>) {
  if (!group) return null

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            {group.isActive ? (
              <ShieldOff className="h-5 w-5 text-red-500" />
            ) : (
              <CheckCircle className="h-5 w-5 text-green-500" />
            )}
            {group.isActive ? 'Disable Group' : 'Enable Group'}
          </DialogTitle>
          <DialogDescription>
            {`Are you sure you want to ${group.isActive ? 'disable' : 'enable'} the group ${group.logicalName || group.groupIdentifier}?`}
            {group.isActive ? (
              <span className="block mt-2 text-orange-600">
                This will prevent users in this group from accessing the system.
              </span>
            ) : (
              <span className="block mt-2 text-green-600">
                This will allow users in this group to access the system.
              </span>
            )}
          </DialogDescription>
        </DialogHeader>
        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button
            onClick={onConfirm}
            variant={group.isActive ? "destructive" : "default"}
            className={group.isActive ? "" : "bg-green-600 hover:bg-green-700"}
          >
            {group.isActive ? 'Disable Group' : 'Enable Group'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/components/advanced-filters-sheet.tsx
import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetTrigger, SheetFooter } from '../../../ui/sheet'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../../../ui/select'
import { Button } from '../../../ui/button'
import { Badge } from '../../../ui/badge'
import { SlidersHorizontal, X } from 'lucide-react'
import { getBusinessField } from '@/hooks/features/use-business-terminology'
import type { RegionDto, BusinessUnitDto, CountryDto } from '@/services/api/reference-data.service'

const PLACEHOLDER_LOADING = 'Loading...'

interface AdvancedFiltersSheetProps {
  marketFilter: string
  onMarketFilterChange: (value: string) => void
  regionFilter: string
  onRegionFilterChange: (value: string) => void
  countryFilter: string
  onCountryFilterChange: (value: string) => void
  businessUnitFilter: string
  onBusinessUnitFilterChange: (value: string) => void
  onClearAll: () => void
  regions: RegionDto[]
  countries: CountryDto[]
  businessUnits: BusinessUnitDto[]
  isLoading: boolean
}

export function AdvancedFiltersSheet(props: Readonly<AdvancedFiltersSheetProps>) {
  const {
    regionFilter,
    onRegionFilterChange,
    countryFilter,
    onCountryFilterChange,
    businessUnitFilter,
    onBusinessUnitFilterChange,
    onClearAll,
    regions,
    businessUnits,
    countries,
    isLoading
  } = props

  // Count active filters (non-"all" values)
  // Market filter excluded - currently hidden
  const activeFilterCount = [
    // marketFilter !== 'all' ? 1 : 0,  // Hidden
    regionFilter !== 'all' ? 1 : 0,
    countryFilter !== 'all' ? 1 : 0,
    businessUnitFilter !== 'all' ? 1 : 0
  ].reduce((sum, val) => sum + val, 0)

  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button variant="outline" size="sm" className="relative">
          <SlidersHorizontal className="h-4 w-4 mr-2" />
          More Filters
          {activeFilterCount > 0 && (
            <Badge
              variant="default"
              className="ml-2 h-5 min-w-5 rounded-full px-1.5 text-xs"
            >
              {activeFilterCount}
            </Badge>
          )}
        </Button>
      </SheetTrigger>
      <SheetContent side="right" className="w-full sm:max-w-md">
        <SheetHeader>
          <SheetTitle>Advanced Filters</SheetTitle>
        </SheetHeader>

        <div className="mt-6 space-y-4">
          {/* Active Filters Chips */}
          {activeFilterCount > 0 && (
            <div className="pb-4 border-b">
              <p className="text-sm font-medium mb-2">Active Filters</p>
              <div className="flex flex-wrap gap-2">
                {[
                  { value: regionFilter, label: 'Region', onClear: () => onRegionFilterChange('all') },
                  { value: countryFilter, label: 'Country', onClear: () => onCountryFilterChange('all') },
                  { value: businessUnitFilter, label: 'Department', onClear: () => onBusinessUnitFilterChange('all') }
                ]
                  .filter(f => f.value !== 'all')
                  .map(f => (
                    <Badge key={f.label} variant="secondary" className="gap-1">
                      {f.label}: {f.value}
                      <button onClick={f.onClear} className="ml-1 hover:text-destructive">
                        <X className="h-3 w-3" />
                      </button>
                    </Badge>
                  ))}
              </div>
            </div>
          )}

          {/* Filter Dropdowns */}
          <div className="space-y-4">
            {/* Market filter hidden - currently redundant with Country
            <div>
              <label className="text-sm font-medium mb-2 block">Market</label>
              <Select value={marketFilter} onValueChange={onMarketFilterChange} disabled={isLoading}>
                <SelectTrigger className="w-full">
                  <SelectValue placeholder={isLoading ? PLACEHOLDER_LOADING : 'All Markets'} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Markets</SelectItem>
                  {countries.map((country) => (
                    <SelectItem key={country.countryCode} value={country.countryName}>
                      {country.countryName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            */}

            <div>
              <label htmlFor="filter-region" className="text-sm font-medium mb-2 block">Region</label>
              <Select value={regionFilter} onValueChange={onRegionFilterChange} disabled={isLoading}>
                <SelectTrigger id="filter-region" className="w-full">
                  <SelectValue placeholder={isLoading ? PLACEHOLDER_LOADING : 'All Regions'} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">{getBusinessField('allRegions')}</SelectItem>
                  {regions.map((region) => (
                    <SelectItem key={region.regionCode} value={region.regionCode}>
                      {region.regionName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div>
              <label htmlFor="filter-country" className="text-sm font-medium mb-2 block">Country</label>
              <Select value={countryFilter} onValueChange={onCountryFilterChange} disabled={isLoading}>
                <SelectTrigger id="filter-country" className="w-full">
                  <SelectValue placeholder={isLoading ? PLACEHOLDER_LOADING : 'All Countries'} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">{getBusinessField('allCountries')}</SelectItem>
                  {countries.map((country) => (
                    <SelectItem key={country.countryCode} value={country.countryCode}>
                      {country.countryName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div>
              <label htmlFor="filter-department" className="text-sm font-medium mb-2 block">Department</label>
              <Select value={businessUnitFilter} onValueChange={onBusinessUnitFilterChange} disabled={isLoading}>
                <SelectTrigger id="filter-department" className="w-full">
                  <SelectValue placeholder={isLoading ? PLACEHOLDER_LOADING : 'All Departments'} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">{getBusinessField('allBusinessUnits')}</SelectItem>
                  {businessUnits.map((unit) => (
                    <SelectItem key={unit.unitCode} value={unit.unitCode}>
                      {unit.unitName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>

        <SheetFooter className="mt-6 pt-6 border-t">
          <Button
            variant="outline"
            onClick={onClearAll}
            disabled={activeFilterCount === 0}
          >
            Clear All
          </Button>
        </SheetFooter>
      </SheetContent>
    </Sheet>
  )
}
===ENDFILE
===FILE: ./src/components/admin/ad-groups-view/index.ts
export { AdGroupsView } from './ad-groups-view'
===ENDFILE
===FILE: ./src/components/admin/admin-layout.tsx
import { lazy, Suspense, useEffect, useMemo, useState } from 'react'
import { AdminSidebar } from './admin-sidebar'
import { BrandLoader } from '@/components/common/brand-loader'
import { Button } from '../ui/button'
import { Sheet, SheetContent, SheetDescription, SheetHeader, SheetTitle } from '../ui/sheet'
import { Menu } from 'lucide-react'

export type AdminView = 'ad-groups' | 'pending-approvals' | 'notices'
const AdGroupsView = lazy(() =>
  import('./ad-groups-view').then((m) => ({ default: m.AdGroupsView }))
)
const PendingApprovalsView = lazy(() =>
  import('./pending-approvals-view/pending-approvals-view').then((m) => ({ default: m.PendingApprovalsView }))
)
const NoticeManagementView = lazy(() =>
  import('./views/notice-management-view').then((m) => ({ default: m.NoticeManagementView }))
)

// Mirrors host-side admin capability surface so the host can pass permissions directly.
export interface AdminPermissions {
  canPreviewDashboards: boolean
  canViewRoleTemplates: boolean
  canViewAdGroups: boolean
  canViewPendingApprovals: boolean
  canApproveChanges: boolean
  canEditBusinessInfo: boolean
  canEditPermissions: boolean
  canEditApplications: boolean
  canEnableDisableGroups: boolean
  canDirectSave: boolean
  canViewNotices: boolean
  canCreateNotice: boolean
  canEditNotice: boolean
  canPublishNotice: boolean
  canArchiveNotice: boolean
  canSaveDraft: boolean
}

interface AdminLayoutProps {
  permissions: AdminPermissions
  currentRole: string
}

const ADMIN_VIEW_STORAGE_KEY = 'admin-active-view'

export function resolveAvailableViews(permissions: AdminPermissions): AdminView[] {
  const views: AdminView[] = []
  if (permissions.canViewAdGroups) views.push('ad-groups')
  if (permissions.canViewPendingApprovals) views.push('pending-approvals')
  if (permissions.canViewNotices) views.push('notices')
  return views
}

export function resolveInitialView(saved: AdminView | null, availableViews: AdminView[]): AdminView | null {
  if (saved && availableViews.includes(saved)) {
    return saved
  }
  return availableViews[0] ?? null
}

export function resolveActiveView(activeView: AdminView | null, availableViews: AdminView[]): AdminView | null {
  if (activeView && availableViews.includes(activeView)) {
    return activeView
  }

  return availableViews[0] ?? null
}

function renderAdminView(view: AdminView, permissions: AdminPermissions, _currentRole: string) {
  switch (view) {
    case 'ad-groups':
      return <AdGroupsView permissions={permissions} />
    case 'pending-approvals':
      return <PendingApprovalsView permissions={permissions} />
    case 'notices':
      return <NoticeManagementView permissions={permissions} />
    default:
      return <AdGroupsView permissions={permissions} />
  }
}

export function AdminLayout({ permissions, currentRole }: Readonly<AdminLayoutProps>) {
  const availableViews = useMemo(
    () => resolveAvailableViews(permissions),
    [
      permissions.canViewAdGroups,
      permissions.canViewNotices,
      permissions.canViewPendingApprovals
    ]
  )

  const getInitialView = (): AdminView | null => {
    const saved = localStorage.getItem(ADMIN_VIEW_STORAGE_KEY) as AdminView | null
    return resolveInitialView(saved, availableViews)
  }

  const [activeView, setActiveView] = useState<AdminView | null>(getInitialView)
  const [sidebarCollapsed, setSidebarCollapsed] = useState<boolean>(() => {
    if (typeof window === 'undefined') return false
    return localStorage.getItem('admin-sidebar-collapsed') === 'true'
  })
  const [mobileNavOpen, setMobileNavOpen] = useState(false)

  useEffect(() => {
    const nextView = resolveActiveView(activeView, availableViews)
    if (nextView === activeView) {
      return
    }

    setActiveView(nextView)

    if (nextView) {
      localStorage.setItem(ADMIN_VIEW_STORAGE_KEY, nextView)
      return
    }

    localStorage.removeItem(ADMIN_VIEW_STORAGE_KEY)
  }, [activeView, availableViews])

  const handleViewChange = (view: AdminView) => {
    setActiveView(view)
    localStorage.setItem(ADMIN_VIEW_STORAGE_KEY, view)
    setMobileNavOpen(false)
  }

  const handleSidebarToggle = () => {
    setSidebarCollapsed((previous) => {
      const next = !previous
      localStorage.setItem('admin-sidebar-collapsed', String(next))
      return next
    })
  }

  if (!activeView) {
    return (
      <div className="flex h-screen items-center justify-center bg-background">
        <p className="text-lg text-muted-foreground">No admin access configured for your account</p>
      </div>
    )
  }

  return (
    <div className="flex h-full min-h-0 w-full overflow-hidden bg-background">
      <div className="hidden h-full lg:block">
        <AdminSidebar
          activeView={activeView}
          onViewChange={handleViewChange}
          permissions={permissions}
          collapsed={sidebarCollapsed}
          onToggleCollapse={handleSidebarToggle}
        />
      </div>
      <main className="flex-1 min-h-0 overflow-y-auto bg-background scrollbar-visible">
        <div className="sticky top-0 z-20 border-b bg-background/95 px-4 py-3 backdrop-blur supports-[backdrop-filter]:bg-background/75 lg:hidden">
          <Button
            variant="outline"
            size="sm"
            onClick={() => setMobileNavOpen(true)}
            className="gap-2"
          >
            <Menu className="h-4 w-4" />
            Navigation
          </Button>
        </div>

        <div className="p-4 sm:p-6">
          <Suspense
            fallback={
              <div className="flex min-h-[260px] items-center justify-center">
                <BrandLoader />
              </div>
            }
          >
            {renderAdminView(activeView, permissions, currentRole)}
          </Suspense>
        </div>
      </main>

      <Sheet open={mobileNavOpen} onOpenChange={setMobileNavOpen}>
        <SheetContent side="left" className="w-[300px] overflow-y-auto p-0 scrollbar-visible sm:w-[320px]">
          <SheetHeader className="sr-only">
            <SheetTitle>Navigation</SheetTitle>
            <SheetDescription>
              Switch between admin sections
            </SheetDescription>
          </SheetHeader>
          <AdminSidebar
            activeView={activeView}
            onViewChange={handleViewChange}
            permissions={permissions}
            mobile
          />
        </SheetContent>
      </Sheet>
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/admin/admin-screen.tsx
import { AdminLayout } from './admin-layout'
import type { AdminPermissions } from './admin-layout'

interface AdminScreenProps {
  permissions: AdminPermissions
  currentRole: string
}

export function AdminScreen({ permissions, currentRole }: Readonly<AdminScreenProps>) {
  return <AdminLayout permissions={permissions} currentRole={currentRole} />
}
===ENDFILE
===FILE: ./src/components/admin/admin-sidebar.tsx
import { type ComponentType, useMemo } from 'react'
import { cn } from '../../lib/utils'
import { Button } from '../ui/button'
import { Badge } from '../ui/badge'
import { Bell, ChevronLeft, ChevronRight, ClipboardCheck, Users } from 'lucide-react'
import { usePendingChangesCount } from '../../hooks/admin/use-pending-changes'
import type { AdminPermissions, AdminView } from './admin-layout'

interface AdminSidebarProps {
  activeView: AdminView
  onViewChange: (view: AdminView) => void
  permissions: AdminPermissions
  collapsed?: boolean
  onToggleCollapse?: () => void
  mobile?: boolean
}

interface NavItem {
  id: AdminView
  label: string
  icon: ComponentType<{ className?: string }>
  description: string
  badgeCount?: number
}

function getSidebarWidthClass(mobile: boolean, collapsed: boolean): string {
  if (mobile) return 'h-full w-full'
  return collapsed ? 'h-full w-20' : 'h-full w-72'
}

function AdminSidebarContent({
  activeView,
  onViewChange,
  permissions,
  collapsed = false,
  onToggleCollapse,
  mobile = false
}: Readonly<AdminSidebarProps>) {
  const {
    canViewAdGroups,
    canViewPendingApprovals,
    canViewNotices
  } = permissions

  // Get pending changes count for badge
  const { data: pendingCount } = usePendingChangesCount(canViewPendingApprovals)
  const totalPending = pendingCount?.total ?? 0

  const navItems: NavItem[] = useMemo(() => {
    const items: NavItem[] = []
    if (canViewAdGroups) {
      items.push({
        id: 'ad-groups',
        label: 'AD Groups',
        icon: Users,
        description: 'Manage Permissions'
      })
    }
    if (canViewPendingApprovals) {
      items.push({
        id: 'pending-approvals',
        label: 'Pending Approvals',
        icon: ClipboardCheck,
        description: 'Review Changes',
        badgeCount: totalPending
      })
    }
    if (canViewNotices) {
      items.push({
        id: 'notices',
        label: 'System Notices',
        icon: Bell,
        description: 'Broadcast Messages'
      })
    }
    return items
  }, [canViewAdGroups, canViewNotices, canViewPendingApprovals, totalPending])

  return (
    <aside
      className={cn(
        'border-r bg-gradient-to-b from-background to-muted/10 transition-[width] duration-200',
        getSidebarWidthClass(mobile, collapsed)
      )}
      aria-label="Admin navigation"
    >
      <div className={cn('border-b p-3', 'min-h-[56px]')}>
        {!mobile && onToggleCollapse ? (
          <div className="flex items-center justify-end">
            <Button
              variant="ghost"
              size="icon"
              onClick={onToggleCollapse}
              aria-label={
                collapsed
                  ? 'Expand navigation'
                  : 'Collapse navigation'
              }
            >
              {collapsed ? <ChevronRight className="h-4 w-4" /> : <ChevronLeft className="h-4 w-4" />}
            </Button>
          </div>
        ) : null}
      </div>
      <nav className="space-y-2 overflow-y-auto p-3 scrollbar-visible">
        {navItems.map((item) => {
          const Icon = item.icon
          const isActive = activeView === item.id
          const compact = collapsed && !mobile
          return (
            <Button
              key={item.id}
              variant="ghost"
              onClick={() => onViewChange(item.id)}
              title={compact ? item.label : undefined}
              aria-label={item.label}
              className={cn(
                'h-auto w-full rounded-lg border border-transparent text-left',
                compact
                  ? 'items-center justify-center px-2 py-3'
                  : 'items-start justify-start gap-3 px-3 py-3',
                isActive && 'border-red-200 bg-red-50 text-red-700'
              )}
            >
              <Icon className={cn('h-4 w-4 shrink-0', compact ? '' : 'mt-0.5')} />
              {compact ? (
                <span className="sr-only">{item.label}</span>
              ) : (
                <>
                  <span className="flex-1">
                    <span className="block text-sm font-semibold">{item.label}</span>
                    <span className="block text-xs text-muted-foreground">{item.description}</span>
                  </span>
                  {item.badgeCount && item.badgeCount > 0 ? (
                    <Badge variant="secondary" className="bg-red-100 text-red-700">
                      {item.badgeCount > 99 ? '99+' : item.badgeCount}
                    </Badge>
                  ) : null}
                </>
              )}
            </Button>
          )
        })}
      </nav>
    </aside>
  )
}

export function AdminSidebar({
  activeView,
  onViewChange,
  permissions,
  collapsed,
  onToggleCollapse,
  mobile
}: Readonly<AdminSidebarProps>) {
  return (
    <AdminSidebarContent
      activeView={activeView}
      onViewChange={onViewChange}
      permissions={permissions}
      collapsed={collapsed}
      onToggleCollapse={onToggleCollapse}
      mobile={mobile}
    />
  )
}
===ENDFILE
===FILE: ./src/components/admin/app-card.tsx
import { Card, CardContent } from '../ui/card'
import { Badge } from '../ui/badge'
import { CheckCircle, Package } from 'lucide-react'
import { cn } from '../../lib/utils'
import { EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'

interface AppCardProps {
  app: EmbeddedAppWithStatus
  selected: boolean
  onClick: () => void
}

export function AppCard({ app, selected, onClick }: Readonly<AppCardProps>) {
  return (
    <Card
      className={cn(
        "cursor-pointer transition-all duration-200 hover:shadow-md",
        selected
          ? "border-blue-500 bg-blue-50 ring-2 ring-blue-200 shadow-sm"
          : "border-gray-200 hover:bg-gray-50"
      )}
      onClick={onClick}
    >
      <CardContent className="p-4">
        <div className="flex items-start justify-between">
          <div className="flex items-start gap-3 flex-1">
            <div className={cn(
              "p-2 rounded-lg flex-shrink-0",
              selected ? "bg-blue-100" : "bg-gray-100"
            )}>
              <Package className={cn(
                "h-5 w-5",
                selected ? "text-blue-600" : "text-gray-600"
              )} />
            </div>

            <div className="flex-1 min-w-0">
              <div className="flex items-center gap-2 mb-1">
                <h3 className="font-medium text-sm text-gray-900 truncate">
                  {app.titleText}
                </h3>
                {app.isAssignedIndicator && (
                  <CheckCircle className="h-4 w-4 text-green-500 flex-shrink-0" />
                )}
              </div>

              <p className="text-xs text-gray-600 line-clamp-2 mb-2">
                {app.descriptionText}
              </p>

              <div className="flex items-center gap-2">
                <Badge
                  variant="secondary"
                  className="text-xs bg-gray-100 text-gray-700 hover:bg-gray-100"
                >
                  {app.categoryName}
                </Badge>

                {app.isAssignedIndicator && (
                  <Badge
                    variant="secondary"
                    className="text-xs bg-green-100 text-green-700 hover:bg-green-100"
                  >
                    {app.assignedFunctionKeys.length === 1 ? `${app.assignedFunctionKeys.length} feature` : `${app.assignedFunctionKeys.length} features`}
                  </Badge>
                )}
              </div>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
===ENDFILE
===FILE: ./src/components/admin/bulk-operations-toolbar.tsx
import { useMemo, useState, memo } from 'react'
import { cn } from '../../lib/utils'
import {
  Copy,
  CheckSquare,
  Square,
  MinusSquare,
  X
} from 'lucide-react'
import { Button } from '../ui/button'
import { Badge } from '../ui/badge'
import { Checkbox } from '../ui/checkbox'
import { CopySourceSelectionModal } from './copy-source-selection-modal'
import { AdGroup } from '../../types/features/ad-group-config'
import type { BulkCopyExecutionOptions } from '../../hooks/admin/use-ad-groups-selection'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle
} from '../ui/dialog'
import { Label } from '../ui/label'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from '../ui/select'

function SelectionIcon({ isAllSelected, isPartiallySelected }: Readonly<{ isAllSelected: boolean; isPartiallySelected: boolean }>) {
  if (isAllSelected) return <CheckSquare className="h-5 w-5 text-primary" />
  if (isPartiallySelected) return <MinusSquare className="h-5 w-5 text-primary" />
  return <Square className="h-5 w-5" />
}

interface BulkOperationsToolbarProps {
  selectedCount: number
  selectedVisibleCount: number
  totalCount: number
  visibleCount: number
  selectedGroups: string[]
  allAdGroups: AdGroup[]  // All available AD groups for copy source selection
  onSelectAll: () => void
  onDeselectAll: () => void
  onCopyFrom: (
    sourceGroup: AdGroup,
    targetGroupIds: string[],
    options: BulkCopyExecutionOptions
  ) => Promise<void>
  onSearchAdGroups: (query: string) => Promise<AdGroup[]>
  isLookupLoading?: boolean
  className?: string
}

function hasAnyCopySection(options: BulkCopyExecutionOptions): boolean {
  return options.copyRoleAndPermissionsFlag
    || options.copyBusinessInfoFlag
    || options.copyApplicationsFlag
}

function CopyConfirmationSource({ group }: Readonly<{ group: AdGroup | null }>) {
  if (!group) return null
  return (
    <div className="border rounded-md p-4">
      <p className="text-sm font-semibold text-muted-foreground">Source group</p>
      <p className="mt-1 text-sm font-medium">
        {group.logicalName || group.groupIdentifier || 'Unknown group'}
      </p>
      {group.groupIdentifier && (
        <p className="text-xs text-muted-foreground mt-1 font-mono">
          {group.groupIdentifier}
        </p>
      )}
    </div>
  )
}

function CopyConfirmationTargets({ targets, count }: Readonly<{ targets: AdGroup[]; count: number }>) {
  return (
    <div className="border rounded-md p-4 max-h-48 overflow-y-auto">
      <p className="text-sm font-semibold text-muted-foreground">
        {`Target groups (${count})`}
      </p>
      <ul className="mt-2 space-y-1 text-sm">
        {targets.length === 0 ? (
          <li className="text-muted-foreground text-xs">No groups selected.</li>
        ) : (
          targets.map(group => (
            <li key={group.id} className="flex flex-col">
              <span className="font-medium">{group.logicalName || 'Unconfigured Group'}</span>
              <span className="text-xs text-muted-foreground font-mono">{group.groupIdentifier}</span>
            </li>
          ))
        )}
      </ul>
    </div>
  )
}

function BulkOperationsToolbarComponent({
  selectedCount,
  selectedVisibleCount,
  totalCount,
  visibleCount,
  selectedGroups,
  allAdGroups,
  onSelectAll,
  onDeselectAll,
  onCopyFrom,
  onSearchAdGroups,
  isLookupLoading = false,
  className
}: Readonly<BulkOperationsToolbarProps>) {
  const [showCopyModal, setShowCopyModal] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)
  const [showConfirmation, setShowConfirmation] = useState(false)
  const [selectedSourceGroup, setSelectedSourceGroup] = useState<AdGroup | null>(null)
  const [pendingTargetIds, setPendingTargetIds] = useState<string[]>([])
  const [copyExecutionOptions, setCopyExecutionOptions] = useState<BulkCopyExecutionOptions>({
    copyRoleAndPermissionsFlag: true,
    copyBusinessInfoFlag: true,
    copyApplicationsFlag: true,
    copyWorkflowModeCode: 'SUBMIT_FOR_APPROVAL',
    functionMismatchPolicyCode: 'FAIL_ON_MISMATCH'
  })

  const isPartiallySelected = selectedVisibleCount > 0 && selectedVisibleCount < visibleCount
  const isAllSelected = selectedVisibleCount === visibleCount && visibleCount > 0
  const hasAtLeastOneCopySection = hasAnyCopySection(copyExecutionOptions)

  const pendingTargetGroups = useMemo(() => {
    if (!pendingTargetIds.length) {
      return [] as AdGroup[]
    }
    const lookup = new Map(allAdGroups.map(group => [group.id, group]))
    return pendingTargetIds
      .map(id => lookup.get(id))
      .filter((group): group is AdGroup => Boolean(group))
  }, [pendingTargetIds, allAdGroups])

  const handleSelectToggle = () => {
    if (isAllSelected) {
      onDeselectAll()
    } else {
      onSelectAll()
    }
  }

  const resetConfirmationState = () => {
    setShowConfirmation(false)
    setSelectedSourceGroup(null)
    setPendingTargetIds([])
  }

  const handleCopyFromSource = (sourceGroup: AdGroup) => {
    setPendingTargetIds(selectedGroups)
    setSelectedSourceGroup(sourceGroup)
    setShowCopyModal(false)
    setShowConfirmation(true)
  }

  const handleConfirmCopy = async () => {
    if (!selectedSourceGroup || pendingTargetIds.length === 0) {
      resetConfirmationState()
      return
    }

    setIsProcessing(true)
    try {
      await onCopyFrom(selectedSourceGroup, pendingTargetIds, copyExecutionOptions)
    } finally {
      setIsProcessing(false)
      resetConfirmationState()
    }
  }

  const handleCancelConfirmation = () => {
    if (isProcessing) {
      return
    }
    resetConfirmationState()
  }

  if (selectedCount === 0) return null

  return (
    <>
      <div
        className={cn(
          'sticky top-0 z-10 flex items-center justify-between gap-4 p-4 bg-muted/90 backdrop-blur-sm border-y',
          className
        )}
      >
        {/* Selection Info */}
        <div className="flex items-center gap-3">
          <button
            onClick={handleSelectToggle}
            className="p-1 hover:bg-background rounded transition-colors"
          >
            <SelectionIcon isAllSelected={isAllSelected} isPartiallySelected={isPartiallySelected} />
          </button>

          <div className="flex items-center gap-2">
            <Badge variant="secondary" className="font-semibold">
              {`${selectedCount} selected`}
            </Badge>
            <span className="text-sm text-muted-foreground">
              {`of ${visibleCount} visible`}
            </span>
            {totalCount !== visibleCount && (
              <span className="text-xs text-muted-foreground">
                ({`${totalCount} total`})
              </span>
            )}
          </div>

          <Button
            variant="ghost"
            size="sm"
            onClick={onDeselectAll}
            className="text-muted-foreground hover:text-foreground"
          >
            <X className="h-4 w-4 mr-1" />
            Clear selection
          </Button>
        </div>

        {/* Bulk Actions */}
        <div className="flex items-center gap-2">
          {/* Copy From Another Group */}
          <Button
            variant="outline"
            size="sm"
            onClick={() => setShowCopyModal(true)}
          >
            <Copy className="h-4 w-4 mr-2" />
            Copy From Another Group
          </Button>
        </div>
      </div>

      {/* Copy Source Selection Modal */}
      <CopySourceSelectionModal
        open={showCopyModal}
        onOpenChange={setShowCopyModal}
        adGroups={allAdGroups}
        excludeGroupIds={selectedGroups}
        onSelect={handleCopyFromSource}
        isLoading={isProcessing || isLookupLoading}
        onSearch={onSearchAdGroups}
      />

      <Dialog open={showConfirmation} onOpenChange={(open) => {
        if (!open) {
          handleCancelConfirmation()
        }
      }}>
        <DialogContent className="max-w-lg">
          <DialogHeader>
            <DialogTitle>Confirm bulk copy</DialogTitle>
            <DialogDescription>
              Review the source and target groups before copying configuration.
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4 py-2">
            <CopyConfirmationSource group={selectedSourceGroup} />
            <CopyConfirmationTargets targets={pendingTargetGroups} count={pendingTargetIds.length} />

            <p className="text-xs text-muted-foreground">
              This action copies role, permission, location metadata, and embedded app settings. Existing configurations in the selected groups will be overwritten.
            </p>

            <div className="border rounded-md p-4 space-y-4">
              <p className="text-sm font-semibold text-muted-foreground">
                Copy options
              </p>

              <div className="space-y-2">
                <div className="flex items-center gap-2">
                  <Checkbox
                    id="copy-role-permissions"
                    checked={copyExecutionOptions.copyRoleAndPermissionsFlag}
                    onCheckedChange={(checked) => setCopyExecutionOptions(prev => ({
                      ...prev,
                      copyRoleAndPermissionsFlag: Boolean(checked)
                    }))}
                  />
                  <Label htmlFor="copy-role-permissions" className="text-sm">
                    Role and permission settings
                  </Label>
                </div>

                <div className="flex items-center gap-2">
                  <Checkbox
                    id="copy-business-info"
                    checked={copyExecutionOptions.copyBusinessInfoFlag}
                    onCheckedChange={(checked) => setCopyExecutionOptions(prev => ({
                      ...prev,
                      copyBusinessInfoFlag: Boolean(checked)
                    }))}
                  />
                  <Label htmlFor="copy-business-info" className="text-sm">
                    Business information
                  </Label>
                </div>

                <div className="flex items-center gap-2">
                  <Checkbox
                    id="copy-applications"
                    checked={copyExecutionOptions.copyApplicationsFlag}
                    onCheckedChange={(checked) => setCopyExecutionOptions(prev => ({
                      ...prev,
                      copyApplicationsFlag: Boolean(checked)
                    }))}
                  />
                  <Label htmlFor="copy-applications" className="text-sm">
                    Applications and functions
                  </Label>
                </div>
              </div>

              <div className="space-y-2">
                <Label className="text-sm">Compliance workflow</Label>
                <Select
                  value={copyExecutionOptions.copyWorkflowModeCode}
                  onValueChange={(value: BulkCopyExecutionOptions['copyWorkflowModeCode']) => setCopyExecutionOptions(prev => ({
                    ...prev,
                    copyWorkflowModeCode: value
                  }))}
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="SUBMIT_FOR_APPROVAL">Submit for approval (recommended)</SelectItem>
                    <SelectItem value="DIRECT_SAVE">Direct save (bypass approval)</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-2">
                <Label className="text-sm">Cross-market function mismatch</Label>
                <Select
                  value={copyExecutionOptions.functionMismatchPolicyCode}
                  onValueChange={(value: BulkCopyExecutionOptions['functionMismatchPolicyCode']) => setCopyExecutionOptions(prev => ({
                    ...prev,
                    functionMismatchPolicyCode: value
                  }))}
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="FAIL_ON_MISMATCH">Fail if function unavailable</SelectItem>
                    <SelectItem value="SKIP_UNAVAILABLE">Skip unavailable functions</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              {!hasAtLeastOneCopySection && (
                <p className="text-xs text-red-600">Select at least one section to copy.</p>
              )}
            </div>
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={handleCancelConfirmation}
              disabled={isProcessing}
            >
              Cancel
            </Button>
            <Button
              onClick={handleConfirmCopy}
              disabled={isProcessing || pendingTargetIds.length === 0 || !hasAtLeastOneCopySection}
            >
              {isProcessing ? 'Copying...' : 'Confirm copy'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  )
}

export const BulkOperationsToolbar = memo(BulkOperationsToolbarComponent)
===ENDFILE
===FILE: ./src/components/admin/business-relevant-toggles.ts
/**
 * Business-Relevant Toggle Configuration
 *
 * 2-SECTION STRUCTURE for the Permissions tab:
 * 1. "Access Controls" (capabilities) - What users can DO (columns + micro_frontends)
 * 2. "Workspace & Preferences" (workspacePreferences) - What users can CONFIGURE (settings_options only)
 *
 * MINIMAL TOGGLES (10 total, down from 28):
 * - Only business-meaningful toggles admins configure per market/region/team
 * - Linked keys auto-sync dependent technical keys (hidden from UI)
 * - Settings tabs, basic widgets, and role-structural features are NOT toggleable
 *
 * Admin sections are separate and used by the admin panel views.
 *
 * Hidden/auto-synced keys:
 * - features.search.knowledgeBase (follows columns.kms via linkedKeys)
 * - features.search.embeddedApps (follows columns.embeddedApps via linkedKeys)
 * - micro_frontends.spaceCopilot (follows columns.spaceCopilot via linkedKeys)
 * - widgets.mediaBar.callControls (follows micro_frontends.mediaBar via linkedKeys)
 * - All settings_tabs.* (role-structural, no admin ever toggles these)
 * - All widgets.* (role-structural)
 * - settings_options.notifications.desktop (role-structural)
 */

interface ToggleVisibility {
  visible: boolean;
  businessName: string;
  description?: string;
  warning?: string;
  section?: string;
  parent?: string;
  linkedKeys?: string[];
}

interface CategoryConfig {
  title: string;
  description: string;
  toggles: Record<string, ToggleVisibility>;
}

const SECTION_DASHBOARD_ACCESS = 'Dashboard Access'

export const businessRelevantToggles: Record<string, CategoryConfig> = {
  // SECTION 1: ACCESS CONTROLS (What users can DO)
  // 5 toggles with linkedKeys for auto-sync
  capabilities: {
    title: 'Access Controls',
    description: 'Platform capabilities, dashboard panels, and applications',
    toggles: {
      'columns.kms': {
        visible: true,
        businessName: 'Knowledge Base',
        description: 'Access to knowledge base features',
        section: SECTION_DASHBOARD_ACCESS,
        linkedKeys: ['features.search.knowledgeBase']
      },
      'columns.embeddedApps': {
        visible: true,
        businessName: 'Banking Applications',
        description: 'Access to banking applications',
        section: SECTION_DASHBOARD_ACCESS,
        linkedKeys: ['features.search.embeddedApps']
      },
      'columns.spaceCopilot': {
        visible: true,
        businessName: 'AI Assistant',
        description: 'Access to AI assistant features',
        section: SECTION_DASHBOARD_ACCESS,
        linkedKeys: ['micro_frontends.spaceCopilot']
      },
      'columns.chat': {
        visible: true,
        businessName: 'Chat Interface',
        description: 'Access to chat conversation features',
        section: SECTION_DASHBOARD_ACCESS
      },
      'micro_frontends.mediaBar': {
        visible: true,
        businessName: 'Media Controls',
        description: 'Voice and video controls',
        section: 'Platform Apps',
        warning: 'Required for voice agents',
        linkedKeys: ['widgets.mediaBar.callControls']
      }
    }
  },

  // SECTION 2: WORKSPACE & PREFERENCES (What users can CONFIGURE)
  // 5 toggles - settings_options only
  workspacePreferences: {
    title: 'Workspace & Preferences',
    description: 'User preferences and workspace configuration',
    toggles: {
      'settings_options.calls.autoAccept': {
        visible: true,
        businessName: 'Auto-Accept Calls',
        description: 'Automatically accept incoming calls',
        section: 'Call Preferences'
      },
      'settings_options.calls.doNotDisturb.duration': {
        visible: true,
        businessName: 'Do Not Disturb',
        description: 'Set break duration',
        section: 'Call Preferences'
      },
      'settings_options.interface.showTranscript': {
        visible: true,
        businessName: 'Show Transcripts',
        description: 'Display call/chat transcripts',
        section: 'Privacy & Display'
      },
      'settings_options.interface.autoCloseKnowledgeOnCallEnd': {
        visible: true,
        businessName: 'Auto-Close Knowledge',
        description: 'Automatically close knowledge panel when call ends',
        section: 'Privacy & Display'
      },
      'settings_options.interface.spaceCopilotMode': {
        visible: true,
        businessName: 'AI Assistant Mode',
        description: 'Choose AI assistance level',
        section: 'AI Preference'
      }
    }
  },

  // ADMIN PANEL SECTIONS
  adminViews: {
    title: 'Admin Panel Views',
    description: 'Main administrative sections and dashboards',
    toggles: {
      'admin.roleTemplatesView': {
        visible: true,
        businessName: 'Role Templates',
        description: 'View and preview role-based dashboard configurations'
      },
      'admin.adGroupsView': {
        visible: true,
        businessName: 'Team Access Management',
        description: 'Manage AD group configurations and permissions'
      },
      'admin.systemNoticesView': {
        visible: true,
        businessName: 'System Notices',
        description: 'Create and manage system-wide announcements'
      }
    }
  },

  // AD GROUP MANAGEMENT TABS
  adminAdGroupTabs: {
    title: 'AD Group Configuration Tabs',
    description: 'Tabs available when editing AD group configurations',
    toggles: {
      'admin.tab.businessInfo': {
        visible: true,
        businessName: 'Business Info Tab',
        description: 'Edit group name, role, market, region, business unit'
      },
      'admin.tab.permissions': {
        visible: true,
        businessName: 'Permissions Tab',
        description: 'Configure role-based permissions for the group'
      },
      'admin.tab.applications': {
        visible: true,
        businessName: 'Applications Tab',
        description: 'Assign embedded applications and functions'
      }
    }
  },

  // ADMIN ACTIONS
  adminActions: {
    title: 'Administrative Actions',
    description: 'Specific admin capabilities and permissions',
    toggles: {
      'admin.editBusinessInfo': {
        visible: true,
        businessName: 'Edit Business Info',
        description: 'Modify AD group business information'
      },
      'admin.editPermissions': {
        visible: true,
        businessName: 'Edit Permissions',
        description: 'Toggle capabilities and widgets for groups'
      },
      'admin.editApplications': {
        visible: true,
        businessName: 'Manage Applications',
        description: 'Assign applications and functions to groups'
      },
      'admin.enableDisableGroups': {
        visible: true,
        businessName: 'Enable/Disable Groups',
        description: 'Activate or deactivate AD groups'
      },
      'admin.previewDashboards': {
        visible: true,
        businessName: 'Preview Dashboards',
        description: 'Preview role and group configurations'
      },
      'admin.createNotice': {
        visible: true,
        businessName: 'Create Notices',
        description: 'Create new system announcements'
      },
      'admin.publishNotice': {
        visible: true,
        businessName: 'Publish Notices',
        description: 'Publish draft notices to active status'
      },
      'admin.archiveNotice': {
        visible: true,
        businessName: 'Archive Notices',
        description: 'Archive active notices'
      },
      'admin.editNotice': {
        visible: true,
        businessName: 'Edit Notices',
        description: 'Modify existing draft notices'
      },
      'admin.saveDraft': {
        visible: true,
        businessName: 'Save Draft Notices',
        description: 'Save notices as drafts for later publishing'
      }
    }
  }
};

/**
 * Check if a specific toggle should be shown in admin UI
 */
export function isToggleBusinessRelevant(category: string, toggleKey: string): boolean {
  const categoryConfig = businessRelevantToggles[category];
  if (!categoryConfig) return false;

  const toggle = categoryConfig.toggles[toggleKey];
  return toggle?.visible === true;
}
===ENDFILE
===FILE: ./src/components/admin/copy-source-selection-modal.tsx
import { useDeferredValue, useEffect, useMemo, useRef, useState } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '../ui/dialog'
import { Button } from '../ui/button'
import { Input } from '../ui/input'
import { Badge } from '../ui/badge'
// Removed ScrollArea - using native overflow-y-auto for better scrollbar visibility
import { Search, Copy, X } from 'lucide-react'
import { useBusinessRoles } from '@/hooks/features/use-business-terminology'
import type { AdGroup } from '../../types/features/ad-group-config'
import { BrandLoader } from '@/components/common/brand-loader'
import { isConfiguredGroup } from '../../utils/admin/notice-validators'

function GroupLocationInfo({ group }: Readonly<{ group: AdGroup }>) {
  if (!group.market && !group.region && !group.country) return null
  const parts: string[] = []
  if (group.market) parts.push(group.market)
  if (group.region) parts.push(group.region)
  if (group.country) parts.push(group.country)
  return (
    <div className="flex items-center gap-2 text-xs text-muted-foreground mt-1">
      {parts.map((part, i) => (
        <span key={part}>
          {i > 0 && <span className="mr-2"></span>}
          {part}
        </span>
      ))}
    </div>
  )
}

function matchesSearchQuery(group: AdGroup, query: string): boolean {
  return Boolean(
    group.logicalName?.toLowerCase().includes(query) ||
    group.groupIdentifier.toLowerCase().includes(query) ||
    group.roleName?.toLowerCase().includes(query) ||
    group.market?.toLowerCase().includes(query) ||
    group.region?.toLowerCase().includes(query)
  )
}

function filterAndSortGroups(adGroups: AdGroup[], excludeGroupIds: string[], query: string): AdGroup[] {
  let groups = adGroups.filter(group =>
    !excludeGroupIds.includes(group.id) && isConfiguredGroup({ group })
  )
  if (query) {
    const lowerQuery = query.toLowerCase()
    groups = groups.filter(group => matchesSearchQuery(group, lowerQuery))
  }
  return groups.sort((a, b) =>
    (a.logicalName || a.groupIdentifier).localeCompare(b.logicalName || b.groupIdentifier)
  )
}

function GroupCard({ group, isSelected, businessRole, onSelect }: Readonly<{
  group: AdGroup
  isSelected: boolean
  businessRole: { displayName: string }
  onSelect: (group: AdGroup) => void
}>) {
  return (
    <button
      key={group.id}
      onClick={() => onSelect(group)}
      className={`w-full text-left p-4 rounded-lg border-2 transition-all ${
        isSelected
          ? 'border-red-600 bg-red-50 hover:bg-red-100'
          : 'border-border hover:border-red-500 hover:bg-red-50/50'
      }`}
    >
      <div className="flex items-start justify-between gap-3">
        <div className="flex-1 space-y-1">
          <div className="flex items-center gap-2">
            <p className="font-semibold text-sm">
              {group.logicalName || 'Unconfigured Group'}
            </p>
            <Badge variant="outline" className="text-xs">
              {businessRole.displayName}
            </Badge>
          </div>
          <p className="text-xs text-muted-foreground font-mono truncate">
            {group.groupIdentifier}
          </p>
          <GroupLocationInfo group={group} />
        </div>
        {isSelected && (
          <div className="flex-shrink-0">
            <div className="h-5 w-5 rounded-full bg-primary flex items-center justify-center">
              <Copy className="h-3 w-3 text-primary-foreground" />
            </div>
          </div>
        )}
      </div>
    </button>
  )
}

function GroupsListContent({ isLoading, filteredGroups, searchQuery, selectedGroup, businessRoles, onSelect }: Readonly<{
  isLoading: boolean
  filteredGroups: AdGroup[]
  searchQuery: string
  selectedGroup: AdGroup | null
  businessRoles: Record<string, { displayName: string; description: string; category: string }>
  onSelect: (group: AdGroup) => void
}>) {
  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-12">
        <BrandLoader message="Loading AD groups..." />
      </div>
    )
  }

  if (filteredGroups.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center py-12 text-center">
        <Search className="h-12 w-12 text-muted-foreground mb-4" />
        <p className="text-sm text-muted-foreground">
          {searchQuery ? 'No matching groups found' : 'No configured groups available'}
        </p>
      </div>
    )
  }

  return (
    <div className="space-y-2">
      {filteredGroups.map((group) => {
        const isSelected = selectedGroup?.id === group.id
        const businessRole = businessRoles[group.roleName || 'voice_agent'] || { displayName: group.roleName || 'Unknown', description: '', category: '' }
        return (
          <GroupCard
            key={group.id}
            group={group}
            isSelected={isSelected}
            businessRole={businessRole}
            onSelect={onSelect}
          />
        )
      })}
    </div>
  )
}

interface CopySourceSelectionModalProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  adGroups: AdGroup[]
  excludeGroupIds: string[]  // Groups that can't be selected (e.g., the target group)
  onSelect: (sourceGroup: AdGroup) => void
  isLoading?: boolean
  onSearch?: (query: string) => Promise<AdGroup[]>
}

export function CopySourceSelectionModal({
  open,
  onOpenChange,
  adGroups,
  excludeGroupIds,
  onSelect,
  isLoading = false,
  onSearch
}: Readonly<CopySourceSelectionModalProps>) {
  const businessRoles = useBusinessRoles()
  const [searchQuery, setSearchQuery] = useState('')
  const [selectedGroup, setSelectedGroup] = useState<AdGroup | null>(null)
  const debouncedQuery = useDeferredValue(searchQuery)
  const lastSearchedRef = useRef<string | null>(null)

  useEffect(() => {
    if (!open) {
      lastSearchedRef.current = null
      return
    }

    const shouldSkip = !onSearch
      || (debouncedQuery === '' && adGroups.length > 0)
      || lastSearchedRef.current === debouncedQuery
    if (shouldSkip) return

    lastSearchedRef.current = debouncedQuery
    onSearch(debouncedQuery)
  }, [debouncedQuery, onSearch, open, adGroups.length])

  const filteredGroups = useMemo(() =>
    filterAndSortGroups(adGroups, excludeGroupIds, debouncedQuery),
    [adGroups, excludeGroupIds, debouncedQuery]
  )

  const handleSelect = () => {
    if (selectedGroup) {
      onSelect(selectedGroup)
      // Reset state
      setSelectedGroup(null)
      setSearchQuery('')
    }
  }

  const handleCancel = () => {
    setSelectedGroup(null)
    setSearchQuery('')
    onOpenChange(false)
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl max-h-[85vh] flex flex-col">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Copy className="h-5 w-5" />
            Copy Configuration From Another Group
          </DialogTitle>
          <DialogDescription>
            Select a source AD group to copy configuration from. The role, permissions, and location metadata will be copied.
          </DialogDescription>
        </DialogHeader>

        {/* Search Bar */}
        <div className="flex items-center gap-2 px-1 flex-shrink-0">
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search by name, DN, role, or location..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10 pr-10"
            />
            {searchQuery && (
              <button
                onClick={() => setSearchQuery('')}
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-muted-foreground hover:text-foreground"
              >
                <X className="h-4 w-4" />
              </button>
            )}
          </div>
        </div>

        {/* Groups List - using overflow-y-scroll to always show scrollbar */}
        <div className="flex-1 min-h-0 max-h-[400px] overflow-y-scroll pr-2" style={{
          scrollbarWidth: 'thin',
          scrollbarColor: '#9ca3af #f3f4f6'
        }}>
          <GroupsListContent
            isLoading={isLoading}
            filteredGroups={filteredGroups}
            searchQuery={searchQuery}
            selectedGroup={selectedGroup}
            businessRoles={businessRoles}
            onSelect={setSelectedGroup}
          />
        </div>

        {/* Footer */}
        <DialogFooter className="flex-shrink-0">
          <div className="flex items-center justify-between w-full">
            <p className="text-sm text-muted-foreground">
              {filteredGroups.length === 1 ? `${filteredGroups.length} group available` : `${filteredGroups.length} groups available`}
            </p>
            <div className="flex gap-2">
              <Button
                variant="outline"
                onClick={handleCancel}
                disabled={isLoading}
              >
                Cancel
              </Button>
              <Button
                onClick={handleSelect}
                disabled={!selectedGroup || isLoading}
              >
                {isLoading ? 'Copying...' : 'Copy Configuration'}
              </Button>
            </div>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE
===FILE: ./src/components/admin/function-assignment-panel.tsx
import React, { useState, useEffect } from 'react'
import { useFunctionSelection } from '../../hooks/admin/use-function-selection'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../ui/card'
import { Checkbox } from '../ui/checkbox'
import { Badge } from '../ui/badge'
import { Button } from '../ui/button'
import { Label } from '../ui/label'
import { Package, Settings, Save, X } from 'lucide-react'
import { EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'
import { cn } from '../../lib/utils'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle
} from '../ui/alert-dialog'

type PermissionFilter = 'all' | 'write' | 'read'

interface ModalStateConfig {
  type: 'none' | 'default' | 'standard' | 'missing' | 'removal'
  title?: string
  description?: string
  confirmLabel?: string
  cancelLabel?: string
  context?: 'save-removal' | 'button-removal'
}

interface SaveDetermination {
  modalState: ModalStateConfig
  pendingSave: { functions: string[]; defaultFunction?: string } | null
}

const LABEL_UNASSIGN = 'Unassign Application'

function getOriginalAssignedCount(app: EmbeddedAppWithStatus): number {
  return app.assignedFunctionKeys?.length ?? 0
}

function getDefaultDisplayName(
  defaultFeatureKey: string | undefined,
  functionDefinitions: Record<string, { displayName?: string }>
): string | undefined {
  if (!defaultFeatureKey) return undefined
  return functionDefinitions[defaultFeatureKey]?.displayName || defaultFeatureKey
}

function determineSaveModalState(
  selectedFunctions: string[],
  app: EmbeddedAppWithStatus,
  groupLabel: string,
  functionDefinitions: Record<string, { displayName?: string }>
): SaveDetermination {
  const originalAssignedCount = getOriginalAssignedCount(app)
  const defaultFeatureKey = app.defaultFunctionKey
  const defaultDisplayName = getDefaultDisplayName(defaultFeatureKey, functionDefinitions)

  const isDefaultOnlySelection = selectedFunctions.length === 1
    && selectedFunctions[0] === defaultFeatureKey

  if (isDefaultOnlySelection && originalAssignedCount === 0) {
    return {
      modalState: {
        type: 'default',
        title: 'Default feature included',
        description: `${defaultDisplayName} will be assigned automatically so "${app.titleText}" can load its baseline view. Continue with this assignment?`,
        confirmLabel: 'Assign application',
        cancelLabel: 'Cancel'
      },
      pendingSave: { functions: selectedFunctions, defaultFunction: defaultFeatureKey }
    }
  }

  if (selectedFunctions.length === 0) {
    if (originalAssignedCount === 0) {
      return {
        modalState: {
          type: 'missing',
          title: 'Select at least one feature',
          description: 'Choose a capability to assign or cancel to keep the application unassigned.',
          confirmLabel: 'OK'
        },
        pendingSave: null
      }
    }
    return {
      modalState: {
        type: 'removal',
        title: LABEL_UNASSIGN,
        description: `Saving without any features will unassign "${app.titleText}" from ${groupLabel}. Continue?`,
        confirmLabel: LABEL_UNASSIGN,
        cancelLabel: 'Cancel',
        context: 'save-removal'
      },
      pendingSave: { functions: [] }
    }
  }

  return {
    modalState: {
      type: 'standard',
      title: 'Confirm feature assignment',
      description: selectedFunctions.length === 1
        ? `Apply ${selectedFunctions.length} feature to "${app.titleText}" for ${groupLabel}?`
        : `Apply ${selectedFunctions.length} features to "${app.titleText}" for ${groupLabel}?`,
      confirmLabel: 'Save Assignment',
      cancelLabel: 'Cancel'
    },
    pendingSave: { functions: selectedFunctions }
  }
}

function getFunctionItemStyle(isChecked: boolean, isDefaultFeature: boolean): string {
  if (!isChecked) return "border-gray-200 hover:bg-gray-50"
  if (isDefaultFeature) return "border-green-200 bg-green-50"
  return "border-blue-200 bg-blue-50"
}

function getFilteredFunctions(
  availableFunctions: string[],
  functionDefinitions: Record<string, { categoryText?: string }>,
  permissionFilter: PermissionFilter
): string[] {
  if (permissionFilter === 'all') return availableFunctions
  return availableFunctions.filter(functionKey =>
    functionDefinitions[functionKey]?.categoryText === permissionFilter
  )
}

function countByCategory(
  availableFunctions: string[],
  functionDefinitions: Record<string, { categoryText?: string }>,
  category: string
): number {
  return availableFunctions.filter(fk =>
    functionDefinitions[fk]?.categoryText === category
  ).length
}

interface FunctionAssignmentPanelProps {
  app: EmbeddedAppWithStatus
  groupName: string
  onSave: (functions: string[], defaultFunction?: string) => Promise<void>
  onSelectionChange?: (functions: string[], defaultFunction?: string) => void
  isLoading?: boolean
  isReadOnly?: boolean
}

function FunctionListItem({ functionKey, definition, defaultFunctionKey, selectedFunctions, isReadOnly, onToggle }: Readonly<{
  functionKey: string
  definition: { displayName?: string; description?: string; categoryText?: string } | undefined
  defaultFunctionKey: string | undefined
  selectedFunctions: string[]
  isReadOnly: boolean
  onToggle: (params: { functionKey: string; checked: boolean }) => void
}>) {
  const isDefaultFeature = defaultFunctionKey === functionKey
  const isChecked = isDefaultFeature || selectedFunctions.includes(functionKey)
  const isDisabled = isReadOnly || isDefaultFeature

  return (
    <div
      className={cn(
        "flex items-start space-x-3 p-3 border rounded-lg transition-colors",
        getFunctionItemStyle(isChecked, isDefaultFeature)
      )}
    >
      <Checkbox
        id={functionKey}
        checked={isChecked}
        disabled={isDisabled}
        onCheckedChange={(checked) =>
          onToggle({ functionKey, checked: checked as boolean })
        }
        className="mt-0.5 flex-shrink-0"
      />
      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2 flex-wrap">
          <Label
            htmlFor={functionKey}
            className={cn(
              "text-sm font-medium",
              isDisabled ? "cursor-not-allowed text-gray-600" : "cursor-pointer"
            )}
          >
            {definition?.displayName || functionKey}
          </Label>
          {isDefaultFeature && (
            <Badge variant="secondary" className="bg-green-100 text-green-700 text-xs">
              Required
            </Badge>
          )}
        </div>
        {definition?.description && (
          <p className="text-xs text-gray-600 mt-1">
            {definition.description}
          </p>
        )}
        {definition?.categoryText && (
          <Badge
            variant="outline"
            className="text-xs mt-2"
          >
            {definition.categoryText}
          </Badge>
        )}
      </div>
    </div>
  )
}

function FooterStatusMessage({ selectedCount }: Readonly<{ selectedCount: number }>) {
  return (
    <div className="text-center text-sm py-2 text-gray-500">
      {selectedCount === 0
        ? 'No features assigned to this application'
        : 'Current assignment saved'}
    </div>
  )
}

function FooterEditStatus({ selectedCount, hasChanges, isLoading, onSave, onReset }: Readonly<{
  selectedCount: number
  hasChanges: boolean
  isLoading: boolean
  onSave: () => void
  onReset: () => void
}>) {
  if (hasChanges) {
    return (
      <div className="flex items-center gap-2">
        <Button onClick={onSave} disabled={isLoading} className="flex-1">
          {isLoading ? 'Saving...' : <><Save className="h-4 w-4 mr-2" />Save Assignment</>}
        </Button>
        <Button variant="outline" onClick={onReset} disabled={isLoading}>
          <X className="h-4 w-4 mr-2" />
          Reset
        </Button>
      </div>
    )
  }

  return (
    <div className={cn('text-center text-sm py-2', selectedCount === 0 ? 'text-gray-500' : 'text-green-600')}>
      {selectedCount === 0 ? 'Select features to assign this application to the AD group' : 'Current assignment saved'}
    </div>
  )
}

function PanelFooterSection({ isReadOnly, selectedCount, hasChanges, isLoading, isAssigned, onSave, onReset, onUnassign }: Readonly<{
  isReadOnly: boolean
  selectedCount: number
  hasChanges: boolean
  isLoading: boolean
  isAssigned: boolean
  onSave: () => void
  onReset: () => void
  onUnassign: () => void
}>) {
  return (
    <div className="pt-4 border-t space-y-3">
      {isReadOnly && <FooterStatusMessage selectedCount={selectedCount} />}
      {!isReadOnly && (
        <FooterEditStatus
          selectedCount={selectedCount}
          hasChanges={hasChanges}
          isLoading={isLoading}
          onSave={onSave}
          onReset={onReset}
        />
      )}

      {!isReadOnly && isAssigned && (
        <Button
          variant="outline"
          onClick={onUnassign}
          disabled={isLoading}
          className="w-full border-red-200 text-red-600 hover:bg-red-50 hover:text-red-700"
        >
          {LABEL_UNASSIGN}
        </Button>
      )}
    </div>
  )
}

function PermissionFilterBar({ permissionFilter, setPermissionFilter, availableFunctions, writeCount, readCount }: Readonly<{
  permissionFilter: PermissionFilter
  setPermissionFilter: (v: PermissionFilter) => void
  availableFunctions: string[]
  writeCount: number
  readCount: number
}>) {
  return (
    <div className="flex items-center gap-2">
      <Button
        variant={permissionFilter === 'all' ? 'default' : 'outline'}
        size="sm"
        onClick={() => setPermissionFilter('all')}
        className="h-8"
      >
        {`All (${availableFunctions.length})`}
      </Button>
      <Button
        variant={permissionFilter === 'write' ? 'default' : 'outline'}
        size="sm"
        onClick={() => setPermissionFilter('write')}
        className="h-8"
      >
        {`Write (${writeCount})`}
      </Button>
      <Button
        variant={permissionFilter === 'read' ? 'default' : 'outline'}
        size="sm"
        onClick={() => setPermissionFilter('read')}
        className="h-8"
      >
        {`Read (${readCount})`}
      </Button>
    </div>
  )
}

function BulkActionsBar({ permissionFilter, writeCount, readCount, filteredFunctions, onSelectAll, onClear }: Readonly<{
  permissionFilter: PermissionFilter
  writeCount: number
  readCount: number
  filteredFunctions: string[]
  onSelectAll: (params: { filteredFunctions: string[] }) => void
  onClear: () => void
}>) {
  if (permissionFilter === 'all' || filteredFunctions.length === 0) return null
  const filterLabel = permissionFilter === 'write' ? `Write (${writeCount})` : `Read (${readCount})`
  return (
    <div className="flex items-center gap-3 text-sm px-2">
      <Button
        variant="ghost"
        size="sm"
        onClick={() => onSelectAll({ filteredFunctions })}
        className="h-7 text-xs"
      >
        {`Select All ${filterLabel}`}
      </Button>
      <span className="text-gray-400">&bull;</span>
      <Button
        variant="ghost"
        size="sm"
        onClick={onClear}
        className="h-7 text-xs"
      >
        Clear Selection
      </Button>
    </div>
  )
}

function FunctionConfirmationDialog({ modalState, onConfirm, onCancel, isOpen }: Readonly<{
  modalState: ModalStateConfig
  onConfirm: () => Promise<void>
  onCancel: () => void
  isOpen: boolean
}>) {
  return (
    <AlertDialog open={isOpen} onOpenChange={(open) => { if (!open) onCancel() }}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>{modalState.title}</AlertDialogTitle>
          {modalState.description && (
            <AlertDialogDescription>{modalState.description}</AlertDialogDescription>
          )}
        </AlertDialogHeader>
        <AlertDialogFooter>
          {modalState.type !== 'missing' && modalState.cancelLabel && (
            <AlertDialogCancel
              onClick={(event) => {
                event.preventDefault()
                onCancel()
              }}
            >
              {modalState.cancelLabel}
            </AlertDialogCancel>
          )}
          <AlertDialogAction
            onClick={async (event) => {
              event.preventDefault()
              await onConfirm()
            }}
          >
            {modalState.confirmLabel || 'Continue'}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  )
}

export function FunctionAssignmentPanel({
  app,
  groupName,
  onSave,
  onSelectionChange,
  isLoading = false,
  isReadOnly = false
}: Readonly<FunctionAssignmentPanelProps>) {
  const {
    selectedFunctions,
    defaultFunction,
    hasChanges,
    handleFunctionToggle,
    handleSelectAllFiltered,
    handleClearSelection,
    handleReset
  } = useFunctionSelection({ app })

  // Report selection changes to parent so modal-level save can include them
  useEffect(() => {
    if (onSelectionChange && hasChanges()) {
      onSelectionChange(selectedFunctions, defaultFunction)
    }
  }, [selectedFunctions, defaultFunction])

  const [permissionFilter, setPermissionFilter] = useState<PermissionFilter>('all')
  const [modalState, setModalState] = useState<ModalStateConfig>({ type: 'none' })
  const [pendingSave, setPendingSave] = useState<{
    functions: string[]
    defaultFunction?: string
  } | null>(null)

  const functionDefinitions = app.functionDefinitionsObject || {}
  const availableFunctions = Object.keys(functionDefinitions)

  const closeModal = () => {
    setModalState({ type: 'none' })
    setPendingSave(null)
  }

  const handleConfirmModal = async () => {
    if (modalState.type === 'missing') {
      closeModal()
      return
    }

    if (!pendingSave) {
      closeModal()
      return
    }

    try {
      await onSave(pendingSave.functions, pendingSave.defaultFunction)
      // Clear pending state after successful save
      onSelectionChange?.([], undefined)
      closeModal()
    } catch {
      // onSave handles its own notifications; keep dialog open for retry
    }
  }

  const handleSave = async () => {
    const groupLabel = groupName || 'this AD group'
    const determination = determineSaveModalState(selectedFunctions, app, groupLabel, functionDefinitions)

    // Override defaultFunction with the actual tracked value for standard saves
    if (determination.pendingSave && determination.modalState.type === 'standard') {
      determination.pendingSave.defaultFunction = defaultFunction
    }

    setPendingSave(determination.pendingSave)
    setModalState(determination.modalState)
  }

  const filteredFunctions = getFilteredFunctions(availableFunctions, functionDefinitions, permissionFilter)
  const writeCount = countByCategory(availableFunctions, functionDefinitions, 'write')
  const readCount = countByCategory(availableFunctions, functionDefinitions, 'read')

  const handleUnassign = () => {
    if (isLoading || !app.isAssignedIndicator) return

    setPendingSave({ functions: [] })
    setModalState({
      type: 'removal',
      title: LABEL_UNASSIGN,
      description: `Unassigning "${app.titleText}" will remove all access for ${groupName || 'this AD group'}. Continue?`,
      confirmLabel: LABEL_UNASSIGN,
      cancelLabel: 'Cancel',
      context: 'button-removal'
    })
  }

  return (
    <>
      <Card className="h-full">
      <CardHeader className="pb-4">
        <div className="flex items-start justify-between">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-blue-100 rounded-lg">
              <Package className="h-5 w-5 text-blue-600" />
            </div>
            <div>
              <CardTitle className="text-lg">{app.titleText}</CardTitle>
              <CardDescription>{app.descriptionText}</CardDescription>
            </div>
          </div>
          {app.isAssignedIndicator && (
            <Badge variant="secondary" className="bg-green-100 text-green-700">
              Assigned
            </Badge>
          )}
        </div>
      </CardHeader>

      <CardContent className="space-y-6">
        {/* Function Selection */}
        <div className="space-y-4">
          <div className="flex items-center justify-between flex-wrap gap-3">
            <div className="flex items-center gap-2">
              <Settings className="h-4 w-4 text-gray-500" />
              <Label className="text-sm font-medium">Available Features</Label>
              <Badge variant="outline" className="text-xs">
                {`${selectedFunctions.length} of ${availableFunctions.length} selected`}
              </Badge>
            </div>

            <PermissionFilterBar
              permissionFilter={permissionFilter}
              setPermissionFilter={setPermissionFilter}
              availableFunctions={availableFunctions}
              writeCount={writeCount}
              readCount={readCount}
            />
          </div>

          <BulkActionsBar
            permissionFilter={permissionFilter}
            writeCount={writeCount}
            readCount={readCount}
            filteredFunctions={filteredFunctions}
            onSelectAll={handleSelectAllFiltered}
            onClear={handleClearSelection}
          />

          {filteredFunctions.length > 0 ? (
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-3 max-h-[400px] overflow-y-auto">
              {filteredFunctions.map((functionKey) => (
                <FunctionListItem
                  key={functionKey}
                  functionKey={functionKey}
                  definition={functionDefinitions[functionKey]}
                  defaultFunctionKey={app.defaultFunctionKey}
                  selectedFunctions={selectedFunctions}
                  isReadOnly={isReadOnly}
                  onToggle={handleFunctionToggle}
                />
              ))}
            </div>
          ) : (
            <div className="text-center py-8 text-gray-500 text-sm">
              {permissionFilter !== 'all'
                ? `No ${permissionFilter} features available`
                : 'No features available for this application'}
            </div>
          )}
        </div>


        <PanelFooterSection
          isReadOnly={isReadOnly}
          selectedCount={selectedFunctions.length}
          hasChanges={hasChanges()}
          isLoading={isLoading}
          isAssigned={app.isAssignedIndicator}
          onSave={handleSave}
          onReset={handleReset}
          onUnassign={handleUnassign}
        />
      </CardContent>
      </Card>

      <FunctionConfirmationDialog
        modalState={modalState}
        onConfirm={handleConfirmModal}
        onCancel={closeModal}
        isOpen={modalState.type !== 'none'}
      />
    </>
  )
}
===ENDFILE
===FILE: ./src/components/admin/iframe-layout-preview.tsx
import { useState, useEffect } from 'react';
import { Card } from '../ui/card';
import { Button } from '../ui/button';
import { Badge } from '../ui/badge';
import { RefreshCw, ExternalLink } from 'lucide-react';
import type { RoleTemplate } from '../../types/system/layout-template';

interface IframeLayoutPreviewProps {
  role: RoleTemplate;
  adGroup?: string;
}

export function IframeLayoutPreview({ role, adGroup }: Readonly<IframeLayoutPreviewProps>) {
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);
  const [mergedTemplate, setMergedTemplate] = useState<RoleTemplate>(role);
  const currentRole = 'admin';

  // Note: We don't fetch AD group data here because:
  // 1. The role template is already merged with AD group overrides by the parent component
  // 2. API calls from within iframes may not work due to proxy limitations
  // 3. The preview receives the complete merged template via URL parameters
  useEffect(() => {
    setMergedTemplate(role);
  }, [role]);

  // Build preview URL with merged template JSON
  const previewParams = new URLSearchParams({
    mode: 'preview',
    role: mergedTemplate.roleName,
    currentRole: currentRole, // Pass the current role context to iframe
    template: btoa(JSON.stringify(mergedTemplate)) // Pass merged template JSON as base64 encoded string
  });

  if (adGroup) {
    previewParams.set('adGroup', adGroup);
  }

  const previewUrl = `/dashboard/preview?${previewParams.toString()}`;

  // Handle iframe load events
  const handleIframeLoad = () => {
    setIsLoading(false);
    setHasError(false);
  };

  const handleIframeError = () => {
    setIsLoading(false);
    setHasError(true);
  };

  // Refresh preview
  const refreshPreview = () => {
    setIsLoading(true);
    setHasError(false);
    // Force iframe reload by updating key
    const iframe = document.getElementById('preview-iframe') as HTMLIFrameElement;
    if (iframe) {
      iframe.src = previewUrl;
    }
  };

  // Open in new tab
  const openInNewTab = () => {
    window.open(previewUrl, '_blank');
  };

  return (
    <div className="w-full h-full flex flex-col">
      {/* Preview Header */}
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-3">
          <h3 className="text-lg font-semibold">
            {`${role.displayName} Layout Preview`}
          </h3>
          {adGroup && (
            <Badge variant="outline" className="text-xs">
              {`AD Group: ${adGroup}`}
            </Badge>
          )}
        </div>

        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={refreshPreview}
            disabled={isLoading}
          >
            <RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} />
            Refresh
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={openInNewTab}
          >
            <ExternalLink className="h-4 w-4" />
            Open Full
          </Button>
        </div>
      </div>

      {/* Preview Container */}
      <Card className="relative overflow-hidden flex-1">
        {/* Error State */}
        {hasError && !isLoading && (
          <div className="absolute inset-0 bg-background/80 backdrop-blur-sm z-10 flex items-center justify-center">
            <div className="text-center">
              <p className="text-destructive font-medium mb-2">Failed to load preview</p>
              <Button variant="outline" size="sm" onClick={refreshPreview}>
                <RefreshCw className="h-4 w-4 mr-2" />
                Try Again
              </Button>
            </div>
          </div>
        )}

        {/* Preview iframe */}
        <iframe
          id="preview-iframe"
          src={previewUrl}
          className="w-full h-full border-0 rounded-lg"
          data-panel-iframe="true"
          title={`${role.displayName} Dashboard Preview`}
          sandbox="allow-same-origin allow-scripts allow-forms"
          onLoad={handleIframeLoad}
          onError={handleIframeError}
        />
      </Card>

      {/* Preview Info */}
      <div className="mt-3 text-xs text-muted-foreground">
        <p>
          {(() => {
            const suffix = adGroup ? ` with ${adGroup} AD group overrides applied` : ''
            return `This preview shows the exact dashboard interface that ${role.displayName.toLowerCase()}s see${suffix}.`
          })()}
        </p>
        <p className="mt-1">
           Real components with demo data  Interactive elements disabled  Secure sandbox environment
        </p>
      </div>
    </div>
  );
}
===ENDFILE
===FILE: ./src/components/admin/layout-preview-modal.tsx
import { useState, useEffect, useRef } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '../ui/dialog';
import { Button } from '../ui/button';
import { Eye } from 'lucide-react';
import { IframeLayoutPreview } from './iframe-layout-preview';
import { AdGroup } from '../../types/features/ad-group-config';
import type { RoleTemplate } from '../../types/system/layout-template';

interface LayoutPreviewModalProps {
  role?: RoleTemplate;
  adGroup?: AdGroup;
  fetchLayout?: () => Promise<RoleTemplate>;
  children?: React.ReactNode;
}

export function LayoutPreviewModal({ role, adGroup, fetchLayout, children }: Readonly<LayoutPreviewModalProps>) {
  const [open, setOpen] = useState(false);
  const [loadedRole, setLoadedRole] = useState<RoleTemplate | null>(role || null);
  const [loading, setLoading] = useState(false);
  const fetchingRef = useRef(false);

  useEffect(() => {
    if (!open) {
      // Reset when modal closes
      if (fetchLayout) {
        setLoadedRole(null);
      }
      fetchingRef.current = false;
      return undefined;
    }

    if (!fetchLayout || fetchingRef.current || loadedRole) return undefined;

    let ignore = false;
    fetchingRef.current = true;
    setLoading(true);

    fetchLayout()
      .then(roleData => {
        if (!ignore) {
          setLoadedRole(roleData);
          setLoading(false);
        }
      })
      .catch(() => {
        if (!ignore) {
          setLoading(false);
        }
      })
      .finally(() => {
        if (!ignore) {
          fetchingRef.current = false;
        }
      });

    return () => {
      ignore = true;
    };
  }, [open, fetchLayout]);

  const displayRole = loadedRole || role;
  const adGroupName = adGroup?.logicalName || adGroup?.groupIdentifier;

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        {children || (
          <Button variant="outline" size="sm" className="w-full group border-primary/20 hover:border-primary/40 hover:bg-primary/5 transition-all">
            <Eye className="h-4 w-4 mr-2 group-hover:text-primary transition-colors" />
            <span className="group-hover:text-primary transition-colors">Preview Dashboard</span>
          </Button>
        )}
      </DialogTrigger>
      <DialogContent className="w-[90vw] h-[90vh] max-w-[90vw] max-h-[90vh] p-4 sm:p-6 gap-3 flex flex-col">
        <DialogHeader className="space-y-1 sm:text-left">
          <DialogTitle className="text-xl font-bold flex items-center gap-2">
            Dashboard Layout Preview
            {adGroupName && (
              <span className="text-sm font-normal text-muted-foreground">
                 {adGroupName}
              </span>
            )}
          </DialogTitle>
          <DialogDescription className="text-sm text-muted-foreground/90">
            Live preview showing the exact interface this role sees
            {adGroupName && ' with AD group-specific overrides'}
          </DialogDescription>
        </DialogHeader>

        <div className="flex-1 min-h-0">
          {displayRole && (
            <IframeLayoutPreview role={displayRole} adGroup={adGroupName} />
          )}
          {!displayRole && !loading && (
            <div className="flex items-center justify-center h-96">
              <div className="text-muted-foreground">No layout data available</div>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}
===ENDFILE
===FILE: ./src/components/admin/notices/__tests__/notice-form-modal.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))
vi.mock('../../../ui/button', () => ({ Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button> }))
vi.mock('../../../ui/input', () => ({ Input: (p: any) => <input data-testid="input" {...p} /> }))
vi.mock('../../../ui/label', () => ({ Label: ({ children }: any) => <label>{children}</label> }))
vi.mock('../../../ui/textarea', () => ({ Textarea: (p: any) => <textarea data-testid="textarea" {...p} /> }))
vi.mock('../../../ui/switch', () => ({ Switch: (p: any) => <input type="checkbox" data-testid="switch" {...p} /> }))
vi.mock('../../../ui/tabs', () => ({
  Tabs: ({ children }: any) => <div>{children}</div>,
  TabsContent: ({ children }: any) => <div>{children}</div>,
  TabsList: ({ children }: any) => <div>{children}</div>,
  TabsTrigger: ({ children }: any) => <div>{children}</div>
}))
vi.mock('../../../ui/select', () => ({
  Select: ({ children }: any) => <div>{children}</div>,
  SelectContent: ({ children }: any) => <div>{children}</div>,
  SelectItem: ({ children }: any) => <div>{children}</div>,
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: () => <span />
}))
vi.mock('../../../ui/date-time-picker', () => ({
  DateTimePicker: (p: any) => <input data-testid="date-picker" {...p} />
}))
vi.mock('lucide-react', () => ({
  Loader2: (p: any) => <span data-testid="loader" {...p} />
}))
const MockIcon = (p: any) => <span data-testid="icon" {...p} />
vi.mock('@/hooks/features/use-notice-config', () => ({
  useNoticeSeverities: () => [{ value: 'INFO', label: 'Info', icon: MockIcon }, { value: 'WARNING', label: 'Warning', icon: MockIcon }],
  useTargetRoles: () => [{ value: 'all', label: 'All' }]
}))
vi.mock('../../../../lib/utils', () => ({ cn: (...a: unknown[]) => a.filter(Boolean).join(' ') }))
vi.mock('../../../../hooks/admin/use-notice-form', () => ({
  useNoticeForm: () => ({
    formData: { title: '', message: '', severity: 'INFO', targetRoles: ['all'], isActive: true, scheduledStartAt: null, scheduledEndAt: null, adGroupIds: [] },
    setFormData: vi.fn(),
    minScheduleDate: new Date().toISOString(),
    parsedStartDate: null,
    isEndDateValid: true,
    toggleRole: vi.fn(),
    isRoleSelected: vi.fn(() => false),
    toggleAdGroup: vi.fn(),
    isAdGroupSelected: vi.fn(() => false),
    resetForm: vi.fn(),
  })
}))
vi.mock('../../../../hooks/admin/use-ad-groups-loader', () => ({
  useAdGroupsLoader: () => ({ adGroups: [], isLoadingGroups: false })
}))
vi.mock('../../../../hooks/admin/use-notice-save', () => ({
  useNoticeSave: () => ({ isSaving: false, handleSave: vi.fn() })
}))

import { NoticeFormModal } from '../notice-form-modal'

describe('NoticeFormModal', () => {
  it('renders nothing when closed', () => {
    const { container } = render(
      <NoticeFormModal open={false} onClose={vi.fn()} onSave={vi.fn()} />
    )
    expect(container.querySelector('[data-testid="dialog"]')).toBeNull()
  })

  it('renders form when open', () => {
    render(<NoticeFormModal open={true} onClose={vi.fn()} onSave={vi.fn()} />)
    expect(screen.getByTestId('dialog')).toBeInTheDocument()
  })

  it('shows create title for new notice', () => {
    render(<NoticeFormModal open={true} onClose={vi.fn()} onSave={vi.fn()} />)
    expect(screen.getByText('Create System Notice')).toBeInTheDocument()
  })

  it('shows edit title for existing notice', () => {
    const existing = { id: '1', title: 'Test', message: 'Hello', severity: 'INFO', targetRoles: ['all'], isActive: true }
    render(<NoticeFormModal open={true} onClose={vi.fn()} onSave={vi.fn()} editNotice={existing as any} />)
    expect(screen.getByText('Edit Notice')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/notices/__tests__/notice-row.test.tsx
import { describe, expect, it, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'

const mockUpdateNoticeStatus = vi.fn()

vi.mock('@/hooks/features/use-notice-config', () => ({
  useNoticeSeverities: () => [
    { value: 'INFO', label: 'Information', icon: () => <span data-testid="info-icon" /> },
    { value: 'WARNING', label: 'Warning', icon: () => <span data-testid="warning-icon" /> },
    { value: 'CRITICAL', label: 'Critical', icon: () => <span data-testid="critical-icon" /> }
  ]
}))

vi.mock('../../../../services/api/admin.service', () => ({
  adminService: {
    updateNoticeStatus: (...args: unknown[]) => mockUpdateNoticeStatus(...args)
  }
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}

vi.mock('../../../../hooks/features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

vi.mock('../../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

vi.mock('lucide-react', () => ({
  Archive: () => <span data-testid="archive-icon" />,
  Play: () => <span data-testid="play-icon" />,
  Pencil: () => <span data-testid="pencil-icon" />
}))

vi.mock('../../../ui/badge', () => ({
  Badge: ({ children, ...rest }: Record<string, unknown>) => (
    <span data-testid="badge" {...rest}>{children as React.ReactNode}</span>
  )
}))

vi.mock('../../../ui/button', () => ({
  Button: ({ children, onClick, disabled, ...rest }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} disabled={disabled as boolean} {...rest}>
      {children as React.ReactNode}
    </button>
  )
}))

vi.mock('../../../ui/table', () => ({
  TableRow: ({ children, className }: { children: React.ReactNode; className?: string }) => (
    <tr className={className}>{children}</tr>
  ),
  TableCell: ({ children, ...rest }: Record<string, unknown>) => <td {...rest}>{children as React.ReactNode}</td>
}))

import { NoticeRow } from '../notice-row'
import type { AdminPermissions } from '../../admin-layout'

const allPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

const baseNotice = {
  id: 'n1',
  title: 'Test Notice',
  message: 'This is a test notice message',
  severity: 'INFO',
  status: 'ACTIVE' as const,
  createdAt: '2025-01-15T10:00:00Z',
  broadcastToAll: false,
  targetRoles: [],
  targetAdGroups: []
}

describe('NoticeRow', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders notice title and message', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('Test Notice')).toBeInTheDocument()
    expect(screen.getByText('This is a test notice message')).toBeInTheDocument()
  })

  it('renders severity badge', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('Information')).toBeInTheDocument()
  })

  it('displays "All Users" for broadcast notices', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={{ ...baseNotice, broadcastToAll: true } as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('All Users')).toBeInTheDocument()
  })

  it('displays role count for targeted notices', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={{ ...baseNotice, targetRoles: ['voice_agent', 'chat_agent'] } as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('2 role(s)')).toBeInTheDocument()
  })

  it('displays AD group count', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={{ ...baseNotice, targetAdGroups: ['g1'] } as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('1 AD group(s)')).toBeInTheDocument()
  })

  it('displays "No targets" when empty', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('No targets')).toBeInTheDocument()
  })

  it('formats date', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('Jan 15, 2025')).toBeInTheDocument()
  })

  it('shows N/A for missing date', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={{ ...baseNotice, createdAt: undefined } as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByText('N/A')).toBeInTheDocument()
  })

  it('shows archive button for active notices', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByTestId('archive-icon')).toBeInTheDocument()
  })

  it('shows publish and edit buttons for draft notices', () => {
    const draftNotice = { ...baseNotice, status: 'DRAFT' }
    render(
      <table><tbody>
        <NoticeRow
          notice={draftNotice as any}
          onUpdate={vi.fn()}
          onEdit={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )
    expect(screen.getByTestId('play-icon')).toBeInTheDocument()
    expect(screen.getByTestId('pencil-icon')).toBeInTheDocument()
  })

  it('hides archive button without permission', () => {
    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={{ ...allPermissions, canArchiveNotice: false }}
        />
      </tbody></table>
    )
    expect(screen.queryByTestId('archive-icon')).not.toBeInTheDocument()
  })

  it('calls handleArchive on archive click', async () => {
    mockUpdateNoticeStatus.mockResolvedValue({ ...baseNotice, status: 'ARCHIVED' })
    const onUpdate = vi.fn()

    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={onUpdate}
          permissions={allPermissions}
        />
      </tbody></table>
    )

    fireEvent.click(screen.getByText('Archive'))

    await waitFor(() => {
      expect(mockUpdateNoticeStatus).toHaveBeenCalledWith('n1', 'ARCHIVED')
      expect(mockNotifications.success).toHaveBeenCalled()
    })
  })

  it('handles archive error', async () => {
    mockUpdateNoticeStatus.mockRejectedValue(new Error('Failed'))

    render(
      <table><tbody>
        <NoticeRow
          notice={baseNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )

    fireEvent.click(screen.getByText('Archive'))

    await waitFor(() => {
      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })

  it('calls handlePublish on publish click', async () => {
    mockUpdateNoticeStatus.mockResolvedValue({ ...baseNotice, status: 'ACTIVE' })
    const draftNotice = { ...baseNotice, status: 'DRAFT' }

    render(
      <table><tbody>
        <NoticeRow
          notice={draftNotice as any}
          onUpdate={vi.fn()}
          permissions={allPermissions}
        />
      </tbody></table>
    )

    fireEvent.click(screen.getByText('Publish'))

    await waitFor(() => {
      expect(mockUpdateNoticeStatus).toHaveBeenCalledWith('n1', 'ACTIVE')
      expect(mockNotifications.success).toHaveBeenCalled()
    })
  })

  it('calls onEdit when edit button clicked', () => {
    const onEdit = vi.fn()
    const draftNotice = { ...baseNotice, status: 'DRAFT' }

    render(
      <table><tbody>
        <NoticeRow
          notice={draftNotice as any}
          onUpdate={vi.fn()}
          onEdit={onEdit}
          permissions={allPermissions}
        />
      </tbody></table>
    )

    fireEvent.click(screen.getByText('Edit'))
    expect(onEdit).toHaveBeenCalledWith(draftNotice)
  })
})
===ENDFILE
===FILE: ./src/components/admin/notices/notice-form-modal.tsx
import { useState } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle
} from '../../ui/dialog'
import { Button } from '../../ui/button'
import { Input } from '../../ui/input'
import { Label } from '../../ui/label'
import { Textarea } from '../../ui/textarea'
import { Switch } from '../../ui/switch'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../../ui/tabs'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from '../../ui/select'
import { useNoticeSeverities, useTargetRoles } from '@/hooks/features/use-notice-config'
import type { AdminNoticeResponse } from '../../../services/api/admin.service'
import { Loader2 } from 'lucide-react'
import { DateTimePicker } from '../../ui/date-time-picker'
import { useAdGroupsLoader } from '../../../hooks/admin/use-ad-groups-loader'
import { useNoticeForm } from '../../../hooks/admin/use-notice-form'
import { useNoticeSave } from '../../../hooks/admin/use-notice-save'

interface NoticeFormModalProps {
  open: boolean
  onClose: () => void
  onSave: () => void
  editNotice?: AdminNoticeResponse | null
}

function AdGroupListContent({ isLoading, adGroups, isAdGroupSelected, toggleAdGroup }: Readonly<{
  isLoading: boolean
  adGroups: Array<{ groupIdentifier: string; logicalName?: string }>
  isAdGroupSelected: (args: { groupIdentifier: string }) => boolean
  toggleAdGroup: (args: { groupIdentifier: string }) => void
}>) {
  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-8">
        <Loader2 className="h-5 w-5 animate-spin text-primary" />
      </div>
    )
  }
  if (adGroups.length === 0) {
    return <p className="text-sm text-muted-foreground">No AD groups match your search.</p>
  }
  return (
    <>
      {adGroups.map(group => (
        <div key={group.groupIdentifier} className="flex items-center space-x-2">
          <Switch
            id={`adgroup-${group.groupIdentifier}`}
            checked={isAdGroupSelected({ groupIdentifier: group.groupIdentifier })}
            onCheckedChange={() => toggleAdGroup({ groupIdentifier: group.groupIdentifier })}
          />
          <Label
            htmlFor={`adgroup-${group.groupIdentifier}`}
            className="cursor-pointer text-sm"
          >
            {group.logicalName}
          </Label>
        </div>
      ))}
    </>
  )
}

function NoticeFormFooter({ editNotice, isSaving, isEndDateValid, handleSave, handleClose }: Readonly<{
  editNotice: AdminNoticeResponse | null | undefined
  isSaving: boolean
  isEndDateValid: boolean
  handleSave: (opts: { asDraft: boolean }) => void
  handleClose: () => void
}>) {
  return (
    <DialogFooter>
      <Button variant="outline" onClick={handleClose} disabled={isSaving}>
        Cancel
      </Button>
      {editNotice ? (
        <Button onClick={() => handleSave({ asDraft: true })} disabled={isSaving || !isEndDateValid}>
          {isSaving && <Loader2 className="h-4 w-4 mr-2 animate-spin text-primary" />}
          Update Notice
        </Button>
      ) : (
        <>
          <Button
            variant="outline"
            onClick={() => handleSave({ asDraft: true })}
            disabled={isSaving || !isEndDateValid}
          >
            {isSaving && <Loader2 className="h-4 w-4 mr-2 animate-spin text-primary" />}
            Save Draft
          </Button>
          <Button onClick={() => handleSave({ asDraft: false })} disabled={isSaving || !isEndDateValid}>
            {isSaving && <Loader2 className="h-4 w-4 mr-2 animate-spin text-primary" />}
            Publish Now
          </Button>
        </>
      )}
    </DialogFooter>
  )
}

export function NoticeFormModal({ open, onClose, onSave, editNotice = null }: Readonly<NoticeFormModalProps>) {
  const NOTICE_SEVERITIES = useNoticeSeverities()
  const TARGET_ROLES = useTargetRoles()
  const [activeTab, setActiveTab] = useState('details')
  const [adGroupSearch, setAdGroupSearch] = useState('')

  const {
    formData,
    setFormData,
    minScheduleDate,
    parsedStartDate,
    isEndDateValid,
    toggleRole,
    isRoleSelected,
    toggleAdGroup,
    isAdGroupSelected,
    resetForm
  } = useNoticeForm({ open, editNotice })

  const { adGroups, isLoadingGroups } = useAdGroupsLoader({
    open,
    searchTerm: adGroupSearch
  })

  const { isSaving, handleSave } = useNoticeSave({
    formData,
    editNotice,
    isEndDateValid,
    onSuccess: () => {
      handleClose()
      onSave()
    }
  })

  const handleClose = () => {
    resetForm()
    setActiveTab('details')
    setAdGroupSearch('')
    onClose()
  }

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>{editNotice ? 'Edit Notice' : 'Create System Notice'}</DialogTitle>
          <DialogDescription>
            {editNotice
              ? 'Update the notice details and save your changes.'
              : 'Create a new system notice to broadcast to users. You can save as a draft or publish immediately.'}
          </DialogDescription>
        </DialogHeader>

        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="details">Details</TabsTrigger>
            <TabsTrigger value="targeting">Targeting & Schedule</TabsTrigger>
          </TabsList>

          <TabsContent value="details" className="space-y-4 mt-4">
            <div className="space-y-2">
              <Label htmlFor="title">Title *</Label>
              <Input
                id="title"
                placeholder="Enter notice title..."
                maxLength={200}
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
              />
              <p className="text-xs text-muted-foreground">
                {`${formData.title?.length || 0}/200 characters`}
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="message">Message *</Label>
              <Textarea
                id="message"
                placeholder="Enter notice message..."
                rows={4}
                maxLength={2000}
                value={formData.message}
                onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => setFormData({ ...formData, message: e.target.value })}
              />
              <p className="text-xs text-muted-foreground">
                {`${formData.message?.length || 0}/2000 characters`}
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="severity">Severity</Label>
              <Select
                value={formData.severity}
                onValueChange={(value: string) => setFormData({ ...formData, severity: value })}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {NOTICE_SEVERITIES.map(sev => {
                    const Icon = sev.icon
                    return (
                      <SelectItem key={sev.value} value={sev.value}>
                        <div className="flex items-center gap-2">
                          <Icon className="h-4 w-4" />
                          {sev.label}
                        </div>
                      </SelectItem>
                    )
                  })}
                </SelectContent>
              </Select>
            </div>

            <div className="flex items-center space-x-2">
              <Switch
                id="requires-ack"
                checked={formData.requiresAcknowledgement}
                onCheckedChange={(checked) =>
                  setFormData({ ...formData, requiresAcknowledgement: checked })
                }
              />
              <Label htmlFor="requires-ack" className="cursor-pointer">
                Requires acknowledgement
              </Label>
            </div>
          </TabsContent>

          <TabsContent value="targeting" className="space-y-4 mt-4">
            <div className="flex items-center space-x-2">
              <Switch
                id="broadcast-all"
                checked={formData.broadcastToAll}
                onCheckedChange={(checked) =>
                  setFormData({ ...formData, broadcastToAll: checked })
                }
              />
              <Label htmlFor="broadcast-all" className="cursor-pointer">
                Broadcast to all users
              </Label>
            </div>

            {!formData.broadcastToAll && (
              <>
                <div className="space-y-2">
                  <Label>Target specific roles</Label>
                  <div className="grid grid-cols-2 gap-2">
                    {TARGET_ROLES.map(role => (
                      <div key={role.value} className="flex items-center space-x-2">
                        <Switch
                          id={`role-${role.value}`}
                          checked={isRoleSelected({ roleValue: role.value })}
                          onCheckedChange={() => toggleRole({ roleValue: role.value })}
                        />
                        <Label
                          htmlFor={`role-${role.value}`}
                          className="cursor-pointer text-sm"
                        >
                          {role.label}
                        </Label>
                      </div>
                    ))}
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Target specific AD groups</Label>
                  <Input
                    placeholder="Search AD groups by name, DN, role, or location..."
                    value={adGroupSearch}
                    onChange={(event) => setAdGroupSearch(event.target.value)}
                  />
                  <div className="max-h-48 overflow-y-auto border rounded-md p-3 space-y-2">
                    <AdGroupListContent
                      isLoading={isLoadingGroups}
                      adGroups={adGroups}
                      isAdGroupSelected={isAdGroupSelected}
                      toggleAdGroup={toggleAdGroup}
                    />
                  </div>
                </div>
              </>
            )}

            <DateTimePicker
              id="start-date"
              label="Start Date (optional)"
              value={formData.startAt}
              onChange={(value) => setFormData({ ...formData, startAt: value })}
              minDate={minScheduleDate}
            />

            <div className="space-y-2">
              <DateTimePicker
                id="end-date"
                label="End Date (optional)"
                value={formData.endAt}
                onChange={(value) => setFormData({ ...formData, endAt: value })}
                minDate={parsedStartDate ?? minScheduleDate}
                placeholder="Pick an end date and time"
              />
              {!isEndDateValid && (
                <p className="text-sm text-destructive">
                  End date and time must be after start date and time
                </p>
              )}
            </div>
          </TabsContent>
        </Tabs>

        <NoticeFormFooter
          editNotice={editNotice}
          isSaving={isSaving}
          isEndDateValid={isEndDateValid}
          handleSave={handleSave}
          handleClose={handleClose}
        />
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE
===FILE: ./src/components/admin/notices/notice-row.tsx
import { Badge } from '../../ui/badge'
import { Button } from '../../ui/button'
import { TableCell, TableRow } from '../../ui/table'
import { Archive, Play, Pencil } from 'lucide-react'
import { useNoticeSeverities } from '@/hooks/features/use-notice-config'
import { adminService, type AdminNoticeResponse } from '../../../services/api/admin.service'
import { useState } from 'react'
import { useNotifications } from '../../../hooks/features/use-notifications'
import type { AdminPermissions } from '../admin-layout'
import { cn } from '../../../lib/utils'

function getTargetsDisplay(notice: AdminNoticeResponse): string {
  if (notice.broadcastToAll) return 'All Users'
  if (notice.targetRoles && notice.targetRoles.length > 0) return `${notice.targetRoles.length} role(s)`
  if (notice.targetAdGroups && notice.targetAdGroups.length > 0) return `${notice.targetAdGroups.length} AD group(s)`
  return 'No targets'
}

function formatNoticeDate(dateString?: string): string {
  if (!dateString) return 'N/A'
  return new Date(dateString).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  })
}

const SEVERITY_STYLES: Record<string, { badge: string; dot: string; icon: string }> = {
  INFO: { badge: 'bg-white border-slate-300 text-slate-700', dot: 'bg-slate-500', icon: 'text-slate-500' },
  SUCCESS: { badge: 'bg-white border-emerald-300 text-emerald-700', dot: 'bg-emerald-500', icon: 'text-emerald-500' },
  WARNING: { badge: 'bg-white border-amber-300 text-amber-700', dot: 'bg-amber-500', icon: 'text-amber-500' },
  ERROR: { badge: 'bg-white border-orange-300 text-orange-700', dot: 'bg-orange-500', icon: 'text-orange-500' },
  CRITICAL: { badge: 'bg-white border-red-300 text-red-700', dot: 'bg-red-500', icon: 'text-red-500' }
}

interface NoticeRowProps {
  notice: AdminNoticeResponse
  onUpdate: (updatedNotice: AdminNoticeResponse) => void
  onEdit?: (notice: AdminNoticeResponse) => void
  permissions: AdminPermissions
}

function NoticeActionButtons({ notice, permissions, onEdit, onPublish, onArchive, isUpdating }: Readonly<{
  notice: AdminNoticeResponse
  permissions: AdminPermissions
  onEdit?: (notice: AdminNoticeResponse) => void
  onPublish: () => void
  onArchive: () => void
  isUpdating: boolean
}>) {
  return (
    <div className="flex items-center justify-end gap-2">
      {notice.status === 'DRAFT' && (
        <>
          {permissions.canEditNotice && onEdit && (
            <Button
              type="button"
              size="sm"
              variant="outline"
              onClick={() => onEdit(notice)}
              disabled={isUpdating}
            >
              <Pencil className="h-3 w-3 mr-1" />
              Edit
            </Button>
          )}
          {permissions.canPublishNotice && (
            <Button
              type="button"
              size="sm"
              variant="outline"
              onClick={onPublish}
              disabled={isUpdating}
            >
              <Play className="h-3 w-3 mr-1" />
              Publish
            </Button>
          )}
        </>
      )}
      {notice.status === 'ACTIVE' && permissions.canArchiveNotice && (
        <Button
          type="button"
          size="sm"
          variant="outline"
          onClick={onArchive}
          disabled={isUpdating}
        >
          <Archive className="h-3 w-3 mr-1" />
          Archive
        </Button>
      )}
    </div>
  )
}

export function NoticeRow({ notice, onUpdate, onEdit, permissions }: Readonly<NoticeRowProps>) {
  const NOTICE_SEVERITIES = useNoticeSeverities()
  const [isUpdating, setIsUpdating] = useState(false)
  const [isRemoving, setIsRemoving] = useState(false)
  const notifications = useNotifications()

  const severityConfig = NOTICE_SEVERITIES.find(s => s.value === notice.severity)
  const SeverityIcon = severityConfig?.icon

  const severityStyles = SEVERITY_STYLES

  const handleArchive = async () => {
    setIsUpdating(true)
    setIsRemoving(true)
    try {
      const updatedNotice = await adminService.updateNoticeStatus(notice.id, 'ARCHIVED')
      notifications.success({
        title: 'Notice archived',
        description: `"${notice.title}" has been archived`
      })
      // Delay the state update to allow fade-out animation
      setTimeout(() => {
        onUpdate(updatedNotice)
      }, 300)
    } catch (error) {
      setIsRemoving(false)
      notifications.error({
        title: 'Failed to archive',
        description: error instanceof Error ? error.message : 'An error occurred'
      })
    } finally {
      setIsUpdating(false)
    }
  }

  const handlePublish = async () => {
    setIsUpdating(true)
    setIsRemoving(true)
    try {
      const updatedNotice = await adminService.updateNoticeStatus(notice.id, 'ACTIVE')
      notifications.success({
        title: 'Notice published',
        description: `"${notice.title}" is now active`
      })
      // Delay the state update to allow fade-out animation
      setTimeout(() => {
        onUpdate(updatedNotice)
      }, 300)
    } catch (error) {
      setIsRemoving(false)
      notifications.error({
        title: 'Failed to publish',
        description: error instanceof Error ? error.message : 'An error occurred'
      })
    } finally {
      setIsUpdating(false)
    }
  }

  return (
    <TableRow className={`transition-opacity duration-300 ${isRemoving ? 'opacity-0' : 'opacity-100'}`}>
      <TableCell className="font-medium">
        <div className="flex flex-col">
          <span className="font-semibold">{notice.title}</span>
          <span className="text-xs text-muted-foreground line-clamp-1">
            {notice.message}
          </span>
        </div>
      </TableCell>
      <TableCell>
        <Badge
          variant="outline"
          className={cn(
            'flex items-center gap-2 w-fit px-3 py-1 rounded-full border bg-white shadow-sm text-sm font-medium',
            severityStyles[notice.severity]?.badge ?? 'border-slate-200 text-slate-700'
          )}
        >
          <span
            className={cn(
              'h-2 w-2 rounded-full',
              severityStyles[notice.severity]?.dot ?? 'bg-slate-400'
            )}
          />
          {SeverityIcon && (
            <SeverityIcon
              className={cn(
                'h-4 w-4',
                severityStyles[notice.severity]?.icon ?? 'text-slate-500'
              )}
              aria-hidden
            />
          )}
          <span>{severityConfig?.label}</span>
        </Badge>
      </TableCell>
      <TableCell className="text-sm text-muted-foreground">
        {getTargetsDisplay(notice)}
      </TableCell>
      <TableCell className="text-sm text-muted-foreground">
        {formatNoticeDate(notice.createdAt)}
      </TableCell>
      <TableCell className="text-right">
        <NoticeActionButtons
          notice={notice}
          permissions={permissions}
          onEdit={onEdit}
          onPublish={handlePublish}
          onArchive={handleArchive}
          isUpdating={isUpdating}
        />
      </TableCell>
    </TableRow>
  )
}
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/__tests__/pending-approvals-view.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../ui/tabs', () => ({
  Tabs: ({ children }: any) => <div data-testid="tabs">{children}</div>,
  TabsContent: ({ children }: any) => <div>{children}</div>,
  TabsList: ({ children }: any) => <div>{children}</div>,
  TabsTrigger: ({ children }: any) => <div data-testid="tab-trigger">{children}</div>
}))
vi.mock('../../../ui/badge', () => ({ Badge: ({ children }: any) => <span>{children}</span> }))
vi.mock('../../../ui/card', () => ({
  Card: ({ children }: any) => <div>{children}</div>,
  CardContent: ({ children }: any) => <div>{children}</div>,
  CardDescription: ({ children }: any) => <div>{children}</div>,
  CardHeader: ({ children }: any) => <div>{children}</div>
}))
vi.mock('../../../ui/toggle-group', () => ({
  ToggleGroup: ({ children }: any) => <div>{children}</div>,
  ToggleGroupItem: ({ children }: any) => <div>{children}</div>
}))
vi.mock('../../../ui/button', () => ({ Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button> }))
vi.mock('lucide-react', () => ({
  AlertCircle: (p: any) => <span {...p} />,
  Clock: (p: any) => <span {...p} />,
  RefreshCw: (p: any) => <span {...p} />
}))
vi.mock('../../../../hooks/admin/use-pending-changes', () => ({
  usePendingChanges: () => ({ data: { changes: [] }, isLoading: false, isError: false, refetch: vi.fn() }),
  useMyActivity: () => ({ data: null, isLoading: false, isError: false, refetch: vi.fn() })
}))
vi.mock('../components/approval-request-list', () => ({
  ApprovalRequestList: () => <div data-testid="request-list" />
}))
vi.mock('../components/activity-history-list', () => ({
  ActivityHistoryList: () => <div data-testid="activity-list" />
}))

import { PendingApprovalsView } from '../pending-approvals-view'

describe('PendingApprovalsView', () => {
  const permissions = { canApprove: true, canMakeChanges: true, canManageNotices: true } as any

  it('renders tabs', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    expect(screen.getByTestId('tabs')).toBeInTheDocument()
  })

  it('renders awaiting review tab trigger', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    expect(screen.getAllByText('Awaiting Review').length).toBeGreaterThan(0)
  })

  it('renders request lists', () => {
    render(<PendingApprovalsView permissions={permissions} />)
    expect(screen.getAllByTestId('request-list').length).toBeGreaterThan(0)
  })
})
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/components/__tests__/activity-history-card.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('date-fns', () => ({
  formatDistanceToNow: () => '2 hours ago',
  format: () => 'Jan 1, 2026 12:00 PM'
}))

vi.mock('lucide-react', () => ({
  AlertTriangle: (p: any) => <span data-testid="alert-triangle" {...p} />,
  CheckCircle2: (p: any) => <span data-testid="check-circle" {...p} />,
  MinusCircle: (p: any) => <span data-testid="minus-circle" {...p} />,
  Pencil: (p: any) => <span data-testid="pencil" {...p} />,
  Save: (p: any) => <span data-testid="save" {...p} />,
  XCircle: (p: any) => <span data-testid="x-circle" {...p} />
}))

vi.mock('../../../../ui/card', () => ({
  Card: ({ children }: any) => <div data-testid="card">{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>
}))

vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children }: any) => <span data-testid="badge">{children}</span>
}))

import { ActivityHistoryCard } from '../activity-history-card'

describe('ActivityHistoryCard', () => {
  const baseActivity = {
    id: '1',
    action: 'SUBMIT' as const,
    changeType: 'CONFIG_UPDATE',
    targetGroupName: 'Test Group',
    performedAt: '2026-01-01T12:00:00Z',
    criticalIndicator: false,
    performedBy: 'user1'
  }

  it('renders activity with SUBMIT action', () => {
    render(<ActivityHistoryCard activity={baseActivity as any} />)
    expect(screen.getByText('You submitted')).toBeInTheDocument()
    expect(screen.getByText('Test Group')).toBeInTheDocument()
  })

  it('renders relative time', () => {
    render(<ActivityHistoryCard activity={baseActivity as any} />)
    expect(screen.getByText('2 hours ago')).toBeInTheDocument()
  })

  it('shows Config badge for CONFIG_UPDATE', () => {
    render(<ActivityHistoryCard activity={baseActivity as any} />)
    expect(screen.getByText('Config')).toBeInTheDocument()
  })

  it('shows App badge for APP_UPDATE', () => {
    const appActivity = { ...baseActivity, changeType: 'APP_UPDATE' }
    render(<ActivityHistoryCard activity={appActivity as any} />)
    expect(screen.getByText('App')).toBeInTheDocument()
  })

  it('shows critical indicator when set', () => {
    const critical = { ...baseActivity, criticalIndicator: true }
    render(<ActivityHistoryCard activity={critical as any} />)
    expect(screen.getByText('Critical')).toBeInTheDocument()
    expect(screen.getByTestId('alert-triangle')).toBeInTheDocument()
  })

  it('does not show critical when not set', () => {
    render(<ActivityHistoryCard activity={baseActivity as any} />)
    expect(screen.queryByText('Critical')).not.toBeInTheDocument()
  })

  it('renders L1_APPROVE action', () => {
    const approved = { ...baseActivity, action: 'L1_APPROVE' as const }
    render(<ActivityHistoryCard activity={approved as any} />)
    expect(screen.getByText('You approved (L1)')).toBeInTheDocument()
  })

  it('renders REJECT action', () => {
    const rejected = { ...baseActivity, action: 'REJECT' as const }
    render(<ActivityHistoryCard activity={rejected as any} />)
    expect(screen.getByText('You rejected')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/components/__tests__/activity-history-list.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  Inbox: (p: any) => <span data-testid="inbox" {...p} />
}))

vi.mock('../../../../ui/skeleton', () => ({
  Skeleton: ({ className }: any) => <div data-testid="skeleton" className={className} />
}))

vi.mock('../../../../ui/card', () => ({
  Card: ({ children }: any) => <div data-testid="card">{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>
}))

vi.mock('../../../../ui/button', () => ({
  Button: ({ children, onClick, disabled }: any) => <button onClick={onClick} disabled={disabled}>{children}</button>
}))

vi.mock('../activity-history-card', () => ({
  ActivityHistoryCard: ({ activity }: any) => <div data-testid="activity-card">{activity.id}</div>
}))

import { ActivityHistoryList } from '../activity-history-list'

describe('ActivityHistoryList', () => {
  const activities = [
    { id: '1', action: 'SUBMIT', changeType: 'CONFIG_UPDATE', targetGroupName: 'G1', performedAt: '2026-01-01T12:00:00Z', criticalIndicator: false },
    { id: '2', action: 'L1_APPROVE', changeType: 'APP_UPDATE', targetGroupName: 'G2', performedAt: '2026-01-02T12:00:00Z', criticalIndicator: false },
  ]

  it('shows loading skeletons when loading with no data', () => {
    render(<ActivityHistoryList activities={[]} isLoading={true} totalCount={0} page={0} onLoadMore={vi.fn()} />)
    const skeletons = screen.getAllByTestId('skeleton')
    expect(skeletons.length).toBeGreaterThan(0)
  })

  it('shows empty state when no activities', () => {
    render(<ActivityHistoryList activities={[]} isLoading={false} totalCount={0} page={0} onLoadMore={vi.fn()} />)
    expect(screen.getByText('No Activity Yet')).toBeInTheDocument()
  })

  it('renders activity cards', () => {
    render(<ActivityHistoryList activities={activities as any} isLoading={false} totalCount={2} page={0} onLoadMore={vi.fn()} />)
    const cards = screen.getAllByTestId('activity-card')
    expect(cards).toHaveLength(2)
  })

  it('shows load more button when hasMore', () => {
    render(<ActivityHistoryList activities={activities as any} isLoading={false} totalCount={10} page={0} onLoadMore={vi.fn()} />)
    expect(screen.getByText('Load more')).toBeInTheDocument()
  })

  it('does not show load more when all loaded', () => {
    render(<ActivityHistoryList activities={activities as any} isLoading={false} totalCount={2} page={0} onLoadMore={vi.fn()} />)
    expect(screen.queryByText('Load more')).not.toBeInTheDocument()
  })

  it('calls onLoadMore when button clicked', () => {
    const onLoadMore = vi.fn()
    render(<ActivityHistoryList activities={activities as any} isLoading={false} totalCount={10} page={0} onLoadMore={onLoadMore} />)
    fireEvent.click(screen.getByText('Load more'))
    expect(onLoadMore).toHaveBeenCalled()
  })
})
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/components/__tests__/approval-request-card.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('date-fns', () => ({ formatDistanceToNow: () => '2 hours ago' }))
vi.mock('../../../../ui/card', () => ({
  Card: ({ children }: any) => <div data-testid="card">{children}</div>,
  CardContent: ({ children }: any) => <div>{children}</div>,
  CardHeader: ({ children }: any) => <div>{children}</div>
}))
vi.mock('../../../../ui/badge', () => ({ Badge: ({ children }: any) => <span data-testid="badge">{children}</span> }))
vi.mock('../../../../ui/button', () => ({ Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button> }))
vi.mock('../../../../ui/collapsible', () => ({
  Collapsible: ({ children }: any) => <div>{children}</div>,
  CollapsibleContent: ({ children }: any) => <div>{children}</div>,
  CollapsibleTrigger: ({ children }: any) => <div>{children}</div>
}))
vi.mock('lucide-react', () => ({
  AlertTriangle: (p: any) => <span {...p} />,
  CheckCircle2: (p: any) => <span {...p} />,
  ChevronDown: (p: any) => <span {...p} />,
  ChevronUp: (p: any) => <span {...p} />,
  Clock: (p: any) => <span {...p} />,
  User: (p: any) => <span {...p} />,
  XCircle: (p: any) => <span {...p} />,
  MinusCircle: (p: any) => <span {...p} />
}))
vi.mock('../what-changed-diff', () => ({
  WhatChangedDiff: () => <div data-testid="what-changed" />
}))
vi.mock('../../dialogs/approval-dialog', () => ({
  ApprovalDialog: () => <div data-testid="approval-dialog" />
}))
vi.mock('../../dialogs/decline-dialog', () => ({
  DeclineDialog: () => <div data-testid="decline-dialog" />
}))
vi.mock('../../dialogs/cancel-dialog', () => ({
  CancelDialog: () => <div data-testid="cancel-dialog" />
}))

import { ApprovalRequestCard } from '../approval-request-card'

const mockChange = {
  id: '1',
  targetGroupName: 'Voice Agent Group',
  status: 'PENDING_LEVEL_ONE',
  criticalIndicator: false,
  submittedBy: { displayName: 'Alice', userId: 'alice' },
  submittedDateTime: new Date().toISOString(),
  expiresDateTime: new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString(),
  matchedRules: [],
  currentState: {},
  proposedState: {},
  appsChanges: [],
  canApprove: true,
  canCancel: false,
  activityLog: []
} as any

describe('ApprovalRequestCard', () => {
  it('renders group name', () => {
    render(<ApprovalRequestCard change={mockChange} onActionComplete={vi.fn()} />)
    expect(screen.getByText('Voice Agent Group')).toBeInTheDocument()
  })

  it('renders status badge', () => {
    render(<ApprovalRequestCard change={mockChange} onActionComplete={vi.fn()} />)
    expect(screen.getAllByText('Awaiting Review').length).toBeGreaterThan(0)
  })

  it('shows critical badge when critical', () => {
    const critical = { ...mockChange, criticalIndicator: true }
    render(<ApprovalRequestCard change={critical} onActionComplete={vi.fn()} />)
    expect(screen.getByText('Requires Sr. Review')).toBeInTheDocument()
  })

  it('renders submitted time', () => {
    render(<ApprovalRequestCard change={mockChange} onActionComplete={vi.fn()} />)
    expect(screen.getByText('2 hours ago')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/components/__tests__/approval-request-list.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../ui/skeleton', () => ({ Skeleton: ({ className }: any) => <div data-testid="skeleton" className={className} /> }))
vi.mock('../../../../ui/card', () => ({
  Card: ({ children }: any) => <div data-testid="card">{children}</div>,
  CardContent: ({ children }: any) => <div>{children}</div>
}))
vi.mock('lucide-react', () => ({
  Inbox: (p: any) => <span data-testid="inbox-icon" {...p} />
}))
vi.mock('../approval-request-card', () => ({
  ApprovalRequestCard: ({ change }: any) => <div data-testid="request-card">{change.targetGroupName}</div>
}))

import { ApprovalRequestList } from '../approval-request-list'

describe('ApprovalRequestList', () => {
  it('shows skeletons when loading', () => {
    render(<ApprovalRequestList changes={[]} isLoading={true} emptyMessage="No items" onRefresh={vi.fn()} />)
    expect(screen.getAllByTestId('skeleton').length).toBeGreaterThan(0)
  })

  it('shows empty message when no changes', () => {
    render(<ApprovalRequestList changes={[]} isLoading={false} emptyMessage="Nothing here" onRefresh={vi.fn()} />)
    expect(screen.getByText('Nothing here')).toBeInTheDocument()
  })

  it('renders change cards', () => {
    const changes = [
      { id: '1', targetGroupName: 'Group A' },
      { id: '2', targetGroupName: 'Group B' }
    ] as any
    render(<ApprovalRequestList changes={changes} isLoading={false} emptyMessage="" onRefresh={vi.fn()} />)
    expect(screen.getAllByTestId('request-card')).toHaveLength(2)
    expect(screen.getByText('Group A')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/components/__tests__/what-changed-diff.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../../lib/utils', () => ({
  cn: (...a: unknown[]) => a.filter(Boolean).join(' ')
}))

vi.mock('../../../../ui/table', () => ({
  Table: ({ children }: any) => <table data-testid="diff-table">{children}</table>,
  TableBody: ({ children }: any) => <tbody>{children}</tbody>,
  TableCell: ({ children, className }: any) => <td className={className}>{children}</td>,
  TableHead: ({ children, className }: any) => <th className={className}>{children}</th>,
  TableHeader: ({ children }: any) => <thead>{children}</thead>,
  TableRow: ({ children }: any) => <tr>{children}</tr>
}))

vi.mock('../../../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('lucide-react', () => ({
  Plus: (p: any) => <span data-testid="plus-icon" {...p} />,
  Minus: (p: any) => <span data-testid="minus-icon" {...p} />,
  Check: (p: any) => <span data-testid="check-icon" {...p} />
}))

import { WhatChangedDiff } from '../what-changed-diff'

describe('WhatChangedDiff', () => {
  it('shows no changes message when states are identical', () => {
    const state = { logicalName: 'Group A', roleName: 'voice_agent' }
    render(<WhatChangedDiff currentState={state} proposedState={state} />)
    expect(screen.getByText('No changes detected')).toBeInTheDocument()
  })

  it('renders diff table when business fields differ', () => {
    const current = { logicalName: 'Old Name', roleName: 'voice_agent' }
    const proposed = { logicalName: 'New Name', roleName: 'voice_agent' }
    render(<WhatChangedDiff currentState={current} proposedState={proposed} />)
    expect(screen.getByText('What Changed')).toBeInTheDocument()
    expect(screen.getByText('Old Name')).toBeInTheDocument()
    expect(screen.getByText('New Name')).toBeInTheDocument()
  })

  it('renders app changes section when appsChanges provided', () => {
    const current = { logicalName: 'Group' }
    const proposed = { logicalName: 'Group' }
    const appsChanges = {
      added: ['banking-app'],
      removed: ['old-app'],
      unchanged: ['stable-app']
    }
    render(
      <WhatChangedDiff
        currentState={current}
        proposedState={proposed}
        appsChanges={appsChanges}
      />
    )
    expect(screen.getByText('Application Changes')).toBeInTheDocument()
    expect(screen.getByText('Banking App')).toBeInTheDocument()
    expect(screen.getByText('Old App')).toBeInTheDocument()
  })

  it('renders function changes section when functionsChanges provided', () => {
    const current = { logicalName: 'Group' }
    const proposed = { logicalName: 'Group' }
    const functionsChanges = {
      added: [{ app: 'banking-app', function: 'view-balance' }],
      removed: [{ app: 'banking-app', function: 'edit-profile' }],
      unchanged: []
    }
    render(
      <WhatChangedDiff
        currentState={current}
        proposedState={proposed}
        functionsChanges={functionsChanges}
      />
    )
    expect(screen.getByText('Function Changes')).toBeInTheDocument()
  })

  it('shows boolean changes as Enabled/Disabled', () => {
    const current = { isActive: true }
    const proposed = { isActive: false }
    render(<WhatChangedDiff currentState={current} proposedState={proposed} />)
    expect(screen.getByText('Enabled')).toBeInTheDocument()
    expect(screen.getByText('Disabled')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/components/activity-history-card.tsx
import { formatDistanceToNow, format } from 'date-fns'
import { Card, CardContent } from '../../../ui/card'
import { Badge } from '../../../ui/badge'
import {
  AlertTriangle,
  CheckCircle2,
  MinusCircle,
  Pencil,
  Save,
  XCircle
} from 'lucide-react'
import type { ActivityLogDto, AuditAction } from '../../../../types/features/approval-workflow.types'

interface ActivityHistoryCardProps {
  activity: ActivityLogDto
}

const ACTION_CONFIG: Record<AuditAction, { icon: typeof CheckCircle2; colorClass: string; label: string }> = {
  L1_APPROVE: { icon: CheckCircle2, colorClass: 'text-green-600', label: 'You approved (L1)' },
  L2_APPROVE: { icon: CheckCircle2, colorClass: 'text-green-700', label: 'You approved (L2)' },
  REJECT: { icon: XCircle, colorClass: 'text-red-600', label: 'You rejected' },
  SUBMIT: { icon: Pencil, colorClass: 'text-blue-600', label: 'You submitted' },
  CANCEL: { icon: MinusCircle, colorClass: 'text-gray-500', label: 'You withdrew' },
  DIRECT_SAVE: { icon: Save, colorClass: 'text-purple-600', label: 'You saved directly' }
}

export function ActivityHistoryCard({ activity }: Readonly<ActivityHistoryCardProps>) {
  const config = ACTION_CONFIG[activity.action] ?? ACTION_CONFIG.SUBMIT
  const Icon = config.icon

  const relativeTime = formatDistanceToNow(new Date(activity.performedAt), { addSuffix: true })
  const absoluteTime = format(new Date(activity.performedAt), 'PPpp')

  return (
    <Card>
      <CardContent className="flex items-start gap-3 p-4">
        <div className={`mt-0.5 shrink-0 ${config.colorClass}`}>
          <Icon className="h-5 w-5" />
        </div>
        <div className="flex-1 min-w-0 space-y-1">
          <div className="flex items-center gap-2 flex-wrap">
            <span className="font-medium text-sm">{config.label}</span>
            <Badge variant="outline" className="text-xs">
              {activity.changeType === 'APP_UPDATE' ? 'App' : 'Config'}
            </Badge>
            {activity.criticalIndicator && (
              <Badge variant="outline" className="bg-orange-50 text-orange-700 border-orange-200 text-xs">
                <AlertTriangle className="h-3 w-3 mr-1" />
                Critical
              </Badge>
            )}
          </div>
          <p className="text-sm text-muted-foreground truncate">
            {activity.targetGroupName}
          </p>
          <p className="text-xs text-muted-foreground" title={absoluteTime}>
            {relativeTime}
          </p>
        </div>
      </CardContent>
    </Card>
  )
}
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/components/activity-history-list.tsx
import { Skeleton } from '../../../ui/skeleton'
import { Card, CardContent } from '../../../ui/card'
import { Button } from '../../../ui/button'
import { Inbox } from 'lucide-react'
import { ActivityHistoryCard } from './activity-history-card'
import type { ActivityLogDto } from '../../../../types/features/approval-workflow.types'

interface ActivityHistoryListProps {
  activities: ActivityLogDto[]
  isLoading: boolean
  totalCount: number
  page: number
  onLoadMore: () => void
}

export function ActivityHistoryList({
  activities,
  isLoading,
  totalCount,
  page: _page,
  onLoadMore
}: Readonly<ActivityHistoryListProps>) {
  if (isLoading && activities.length === 0) {
    return (
      <div className="space-y-3">
        {['s1', 's2', 's3', 's4'].map(id => (
          <Card key={id}>
            <CardContent className="p-4">
              <div className="flex items-start gap-3">
                <Skeleton className="h-5 w-5 rounded-full shrink-0" />
                <div className="space-y-2 flex-1">
                  <Skeleton className="h-4 w-40" />
                  <Skeleton className="h-3 w-56" />
                  <Skeleton className="h-3 w-24" />
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    )
  }

  if (activities.length === 0) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-16">
          <Inbox className="h-16 w-16 text-muted-foreground/50 mb-4" />
          <p className="text-lg font-medium text-muted-foreground">
            No Activity Yet
          </p>
          <p className="text-sm text-muted-foreground/70 mt-1">
            Your approval and review activity will appear here.
          </p>
        </CardContent>
      </Card>
    )
  }

  const hasMore = activities.length < totalCount

  return (
    <div className="space-y-3">
      {activities.map((activity) => (
        <ActivityHistoryCard key={activity.id} activity={activity} />
      ))}

      {hasMore && (
        <div className="flex justify-center pt-2">
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={onLoadMore}
            disabled={isLoading}
          >
            {isLoading ? 'Refresh' : 'Load more'}
          </Button>
        </div>
      )}
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/components/approval-request-card.tsx
/**
 * Approval Request Card
 * Displays a single pending change with actions
 */

import React, { useState } from 'react'
import { formatDistanceToNow } from 'date-fns'
import { Card, CardContent, CardHeader } from '../../../ui/card'
import { Badge } from '../../../ui/badge'
import { Button } from '../../../ui/button'
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger
} from '../../../ui/collapsible'
import {
  AlertTriangle,
  CheckCircle2,
  ChevronDown,
  ChevronUp,
  Clock,
  User,
  XCircle,
  MinusCircle
} from 'lucide-react'
import { WhatChangedDiff } from './what-changed-diff'
import { ApprovalDialog } from '../dialogs/approval-dialog'
import { DeclineDialog } from '../dialogs/decline-dialog'
import { CancelDialog } from '../dialogs/cancel-dialog'
import type { PendingChangeDto } from '../../../../types/features/approval-workflow.types'

const STATUS_BADGE_CONFIG: Record<string, { className: string; icon: React.ComponentType<{ className?: string }>; label: string }> = {
  APPROVED: { className: 'bg-green-50 text-green-700 border-green-200', icon: CheckCircle2, label: 'Approved' },
  REJECTED: { className: 'bg-red-50 text-red-700 border-red-200', icon: XCircle, label: 'Rejected' },
  CANCELLED: { className: 'bg-gray-50 text-gray-600 border-gray-200', icon: MinusCircle, label: 'Cancelled' },
  EXPIRED: { className: 'bg-gray-50 text-gray-500 border-gray-200', icon: Clock, label: 'Expired' },
  PENDING_LEVEL_ONE: { className: 'bg-yellow-50 text-yellow-700 border-yellow-200', icon: Clock, label: 'Awaiting Review' },
  PENDING_LEVEL_TWO: { className: 'bg-orange-50 text-orange-700 border-orange-200', icon: Clock, label: 'Awaiting Sr. Review' }
}

const COMPLETED_STATUSES = new Set(['APPROVED', 'REJECTED', 'CANCELLED', 'EXPIRED'])

function StatusBadge({ status }: Readonly<{ status: string }>) {
  const config = STATUS_BADGE_CONFIG[status]
  if (!config) return null
  const Icon = config.icon
  return (
    <Badge variant="outline" className={config.className}>
      <Icon className="h-3 w-3 mr-1" />
      {config.label}
    </Badge>
  )
}

function isExpiringSoon(expiresDateTime: string): boolean {
  const hoursRemaining = (new Date(expiresDateTime).getTime() - Date.now()) / (1000 * 60 * 60)
  return hoursRemaining < 24
}

interface ApprovalRequestCardProps {
  change: PendingChangeDto
  onActionComplete: () => void
}

function ApprovalInfo({ approval, label }: Readonly<{
  approval: { approverName: string; approvalDateTime?: string } | null | undefined
  label: string
}>) {
  if (!approval) return null
  return (
    <p className="text-green-700">
      {`${label} Approved by ${approval.approverName}`}
      {approval.approvalDateTime && (
        <span className="text-muted-foreground ml-1">
          ({formatDistanceToNow(new Date(approval.approvalDateTime), { addSuffix: true })})
        </span>
      )}
    </p>
  )
}

function ResolutionInfo({ change }: Readonly<{ change: PendingChangeDto }>) {
  if (!COMPLETED_STATUSES.has(change.status)) return null
  return (
    <div className="rounded-md border p-3 text-sm space-y-1.5">
      {change.status === 'APPROVED' && (
        <>
          <ApprovalInfo approval={change.levelOneApproval} label="L1" />
          <ApprovalInfo approval={change.levelTwoApproval} label="L2" />
        </>
      )}
      {change.status === 'REJECTED' && (
        <>
          <p className="text-red-700">
            {`Rejected by ${change.rejectedBy?.displayName ?? 'Unknown'}`}
            {change.rejectedDateTime && (
              <span className="text-muted-foreground ml-1">
                ({formatDistanceToNow(new Date(change.rejectedDateTime), { addSuffix: true })})
              </span>
            )}
          </p>
          {change.rejectionReason && (
            <p className="text-muted-foreground">
              {`Reason: ${change.rejectionReason}`}
            </p>
          )}
        </>
      )}
      {change.status === 'CANCELLED' && (
        <p className="text-gray-600">Withdrawn by you</p>
      )}
    </div>
  )
}

function CardActionButtons({ change, onShowApprove, onShowDecline, onShowCancel }: Readonly<{
  change: PendingChangeDto
  onShowApprove: () => void
  onShowDecline: () => void
  onShowCancel: () => void
}>) {
  if (COMPLETED_STATUSES.has(change.status)) return null
  const isCritical = change.criticalIndicator
  const isLevelTwo = change.status === 'PENDING_LEVEL_TWO'
  const approveLabel = isCritical && !isLevelTwo ? 'Approve (Escalate)' : 'Approve'
  return (
    <div className="flex justify-end gap-2 pt-2 border-t">
      {change.canCancelIndicator && (
        <Button
          type="button"
          variant="outline"
          className="text-destructive border-destructive hover:bg-destructive/10"
          onClick={onShowCancel}
        >
          Withdraw Request
        </Button>
      )}
      {change.canRejectIndicator && (
        <Button type="button" variant="outline" onClick={onShowDecline}>
          Decline
        </Button>
      )}
      {change.canApproveIndicator && (
        <Button type="button" onClick={onShowApprove}>{approveLabel}</Button>
      )}
    </div>
  )
}

function SeniorReviewSection({ change }: Readonly<{ change: PendingChangeDto }>) {
  if (!change.criticalIndicator || change.matchedRules.length === 0) return null
  return (
    <div className="mt-4 p-3 bg-orange-50 border border-orange-200 rounded-md">
      <h4 className="font-medium text-orange-800 mb-2">
        Why Senior Review Required:
      </h4>
      <ul className="text-sm text-orange-700 space-y-1">
        {change.matchedRules.map((rule) => (
          <li key={`${rule.entityType}-${rule.entityKey}`} className="flex items-start gap-2">
            <span className="text-orange-500">*</span>
            <span>{rule.reason}</span>
          </li>
        ))}
      </ul>
    </div>
  )
}

export function ApprovalRequestCard({
  change,
  onActionComplete
}: Readonly<ApprovalRequestCardProps>) {
  const [isExpanded, setIsExpanded] = useState(false)
  const [showApproveDialog, setShowApproveDialog] = useState(false)
  const [showDeclineDialog, setShowDeclineDialog] = useState(false)
  const [showCancelDialog, setShowCancelDialog] = useState(false)

  const submittedAgo = formatDistanceToNow(new Date(change.submittedDateTime), {
    addSuffix: true
  })

  const isCritical = change.criticalIndicator

  return (
    <>
      <Card className="overflow-hidden">
        <CardHeader className="pb-3">
          <div className="flex items-start justify-between">
            <div className="space-y-1">
              <div className="flex items-center gap-2 flex-wrap">
                <h3 className="font-semibold text-lg">
                  {change.targetGroupName}
                </h3>
                <StatusBadge status={change.status} />
                {isCritical && (
                  <Badge
                    variant="outline"
                    className="bg-orange-50 text-orange-700 border-orange-200"
                  >
                    <AlertTriangle className="h-3 w-3 mr-1" />
                    Requires Sr. Review
                  </Badge>
                )}
              </div>
              <div className="flex items-center gap-4 text-sm text-muted-foreground">
                <span className="flex items-center gap-1">
                  <User className="h-3.5 w-3.5" />
                  {`Submitted by ${change.submittedBy.displayName}`}
                </span>
                <span className="flex items-center gap-1">
                  <Clock className="h-3.5 w-3.5" />
                  {submittedAgo}
                </span>
              </div>
            </div>
            {isExpiringSoon(change.expiresDateTime) && (
              <Badge variant="destructive" className="shrink-0">
                Expires soon
              </Badge>
            )}
          </div>
        </CardHeader>

        <CardContent className="space-y-4">
          {/* Collapsible Change Details */}
          <Collapsible open={isExpanded} onOpenChange={setIsExpanded}>
            <CollapsibleTrigger asChild>
              <Button
                variant="ghost"
                size="sm"
                className="w-full justify-between hover:bg-muted/50"
              >
                <span>
                  {isExpanded
                    ? 'Hide Changes'
                    : 'View Changes'}
                </span>
                {isExpanded ? (
                  <ChevronUp className="h-4 w-4" />
                ) : (
                  <ChevronDown className="h-4 w-4" />
                )}
              </Button>
            </CollapsibleTrigger>
            <CollapsibleContent className="mt-4">
              <WhatChangedDiff
                currentState={change.currentState}
                proposedState={change.proposedState}
                appsChanges={change.appsChanges}
                functionsChanges={change.functionsChanges}
              />

              <SeniorReviewSection change={change} />
            </CollapsibleContent>
          </Collapsible>

          {/* Resolution Info (for completed items) */}
          <ResolutionInfo change={change} />

          {/* Action Buttons (hidden for completed items) */}
          <CardActionButtons
            change={change}
            onShowApprove={() => setShowApproveDialog(true)}
            onShowDecline={() => setShowDeclineDialog(true)}
            onShowCancel={() => setShowCancelDialog(true)}
          />
        </CardContent>
      </Card>

      {/* Dialogs */}
      <ApprovalDialog
        open={showApproveDialog}
        onOpenChange={setShowApproveDialog}
        change={change}
        onSuccess={onActionComplete}
      />
      <DeclineDialog
        open={showDeclineDialog}
        onOpenChange={setShowDeclineDialog}
        change={change}
        onSuccess={onActionComplete}
      />
      <CancelDialog
        open={showCancelDialog}
        onOpenChange={setShowCancelDialog}
        change={change}
        onSuccess={onActionComplete}
      />
    </>
  )
}
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/components/approval-request-list.tsx
/**
 * Approval Request List
 * Displays a list of pending change cards
 */

import { Skeleton } from '../../../ui/skeleton'
import { Card, CardContent } from '../../../ui/card'
import { Inbox } from 'lucide-react'
import { ApprovalRequestCard } from './approval-request-card'
import type { PendingChangeDto } from '../../../../types/features/approval-workflow.types'

interface ApprovalRequestListProps {
  changes: PendingChangeDto[]
  isLoading: boolean
  emptyMessage: string
  emptyDescription?: string
  onRefresh: () => void
}

export function ApprovalRequestList({
  changes,
  isLoading,
  emptyMessage,
  emptyDescription,
  onRefresh
}: Readonly<ApprovalRequestListProps>) {
  if (isLoading) {
    return (
      <div className="space-y-4">
        {['s1', 's2', 's3'].map(id => (
          <Card key={id}>
            <CardContent className="p-6">
              <div className="space-y-3">
                <Skeleton className="h-5 w-48" />
                <Skeleton className="h-4 w-64" />
                <div className="flex gap-2 mt-4">
                  <Skeleton className="h-9 w-24" />
                  <Skeleton className="h-9 w-24" />
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    )
  }

  if (changes.length === 0) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-16">
          <Inbox className="h-16 w-16 text-muted-foreground/50 mb-4" />
          <p className="text-lg font-medium text-muted-foreground">
            {emptyMessage}
          </p>
          <p className="text-sm text-muted-foreground/70 mt-1">
            {emptyDescription || 'Changes submitted for review will appear here'}
          </p>
        </CardContent>
      </Card>
    )
  }

  return (
    <div className="space-y-4">
      {changes.map((change) => (
        <ApprovalRequestCard
          key={change.id}
          change={change}
          onActionComplete={onRefresh}
        />
      ))}
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/components/what-changed-diff.tsx
/**
 * What Changed Diff
 * Displays a comparison table of before/after configuration changes
 * Uses business-friendly labels and filters out system/metadata fields
 */

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow
} from '../../../ui/table'
import { Badge } from '../../../ui/badge'
import { cn } from '../../../../lib/utils'
import { Plus, Minus, Check } from 'lucide-react'
import type {
  AppsChangeDetail,
  FunctionsChangeDetail
} from '../../../../types/features/approval-workflow.types'

interface WhatChangedDiffProps {
  currentState: Record<string, unknown>
  proposedState: Record<string, unknown>
  appsChanges?: AppsChangeDetail | null
  functionsChanges?: FunctionsChangeDetail | null
}

interface DiffEntry {
  settingName: string
  before: string
  after: string
  category: 'business' | 'permission' | 'application'
}

// System/metadata fields that should NOT be shown to reviewers
const HIDDEN_FIELDS = new Set([
  'id',
  'createdAt',
  'updatedAt',
  'lastModified',
  'lastModifiedBy',
  'groupIdentifier',
  'adminGroupIdentifier',
  'superAdminGroupIdentifier',
  'userCount',
  'widgetAssignments',
  'featureAssignments',
  'settingsTabAssignments',
  'settingsOptionAssignments',
  'microFrontendAssignments',
  // These are complex nested objects - handle separately if needed
  'columnAssignments',
  // App/function changes are rendered in dedicated sections below the table
  'applicationChanges',
  'appFunctionChanges',
])

// Business-friendly field name mappings
const FIELD_DISPLAY_NAMES: Record<string, string> = {
  // Business Info fields
  'logicalName': 'Group Name',
  'roleName': 'Role Template',
  'region': 'Region',
  'country': 'Country',
  'market': 'Market',
  'channel': 'Channel',
  'businessUnit': 'Business Unit',
  'isActive': 'Status',
  'activeIndicator': 'Status',

  // Permission fields - columns
  'permissions.widgets.kms.articleViewer.enabledIndicator': 'Knowledge Base Access',
  'permissions.columns.kms.enabledIndicator': 'Knowledge Column',
  'permissions.columns.customer.enabledIndicator': 'Customer Column',
  'permissions.columns.transcript.enabledIndicator': 'Transcript Column',
  'permissions.columns.embeddedApps.enabledIndicator': 'Embedded Apps Column',
  'permissions.columns.chat.enabledIndicator': 'Chat Column',

  // Column state shortcuts
  'columnAssignments.chat.state': 'Chat Panel',
  'columnAssignments.kms.state': 'Knowledge Panel',
  'columnAssignments.customer.state': 'Customer Panel',
  'columnAssignments.transcript.state': 'Transcript Panel',
  'columnAssignments.embeddedApps.state': 'Banking Apps Panel',

  // Application assignments
  'embeddedApps': 'Assigned Applications',
  'applications': 'Assigned Applications',
  'appAssignments': 'Application Access',
}

function formatStatusString(value: string): string {
  if (value === 'enabled' || value === 'active') return 'Enabled'
  if (value === 'disabled' || value === 'inactive') return 'Disabled'
  return value
}

function formatArrayValue(value: unknown[]): string {
  if (value.length === 0) return 'None'
  if (typeof value[0] === 'object') return formatApplicationsArray(value)
  return value.join(', ')
}

function formatValue(value: unknown): string {
  if (value === null || value === undefined) return '-'
  if (typeof value === 'boolean') return value ? 'Enabled' : 'Disabled'
  if (Array.isArray(value)) return formatArrayValue(value)
  if (typeof value === 'object') return formatObjectValue(value as Record<string, unknown>)
  if (typeof value === 'string') return formatStatusString(value)
  if (typeof value === 'number' || typeof value === 'bigint') return String(value)
  return '-'
}

function formatObjectValue(obj: Record<string, unknown>): string {
  // Handle app assignment objects
  if ('appKey' in obj && 'functionKeys' in obj) {
    const appKey = obj.appKey as string
    const functions = obj.functionKeys as string[]
    const assigned = obj.assignedIndicator as boolean

    if (!assigned) {
      return `${formatAppName(appKey)}: Removed`
    }

    const funcList = functions?.length
      ? functions.map(f => formatFunctionName(f)).join(', ')
      : 'All functions'
    return `${formatAppName(appKey)}: ${funcList}`
  }

  // Default: show key-value pairs
  const entries = Object.entries(obj)
    .filter(([key]) => !HIDDEN_FIELDS.has(key))
    .map(([key, val]) => `${formatFieldName(key)}: ${formatValue(val)}`)

  return entries.length > 0 ? entries.join(', ') : '-'
}

function formatApplicationsArray(apps: unknown[]): string {
  const formatted = apps
    .map((app) => {
      if (typeof app === 'object' && app !== null) {
        const appObj = app as Record<string, unknown>
        const appKey = appObj.appKey as string
        const functions = appObj.functionKeys as string[]
        const assigned = appObj.assignedIndicator as boolean

        if (assigned === false) {
          return null // Skip unassigned apps
        }

        const funcList = functions?.length
          ? functions.map(f => formatFunctionName(f)).join(', ')
          : 'All functions'
        return `${formatAppName(appKey || 'Unknown')}: ${funcList}`
      }
      return String(app)
    })
    .filter(Boolean)

  return formatted.length > 0 ? formatted.join('\n') : 'None'
}

const SUFFIX_ENABLED = '.enabled'
const SUFFIX_ASSIGNED = '.assignedIndicator'
const PREFIX_EMBEDDED_APPS = 'embeddedApps.'
const SEPARATOR_FUNCTIONS = '.functions.'

function stripSuffixes(value: string): string {
  return value.replace(SUFFIX_ENABLED, '').replace(SUFFIX_ASSIGNED, '')
}

function getSettingDisplayName(path: string): string {
  // Check direct mapping first
  if (FIELD_DISPLAY_NAMES[path]) {
    return FIELD_DISPLAY_NAMES[path]
  }

  // Handle embedded app paths
  if (path.startsWith(PREFIX_EMBEDDED_APPS)) {
    const appKey = stripSuffixes(path.replace(PREFIX_EMBEDDED_APPS, ''))
    return `${formatAppName(appKey)} Application`
  }

  // Handle function paths
  if (path.includes(SEPARATOR_FUNCTIONS)) {
    const parts = path.split(SEPARATOR_FUNCTIONS)
    const funcKey = stripSuffixes(parts[1] ?? path)
    return `${formatFunctionName(funcKey)} Feature`
  }

  // Handle column assignment paths
  if (path.startsWith('columnAssignments.')) {
    const columnKey = path.split('.')[1]
    return `${formatFieldName(columnKey)} Panel`
  }

  // Fallback: format the field name nicely
  return formatFieldName(path)
}

function formatFieldName(key: string): string {
  // Remove common prefixes
  const cleanKey = key
    .replace(/^(permissions\.|businessInfo\.|columnAssignments\.|widgetAssignments\.)/, '')
    .replace(/\.(enabledIndicator|state|enabled)$/, '')

  // Convert camelCase to Title Case
  return cleanKey
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, str => str.toUpperCase())
    .trim()
}

function formatIdentifierName(key: string): string {
  return key
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ')
}

const formatAppName = formatIdentifierName
const formatFunctionName = formatIdentifierName

// Check if a field path should be hidden
function shouldHideField(path: string): boolean {
  // Check if the root key is in hidden fields
  const rootKey = path.split('.')[0]
  if (HIDDEN_FIELDS.has(rootKey)) {
    return true
  }

  // Check if the full path ends with a hidden key
  const lastKey = path.split('.').pop() || ''
  if (HIDDEN_FIELDS.has(lastKey)) {
    return true
  }

  return false
}

// Determine the category of a field for sorting
function getFieldCategory(path: string): 'business' | 'permission' | 'application' {
  if (path.startsWith('embeddedApps') || path.includes('App') || path.includes('function')) {
    return 'application'
  }
  if (path.startsWith('permissions') || path.startsWith('columnAssignments')) {
    return 'permission'
  }
  return 'business'
}

function flattenObject(
  obj: Record<string, unknown>,
  prefix = ''
): Record<string, unknown> {
  const result: Record<string, unknown> = {}

  for (const [key, value] of Object.entries(obj)) {
    const newKey = prefix ? `${prefix}.${key}` : key

    // Skip hidden fields
    if (shouldHideField(newKey)) {
      continue
    }

    if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
      Object.assign(result, flattenObject(value as Record<string, unknown>, newKey))
    } else {
      result[newKey] = value
    }
  }

  return result
}

const BUSINESS_RELEVANT_FIELDS = new Set([
  'logicalName', 'roleName', 'region', 'country', 'businessUnit', 'market', 'isActive'
])

function isBusinessRelevantKey(key: string): boolean {
  return Boolean(FIELD_DISPLAY_NAMES[key]) ||
    BUSINESS_RELEVANT_FIELDS.has(key) ||
    key.startsWith(PREFIX_EMBEDDED_APPS) ||
    key.includes(SEPARATOR_FUNCTIONS)
}

function collectRelevantKeys(
  flatCurrent: Record<string, unknown>,
  flatProposed: Record<string, unknown>
): Set<string> {
  const keys = new Set<string>(Object.keys(flatCurrent))
  for (const key of Object.keys(flatProposed)) {
    if (isBusinessRelevantKey(key)) {
      keys.add(key)
    }
  }
  return keys
}

const CATEGORY_ORDER: Record<string, number> = { business: 0, permission: 1, application: 2 }

function computeDiff(
  currentState: Record<string, unknown>,
  proposedState: Record<string, unknown>
): DiffEntry[] {
  const flatCurrent = flattenObject(currentState ?? {})
  const flatProposed = flattenObject(proposedState ?? {})
  const relevantKeys = collectRelevantKeys(flatCurrent, flatProposed)

  const diffs: DiffEntry[] = []

  for (const key of relevantKeys) {
    const currentVal = flatCurrent[key]
    const proposedVal = flatProposed[key]

    if (JSON.stringify(currentVal) === JSON.stringify(proposedVal)) continue

    const beforeStr = formatValue(currentVal)
    const afterStr = formatValue(proposedVal)
    if (beforeStr === '-' && afterStr === '-') continue

    diffs.push({
      settingName: getSettingDisplayName(key),
      before: beforeStr,
      after: afterStr,
      category: getFieldCategory(key)
    })
  }

  diffs.sort((a, b) => CATEGORY_ORDER[a.category] - CATEGORY_ORDER[b.category])
  return diffs
}

function ChangeListSection({ icon: Icon, label, iconColor, items, renderItem }: Readonly<{
  icon: React.ComponentType<{ className?: string }>
  label: string
  iconColor: string
  items: unknown[]
  renderItem: (item: unknown, idx: number) => React.ReactNode
}>) {
  if (items.length === 0) return null
  return (
    <div className="flex items-start gap-2">
      <Icon className={cn("h-4 w-4 mt-0.5 shrink-0", iconColor)} />
      <div>
        <span className={cn("text-sm font-medium", iconColor)}>{label}</span>
        <div className="flex flex-wrap gap-1.5 mt-1">
          {items.map((item, idx) => renderItem(item, idx))}
        </div>
      </div>
    </div>
  )
}

function buildSummaryParts(
  diffCount: number,
  hasAppsChanges: boolean | null | undefined,
  hasFunctionsChanges: boolean | null | undefined
): string[] {
  const parts: string[] = []
  if (diffCount > 0) {
    parts.push(diffCount === 1 ? '1 setting will be modified' : `${diffCount} settings will be modified`)
  }
  if (hasAppsChanges) parts.push('Application changes detected')
  if (hasFunctionsChanges) parts.push('Function changes detected')
  return parts
}

function computeChangeSummary(
  diffs: DiffEntry[],
  appsChanges: AppsChangeDetail | null | undefined,
  functionsChanges: FunctionsChangeDetail | null | undefined
) {
  const filteredDiffs = appsChanges
    ? diffs.filter(d => d.settingName !== 'Apps')
    : diffs
  const hasAppsChanges = Boolean(appsChanges && (appsChanges.added.length > 0 || appsChanges.removed.length > 0))
  const hasFunctionsChanges = Boolean(functionsChanges && (functionsChanges.added.length > 0 || functionsChanges.removed.length > 0))
  const totalChanges = filteredDiffs.length + (hasAppsChanges ? 1 : 0) + (hasFunctionsChanges ? 1 : 0)
  return { filteredDiffs, hasAppsChanges, hasFunctionsChanges, totalChanges }
}

function AppsChangesSection({ appsChanges }: Readonly<{ appsChanges: AppsChangeDetail }>) {
  return (
    <div className="rounded-md border">
      <div className="p-3 border-b bg-muted/30">
        <h4 className="font-medium">Application Changes</h4>
      </div>
      <div className="p-4 space-y-3">
        <ChangeListSection
          icon={Plus} label="Added:" iconColor="text-green-600"
          items={appsChanges.added}
          renderItem={(app) => (
            <Badge key={app as string} variant="outline" className="bg-green-50 text-green-700 border-green-200">
              {formatAppName(app as string)}
            </Badge>
          )}
        />
        <ChangeListSection
          icon={Minus} label="Removed:" iconColor="text-red-600"
          items={appsChanges.removed}
          renderItem={(app) => (
            <Badge key={app as string} variant="outline" className="bg-red-50 text-red-700 border-red-200">
              {formatAppName(app as string)}
            </Badge>
          )}
        />
        <ChangeListSection
          icon={Check} label="Unchanged:" iconColor="text-muted-foreground"
          items={appsChanges.unchanged}
          renderItem={(app) => (
            <Badge key={app as string} variant="outline" className="text-muted-foreground">
              {formatAppName(app as string)}
            </Badge>
          )}
        />
      </div>
    </div>
  )
}

function FunctionsChangesSection({ functionsChanges }: Readonly<{ functionsChanges: FunctionsChangeDetail }>) {
  return (
    <div className="rounded-md border">
      <div className="p-3 border-b bg-muted/30">
        <h4 className="font-medium">Function Changes</h4>
      </div>
      <div className="p-4 space-y-3">
        <ChangeListSection
          icon={Plus} label="Added:" iconColor="text-green-600"
          items={functionsChanges.added}
          renderItem={(fn) => {
            const entry = fn as { app: string; function: string }
            return (
              <Badge key={`${entry.app}-${entry.function}`} variant="outline" className="bg-green-50 text-green-700 border-green-200">
                {formatAppName(entry.app)}: {formatFunctionName(entry.function)}
              </Badge>
            )
          }}
        />
        <ChangeListSection
          icon={Minus} label="Removed:" iconColor="text-red-600"
          items={functionsChanges.removed}
          renderItem={(fn) => {
            const entry = fn as { app: string; function: string }
            return (
              <Badge key={`${entry.app}-${entry.function}`} variant="outline" className="bg-red-50 text-red-700 border-red-200">
                {formatAppName(entry.app)}: {formatFunctionName(entry.function)}
              </Badge>
            )
          }}
        />
      </div>
    </div>
  )
}

export function WhatChangedDiff({
  currentState,
  proposedState,
  appsChanges,
  functionsChanges
}: Readonly<WhatChangedDiffProps>) {
  const diffs = computeDiff(currentState, proposedState)
  const { filteredDiffs, hasAppsChanges, hasFunctionsChanges, totalChanges } = computeChangeSummary(diffs, appsChanges, functionsChanges)

  if (totalChanges === 0) {
    return (
      <div className="text-center py-4 text-muted-foreground">
        No changes detected
      </div>
    )
  }

  const summaryParts = buildSummaryParts(filteredDiffs.length, hasAppsChanges, hasFunctionsChanges)

  return (
    <div className="space-y-4">
      {/* Header */}
      <div className="rounded-md border">
        <div className="p-3 border-b bg-muted/30">
          <h4 className="font-medium">
            What Changed
          </h4>
          <p className="text-sm text-muted-foreground mt-0.5">
            {summaryParts.join('  ')}
          </p>
        </div>

        {/* Settings diff table - only shown when there are config-level diffs */}
        {filteredDiffs.length > 0 && (
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="w-[40%] whitespace-nowrap">
                  Setting
                </TableHead>
                <TableHead className="w-[30%] whitespace-nowrap">
                  Before
                </TableHead>
                <TableHead className="w-[30%] whitespace-nowrap">
                  After
                </TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredDiffs.map((diff) => (
                <TableRow key={diff.settingName}>
                  <TableCell className="font-medium align-top break-words">{diff.settingName}</TableCell>
                  <TableCell className="align-top">
                    <span
                      className={cn(
                        'inline-block max-w-full whitespace-pre-wrap break-words rounded px-2 py-0.5 text-sm leading-relaxed',
                        diff.before !== '-' && 'bg-red-50 text-red-700'
                      )}
                    >
                      {diff.before}
                    </span>
                  </TableCell>
                  <TableCell className="align-top">
                    <span
                      className={cn(
                        'inline-block max-w-full whitespace-pre-wrap break-words rounded px-2 py-0.5 text-sm leading-relaxed',
                        diff.after !== '-' && 'bg-green-50 text-green-700'
                      )}
                    >
                      {diff.after}
                    </span>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        )}
      </div>

      {/* Structured Apps Changes */}
      {hasAppsChanges && appsChanges && (
        <AppsChangesSection appsChanges={appsChanges} />
      )}

      {/* Structured Functions Changes */}
      {hasFunctionsChanges && functionsChanges && (
        <FunctionsChangesSection functionsChanges={functionsChanges} />
      )}
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/dialogs/__tests__/approval-dialog.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))
vi.mock('../../../../ui/button', () => ({ Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button> }))
vi.mock('../../../../ui/textarea', () => ({ Textarea: (p: any) => <textarea data-testid="textarea" {...p} /> }))
vi.mock('../../../../ui/label', () => ({ Label: ({ children }: any) => <label>{children}</label> }))
vi.mock('../../../../ui/alert', () => ({
  Alert: ({ children }: any) => <div data-testid="alert">{children}</div>,
  AlertDescription: ({ children }: any) => <div>{children}</div>
}))
vi.mock('lucide-react', () => ({
  AlertTriangle: (p: any) => <span {...p} />,
  Loader2: (p: any) => <span {...p} />
}))
vi.mock('../../../../../hooks/admin/use-pending-changes', () => ({
  useApproveChange: () => ({ mutateAsync: vi.fn(), isPending: false })
}))
vi.mock('../../../../../hooks/common/use-toast', () => ({
  useToast: () => ({ notify: vi.fn() })
}))

import { ApprovalDialog } from '../approval-dialog'

const mockChange = {
  id: '1',
  targetGroupName: 'Test Group',
  criticalIndicator: false,
  status: 'PENDING_LEVEL_ONE',
  submittedBy: { displayName: 'John Doe' },
  matchedRules: []
} as any

describe('ApprovalDialog', () => {
  it('renders nothing when closed', () => {
    const { container } = render(
      <ApprovalDialog open={false} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />
    )
    expect(container.querySelector('[data-testid="dialog"]')).toBeNull()
  })

  it('renders dialog when open', () => {
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByTestId('dialog')).toBeInTheDocument()
    expect(screen.getByRole('heading', { name: 'Confirm Approval' })).toBeInTheDocument()
  })

  it('shows group name and submitter', () => {
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByText('Test Group')).toBeInTheDocument()
    expect(screen.getByText('John Doe')).toBeInTheDocument()
  })

  it('shows escalation title for critical changes', () => {
    const critical = { ...mockChange, criticalIndicator: true }
    render(<ApprovalDialog open={true} onOpenChange={vi.fn()} change={critical} onSuccess={vi.fn()} />)
    expect(screen.getByRole('heading', { name: 'Approve and Escalate' })).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/dialogs/__tests__/cancel-dialog.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))
vi.mock('../../../../ui/button', () => ({ Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button> }))
vi.mock('lucide-react', () => ({
  AlertTriangle: (p: any) => <span {...p} />,
  Loader2: (p: any) => <span {...p} />
}))
vi.mock('../../../../../hooks/admin/use-pending-changes', () => ({
  useCancelChange: () => ({ mutateAsync: vi.fn(), isPending: false })
}))
vi.mock('../../../../../hooks/common/use-toast', () => ({
  useToast: () => ({ notify: vi.fn() })
}))

import { CancelDialog } from '../cancel-dialog'

const mockChange = {
  id: '1',
  targetGroupName: 'Test Group',
  submittedBy: { displayName: 'Bob Smith' }
} as any

describe('CancelDialog', () => {
  it('renders nothing when closed', () => {
    const { container } = render(
      <CancelDialog open={false} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />
    )
    expect(container.querySelector('[data-testid="dialog"]')).toBeNull()
  })

  it('renders dialog when open', () => {
    render(<CancelDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByTestId('dialog')).toBeInTheDocument()
    expect(screen.getByRole('heading', { name: 'Withdraw Request' })).toBeInTheDocument()
  })

  it('shows group name', () => {
    render(<CancelDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByText('Test Group')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/dialogs/__tests__/decline-dialog.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../../ui/dialog', () => ({
  Dialog: ({ children, open }: any) => open ? <div data-testid="dialog">{children}</div> : null,
  DialogContent: ({ children }: any) => <div>{children}</div>,
  DialogDescription: ({ children }: any) => <p>{children}</p>,
  DialogFooter: ({ children }: any) => <div>{children}</div>,
  DialogHeader: ({ children }: any) => <div>{children}</div>,
  DialogTitle: ({ children }: any) => <h2>{children}</h2>
}))
vi.mock('../../../../ui/button', () => ({ Button: ({ children, onClick }: any) => <button onClick={onClick}>{children}</button> }))
vi.mock('../../../../ui/textarea', () => ({ Textarea: (p: any) => <textarea data-testid="textarea" {...p} /> }))
vi.mock('../../../../ui/label', () => ({ Label: ({ children }: any) => <label>{children}</label> }))
vi.mock('lucide-react', () => ({ Loader2: (p: any) => <span {...p} /> }))
vi.mock('../../../../../hooks/admin/use-pending-changes', () => ({
  useRejectChange: () => ({ mutateAsync: vi.fn(), isPending: false })
}))
vi.mock('../../../../../hooks/common/use-toast', () => ({
  useToast: () => ({ notify: vi.fn() })
}))

import { DeclineDialog } from '../decline-dialog'

const mockChange = {
  id: '1',
  targetGroupName: 'Test Group',
  submittedBy: { displayName: 'Jane Doe' }
} as any

describe('DeclineDialog', () => {
  it('renders nothing when closed', () => {
    const { container } = render(
      <DeclineDialog open={false} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />
    )
    expect(container.querySelector('[data-testid="dialog"]')).toBeNull()
  })

  it('renders dialog when open', () => {
    render(<DeclineDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByTestId('dialog')).toBeInTheDocument()
    expect(screen.getByRole('heading', { name: 'Decline Request' })).toBeInTheDocument()
  })

  it('shows group name and submitter', () => {
    render(<DeclineDialog open={true} onOpenChange={vi.fn()} change={mockChange} onSuccess={vi.fn()} />)
    expect(screen.getByText('Test Group')).toBeInTheDocument()
    expect(screen.getByText('Jane Doe')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/dialogs/approval-dialog.tsx
/**
 * Approval Dialog
 * Confirmation dialog for approving a pending change
 */

import { useState } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle
} from '../../../ui/dialog'
import { Button } from '../../../ui/button'
import { Textarea } from '../../../ui/textarea'
import { Label } from '../../../ui/label'
import { AlertTriangle, Loader2 } from 'lucide-react'
import { Alert, AlertDescription } from '../../../ui/alert'
import { useApproveChange } from '../../../../hooks/admin/use-pending-changes'
import { useToast } from '../../../../hooks/common/use-toast'
import type { PendingChangeDto } from '../../../../types/features/approval-workflow.types'

interface ApprovalDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  change: PendingChangeDto
  onSuccess: () => void
}

export function ApprovalDialog({
  open,
  onOpenChange,
  change,
  onSuccess
}: Readonly<ApprovalDialogProps>) {
  const { notify } = useToast()
  const [comment, setComment] = useState('')

  const approveMutation = useApproveChange()

  const isCritical = change.criticalIndicator
  const isLevelTwo = change.status === 'PENDING_LEVEL_TWO'
  const willEscalate = isCritical && !isLevelTwo

  const handleApprove = async () => {
    try {
      const result = await approveMutation.mutateAsync({
        changeId: change.id,
        request: comment.trim() ? { comment: comment.trim() } : undefined
      })

      if (result.newStatus === 'PENDING_LEVEL_TWO') {
        notify({
          title: 'Changes Escalated',
          description: 'The changes have been forwarded to a Senior Reviewer for final approval.',
          variant: 'success'
        })
      } else {
        notify({
          title: 'Changes Approved',
          description: 'The configuration changes have been applied successfully.',
          variant: 'success'
        })
      }

      onOpenChange(false)
      setComment('')
      onSuccess()
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'An unexpected error occurred. Please try again.'

      if (errorMessage.toLowerCase().includes('self-approval')) {
        notify({
          title: 'Cannot Approve',
          description: 'You cannot approve changes you submitted. Another reviewer must approve this request.',
          variant: 'error'
        })
      } else {
        notify({
          title: 'Error',
          description: errorMessage,
          variant: 'error'
        })
      }
    }
  }

  const handleClose = () => {
    if (!approveMutation.isPending) {
      onOpenChange(false)
      setComment('')
    }
  }

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>
            {willEscalate
              ? 'Approve and Escalate'
              : 'Confirm Approval'}
          </DialogTitle>
          <DialogDescription>
            {willEscalate
              ? 'This change requires Senior Reviewer approval. Your approval will forward this to a Senior Reviewer for final review.'
              : 'You are about to approve configuration changes. These changes will take effect immediately after approval.'}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* Change Info */}
          <div className="text-sm space-y-1">
            <div>
              <span className="text-muted-foreground">
                Group:
              </span>{' '}
              <span className="font-medium">{change.targetGroupName}</span>
            </div>
            <div>
              <span className="text-muted-foreground">
                Submitted by:
              </span>{' '}
              <span className="font-medium">
                {change.submittedBy.displayName}
              </span>
            </div>
          </div>

          {/* Escalation Warning */}
          {willEscalate && (
            <Alert className="bg-orange-50 border-orange-200">
              <AlertTriangle className="h-4 w-4 text-orange-600" />
              <AlertDescription className="text-orange-800">
                Senior Review required because:
                {change.matchedRules.length > 0 && (
                  <ul className="mt-2 text-sm space-y-1">
                    {change.matchedRules.map((rule) => (
                      <li key={`${rule.entityType}-${rule.entityKey}`}>* {rule.reason}</li>
                    ))}
                  </ul>
                )}
              </AlertDescription>
            </Alert>
          )}

          {/* Comment */}
          <div className="space-y-2">
            <Label htmlFor="comment">
              Add a note (optional)
            </Label>
            <Textarea
              id="comment"
              placeholder="Reviewed and approved. Changes align with team requirements."
              value={comment}
              onChange={(e) => setComment(e.target.value)}
              rows={3}
            />
          </div>
        </div>

        <DialogFooter>
          <Button
            variant="outline"
            onClick={handleClose}
            disabled={approveMutation.isPending}
          >
            Cancel
          </Button>
          <Button
            onClick={handleApprove}
            disabled={approveMutation.isPending}
          >
            {approveMutation.isPending && (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            )}
            {willEscalate
              ? 'Approve and Escalate'
              : 'Confirm Approval'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/dialogs/cancel-dialog.tsx
/**
 * Cancel Dialog
 * Confirmation dialog for makers to withdraw their own pending submissions
 */

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle
} from '../../../ui/dialog'
import { Button } from '../../../ui/button'
import { AlertTriangle, Loader2 } from 'lucide-react'
import { useCancelChange } from '../../../../hooks/admin/use-pending-changes'
import { useToast } from '../../../../hooks/common/use-toast'
import type { PendingChangeDto } from '../../../../types/features/approval-workflow.types'

interface CancelDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  change: PendingChangeDto
  onSuccess: () => void
}

export function CancelDialog({
  open,
  onOpenChange,
  change,
  onSuccess
}: Readonly<CancelDialogProps>) {
  const { notify } = useToast()

  const cancelMutation = useCancelChange()

  const handleCancel = async () => {
    try {
      await cancelMutation.mutateAsync(change.id)

      notify({
        title: 'Request Withdrawn',
        description: 'Your pending change has been withdrawn.',
        variant: 'success'
      })

      onOpenChange(false)
      onSuccess()
    } catch (err) {
      const errorMessage =
        err instanceof Error ? err.message : 'An unexpected error occurred. Please try again.'
      notify({
        title: 'Error',
        description: errorMessage,
        variant: 'error'
      })
    }
  }

  const handleClose = () => {
    if (!cancelMutation.isPending) {
      onOpenChange(false)
    }
  }

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Withdraw Request</DialogTitle>
          <DialogDescription>
            Are you sure you want to withdraw this pending change?
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          <div className="text-sm space-y-1">
            <div>
              <span className="text-muted-foreground">
                Group:
              </span>{' '}
              <span className="font-medium">{change.targetGroupName}</span>
            </div>
            <div>
              <span className="text-muted-foreground">
                Submitted by:
              </span>{' '}
              <span className="font-medium">
                {change.submittedBy.displayName}
              </span>
            </div>
          </div>

          <div className="flex items-start gap-2 p-3 bg-amber-50 border border-amber-200 rounded-md">
            <AlertTriangle className="h-4 w-4 text-amber-600 mt-0.5 shrink-0" />
            <p className="text-sm text-amber-800">
              This will remove the change from the approval queue. This cannot be undone.
            </p>
          </div>
        </div>

        <DialogFooter>
          <Button
            type="button"
            variant="outline"
            onClick={handleClose}
            disabled={cancelMutation.isPending}
          >
            Cancel
          </Button>
          <Button
            type="button"
            variant="destructive"
            onClick={handleCancel}
            disabled={cancelMutation.isPending}
          >
            {cancelMutation.isPending && (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            )}
            Withdraw Request
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/dialogs/decline-dialog.tsx
/**
 * Decline Dialog
 * Confirmation dialog for declining a pending change
 */

import { useState } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle
} from '../../../ui/dialog'
import { Button } from '../../../ui/button'
import { Textarea } from '../../../ui/textarea'
import { Label } from '../../../ui/label'
import { Loader2 } from 'lucide-react'
import { useRejectChange } from '../../../../hooks/admin/use-pending-changes'
import { useToast } from '../../../../hooks/common/use-toast'
import type { PendingChangeDto } from '../../../../types/features/approval-workflow.types'

interface DeclineDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  change: PendingChangeDto
  onSuccess: () => void
}

export function DeclineDialog({
  open,
  onOpenChange,
  change,
  onSuccess
}: Readonly<DeclineDialogProps>) {
  const { notify } = useToast()
  const [reason, setReason] = useState('')
  const [error, setError] = useState('')

  const rejectMutation = useRejectChange()

  const isReasonValid = reason.trim().length >= 10

  const handleDecline = async () => {
    if (!isReasonValid) {
      setError('Please provide a reason (minimum 10 characters)')
      return
    }

    setError('')

    try {
      await rejectMutation.mutateAsync({
        changeId: change.id,
        request: { rejectionReason: reason.trim() }
      })

      notify({
        title: 'Request Declined',
        description: `Your feedback has been sent to ${change.submittedBy.displayName}.`,
        variant: 'success'
      })

      onOpenChange(false)
      setReason('')
      onSuccess()
    } catch (err) {
      const errorMessage =
        err instanceof Error ? err.message : 'An unexpected error occurred. Please try again.'
      notify({
        title: 'Error',
        description: errorMessage,
        variant: 'error'
      })
    }
  }

  const handleClose = () => {
    if (!rejectMutation.isPending) {
      onOpenChange(false)
      setReason('')
      setError('')
    }
  }

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Decline Request</DialogTitle>
          <DialogDescription>
            Please provide feedback for declining this change request.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* Change Info */}
          <div className="text-sm space-y-1">
            <div>
              <span className="text-muted-foreground">
                Group:
              </span>{' '}
              <span className="font-medium">{change.targetGroupName}</span>
            </div>
            <div>
              <span className="text-muted-foreground">
                Submitted by:
              </span>{' '}
              <span className="font-medium">
                {change.submittedBy.displayName}
              </span>
            </div>
          </div>

          {/* Reason */}
          <div className="space-y-2">
            <Label htmlFor="reason">
              Reason for declining *
            </Label>
            <Textarea
              id="reason"
              placeholder="Please explain why this change cannot be approved..."
              value={reason}
              onChange={(e) => {
                setReason(e.target.value)
                if (error && e.target.value.trim().length >= 10) {
                  setError('')
                }
              }}
              rows={4}
              className={error ? 'border-destructive' : ''}
            />
            {error && (
              <p className="text-sm text-destructive">{error}</p>
            )}
            <p className="text-xs text-muted-foreground">
              {`Your feedback will be shared with ${change.submittedBy.displayName}`}
            </p>
          </div>
        </div>

        <DialogFooter>
          <Button
            variant="outline"
            onClick={handleClose}
            disabled={rejectMutation.isPending}
          >
            Cancel
          </Button>
          <Button
            variant="destructive"
            onClick={handleDecline}
            disabled={rejectMutation.isPending || !isReasonValid}
          >
            {rejectMutation.isPending && (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            )}
            Decline Request
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/index.ts
export { PendingApprovalsView } from './pending-approvals-view'
===ENDFILE
===FILE: ./src/components/admin/pending-approvals-view/pending-approvals-view.tsx
/**
 * Pending Approvals View
 * Main view for reviewing and approving configuration changes
 */

import { useEffect, useMemo, useState } from 'react'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../../ui/tabs'
import { Badge } from '../../ui/badge'
import { Card, CardContent, CardDescription, CardHeader } from '../../ui/card'
import { ToggleGroup, ToggleGroupItem } from '../../ui/toggle-group'
import { AlertCircle, Clock, RefreshCw } from 'lucide-react'
import { Button } from '../../ui/button'
import { useMyActivity, usePendingChanges } from '../../../hooks/admin/use-pending-changes'
import { ApprovalRequestList } from './components/approval-request-list'
import { ActivityHistoryList } from './components/activity-history-list'
import type { AdminPermissions } from '../admin-layout'
import type {
  ActivityActionFilter,
  ActivityLogDto,
  ActivityTimeRange,
  PendingChangeStatus
} from '../../../types/features/approval-workflow.types'

type TabValue = 'level-one' | 'level-two' | 'my-submissions' | 'my-activity'
const TAB_MY_SUBMISSIONS: TabValue = 'my-submissions'
const TAB_MY_ACTIVITY: TabValue = 'my-activity'
const TAB_LEVEL_ONE: TabValue = 'level-one'
type SubmissionFilter = 'all' | 'pending' | 'approved' | 'rejected' | 'cancelled'

function TabBadge({ count, className, visible = true }: Readonly<{ count: number; className: string; visible?: boolean }>) {
  if (!visible || count <= 0) return null
  return (
    <Badge variant="secondary" className={`${className} ml-1`}>
      {count}
    </Badge>
  )
}

function TabContentWithError({ isError, onRetry, children }: Readonly<{ isError: boolean; onRetry: () => void; children: React.ReactNode }>) {
  if (isError) return <ErrorCard onRetry={onRetry} />
  return <>{children}</>
}

function handleTabValueChange(
  value: string,
  setActiveTab: (v: TabValue) => void,
  setSubmissionFilter: (v: SubmissionFilter) => void,
  setActivityFilter: (v: ActivityActionFilter) => void
) {
  setActiveTab(value as TabValue)
  if (value !== 'my-submissions') setSubmissionFilter('all')
  if (value !== 'my-activity') setActivityFilter('all')
}

function getActivityTotalCount(filter: ActivityActionFilter, dataCount: number | undefined, filteredCount: number): number {
  if (filter === 'all') return dataCount ?? filteredCount
  return filteredCount
}

interface PendingApprovalsViewProps {
  permissions: AdminPermissions
}

function ErrorCard({ onRetry }: Readonly<{ onRetry: () => void }>) {
  return (
    <Card>
      <CardContent className="flex flex-col items-center justify-center py-12">
        <AlertCircle className="h-12 w-12 text-destructive mb-4" />
        <p className="text-muted-foreground mb-4">Unable to load pending changes</p>
        <Button variant="outline" onClick={onRetry}>
          <RefreshCw className="h-4 w-4 mr-2" />
          Retry
        </Button>
      </CardContent>
    </Card>
  )
}

export function PendingApprovalsView({ permissions: _permissions }: Readonly<PendingApprovalsViewProps>) {
  const [activeTab, setActiveTab] = useState<TabValue>(TAB_LEVEL_ONE)
  const [submissionFilter, setSubmissionFilter] = useState<SubmissionFilter>('all')
  const [activityFilter, setActivityFilter] = useState<ActivityActionFilter>('all')
  const [activityTimeRange, setActivityTimeRange] = useState<ActivityTimeRange>('all')
  const [activityPage, setActivityPage] = useState(1)
  const [activityItems, setActivityItems] = useState<ActivityLogDto[]>([])

  const statusMap: Record<string, PendingChangeStatus[]> = {
    'level-one': ['PENDING_LEVEL_ONE'],
    'level-two': ['PENDING_LEVEL_TWO'],
    'my-submissions': ['MY_SUBMISSIONS']
  }

  const {
    data: pendingData,
    isLoading,
    isError,
    refetch
  } = usePendingChanges({ status: statusMap[activeTab] ?? statusMap[TAB_LEVEL_ONE], limit: 50 })

  const {
    data: activityData,
    isLoading: isActivityLoading,
    isError: isActivityError,
    refetch: refetchActivity
  } = useMyActivity(activityPage, activityTimeRange, activeTab === TAB_MY_ACTIVITY)

  useEffect(() => {
    if (activeTab !== TAB_MY_ACTIVITY || !activityData) {
      return
    }

    setActivityItems((previousItems) => {
      if (activityPage === 1) {
        return activityData.items
      }

      const existingIds = new Set(previousItems.map((item) => item.id))
      const nextItems = activityData.items.filter((item) => !existingIds.has(item.id))
      return [...previousItems, ...nextItems]
    })
  }, [activityData, activityPage, activeTab])

  useEffect(() => {
    setActivityPage(1)
    setActivityItems([])
  }, [activityTimeRange])

  const levelOnePending = pendingData?.counts?.pendingLevelOne ?? 0
  const levelTwoPending = pendingData?.counts?.pendingLevelTwo ?? 0
  const mySubmissionsCount = pendingData?.counts?.mySubmissions ?? pendingData?.items?.length ?? 0
  const totalPending = levelOnePending + levelTwoPending

  const filteredSubmissions = useMemo(() => {
    const items = pendingData?.items ?? []
    if (activeTab !== TAB_MY_SUBMISSIONS || submissionFilter === 'all') {
      return items
    }

    const statusFilters: Record<SubmissionFilter, string[]> = {
      all: [],
      pending: ['PENDING_LEVEL_ONE', 'PENDING_LEVEL_TWO'],
      approved: ['APPROVED'],
      rejected: ['REJECTED'],
      cancelled: ['CANCELLED']
    }

    const allowedStatuses = statusFilters[submissionFilter]
    return items.filter(item => allowedStatuses.includes(item.status))
  }, [pendingData?.items, activeTab, submissionFilter])

  const filteredActivities = useMemo(() => {
    if (activityFilter === 'all') {
      return activityItems
    }

    const actionFilters: Record<Exclude<ActivityActionFilter, 'all'>, Array<ActivityLogDto['action']>> = {
      approvals: ['L1_APPROVE', 'L2_APPROVE'],
      rejections: ['REJECT'],
      submissions: ['SUBMIT', 'CANCEL'],
      direct_saves: ['DIRECT_SAVE']
    }

    return activityItems.filter((activity) => actionFilters[activityFilter].includes(activity.action))
  }, [activityFilter, activityItems])

  const canLoadMoreActivity = activityItems.length < (activityData?.totalCount ?? 0)

  const handleLoadMoreActivity = () => {
    if (!canLoadMoreActivity || isActivityLoading) {
      return
    }
    setActivityPage((currentPage) => currentPage + 1)
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-start justify-between">
        <div>
          <h1 className="text-2xl font-semibold tracking-tight">
            Pending Approvals
          </h1>
          <p className="text-muted-foreground mt-1">
            Review and approve configuration changes
          </p>
        </div>
        <Button
          variant="outline"
        size="sm"
        onClick={() => refetch()}
        disabled={isLoading}
      >
          <RefreshCw className={`h-4 w-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} />
          Refresh
        </Button>
      </div>

      {/* Stats Cards */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardHeader className="pb-2">
            <CardDescription>Total Pending</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <Clock className="h-5 w-5 text-muted-foreground" />
              <span className="text-2xl font-bold">{totalPending}</span>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="pb-2">
            <CardDescription>Awaiting Review</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <Badge variant="secondary" className="bg-yellow-100 text-yellow-800">
                {levelOnePending}
              </Badge>
              <span className="text-sm text-muted-foreground">
                Level 1 approvals
              </span>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="pb-2">
            <CardDescription>Awaiting Senior Review</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <Badge variant="secondary" className="bg-orange-100 text-orange-800">
                {levelTwoPending}
              </Badge>
              <span className="text-sm text-muted-foreground">
                Level 2 approvals
              </span>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Tabs */}
      <Tabs
        value={activeTab}
        onValueChange={(v) => handleTabValueChange(v, setActiveTab, setSubmissionFilter, setActivityFilter)}
      >
        <TabsList className="grid w-full grid-cols-4 max-w-4xl">
          <TabsTrigger value="level-one" className="flex items-center gap-2">
            Awaiting Review
            <TabBadge count={levelOnePending} className="bg-yellow-100 text-yellow-800" />
          </TabsTrigger>
          <TabsTrigger value="level-two" className="flex items-center gap-2">
            Awaiting Sr. Review
            <TabBadge count={levelTwoPending} className="bg-orange-100 text-orange-800" />
          </TabsTrigger>
          <TabsTrigger value="my-submissions" className="flex items-center gap-2">
            My Submissions
            <TabBadge count={mySubmissionsCount} className="bg-blue-100 text-blue-800" visible={activeTab === TAB_MY_SUBMISSIONS} />
          </TabsTrigger>
          <TabsTrigger value="my-activity" className="flex items-center gap-2">
            My Activity
          </TabsTrigger>
        </TabsList>

        <TabsContent value="level-one" className="mt-6">
          <TabContentWithError isError={isError} onRetry={() => refetch()}>
            <ApprovalRequestList
              changes={pendingData?.items ?? []}
              isLoading={isLoading}
              emptyMessage="No changes awaiting review"
              onRefresh={() => refetch()}
            />
          </TabContentWithError>
        </TabsContent>

        <TabsContent value="level-two" className="mt-6">
          <TabContentWithError isError={isError} onRetry={() => refetch()}>
            <ApprovalRequestList
              changes={pendingData?.items ?? []}
              isLoading={isLoading}
              emptyMessage="No changes awaiting senior review"
              onRefresh={() => refetch()}
            />
          </TabContentWithError>
        </TabsContent>

        <TabsContent value="my-submissions" className="mt-6">
          <TabContentWithError isError={isError} onRetry={() => refetch()}>
            <div className="space-y-4">
              {/* Sub-filter chips */}
              <ToggleGroup
                type="single"
                value={submissionFilter}
                onValueChange={(v) => {
                  if (v) setSubmissionFilter(v as SubmissionFilter)
                }}
                className="justify-start"
              >
                <ToggleGroupItem value="all" aria-label="All submissions" className="text-xs px-3">
                  All
                </ToggleGroupItem>
                <ToggleGroupItem value="pending" aria-label="Pending submissions" className="text-xs px-3">
                  Pending
                </ToggleGroupItem>
                <ToggleGroupItem value="approved" aria-label="Approved submissions" className="text-xs px-3">
                  Approved
                </ToggleGroupItem>
                <ToggleGroupItem value="rejected" aria-label="Rejected submissions" className="text-xs px-3">
                  Rejected
                </ToggleGroupItem>
                <ToggleGroupItem value="cancelled" aria-label="Cancelled submissions" className="text-xs px-3">
                  Cancelled
                </ToggleGroupItem>
              </ToggleGroup>

              <ApprovalRequestList
                changes={filteredSubmissions}
                isLoading={isLoading}
                emptyMessage="No Pending Submissions"
                emptyDescription="You have no pending change requests."
                onRefresh={() => refetch()}
              />
            </div>
          </TabContentWithError>
        </TabsContent>

        <TabsContent value="my-activity" className="mt-6">
          <div className="space-y-4">
            <div className="flex flex-wrap items-center gap-3">
              <ToggleGroup
                type="single"
                value={activityFilter}
                onValueChange={(v) => {
                  if (v) setActivityFilter(v as ActivityActionFilter)
                }}
                className="justify-start"
              >
                <ToggleGroupItem value="all" className="text-xs px-3">
                  All
                </ToggleGroupItem>
                <ToggleGroupItem value="approvals" className="text-xs px-3">
                  Approvals
                </ToggleGroupItem>
                <ToggleGroupItem value="rejections" className="text-xs px-3">
                  Rejections
                </ToggleGroupItem>
                <ToggleGroupItem value="submissions" className="text-xs px-3">
                  Submissions
                </ToggleGroupItem>
                <ToggleGroupItem value="direct_saves" className="text-xs px-3">
                  Direct Saves
                </ToggleGroupItem>
              </ToggleGroup>

              <ToggleGroup
                type="single"
                value={activityTimeRange}
                onValueChange={(v) => {
                  if (v) setActivityTimeRange(v as ActivityTimeRange)
                }}
                className="justify-start"
              >
                <ToggleGroupItem value="all" className="text-xs px-3">
                  All Time
                </ToggleGroupItem>
                <ToggleGroupItem value="today" className="text-xs px-3">
                  Today
                </ToggleGroupItem>
                <ToggleGroupItem value="week" className="text-xs px-3">
                  This Week
                </ToggleGroupItem>
                <ToggleGroupItem value="month" className="text-xs px-3">
                  This Month
                </ToggleGroupItem>
              </ToggleGroup>
            </div>

            <TabContentWithError isError={isActivityError} onRetry={() => refetchActivity()}>
              <ActivityHistoryList
                activities={filteredActivities}
                isLoading={isActivityLoading}
                totalCount={getActivityTotalCount(activityFilter, activityData?.totalCount, filteredActivities.length)}
                page={activityPage}
                onLoadMore={handleLoadMoreActivity}
              />
            </TabContentWithError>
          </div>
        </TabsContent>

      </Tabs>
    </div>
  )
}

export { PendingApprovalsView as default }
===ENDFILE
===FILE: ./src/components/admin/tabs/__tests__/applications-tab.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  Search: (p: any) => <span {...p} />, Package: (p: any) => <span {...p} />, Filter: (p: any) => <span {...p} />
}))
vi.mock('../../../ui/card', () => ({ Card: ({ children }: any) => <div>{children}</div>, CardContent: ({ children }: any) => <div>{children}</div> }))
vi.mock('../../../ui/input', () => ({ Input: (p: any) => <input {...p} /> }))
vi.mock('../../../ui/label', () => ({ Label: ({ children }: any) => <label>{children}</label> }))
vi.mock('../../../ui/badge', () => ({ Badge: ({ children }: any) => <span>{children}</span> }))
vi.mock('../../../ui/switch', () => ({ Switch: (p: any) => <input type="checkbox" data-testid="switch" {...p} /> }))
vi.mock('../../../ui/select', () => ({
  Select: ({ children }: any) => <div>{children}</div>,
  SelectContent: ({ children }: any) => <div>{children}</div>,
  SelectItem: ({ children }: any) => <div>{children}</div>,
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: () => <span />
}))
vi.mock('../../app-card', () => ({ AppCard: ({ app }: any) => <div data-testid="app-card">{app.titleText}</div> }))
vi.mock('../../function-assignment-panel', () => ({
  FunctionAssignmentPanel: () => <div data-testid="fn-panel" />
}))
vi.mock('../../../../lib/utils', () => ({ cn: (...a: unknown[]) => a.filter(Boolean).join(' ') }))

import { ApplicationsTab } from '../applications-tab'

const mockApps = [
  { appIdentifier: 'a1', titleText: 'App One', descriptionText: 'Desc', categoryName: 'Cat', isAssignedIndicator: false, assignedFunctionKeys: [] },
  { appIdentifier: 'a2', titleText: 'App Two', descriptionText: 'Desc', categoryName: 'Cat', isAssignedIndicator: true, assignedFunctionKeys: ['f1'] },
]

describe('ApplicationsTab', () => {
  const baseProps = {
    availableApps: mockApps as any[],
    selectedApp: null,
    appSearchTerm: '',
    groupDisplayName: 'Test Group',
    isLoadingApps: false,
    isSavingAppAssignment: false,
    onAppSearchTermChange: vi.fn(),
    onAppSelect: vi.fn(),
    onAppSave: vi.fn(),
  }

  it('renders app cards', () => {
    render(<ApplicationsTab {...baseProps} />)
    expect(screen.getAllByTestId('app-card')).toHaveLength(2)
  })

  it('shows no apps message when empty', () => {
    render(<ApplicationsTab {...baseProps} availableApps={[]} />)
    expect(screen.getByText('No applications available')).toBeInTheDocument()
  })

  it('shows function panel when app selected', () => {
    render(<ApplicationsTab {...baseProps} selectedApp={mockApps[0] as any} />)
    expect(screen.getByTestId('fn-panel')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/tabs/__tests__/business-info-tab.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../ui/card', () => ({
  Card: ({ children }: any) => <div>{children}</div>,
  CardContent: ({ children }: any) => <div>{children}</div>,
  CardDescription: ({ children }: any) => <div>{children}</div>,
  CardHeader: ({ children }: any) => <div>{children}</div>,
  CardTitle: ({ children }: any) => <div>{children}</div>
}))
vi.mock('../../../ui/input', () => ({ Input: (p: any) => <input data-testid="input" {...p} /> }))
vi.mock('../../../ui/label', () => ({ Label: ({ children }: any) => <label>{children}</label> }))
vi.mock('../../../ui/select', () => ({
  Select: ({ children }: any) => <div>{children}</div>,
  SelectContent: ({ children }: any) => <div>{children}</div>,
  SelectItem: ({ children }: any) => <div>{children}</div>,
  SelectTrigger: ({ children }: any) => <div>{children}</div>,
  SelectValue: () => <span />
}))
vi.mock('@/hooks/features/use-dropdown-options', () => ({
  useDropdownOptions: () => ({
    roles: [{ value: 'chat_agent', label: 'Chat Agent' }],
    regions: [],
    markets: [],
    countries: [],
    businessUnits: []
  })
}))
const stableGetMarkets = vi.fn(async () => [])
const stableGetCountries = vi.fn(async () => [])
vi.mock('../../../../hooks/api/use-reference-data', () => ({
  useReferenceData: () => ({
    regions: [],
    businessUnits: [],
    getMarketsForRegion: stableGetMarkets,
    getCountriesForMarket: stableGetCountries,
    isLoading: false,
    error: null
  })
}))
vi.mock('../../../../utils/core/debug', () => ({
  createLogger: () => ({ info: vi.fn(), warn: vi.fn(), error: vi.fn(), debug: vi.fn() })
}))
vi.mock('../../../../lib/utils', () => ({ cn: (...a: unknown[]) => a.filter(Boolean).join(' ') }))

import { BusinessInfoTab } from '../business-info-tab'

describe('BusinessInfoTab', () => {
  const baseProps = {
    formData: { logicalName: 'Test Group', groupIdentifier: 'CN=test', roleName: '', region: '', market: '', country: '' } as any,
    pendingChanges: { businessInfo: {}, permissions: {}, apps: {} } as any,
    onFormDataChange: vi.fn(),
    onPendingChangesUpdate: vi.fn(),
  }

  it('renders business info form', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('Business Information')).toBeInTheDocument()
  })

  it('renders group name field', () => {
    render(<BusinessInfoTab {...baseProps} />)
    expect(screen.getByText('Group Name *')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/tabs/__tests__/permissions-tab.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('../../../ui/card', () => ({
  Card: ({ children }: any) => <div data-testid="card">{children}</div>,
  CardContent: ({ children, className }: any) => <div className={className}>{children}</div>,
  CardDescription: ({ children }: any) => <p>{children}</p>,
  CardHeader: ({ children }: any) => <div>{children}</div>,
  CardTitle: ({ children, className }: any) => <h3 className={className}>{children}</h3>
}))

vi.mock('../../../ui/input', () => ({
  Input: (p: any) => <input data-testid="search-input" {...p} />
}))

vi.mock('../../../ui/badge', () => ({
  Badge: ({ children, className }: any) => <span data-testid="badge" className={className}>{children}</span>
}))

vi.mock('../../../ui/switch', () => ({
  Switch: ({ checked, disabled, onCheckedChange }: any) => (
    <input type="checkbox" data-testid="switch" checked={checked} disabled={disabled} onChange={(e: any) => onCheckedChange?.(e.target.checked)} />
  )
}))

vi.mock('../../../ui/accordion', () => ({
  Accordion: ({ children, className }: any) => <div className={className}>{children}</div>,
  AccordionContent: ({ children, className }: any) => <div className={className}>{children}</div>,
  AccordionItem: ({ children, value }: any) => <div data-testid={`accordion-item-${value}`}>{children}</div>,
  AccordionTrigger: ({ children, className }: any) => <div className={className}>{children}</div>
}))

vi.mock('lucide-react', () => ({
  CheckCircle: (p: any) => <span data-testid="check-circle" {...p} />,
  AlertTriangle: (p: any) => <span data-testid="alert-triangle" {...p} />,
  Search: (p: any) => <span data-testid="search-icon" {...p} />
}))

vi.mock('../../../../lib/utils', () => ({
  cn: (...a: unknown[]) => a.filter(Boolean).join(' ')
}))

vi.mock('../../../../constants/permission-levels', () => ({
  permissionLevels: {
    capabilities: {
      title: 'Access Controls',
      description: 'Core actions',
      icon: (p: any) => <span {...p} />,
      businessNames: {
        'columns.kms': 'Knowledge Base',
        'columns.embeddedApps': 'Banking Applications',
        'columns.spaceCopilot': 'AI Assistant',
        'columns.chat': 'Chat Interface',
        'micro_frontends.mediaBar': 'Media Controls'
      }
    },
    workspacePreferences: {
      title: 'Workspace & Preferences',
      description: 'User preferences',
      icon: (p: any) => <span {...p} />,
      businessNames: {
        'settings_options.calls.autoAccept': 'Auto-Accept Calls',
        'settings_options.calls.doNotDisturb.duration': 'Do Not Disturb',
        'settings_options.interface.showTranscript': 'Show Transcripts',
        'settings_options.interface.autoCloseKnowledgeOnCallEnd': 'Auto-Close Knowledge',
        'settings_options.interface.spaceCopilotMode': 'AI Assistant Mode'
      }
    }
  }
}))

vi.mock('@/hooks/features/use-dropdown-options', () => ({
  useDropdownOptions: () => ({
    roles: [{ value: 'voice_agent', label: 'Voice Agent' }],
    regions: [],
    markets: [],
    countries: [],
    businessUnits: []
  })
}))

vi.mock('../../business-relevant-toggles', () => ({
  businessRelevantToggles: {
    capabilities: {
      title: 'Access Controls',
      description: 'Core actions',
      toggles: {
        'columns.kms': {
          visible: true,
          businessName: 'Knowledge Base',
          description: 'Access to knowledge base features',
          section: 'Dashboard Access',
          linkedKeys: ['features.search.knowledgeBase']
        }
      }
    },
    workspacePreferences: {
      title: 'Workspace & Preferences',
      description: 'User preferences',
      toggles: {
        'settings_options.calls.autoAccept': {
          visible: true,
          businessName: 'Auto-Accept Calls',
          description: 'Automatically accept incoming calls',
          section: 'Call Preferences'
        }
      }
    }
  }
}))

vi.mock('../../../../hooks/admin/use-permission-state', () => ({
  usePermissionState: () => ({
    isPermissionEnabled: () => true,
    hasUnsavedChanges: () => false
  })
}))

vi.mock('../../../../hooks/admin/use-permission-aggregators', () => ({
  usePermissionAggregators: () => ({
    getPermissionCount: () => 1,
    getEnabledPermissions: () => ['columns.kms'],
    getFilteredPermissions: () => ['columns.kms']
  })
}))

vi.mock('../../../../utils/admin/permission-level-resolver', () => ({
  resolvePermissionLevel: ({ level, key }: { level: string; key: string }) => {
    const COMPOUND: Record<string, string[]> = {
      capabilities: ['columns', 'features', 'micro_frontends'],
      workspacePreferences: ['widgets', 'settings_tabs', 'settings_options']
    }
    const prefixes = COMPOUND[level]
    if (!prefixes) return { actualLevel: level, actualKey: key }
    for (const prefix of prefixes) {
      if (key.startsWith(prefix + '.')) {
        return { actualLevel: prefix, actualKey: key.slice(prefix.length + 1) }
      }
    }
    const [p, ...rest] = key.split('.')
    return { actualLevel: p, actualKey: rest.join('.') }
  }
}))

vi.mock('../../../../utils/admin/permission-hierarchy-sorter', () => ({
  sortWithHierarchy: ({ keys }: { keys: string[] }) => keys
}))

import { PermissionsTab } from '../permissions-tab'

describe('PermissionsTab', () => {
  const defaultProps = {
    formData: {
      logicalName: 'Test Group',
      groupIdentifier: 'CN=test',
      roleName: 'voice_agent'
    } as any,
    roleTemplate: {
      name: 'voice_agent',
      capabilities: { 'columns.kms': true }
    } as any,
    permissionOverrides: {},
    pendingChanges: { permissions: {} } as any,
    searchTerm: '',
    loadingPermission: null,
    onSearchTermChange: vi.fn(),
    onTogglePermission: vi.fn()
  }

  it('renders role-inherited card when role and template exist', () => {
    render(<PermissionsTab {...defaultProps} />)
    expect(screen.getByText('Inherited from Voice Agent')).toBeInTheDocument()
    expect(screen.getByText('All permissions below are inherited from the role template. You can toggle features OFF but cannot add new ones.')).toBeInTheDocument()
  })

  it('shows select role message when no role is selected', () => {
    render(
      <PermissionsTab
        {...defaultProps}
        formData={{ ...defaultProps.formData, roleName: '' }}
        roleTemplate={null}
      />
    )
    expect(screen.getByText('Select a Role First')).toBeInTheDocument()
    expect(screen.getByText('Choose a role in the Business Info tab to see inherited permissions')).toBeInTheDocument()
  })

  it('shows loading message when template is being fetched', () => {
    render(
      <PermissionsTab
        {...defaultProps}
        roleTemplate={null}
        isLoadingTemplate
      />
    )
    expect(screen.getByText('Loading role template...')).toBeInTheDocument()
  })

  it('renders search input', () => {
    render(<PermissionsTab {...defaultProps} />)
    expect(screen.getByTestId('search-input')).toBeInTheDocument()
  })

  it('renders both permission level accordion sections', () => {
    render(<PermissionsTab {...defaultProps} />)
    expect(screen.getByText('Access Controls')).toBeInTheDocument()
    expect(screen.getByText('Workspace & Preferences')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/tabs/applications-tab.tsx
import { useState } from 'react'
import { Card, CardContent } from '../../ui/card'
import { Input } from '../../ui/input'
import { Label } from '../../ui/label'
import { Badge } from '../../ui/badge'
import { Switch } from '../../ui/switch'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '../../ui/select'
import { Search, Package, Filter } from 'lucide-react'
import { AppCard } from '../app-card'
import { FunctionAssignmentPanel } from '../function-assignment-panel'
import type { EmbeddedAppWithStatus } from '../../../types/integration/embedded-apps'

interface ApplicationsTabProps {
  availableApps: EmbeddedAppWithStatus[]
  selectedApp: EmbeddedAppWithStatus | null
  appSearchTerm: string
  groupDisplayName: string
  isLoadingApps: boolean
  isSavingAppAssignment: boolean
  onAppSearchTermChange: (term: string) => void
  onAppSelect: (app: EmbeddedAppWithStatus) => void
  onAppSave: (appKey: string, appTitle: string, functions: string[], defaultFunction?: string) => Promise<void>
  onFunctionSelectionChange?: (appKey: string, appTitle: string, functions: string[], defaultFunction?: string) => void
  isReadOnly?: boolean
}

export function ApplicationsTab({
  availableApps,
  selectedApp,
  appSearchTerm,
  groupDisplayName,
  isLoadingApps,
  isSavingAppAssignment,
  onAppSearchTermChange,
  onAppSelect,
  onAppSave,
  onFunctionSelectionChange,
  isReadOnly = false
}: Readonly<ApplicationsTabProps>) {
  // Filter states
  const [selectedCategory, setSelectedCategory] = useState<string>('all')
  const [showAssignedOnly, setShowAssignedOnly] = useState(false)

  // Extract unique categories from available apps
  const categories = ['all', ...new Set(availableApps.map(app => app.categoryName).filter(Boolean))]

  // Combined filtering logic
  const filteredApps = availableApps.filter(app => {
    // Search term filter
    const matchesSearch = !appSearchTerm ||
      app.titleText.toLowerCase().includes(appSearchTerm.toLowerCase()) ||
      app.descriptionText.toLowerCase().includes(appSearchTerm.toLowerCase()) ||
      app.categoryName.toLowerCase().includes(appSearchTerm.toLowerCase())

    // Category filter
    const matchesCategory = selectedCategory === 'all' || app.categoryName === selectedCategory

    // Assigned filter
    const matchesAssigned = !showAssignedOnly || app.isAssignedIndicator

    return matchesSearch && matchesCategory && matchesAssigned
  })

  return (
    <div className="grid h-full grid-cols-1 gap-6 lg:grid-cols-2">
      {/* Left Panel - Apps List */}
      <div className="h-full space-y-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Package className="h-4 w-4 text-gray-500" />
            <Label className="text-sm font-medium">Available Applications</Label>
            <Badge variant="outline" className="text-xs">
              {`${availableApps.filter(app => app.isAssignedIndicator).length} assigned`}
            </Badge>
          </div>
        </div>

        {/* Filter Controls - All in one line */}
        <div className="flex items-center gap-3">
          {/* Category Filter */}
          <div className="flex items-center gap-2 min-w-0 w-[200px]">
            <Filter className="h-4 w-4 text-gray-400 flex-shrink-0" />
            <Select value={selectedCategory} onValueChange={setSelectedCategory}>
              <SelectTrigger className="w-full">
                <SelectValue placeholder="All Categories" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Categories</SelectItem>
                {categories.filter(cat => cat !== 'all').map(category => (
                  <SelectItem key={category} value={category}>
                    {category}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* Assigned Apps Toggle */}
          <div className="flex items-center gap-2 bg-gray-50 border border-gray-200 rounded-lg px-3 py-1.5 whitespace-nowrap">
            <Label htmlFor="assigned-filter" className="text-sm font-medium cursor-pointer">
              Assigned only
            </Label>
            <Switch
              id="assigned-filter"
              checked={showAssignedOnly}
              onCheckedChange={setShowAssignedOnly}
            />
          </div>

          {/* Search Bar - Takes remaining space */}
          <div className="flex items-center gap-2 flex-1 min-w-0">
            <Search className="h-4 w-4 text-gray-400 flex-shrink-0" />
            <Input
              placeholder="Search applications..."
              value={appSearchTerm}
              onChange={(e) => onAppSearchTermChange(e.target.value)}
              className="flex-1"
            />
          </div>
        </div>

        <div className="space-y-2 max-h-[60vh] overflow-y-auto">
          {isLoadingApps && (
            <div className="space-y-2">
              {['s1', 's2', 's3'].map(id => (
                <Card key={id} className="animate-pulse">
                  <CardContent className="p-4">
                    <div className="flex items-start gap-3">
                      <div className="w-10 h-10 bg-gray-200 rounded-lg"></div>
                      <div className="flex-1">
                        <div className="w-24 h-4 bg-gray-200 rounded mb-2"></div>
                        <div className="w-32 h-3 bg-gray-200 rounded"></div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
          {!isLoadingApps && filteredApps.length > 0 && (
            filteredApps.map(app => (
              <AppCard
                key={app.appIdentifier}
                app={app}
                selected={selectedApp?.appIdentifier === app.appIdentifier}
                onClick={() => onAppSelect(app)}
              />
            ))
          )}
          {!isLoadingApps && filteredApps.length === 0 && (
            <div className="text-center py-8 text-gray-500 text-sm">
              {appSearchTerm ? 'No applications found matching your search' : 'No applications available'}
            </div>
          )}
        </div>
      </div>

      {/* Right Panel - Function Assignment */}
      <div className="space-y-4">
        {selectedApp ? (
          <FunctionAssignmentPanel
            app={selectedApp}
            groupName={groupDisplayName}
            onSave={async (functions, defaultFunction) => {
              await onAppSave(selectedApp.appIdentifier, selectedApp.titleText, functions, defaultFunction)
            }}
            onSelectionChange={onFunctionSelectionChange
              ? (functions, defaultFunction) => onFunctionSelectionChange(selectedApp.appIdentifier, selectedApp.titleText, functions, defaultFunction)
              : undefined
            }
            isLoading={isSavingAppAssignment}
            isReadOnly={isReadOnly}
          />
        ) : (
          <Card className="h-full">
            <CardContent className="flex flex-col items-center justify-center py-12">
              <Package className="h-12 w-12 text-gray-400 mb-4" />
              <h3 className="text-lg font-medium text-gray-900 mb-2">
                Select an Application
              </h3>
              <p className="text-gray-600 text-center max-w-sm">
                Choose an application from the list to configure its functions for this AD group
              </p>
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/admin/tabs/business-info-tab.tsx
import { useState, useEffect } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../../ui/card'
import { Input } from '../../ui/input'
import { Label } from '../../ui/label'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '../../ui/select'
import { useDropdownOptions } from '@/hooks/features/use-dropdown-options'
import { useReferenceData } from '../../../hooks/api/use-reference-data'
import { createLogger } from '../../../utils/core/debug'
import type { CountryDto, MarketDto } from '../../../services/api/reference-data.service'
import type { AdGroup, PendingChanges } from '../../../types/features/ad-group-config'

interface BusinessInfoTabProps {
  formData: AdGroup
  pendingChanges: PendingChanges
  onFormDataChange: (data: Partial<AdGroup>) => void
  onPendingChangesUpdate: (changes: PendingChanges) => void
  isReadOnly?: boolean
}

const logger = createLogger('BusinessInfoTab')

function getMarketPlaceholder(region: string | undefined, loadingMarkets: boolean): string {
  if (!region) return 'Select region first...'
  if (loadingMarkets) return 'Loading markets...'
  return 'Select market...'
}

function getCountryPlaceholder(market: string | undefined, loadingCountries: boolean): string {
  if (!market) return 'Select market first...'
  if (loadingCountries) return 'Loading countries...'
  return 'Select country...'
}

function getLoadingPlaceholder(isLoading: boolean, defaultText: string): string {
  return isLoading ? 'Loading...' : defaultText
}

function getFormValue(value: string | undefined | null): string {
  return value || ''
}

function isMarketSelectedWithNoCountries(market: string | undefined, countries: CountryDto[], isLoading: boolean): boolean {
  return Boolean(market) && market !== '' && countries.length === 0 && !isLoading
}

function ReferenceDataError({ visible, message }: Readonly<{ visible: boolean; message: string }>) {
  if (!visible) return null
  return <p className="text-sm text-red-500">{message}</p>
}

function loadDependentOptions<T>(
  parentValue: string | undefined,
  fetcher: (value: string) => Promise<T[]>,
  setOptions: (options: T[]) => void,
  setLoading: (loading: boolean) => void,
  errorMessage: string
): (() => void) | undefined {
  if (!parentValue) {
    setOptions([])
    return undefined
  }
  let ignore = false
  setLoading(true)
  fetcher(parentValue)
    .then(results => { if (!ignore) setOptions(results) })
    .catch(err => {
      if (!ignore) {
        logger.error(errorMessage, err)
        setOptions([])
      }
    })
    .finally(() => { if (!ignore) setLoading(false) })
  return () => { ignore = true }
}

export function BusinessInfoTab({
  formData,
  pendingChanges,
  onFormDataChange,
  onPendingChangesUpdate,
  isReadOnly = false
}: Readonly<BusinessInfoTabProps>) {
  const { regions, businessUnits, roleTemplates, getMarketsForRegion, getCountriesForMarket, isLoading, error } = useReferenceData()
  const dropdownOptions = useDropdownOptions({ roleTemplates })
  const [filteredMarkets, setFilteredMarkets] = useState<MarketDto[]>([])
  const [filteredCountries, setFilteredCountries] = useState<CountryDto[]>([])
  const [loadingMarkets, setLoadingMarkets] = useState(false)
  const [loadingCountries, setLoadingCountries] = useState(false)

  useEffect(
    () => loadDependentOptions(formData.region, getMarketsForRegion, setFilteredMarkets, setLoadingMarkets, 'Failed to load markets for region'),
    [formData.region, getMarketsForRegion]
  )

  useEffect(
    () => loadDependentOptions(formData.market, getCountriesForMarket, setFilteredCountries, setLoadingCountries, 'Failed to load countries for market'),
    [formData.market, getCountriesForMarket]
  )

  const handleFieldChange = (formUpdates: Partial<AdGroup>, pendingUpdates?: Record<string, string>) => {
    onFormDataChange(formUpdates)
    onPendingChangesUpdate({
      ...pendingChanges,
      businessInfo: {
        ...pendingChanges?.businessInfo,
        ...pendingUpdates ?? formUpdates
      }
    })
  }

  const handleRoleChange = (value: string) => {
    handleFieldChange({ roleName: value })
  }

  const handleRegionChange = (value: string) => {
    handleFieldChange(
      { region: value, market: '', country: '' },
      { region: value, market: '', country: '' }
    )
  }

  const handleMarketChange = (value: string) => {
    handleFieldChange(
      { market: value, country: '' },
      { market: value, country: '' }
    )
  }

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">Business Information</CardTitle>
          <CardDescription>
            Configure the basic business details for this AD group
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="logicalName">Group Name *</Label>
              <Input
                id="logicalName"
                placeholder="e.g., UK Retail Voice Agents"
                value={getFormValue(formData.logicalName)}
                onChange={(e) => handleFieldChange({ logicalName: e.target.value })}
                disabled={isReadOnly}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="role">Role *</Label>
              <Select
                value={getFormValue(formData.roleName)}
                onValueChange={handleRoleChange}
                disabled={isReadOnly}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select role..." />
                </SelectTrigger>
                <SelectContent>
                  {dropdownOptions.roles.map((role) => (
                    <SelectItem key={role.value} value={role.value}>
                      {role.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="region">Region *</Label>
              <Select
                value={getFormValue(formData.region)}
                onValueChange={handleRegionChange}
                disabled={isReadOnly || isLoading}
              >
                <SelectTrigger>
                  <SelectValue placeholder={getLoadingPlaceholder(isLoading, 'Select region...')} />
                </SelectTrigger>
                <SelectContent>
                  {regions.map((region) => (
                    <SelectItem key={region.regionCode} value={region.regionCode}>
                      {region.regionName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <ReferenceDataError visible={Boolean(error)} message="Failed to load regions" />
            </div>

            <div className="space-y-2">
              <Label htmlFor="market">Market *</Label>
              <Select
                value={getFormValue(formData.market)}
                onValueChange={handleMarketChange}
                disabled={isReadOnly || !formData.region || loadingMarkets}
              >
                <SelectTrigger>
                  <SelectValue
                    placeholder={getMarketPlaceholder(formData.region, loadingMarkets)}
                  />
                </SelectTrigger>
                <SelectContent>
                  {filteredMarkets.map((market) => (
                    <SelectItem key={market.marketCode} value={market.marketCode}>
                      {market.marketName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="businessUnit">Business Unit *</Label>
              <Select
                value={getFormValue(formData.businessUnit)}
                onValueChange={(value: string) => handleFieldChange({ businessUnit: value })}
                disabled={isReadOnly || isLoading}
              >
                <SelectTrigger>
                  <SelectValue placeholder={getLoadingPlaceholder(isLoading, 'Select business unit...')} />
                </SelectTrigger>
                <SelectContent>
                  {businessUnits.map((unit) => (
                    <SelectItem key={unit.unitCode} value={unit.unitCode}>
                      {unit.unitName}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <ReferenceDataError visible={Boolean(error)} message="Failed to load business units" />
            </div>

            <div className="space-y-2">
              <Label htmlFor="country">Country *</Label>
              <Select
                value={getFormValue(formData.country)}
                onValueChange={(value: string) => handleFieldChange({ country: value })}
                disabled={isReadOnly || !formData.market || loadingCountries}
              >
                <SelectTrigger>
                  <SelectValue
                    placeholder={getCountryPlaceholder(formData.market, loadingCountries)}
                  />
                </SelectTrigger>
                <SelectContent>
                  {filteredCountries.map((country) => (
                    <SelectItem key={country.countryCode} value={country.countryCode}>
                      {country.countryName}
                    </SelectItem>
                  ))}
                  {isMarketSelectedWithNoCountries(formData.market, filteredCountries, loadingCountries) && (
                    <div className="text-sm text-gray-500 px-2 py-1">No countries available</div>
                  )}
                </SelectContent>
              </Select>
              {isMarketSelectedWithNoCountries(formData.market, filteredCountries, loadingCountries) && (
                <p className="text-sm text-red-500">No countries found for selected region</p>
              )}
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/admin/tabs/permissions-tab.tsx
import React from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../../ui/card'
import { Input } from '../../ui/input'
import { Badge } from '../../ui/badge'
import { Switch } from '../../ui/switch'
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '../../ui/accordion'
import {
  CheckCircle,
  AlertTriangle,
  Search
} from 'lucide-react'
import { cn } from '../../../lib/utils'
import { permissionLevels } from '../../../constants/permission-levels'
import { useDropdownOptions } from '@/hooks/features/use-dropdown-options'
import { businessRelevantToggles } from '../business-relevant-toggles'
import { resolvePermissionLevel } from '../../../utils/admin/permission-level-resolver'
import type {
  AdGroup,
  RoleTemplate,
  PermissionOverrides,
  PendingChanges
} from '../../../types/features/ad-group-config'
import { usePermissionState } from '../../../hooks/admin/use-permission-state'
import { usePermissionAggregators } from '../../../hooks/admin/use-permission-aggregators'

function getPermissionRowStyle(hasChanges: boolean, isOverridden: boolean): string {
  if (hasChanges) return "border-blue-300 bg-blue-50 shadow-sm ring-1 ring-blue-200"
  if (isOverridden) return "border-orange-200 bg-orange-50"
  return "border-gray-200"
}

function PermissionDescription({ description, warning, hasChanges, isOverridden, roleName }: Readonly<{
  description?: string
  warning?: string
  hasChanges: boolean
  isOverridden: boolean
  roleName: string
}>) {
  if (description) {
    return (
      <div>
        <div>{description}</div>
        {warning && <div className="text-orange-600 mt-1">{warning}</div>}
      </div>
    )
  }
  if (hasChanges) return <span className="text-blue-600 font-medium">Modified - not saved yet</span>
  if (isOverridden) return <span className="text-orange-600">Modified from role default</span>
  return <>{`Inherited from ${roleName} role`}</>
}

function getPermissionSwitchDisabled(
  isReadOnly: boolean,
  parentEnabled: boolean,
  loadingPermission: string | null,
  levelKey: string,
  permissionKey: string
): boolean {
  return isReadOnly || !parentEnabled || loadingPermission === `${levelKey}.${permissionKey}`
}

interface PermissionRowProps {
  levelKey: string
  permissionKey: string
  formData: AdGroup
  permissionOverrides: PermissionOverrides
  loadingPermission: string | null
  isPermissionEnabled: (args: { level: string; key: string }) => boolean
  hasUnsavedChanges: (args: { level: string; key: string }) => boolean
  onTogglePermission: (level: string, key: string, value: boolean) => void
  isReadOnly?: boolean
}

function PermissionRow({
  levelKey, permissionKey, formData, permissionOverrides,
  loadingPermission, isPermissionEnabled, hasUnsavedChanges, onTogglePermission,
  isReadOnly = false
}: Readonly<PermissionRowProps>) {
  const businessConfig = businessRelevantToggles[levelKey]?.toggles[permissionKey]
  const businessName = businessConfig?.businessName || permissionKey
  const description = businessConfig?.description
  const warning = businessConfig?.warning

  const isEnabled = isPermissionEnabled({ level: levelKey, key: permissionKey })

  // Resolve compound levels to check actual override path
  const { actualLevel, actualKey } = resolvePermissionLevel({ level: levelKey, key: permissionKey })
  const isOverridden = permissionOverrides[actualLevel]?.[actualKey] !== undefined

  const hasChanges = hasUnsavedChanges({ level: levelKey, key: permissionKey })

  const hasParent = !!businessConfig?.parent
  const parentKey = businessConfig?.parent
  const parentEnabled = parentKey ? isPermissionEnabled({ level: levelKey, key: parentKey }) : true

  return (
    <div
      className={cn(
        "flex items-center justify-between p-3 border rounded-lg transition-colors",
        hasParent && "ml-8",
        !parentEnabled && "opacity-50",
        getPermissionRowStyle(hasChanges, isOverridden)
      )}
    >
      <div className="space-y-1 flex-1">
        <div className="font-medium text-sm flex items-center gap-2">
          {businessName}
          {hasChanges && (
            <Badge variant="secondary" className="text-xs bg-blue-100 text-blue-700">
              Unsaved
            </Badge>
          )}
          {warning && <AlertTriangle className="h-3 w-3 text-orange-500" />}
        </div>
        <div className="text-xs text-muted-foreground">
          <PermissionDescription
            description={description}
            warning={warning}
            hasChanges={hasChanges}
            isOverridden={isOverridden}
            roleName={formData.roleName ?? ''}
          />
        </div>
      </div>
      <Switch
        checked={isEnabled && parentEnabled}
        disabled={getPermissionSwitchDisabled(isReadOnly, parentEnabled, loadingPermission, levelKey, permissionKey)}
        onCheckedChange={(checked) => onTogglePermission(levelKey, permissionKey, checked)}
      />
    </div>
  )
}

function groupBySection(keys: string[], levelKey: string): [string, string[]][] {
  const groups: Map<string, string[]> = new Map()

  for (const key of keys) {
    const config = businessRelevantToggles[levelKey]?.toggles[key]
    const section = config?.section || ''
    if (!groups.has(section)) {
      groups.set(section, [])
    }
    groups.get(section)!.push(key)
  }

  return Array.from(groups.entries())
}

interface PermissionsTabProps {
  formData: AdGroup
  roleTemplate: RoleTemplate | null
  isLoadingTemplate?: boolean
  permissionOverrides: PermissionOverrides
  pendingChanges: PendingChanges
  searchTerm: string
  loadingPermission: string | null
  onSearchTermChange: (term: string) => void
  onTogglePermission: (level: string, key: string, value: boolean) => void
  isReadOnly?: boolean
}

export function PermissionsTab({
  formData,
  roleTemplate,
  isLoadingTemplate = false,
  permissionOverrides,
  pendingChanges,
  searchTerm,
  loadingPermission,
  onSearchTermChange,
  onTogglePermission,
  isReadOnly = false
}: Readonly<PermissionsTabProps>) {
  const dropdownOptions = useDropdownOptions()

  const { isPermissionEnabled, hasUnsavedChanges } = usePermissionState({
    roleTemplate,
    permissionOverrides,
    pendingChanges
  })

  const {
    getPermissionCount,
    getEnabledPermissions,
    getFilteredPermissions
  } = usePermissionAggregators({
    roleTemplate,
    searchTerm,
    isPermissionEnabled
  })

  if (formData.roleName && isLoadingTemplate) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-8">
          <p className="text-muted-foreground">Loading role template...</p>
        </CardContent>
      </Card>
    )
  }

  if (!formData.roleName || !roleTemplate) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-8">
          <AlertTriangle className="h-12 w-12 text-orange-500 mb-4" />
          <h3 className="text-lg font-medium mb-2">Select a Role First</h3>
          <p className="text-muted-foreground text-center">
            Choose a role in the Business Info tab to see inherited permissions
          </p>
        </CardContent>
      </Card>
    )
  }

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <CheckCircle className="h-5 w-5 text-green-500" />
            {`Inherited from ${dropdownOptions.roles.find(r => r.value === formData.roleName)?.label || formData.roleName}`}
          </CardTitle>
          <CardDescription>
            All permissions below are inherited from the role template. You can toggle features OFF but cannot add new ones.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex items-center gap-2 mb-4">
            <Search className="h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search permissions..."
              value={searchTerm}
              onChange={(e) => onSearchTermChange(e.target.value)}
              className="max-w-sm"
            />
          </div>
        </CardContent>
      </Card>

      <Accordion type="multiple" className="space-y-4">
        {Object.entries(permissionLevels).map(([levelKey, levelConfig]) => {
          const Icon = levelConfig.icon
          const enabledCount = getEnabledPermissions({ level: levelKey }).length
          const totalCount = getPermissionCount({ level: levelKey })
          const filteredPermissions = getFilteredPermissions({ level: levelKey })

          if (filteredPermissions.length === 0 && searchTerm) return null
          if (totalCount === 0) return null

          const sectionGroups = groupBySection(filteredPermissions, levelKey)
          const hasSections = sectionGroups.some(([name]) => name !== '')

          return (
            <Card key={levelKey}>
              <AccordionItem value={levelKey} className="border-none">
                <AccordionTrigger className="px-6 py-4 hover:no-underline">
                  <div className="flex items-center gap-3 text-left">
                    <Icon className="h-5 w-5" />
                    <div>
                      <h3 className="font-semibold">{levelConfig.title}</h3>
                      <p className="text-sm text-muted-foreground">{levelConfig.description}</p>
                      <div className="flex items-center gap-2 mt-1">
                        <Badge variant="outline" className="text-xs">
                          {`${enabledCount} of ${totalCount} enabled`}
                        </Badge>
                      </div>
                    </div>
                  </div>
                </AccordionTrigger>
                <AccordionContent className="px-6 pb-4">
                  <div className="flex flex-col gap-3">
                    {hasSections ? (
                      sectionGroups.map(([sectionName, keys]) => (
                        <div key={sectionName || '_default'}>
                          {sectionName && (
                            <h4 className="text-xs font-semibold text-muted-foreground uppercase tracking-wider mt-4 mb-2 first:mt-0">
                              {sectionName}
                            </h4>
                          )}
                          <div className="flex flex-col gap-3">
                            {keys.map((permissionKey) => (
                              <PermissionRow
                                key={permissionKey}
                                levelKey={levelKey}
                                permissionKey={permissionKey}
                                formData={formData}
                                permissionOverrides={permissionOverrides}
                                loadingPermission={loadingPermission}
                                isPermissionEnabled={isPermissionEnabled}
                                hasUnsavedChanges={hasUnsavedChanges}
                                onTogglePermission={onTogglePermission}
                                isReadOnly={isReadOnly}
                              />
                            ))}
                          </div>
                        </div>
                      ))
                    ) : (
                      filteredPermissions.map((permissionKey) => (
                        <PermissionRow
                          key={permissionKey}
                          levelKey={levelKey}
                          permissionKey={permissionKey}
                          formData={formData}
                          permissionOverrides={permissionOverrides}
                          loadingPermission={loadingPermission}
                          isPermissionEnabled={isPermissionEnabled}
                          hasUnsavedChanges={hasUnsavedChanges}
                          onTogglePermission={onTogglePermission}
                          isReadOnly={isReadOnly}
                        />
                      ))
                    )}
                  </div>
                  {filteredPermissions.length === 0 && !searchTerm && (
                    <div className="text-center py-8 text-muted-foreground">
                      No permissions available for this category in the selected role.
                    </div>
                  )}
                </AccordionContent>
              </AccordionItem>
            </Card>
          )
        })}
      </Accordion>
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/admin/views/__tests__/notice-management-view.test.tsx
import { describe, expect, it, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'

const mockListNotices = vi.fn()

vi.mock('@/hooks/features/use-notice-config', () => ({
  Bell: () => <span data-testid="bell-icon" />
}))

vi.mock('../../../../services/api/admin.service', () => ({
  adminService: {
    listNotices: (...args: unknown[]) => mockListNotices(...args)
  }
}))

vi.mock('../../notices/notice-form-modal', () => ({
  NoticeFormModal: ({ open }: { open: boolean }) =>
    open ? <div data-testid="notice-form-modal">Modal</div> : null
}))

vi.mock('../../notices/notice-row', () => ({
  NoticeRow: ({ notice }: { notice: { title: string } }) => (
    <tr data-testid="notice-row"><td>{notice.title}</td></tr>
  )
}))

vi.mock('../../../ui/button', () => ({
  Button: ({ children, onClick, ...rest }: Record<string, unknown>) => (
    <button onClick={onClick as () => void} {...rest}>{children as React.ReactNode}</button>
  )
}))

vi.mock('../../../ui/card', () => ({
  Card: ({ children, ...rest }: Record<string, unknown>) => <div data-testid="card" {...rest}>{children as React.ReactNode}</div>
}))

vi.mock('../../../ui/tabs', () => ({
  Tabs: ({ children }: Record<string, unknown>) => (
    <div data-testid="tabs">{children as React.ReactNode}</div>
  ),
  TabsList: ({ children }: { children: React.ReactNode }) => <div data-testid="tabs-list">{children}</div>,
  TabsTrigger: ({ children, value }: { children: React.ReactNode; value: string }) => (
    <button data-testid={`tab-${value}`}>{children}</button>
  ),
  TabsContent: ({ children, value }: { children: React.ReactNode; value: string }) => (
    <div data-testid={`tab-content-${value}`}>{children}</div>
  )
}))

vi.mock('../../../ui/table', () => ({
  Table: ({ children }: { children: React.ReactNode }) => <table>{children}</table>,
  TableBody: ({ children }: { children: React.ReactNode }) => <tbody>{children}</tbody>,
  TableHead: ({ children }: { children: React.ReactNode }) => <th>{children}</th>,
  TableHeader: ({ children }: { children: React.ReactNode }) => <thead>{children}</thead>,
  TableRow: ({ children }: { children: React.ReactNode }) => <tr>{children}</tr>
}))

vi.mock('../../../common/brand-loader', () => ({
  BrandLoader: () => <div data-testid="loader">Loading...</div>
}))

vi.mock('lucide-react', () => ({
  ArrowUpDown: () => <span data-testid="arrow-updown" />,
  ArrowUp: () => <span data-testid="arrow-up" />,
  ArrowDown: () => <span data-testid="arrow-down" />
}))

import { NoticeManagementView } from '../notice-management-view'
import type { AdminPermissions } from '../../admin-layout'

const allPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

const mockNotices = [
  { id: 'n1', title: 'Active Notice', status: 'ACTIVE', severity: 'INFO', createdAt: '2025-01-15T10:00:00Z' },
  { id: 'n2', title: 'Draft Notice', status: 'DRAFT', severity: 'WARNING', createdAt: '2025-01-16T10:00:00Z' },
  { id: 'n3', title: 'Archived Notice', status: 'ARCHIVED', severity: 'ERROR', createdAt: '2025-01-17T10:00:00Z' }
]

describe('NoticeManagementView', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockListNotices.mockResolvedValue(mockNotices)
  })

  it('renders title and description', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByText('System Notices')).toBeInTheDocument()
      expect(screen.getByText('Create and manage notices for users across the platform')).toBeInTheDocument()
    })
  })

  it('renders create notice button with permission', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByText('Create Notice')).toBeInTheDocument()
    })
  })

  it('hides create notice button without permission', async () => {
    render(<NoticeManagementView permissions={{ ...allPermissions, canCreateNotice: false }} />)
    await waitFor(() => {
      expect(screen.queryByText('Create Notice')).not.toBeInTheDocument()
    })
  })

  it('shows loading state initially', () => {
    mockListNotices.mockReturnValue(new Promise(() => {}))
    render(<NoticeManagementView permissions={allPermissions} />)
    expect(screen.getByTestId('loader')).toBeInTheDocument()
  })

  it('renders tab triggers', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByTestId('tab-active')).toBeInTheDocument()
      expect(screen.getByTestId('tab-draft')).toBeInTheDocument()
      expect(screen.getByTestId('tab-archived')).toBeInTheDocument()
    })
  })

  it('renders notice rows after loading', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      const rows = screen.getAllByTestId('notice-row')
      expect(rows.length).toBeGreaterThan(0)
    })
  })

  it('shows empty state when no active notices', async () => {
    mockListNotices.mockResolvedValue([
      { id: 'n1', title: 'Draft', status: 'DRAFT', severity: 'INFO', createdAt: '2025-01-15T10:00:00Z' }
    ])

    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByText('No active notices. Create one to get started.')).toBeInTheDocument()
    })
  })

  it('handles API error gracefully', async () => {
    mockListNotices.mockRejectedValue(new Error('API error'))

    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.getByText('No active notices. Create one to get started.')).toBeInTheDocument()
    })
  })

  it('opens create modal on button click', async () => {
    render(<NoticeManagementView permissions={allPermissions} />)
    await waitFor(() => {
      expect(screen.queryByTestId('notice-form-modal')).not.toBeInTheDocument()
    })

    fireEvent.click(screen.getByText('Create Notice'))
    expect(screen.getByTestId('notice-form-modal')).toBeInTheDocument()
  })
})
===ENDFILE
===FILE: ./src/components/admin/views/notice-management-view.tsx
import { useState, useEffect } from 'react'
import { Button } from '../../ui/button'
import { Card } from '../../ui/card'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../../ui/tabs'
import { Bell } from '@/hooks/features/use-notice-config'
import { adminService, type AdminNoticeResponse } from '../../../services/api/admin.service'
import { NoticeFormModal } from '../notices/notice-form-modal'
import { NoticeRow } from '../notices/notice-row'
import {
  Table,
  TableBody,
  TableHead,
  TableHeader,
  TableRow
} from '../../ui/table'
import { BrandLoader } from '../../common/brand-loader'
import type { AdminPermissions } from '../admin-layout'
import { ArrowUpDown, ArrowUp, ArrowDown } from 'lucide-react'

interface NoticeManagementViewProps {
  permissions: AdminPermissions
}

type SortOrder = 'asc' | 'desc' | null

function sortNoticesByDate(noticeList: AdminNoticeResponse[], order: SortOrder): AdminNoticeResponse[] {
  if (!order) return noticeList
  return [...noticeList].sort((a, b) => {
    const dateA = new Date(a.createdAt).getTime()
    const dateB = new Date(b.createdAt).getTime()
    return order === 'desc' ? dateB - dateA : dateA - dateB
  })
}

function getNextSortOrder(current: SortOrder): SortOrder {
  if (current === null) return 'desc'
  if (current === 'desc') return 'asc'
  return null
}

function SortButton({ sortOrder, onToggle }: Readonly<{ sortOrder: SortOrder; onToggle: () => void }>) {
  return (
    <button
      type="button"
      onClick={onToggle}
      className="flex items-center gap-1 hover:text-foreground transition-colors"
    >
      Created
      {sortOrder === null && <ArrowUpDown className="h-4 w-4" />}
      {sortOrder === 'desc' && <ArrowDown className="h-4 w-4" />}
      {sortOrder === 'asc' && <ArrowUp className="h-4 w-4" />}
    </button>
  )
}

interface NoticeTableProps {
  notices: AdminNoticeResponse[]
  emptyMessage: string
  sortOrder: SortOrder
  onToggleSort: () => void
  onUpdate: (notice: AdminNoticeResponse) => void
  onEdit: (notice: AdminNoticeResponse) => void
  permissions: AdminPermissions
}

function NoticeTable({ notices, emptyMessage, sortOrder, onToggleSort, onUpdate, onEdit, permissions }: Readonly<NoticeTableProps>) {
  if (notices.length === 0) {
    return (
      <div className="p-12 text-center text-muted-foreground">
        {emptyMessage}
      </div>
    )
  }

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Title</TableHead>
          <TableHead>Severity</TableHead>
          <TableHead>Targets</TableHead>
          <TableHead>
            <SortButton sortOrder={sortOrder} onToggle={onToggleSort} />
          </TableHead>
          <TableHead className="text-right">Actions</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {notices.map(notice => (
          <NoticeRow
            key={notice.id}
            notice={notice}
            onUpdate={onUpdate}
            onEdit={onEdit}
            permissions={permissions}
          />
        ))}
      </TableBody>
    </Table>
  )
}

export function NoticeManagementView({ permissions }: Readonly<NoticeManagementViewProps>) {
  const [activeTab, setActiveTab] = useState<string>('active')
  const [showCreateModal, setShowCreateModal] = useState(false)
  const [editingNotice, setEditingNotice] = useState<AdminNoticeResponse | null>(null)
  const [notices, setNotices] = useState<AdminNoticeResponse[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [sortOrder, setSortOrder] = useState<SortOrder>('desc')

  const loadNotices = async () => {
    setIsLoading(true)
    const data = await adminService.listNotices().catch(() => null)
    setNotices(data ?? [])
    setIsLoading(false)
  }

  useEffect(() => {
    loadNotices()
  }, [])

  const toggleSort = () => {
    setSortOrder(getNextSortOrder)
  }

  const activeNotices = sortNoticesByDate(notices.filter(n => n.status === 'ACTIVE'), sortOrder)
  const draftNotices = sortNoticesByDate(notices.filter(n => n.status === 'DRAFT'), sortOrder)
  const archivedNotices = sortNoticesByDate(notices.filter(n => n.status === 'ARCHIVED'), sortOrder)

  const handleNoticeCreated = () => {
    setShowCreateModal(false)
    setEditingNotice(null)
    loadNotices()
  }

  const handleNoticeUpdated = (updatedNotice: AdminNoticeResponse) => {
    // Optimistically update the local state instead of re-fetching
    setNotices(prevNotices =>
      prevNotices.map(notice =>
        notice.id === updatedNotice.id ? updatedNotice : notice
      )
    )
  }

  const handleEditNotice = (notice: AdminNoticeResponse) => {
    setEditingNotice(notice)
    setShowCreateModal(true)
  }

  const handleCloseModal = () => {
    setShowCreateModal(false)
    setEditingNotice(null)
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold tracking-tight">System Notices</h2>
          <p className="text-muted-foreground mt-1">
            Create and manage notices for users across the platform
          </p>
        </div>
        {permissions.canCreateNotice && (
          <Button onClick={() => setShowCreateModal(true)}>
            <Bell className="h-4 w-4 mr-2" />
            Create Notice
          </Button>
        )}
      </div>

      {/* Tabs */}
      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <TabsList>
          <TabsTrigger value="active">
            {`Active (${activeNotices.length})`}
          </TabsTrigger>
          <TabsTrigger value="draft">
            {`Drafts (${draftNotices.length})`}
          </TabsTrigger>
          <TabsTrigger value="archived">
            {`Archived (${archivedNotices.length})`}
          </TabsTrigger>
        </TabsList>

        {isLoading ? (
          <Card className="p-12">
            <BrandLoader size="lg" message="Loading system notices..." />
          </Card>
        ) : (
          <>
            <TabsContent value="active">
              <Card className="w-full">
                <NoticeTable
                  notices={activeNotices}
                  emptyMessage="No active notices. Create one to get started."
                  sortOrder={sortOrder}
                  onToggleSort={toggleSort}
                  onUpdate={handleNoticeUpdated}
                  onEdit={handleEditNotice}
                  permissions={permissions}
                />
              </Card>
            </TabsContent>

            <TabsContent value="draft">
              <Card className="w-full">
                <NoticeTable
                  notices={draftNotices}
                  emptyMessage="No draft notices."
                  sortOrder={sortOrder}
                  onToggleSort={toggleSort}
                  onUpdate={handleNoticeUpdated}
                  onEdit={handleEditNotice}
                  permissions={permissions}
                />
              </Card>
            </TabsContent>

            <TabsContent value="archived">
              <Card className="w-full">
                <NoticeTable
                  notices={archivedNotices}
                  emptyMessage="No archived notices."
                  sortOrder={sortOrder}
                  onToggleSort={toggleSort}
                  onUpdate={handleNoticeUpdated}
                  onEdit={handleEditNotice}
                  permissions={permissions}
                />
              </Card>
            </TabsContent>
          </>
        )}
      </Tabs>

      {/* Create/Edit Notice Modal */}
      <NoticeFormModal
        open={showCreateModal}
        onClose={handleCloseModal}
        onSave={handleNoticeCreated}
        editNotice={editingNotice}
      />
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/common/__tests__/brand-loader.test.tsx
import { describe, expect, it, vi } from 'vitest'
import { render, screen } from '@testing-library/react'

vi.mock('lucide-react', () => ({
  Loader2: (props: Record<string, unknown>) => <span data-testid="loader-icon" className={props.className as string} />
}))

vi.mock('../../../lib/utils', () => ({
  cn: (...args: unknown[]) => args.filter(Boolean).join(' ')
}))

import { BrandLoader } from '../brand-loader'

describe('BrandLoader', () => {
  it('renders with default message from i18n', () => {
    render(<BrandLoader />)
    expect(screen.getByText('Loading your HSBC workspace\u2026')).toBeInTheDocument()
    expect(screen.getByRole('status')).toBeInTheDocument()
  })

  it('renders with custom message', () => {
    render(<BrandLoader message="Please wait..." />)
    expect(screen.getByText('Please wait...')).toBeInTheDocument()
  })

  it('renders the loader icon', () => {
    render(<BrandLoader />)
    expect(screen.getByTestId('loader-icon')).toBeInTheDocument()
  })

  it('applies size classes', () => {
    const { container, rerender } = render(<BrandLoader size="sm" />)
    expect(container.querySelector('[role="status"]')).toBeInTheDocument()

    rerender(<BrandLoader size="lg" />)
    expect(container.querySelector('[role="status"]')).toBeInTheDocument()
  })

  it('renders inline variant', () => {
    const { container } = render(<BrandLoader inline />)
    const status = container.querySelector('[role="status"]')
    expect(status?.className).toContain('flex-row')
  })

  it('applies custom className', () => {
    const { container } = render(<BrandLoader className="my-custom" />)
    const status = container.querySelector('[role="status"]')
    expect(status?.className).toContain('my-custom')
  })
})
===ENDFILE
===FILE: ./src/components/common/brand-loader.tsx
import { cn } from '@/lib/utils'
import { Loader2 } from 'lucide-react'

type LoaderSize = 'sm' | 'md' | 'lg'

interface BrandLoaderProps {
  message?: string
  size?: LoaderSize
  className?: string
  inline?: boolean
}

const ICON_SIZE_CLASSMAP: Record<LoaderSize, string> = {
  sm: 'h-4 w-4',
  md: 'h-6 w-6',
  lg: 'h-8 w-8'
}

const GAP_CLASSMAP: Record<LoaderSize, string> = {
  sm: 'gap-2',
  md: 'gap-3',
  lg: 'gap-4'
}

const TEXT_SIZE_CLASSMAP: Record<LoaderSize, string> = {
  sm: 'text-xs',
  md: 'text-sm',
  lg: 'text-base'
}

/**
 * HSBC branded loader used across all surfaces to maintain consistent experience.
 * Uses Loader2 icon from lucide-react as the standard HSBC spinner.
 * Always displays a message for better user feedback.
 */
export function BrandLoader({
  message,
  size = 'md',
  className,
  inline = false
}: Readonly<BrandLoaderProps>) {
  const containerClasses = cn(
    'flex items-center justify-center text-center',
    inline ? 'flex-row' : 'flex-col',
    inline ? 'gap-2' : GAP_CLASSMAP[size],
    className
  )

  const textClasses = cn(
    'font-medium tracking-wide text-foreground',
    TEXT_SIZE_CLASSMAP[size]
  )

  const displayMessage = message || 'Loading your HSBC workspace\u2026'

  return (
    <output className={containerClasses} aria-live="polite">
      <Loader2
        className={cn(
          'animate-spin text-[#DB0011]',
          ICON_SIZE_CLASSMAP[size]
        )}
        aria-hidden="true"
      />
      <span className={textClasses}>
        {displayMessage}
      </span>
    </output>
  )
}
===ENDFILE
===FILE: ./src/components/ui/__tests__/dialog.test.ts
import { beforeEach, describe, expect, it } from 'vitest'
import { getDialogPortalContainer } from '../dialog'

describe('getDialogPortalContainer', () => {
  beforeEach(() => {
    document.body.innerHTML = ''
  })

  it('returns undefined when admin root is missing', () => {
    expect(getDialogPortalContainer()).toBeUndefined()
  })

  it('returns the admin root element when present', () => {
    const root = document.createElement('div')
    root.className = 'admin-mfe-root'
    document.body.appendChild(root)

    expect(getDialogPortalContainer()).toBe(root)
  })
})
===ENDFILE
===FILE: ./src/components/ui/__tests__/ui-components.test.tsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'

// Test all UI wrapper components render without crashing
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '../card'
import { Badge } from '../badge'
import { Button } from '../button'
import { Input } from '../input'
import { Label } from '../label'
import { Textarea } from '../textarea'
import { Separator } from '../separator'
import { Skeleton } from '../skeleton'
import { Alert, AlertDescription } from '../alert'
import { Checkbox } from '../checkbox'
import { Switch } from '../switch'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '../table'
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '../tooltip'
import { Toggle } from '../toggle'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../tabs'

describe('UI Components', () => {
  describe('Card', () => {
    it('renders card with all sub-components', () => {
      render(
        <Card>
          <CardHeader><CardTitle>Title</CardTitle><CardDescription>Desc</CardDescription></CardHeader>
          <CardContent>Content</CardContent>
          <CardFooter>Footer</CardFooter>
        </Card>
      )
      expect(screen.getByText('Title')).toBeInTheDocument()
      expect(screen.getByText('Content')).toBeInTheDocument()
      expect(screen.getByText('Footer')).toBeInTheDocument()
    })
  })

  describe('Badge', () => {
    it('renders badge', () => {
      render(<Badge>Test Badge</Badge>)
      expect(screen.getByText('Test Badge')).toBeInTheDocument()
    })
  })

  describe('Button', () => {
    it('renders button', () => {
      render(<Button>Click Me</Button>)
      expect(screen.getByText('Click Me')).toBeInTheDocument()
    })
  })

  describe('Input', () => {
    it('renders input', () => {
      render(<Input placeholder="Type here" />)
      expect(screen.getByPlaceholderText('Type here')).toBeInTheDocument()
    })
  })

  describe('Label', () => {
    it('renders label', () => {
      render(<Label>My Label</Label>)
      expect(screen.getByText('My Label')).toBeInTheDocument()
    })
  })

  describe('Textarea', () => {
    it('renders textarea', () => {
      render(<Textarea placeholder="Enter text" />)
      expect(screen.getByPlaceholderText('Enter text')).toBeInTheDocument()
    })
  })

  describe('Separator', () => {
    it('renders separator', () => {
      const { container } = render(<Separator />)
      expect(container.firstChild).toBeTruthy()
    })
  })

  describe('Skeleton', () => {
    it('renders skeleton', () => {
      const { container } = render(<Skeleton className="h-4 w-20" />)
      expect(container.firstChild).toBeTruthy()
    })
  })

  describe('Alert', () => {
    it('renders alert with children', () => {
      render(
        <Alert>
          <AlertDescription>Alert Description</AlertDescription>
        </Alert>
      )
      expect(screen.getByText('Alert Description')).toBeInTheDocument()
    })
  })

  describe('Checkbox', () => {
    it('renders checkbox', () => {
      const { container } = render(<Checkbox />)
      expect(container.querySelector('button')).toBeTruthy()
    })
  })

  describe('Switch', () => {
    it('renders switch', () => {
      const { container } = render(<Switch />)
      expect(container.querySelector('button')).toBeTruthy()
    })
  })

  describe('Table', () => {
    it('renders table with rows', () => {
      render(
        <Table>
          <TableHeader>
            <TableRow><TableHead>Name</TableHead></TableRow>
          </TableHeader>
          <TableBody>
            <TableRow><TableCell>John</TableCell></TableRow>
          </TableBody>
        </Table>
      )
      expect(screen.getByText('Name')).toBeInTheDocument()
      expect(screen.getByText('John')).toBeInTheDocument()
    })
  })

  describe('Tooltip', () => {
    it('renders tooltip provider and trigger', () => {
      render(
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger>Hover me</TooltipTrigger>
            <TooltipContent>Tooltip text</TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )
      expect(screen.getByText('Hover me')).toBeInTheDocument()
    })
  })

  describe('Toggle', () => {
    it('renders toggle', () => {
      render(<Toggle>Toggle Me</Toggle>)
      expect(screen.getByText('Toggle Me')).toBeInTheDocument()
    })
  })

  describe('Tabs', () => {
    it('renders tabs', () => {
      render(
        <Tabs defaultValue="tab1">
          <TabsList>
            <TabsTrigger value="tab1">Tab 1</TabsTrigger>
            <TabsTrigger value="tab2">Tab 2</TabsTrigger>
          </TabsList>
          <TabsContent value="tab1">Content 1</TabsContent>
          <TabsContent value="tab2">Content 2</TabsContent>
        </Tabs>
      )
      expect(screen.getByText('Tab 1')).toBeInTheDocument()
      expect(screen.getByText('Content 1')).toBeInTheDocument()
    })
  })
})
===ENDFILE
===FILE: ./src/components/ui/accordion.tsx
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "../../lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ComponentRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ComponentRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ComponentRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
===ENDFILE
===FILE: ./src/components/ui/alert-dialog.tsx
import * as React from "react"
import { Button } from "./button"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "./dialog"

interface AlertDialogProps {
  open?: boolean
  onOpenChange?: (open: boolean) => void
  children: React.ReactNode
}

export function AlertDialog({ open, onOpenChange, children }: Readonly<AlertDialogProps>) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      {children}
    </Dialog>
  )
}

export function AlertDialogContent({ children, ...props }: React.ComponentProps<typeof DialogContent>) {
  return <DialogContent {...props}>{children}</DialogContent>
}

export function AlertDialogHeader({ children, ...props }: React.ComponentProps<typeof DialogHeader>) {
  return <DialogHeader {...props}>{children}</DialogHeader>
}

export function AlertDialogTitle({ children, ...props }: React.ComponentProps<typeof DialogTitle>) {
  return <DialogTitle {...props}>{children}</DialogTitle>
}

export function AlertDialogDescription({ children, ...props }: React.ComponentProps<typeof DialogDescription>) {
  return <DialogDescription {...props}>{children}</DialogDescription>
}

export function AlertDialogFooter({ children, ...props }: React.ComponentProps<typeof DialogFooter>) {
  return <DialogFooter {...props}>{children}</DialogFooter>
}

export function AlertDialogCancel({ children, ...props }: React.ComponentProps<typeof Button>) {
  return <Button variant="outline" {...props}>{children}</Button>
}

export function AlertDialogAction({ children, ...props }: React.ComponentProps<typeof Button>) {
  return <Button {...props}>{children}</Button>
}
===ENDFILE
===FILE: ./src/components/ui/alert.tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "../../lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, children, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  >{children}</h5>
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertDescription }
===ENDFILE
===FILE: ./src/components/ui/badge.tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: Readonly<BadgeProps>) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge }
===ENDFILE
===FILE: ./src/components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors will-change-[background-color,color] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.memo(
  React.forwardRef<HTMLButtonElement, ButtonProps>(
    ({ className, variant, size, asChild = false, ...props }, ref) => {
      const Comp = asChild ? Slot : "button"
      return (
        <Comp
          className={cn(buttonVariants({ variant, size, className }))}
          ref={ref}
          {...props}
        />
      )
    }
  )
)
Button.displayName = "Button"

export { Button }
===ENDFILE
===FILE: ./src/components/ui/card.tsx
import * as React from "react"

import { cn } from "../../lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

interface CardTitleProps extends React.HTMLAttributes<HTMLHeadingElement> {
  as?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'div'
}

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  CardTitleProps
>(({ className, as: Component = 'h3', ...props }, ref) => (
  <Component
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.memo(
  React.forwardRef<
    HTMLDivElement,
    React.HTMLAttributes<HTMLDivElement>
  >(({ className, ...props }, ref) => (
    <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
  ))
)
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
===ENDFILE
===FILE: ./src/components/ui/checkbox.tsx
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { cn } from "../../lib/utils"
import { CheckIcon } from "@radix-ui/react-icons"

const Checkbox = React.forwardRef<
  React.ComponentRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <CheckIcon className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
===ENDFILE
===FILE: ./src/components/ui/collapsible.tsx
import * as CollapsiblePrimitive from '@radix-ui/react-collapsible'

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
===ENDFILE
===FILE: ./src/components/ui/date-time-picker.tsx
'use client'

import { useEffect, useMemo, useState } from 'react'
import * as PopoverPrimitive from '@radix-ui/react-popover'
import { CalendarIcon, ChevronLeft, ChevronRight } from 'lucide-react'
import {
  addDays,
  addMonths,
  endOfMonth,
  endOfWeek,
  format,
  isBefore,
  isSameDay,
  isSameMonth,
  isToday,
  startOfDay,
  startOfMonth,
  startOfWeek
} from 'date-fns'

import { Button } from './button'
import { Label } from './label'
import { ScrollArea } from './scroll-area'
import { cn } from '../../lib/utils'
import { getDialogPortalContainer } from './dialog'

const DEFAULT_TIME_SLOTS = [
  { time: '09:00', available: false },
  { time: '09:30', available: false },
  { time: '10:00', available: true },
  { time: '10:30', available: true },
  { time: '11:00', available: true },
  { time: '11:30', available: true },
  { time: '12:00', available: false },
  { time: '12:30', available: true },
  { time: '13:00', available: true },
  { time: '13:30', available: true },
  { time: '14:00', available: true },
  { time: '14:30', available: false },
  { time: '15:00', available: false },
  { time: '15:30', available: true },
  { time: '16:00', available: true },
  { time: '16:30', available: true },
  { time: '17:00', available: true },
  { time: '17:30', available: true },
  { time: '18:00', available: true },
  { time: '18:30', available: true },
  { time: '19:00', available: true },
  { time: '19:30', available: true },
  { time: '20:00', available: true },
  { time: '20:30', available: true },
  { time: '21:00', available: true },
  { time: '21:30', available: true },
  { time: '22:00', available: true },
  { time: '22:30', available: true },
  { time: '23:00', available: true },
  { time: '23:30', available: true }
] as const

const WEEKDAY_LABELS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] as const

const toLocalDateTimeValue = (date: Date, time: string) => {
  const [hours, minutes] = time.split(':').map(Number)
  const withTime = new Date(date)
  withTime.setHours(hours, minutes, 0, 0)
  const year = withTime.getFullYear()
  const month = String(withTime.getMonth() + 1).padStart(2, '0')
  const day = String(withTime.getDate()).padStart(2, '0')
  const hour = String(withTime.getHours()).padStart(2, '0')
  const minute = String(withTime.getMinutes()).padStart(2, '0')
  return `${year}-${month}-${day}T${hour}:${minute}`
}

const parseLocalDateTime = (value?: string | null) => {
  if (!value) {
    return { date: null, time: null }
  }

  const parsed = new Date(value)
  if (Number.isNaN(parsed.getTime())) {
    return { date: null, time: null }
  }

  const timePart = value.includes('T') ? value.split('T')[1]?.slice(0, 5) ?? null : null
  return {
    date: parsed,
    time: timePart
  }
}

const formatTimeLabel = (time: string) => {
  const [hours, minutes] = time.split(':').map(Number)
  const base = new Date()
  base.setHours(hours, minutes, 0, 0)
  return format(base, 'p')
}

interface DateTimePickerProps {
  id: string
  label: string
  value?: string
  onChange: (value: string | undefined) => void
  minDate?: Date
  placeholder?: string
  timeSlots?: readonly { time: string; available: boolean }[]
}

export function DateTimePicker({
  id,
  label,
  value,
  onChange,
  minDate,
  placeholder,
  timeSlots = DEFAULT_TIME_SLOTS
}: Readonly<DateTimePickerProps>) {
  const normalizedMinDate = useMemo(() => (minDate ? startOfDay(minDate) : undefined), [minDate])
  const [open, setOpen] = useState(false)
  const [selectedDate, setSelectedDate] = useState<Date | null>(null)
  const [selectedTime, setSelectedTime] = useState<string | null>(null)
  const [currentMonth, setCurrentMonth] = useState<Date>(() => normalizedMinDate ?? startOfDay(new Date()))

  useEffect(() => {
    const { date, time } = parseLocalDateTime(value)
    setSelectedDate(date)
    setSelectedTime(time)
    if (date) {
      setCurrentMonth(date)
    } else if (normalizedMinDate) {
      setCurrentMonth(normalizedMinDate)
    }
  }, [value, normalizedMinDate])

  const calendarDays = useMemo(() => {
    const monthStart = startOfMonth(currentMonth)
    const rangeStart = startOfWeek(monthStart, { weekStartsOn: 0 })
    const rangeEnd = endOfWeek(endOfMonth(currentMonth), { weekStartsOn: 0 })
    const days: Date[] = []
    let cursor = rangeStart

    while (cursor <= rangeEnd) {
      days.push(cursor)
      cursor = addDays(cursor, 1)
    }

    return days
  }, [currentMonth])

  const isDateDisabled = (day: Date) => {
    if (!normalizedMinDate) {
      return false
    }

    const dayStart = startOfDay(day)
    if (selectedDate && isSameDay(dayStart, selectedDate)) {
      return false
    }

    return isBefore(dayStart, normalizedMinDate)
  }

  const handleDateSelect = (day: Date) => {
    const dayStart = startOfDay(day)
    if (isDateDisabled(dayStart)) {
      return
    }

    const isSameAsCurrent = selectedDate ? isSameDay(dayStart, selectedDate) : false
    setSelectedDate(dayStart)
    setCurrentMonth(dayStart)

    if (!isSameAsCurrent && selectedTime) {
      setSelectedTime(null)
      onChange(undefined)
    }
  }

  const handleMonthChange = (direction: 1 | -1) => {
    setCurrentMonth(addMonths(currentMonth, direction))
  }

  const handleTimeSelect = (timeValue: string) => {
    if (!selectedDate) {
      return
    }

    setSelectedTime(timeValue)
    onChange(toLocalDateTimeValue(selectedDate, timeValue))
    setOpen(false)
  }

  const handleClear = () => {
    setSelectedDate(null)
    setSelectedTime(null)
    onChange(undefined)
    setCurrentMonth(normalizedMinDate ?? startOfDay(new Date()))
    setOpen(false)
  }

  const timeLabel = selectedTime ? `  ${formatTimeLabel(selectedTime)}` : ''
  const formattedDate = selectedDate ? `${format(selectedDate, 'PPP')}${timeLabel}` : null
  const displayText = formattedDate ?? placeholder ?? 'Pick a date and time'

  return (
    <div className="space-y-2">
      <Label htmlFor={id}>{label}</Label>
      <PopoverPrimitive.Root open={open} onOpenChange={setOpen}>
        <PopoverPrimitive.Trigger asChild>
          <Button
            id={id}
            type="button"
            variant="outline"
            className="w-full justify-between gap-2 text-left font-normal"
          >
            <span className="flex items-center gap-2">
              <CalendarIcon className="h-4 w-4 text-primary" />
              <span className={selectedDate ? 'text-foreground' : 'text-muted-foreground'}>
                {displayText}
              </span>
            </span>
          </Button>
        </PopoverPrimitive.Trigger>
        <PopoverPrimitive.Portal container={getDialogPortalContainer()}>
          <PopoverPrimitive.Content
            align="start"
            sideOffset={8}
            collisionPadding={16}
            className="z-50 w-auto max-w-[calc(100vw-2rem)] rounded-md border bg-popover p-0 text-popover-foreground shadow-lg outline-none"
          >
            <div className="flex flex-col sm:flex-row">
              <div className="p-4 sm:pr-5">
                <div className="flex items-center justify-between pb-4">
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    aria-label="Previous month"
                    onClick={() => handleMonthChange(-1)}
                  >
                    <ChevronLeft className="h-4 w-4" />
                  </Button>
                  <span className="text-sm font-semibold">{format(currentMonth, 'MMMM yyyy')}</span>
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    aria-label="Next month"
                    onClick={() => handleMonthChange(1)}
                  >
                    <ChevronRight className="h-4 w-4" />
                  </Button>
                </div>
                <div className="grid grid-cols-7 gap-1 text-center text-xs text-muted-foreground">
                  {WEEKDAY_LABELS.map(dayLabel => (
                    <span key={dayLabel} className="rounded-md py-1">
                      {dayLabel}
                    </span>
                  ))}
                </div>
                <div className="grid grid-cols-7 gap-1 pt-1">
                  {calendarDays.map(day => {
                    const dayStart = startOfDay(day)
                    const disabled = isDateDisabled(dayStart)
                    const selected = selectedDate ? isSameDay(dayStart, selectedDate) : false
                    const outsideMonth = !isSameMonth(dayStart, currentMonth)
                    const today = isToday(dayStart)

                    return (
                      <button
                        key={dayStart.getTime()}
                        type="button"
                        onClick={() => handleDateSelect(dayStart)}
                        disabled={disabled}
                        className={cn(
                          'flex h-9 w-9 items-center justify-center rounded-md text-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background',
                          disabled && 'cursor-not-allowed opacity-40',
                          selected && 'bg-primary text-primary-foreground hover:bg-primary/90',
                          !selected && today && 'border border-primary/50 text-primary',
                          !selected && !today && 'hover:bg-accent hover:text-accent-foreground',
                          outsideMonth && !selected && 'text-muted-foreground/50'
                        )}
                      >
                        {format(dayStart, 'd')}
                      </button>
                    )
                  })}
                </div>
                <div className="mt-3 flex justify-between">
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={handleClear}
                    disabled={!selectedDate && !selectedTime}
                  >
                    Clear
                  </Button>
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() => selectedDate && setCurrentMonth(selectedDate)}
                    disabled={!selectedDate}
                  >
                    Jump to date
                  </Button>
                </div>
              </div>
              <div className="relative w-full border-t sm:w-48 sm:border-l sm:border-t-0">
                <ScrollArea className="h-64 sm:h-72">
                  <div className="space-y-3 p-4">
                    <div className="flex h-5 items-center">
                      <p className={cn(
                        "text-xs sm:text-sm font-medium truncate",
                        selectedDate ? "text-foreground" : "text-muted-foreground"
                      )}>
                        {selectedDate ? format(selectedDate, 'EEEE, MMM d') : 'Select a date to view times'}
                      </p>
                    </div>
                    <div className="grid gap-2 grid-cols-2 sm:grid-cols-1">
                      {timeSlots.map(({ time: timeSlot, available }) => (
                        <Button
                          key={timeSlot}
                          type="button"
                          variant={selectedTime === timeSlot ? 'default' : 'outline'}
                          size="sm"
                          className={cn(
                            'justify-center',
                            selectedTime === timeSlot && 'bg-primary text-primary-foreground hover:bg-primary/90'
                          )}
                          onClick={() => handleTimeSelect(timeSlot)}
                          disabled={!selectedDate || !available}
                        >
                          {formatTimeLabel(timeSlot)}
                        </Button>
                      ))}
                    </div>
                  </div>
                </ScrollArea>
              </div>
            </div>
          </PopoverPrimitive.Content>
        </PopoverPrimitive.Portal>
      </PopoverPrimitive.Root>
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/ui/dialog.tsx
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { Cross2Icon } from "@radix-ui/react-icons"

import { cn } from "../../lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

function getDialogPortalContainer(): HTMLElement | undefined {
  if (typeof document === 'undefined') {
    return undefined
  }

  return document.querySelector<HTMLElement>('.admin-mfe-root') ?? undefined
}

const DialogOverlay = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => {
  const portalContainer = getDialogPortalContainer()

  return (
    <DialogPortal container={portalContainer}>
      <DialogOverlay />
      <DialogPrimitive.Content
        ref={ref}
        className={cn(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
          <Cross2Icon className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
})
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
  getDialogPortalContainer,
}
===ENDFILE
===FILE: ./src/components/ui/input.tsx
import * as React from "react"

import { cn } from "../../lib/utils"

type InputProps = React.InputHTMLAttributes<HTMLInputElement>

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
===ENDFILE
===FILE: ./src/components/ui/label.tsx
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ComponentRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
===ENDFILE
===FILE: ./src/components/ui/scroll-area.tsx
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "../../lib/utils"

interface ScrollAreaProps extends React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root> {
  showVerticalScrollbar?: boolean
}

const ScrollArea = React.forwardRef<
  React.ComponentRef<typeof ScrollAreaPrimitive.Root>,
  ScrollAreaProps
>(({ className, children, showVerticalScrollbar = true, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    type="always"
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    {showVerticalScrollbar ? (
      <>
        <ScrollBar />
        <ScrollAreaPrimitive.Corner />
      </>
    ) : null}
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ComponentRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-border/60 bg-background/95 p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-gray-400/70 hover:bg-gray-500/80 transition-colors" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
===ENDFILE
===FILE: ./src/components/ui/select.tsx
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "../../lib/utils"
import { getDialogPortalContainer } from "./dialog"

const Select = SelectPrimitive.Root

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => {
  const portalContainer = getDialogPortalContainer()

  return (
  <SelectPrimitive.Portal container={portalContainer}>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
  )
})
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ComponentRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectItem,
}
===ENDFILE
===FILE: ./src/components/ui/separator.tsx
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "../../lib/utils"

const Separator = React.forwardRef<
  React.ComponentRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
===ENDFILE
===FILE: ./src/components/ui/sheet.tsx
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"
import { getDialogPortalContainer } from "./dialog"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetOverlay = React.forwardRef<
  React.ComponentRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ComponentRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => {
  const portalContainer = getDialogPortalContainer()

  return (
    <SheetPrimitive.Portal container={portalContainer}>
      <SheetOverlay />
      <SheetPrimitive.Content
        ref={ref}
        className={cn(sheetVariants({ side }), className)}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
          <X className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPrimitive.Portal>
  )
})
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ComponentRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ComponentRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetTrigger,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
===ENDFILE
===FILE: ./src/components/ui/skeleton.tsx
import { cn } from "../../lib/utils"

function Skeleton({
  className,
  ...props
}: Readonly<React.HTMLAttributes<HTMLDivElement>>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  )
}

export { Skeleton }
===ENDFILE
===FILE: ./src/components/ui/switch.tsx
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "../../lib/utils"

const Switch = React.forwardRef<
  React.ComponentRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
===ENDFILE
===FILE: ./src/components/ui/table.tsx
import * as React from "react"

import { cn } from "../../lib/utils"
import { ScrollArea, ScrollBar } from "./scroll-area"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <ScrollArea className="relative h-full w-full">
    <table
      ref={ref}
      role="table"
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
    <ScrollBar orientation="horizontal" />
  </ScrollArea>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    scope="col"
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableHead,
  TableRow,
  TableCell,
}
===ENDFILE
===FILE: ./src/components/ui/tabs.tsx
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "../../lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ComponentRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ComponentRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ComponentRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
===ENDFILE
===FILE: ./src/components/ui/textarea.tsx
import * as React from "react"
import { cn } from "../../lib/utils"

type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
===ENDFILE
===FILE: ./src/components/ui/toast.tsx
import React from "react"
import { cn } from "../../lib/utils"
import {
  CircleCheck,
  CircleAlert,
  ShieldAlert,
  Info,
  X
} from "lucide-react"

export type ToastVariant = "info" | "success" | "warning" | "error" | "critical"

export interface ToastProps {
  id: string
  title?: string
  description?: string
  action?: React.ReactNode
  variant?: ToastVariant
  onClose?: () => void
  duration?: number
  persistent?: boolean
  metaKey?: string
}

const VARIANT_STYLES: Record<ToastVariant, {
  container: string
  accentBar: string
  iconWrap: string
  icon: string
  title: string
  description: string
  action?: string
}> = {
  info: {
    container: "bg-white/95 border border-slate-200",
    accentBar: "bg-slate-500/70",
    iconWrap: "bg-slate-100 text-slate-600",
    icon: "text-slate-700",
    title: "text-slate-900",
    description: "text-slate-600",
    action: "text-slate-600 hover:text-slate-900"
  },
  success: {
    container: "bg-white border-green-500",
    accentBar: "bg-green-500",
    iconWrap: "bg-green-50 text-green-600",
    icon: "text-green-600",
    title: "text-[#333333] font-semibold",
    description: "text-[#666666]",
    action: "text-green-700 hover:text-green-900"
  },
  warning: {
    container: "bg-white border border-amber-100",
    accentBar: "bg-amber-500",
    iconWrap: "bg-amber-50 text-amber-600",
    icon: "text-amber-600",
    title: "text-amber-900",
    description: "text-amber-700",
    action: "text-amber-700 hover:text-amber-900"
  },
  error: {
    container: "bg-white border border-red-200",
    accentBar: "bg-red-600",
    iconWrap: "bg-red-50 text-red-600",
    icon: "text-red-600",
    title: "text-red-900",
    description: "text-red-700",
    action: "text-red-700 hover:text-red-900"
  },
  critical: {
    container: "bg-red-50 border border-red-200",
    accentBar: "bg-red-700",
    iconWrap: "bg-red-100 text-red-700",
    icon: "text-red-700",
    title: "text-red-950",
    description: "text-red-900",
    action: "text-red-900 hover:text-red-950"
  }
}

const VARIANT_ICON: Record<ToastVariant, React.ComponentType<{ className?: string }>> = {
  info: Info,
  success: CircleCheck,
  warning: CircleAlert,
  error: CircleAlert,
  critical: ShieldAlert
}

export function Toast({
  title,
  description,
  action,
  variant = "info",
  onClose,
}: Readonly<ToastProps>) {
  const styles = VARIANT_STYLES[variant]
  const Icon = VARIANT_ICON[variant]

  return (
    <output
      role={variant === "error" || variant === "critical" ? "alert" : undefined}
      aria-live={variant === "error" || variant === "critical" ? "assertive" : "polite"}
      className={cn(
        "relative flex w-full items-start gap-3 overflow-hidden rounded-lg p-4 shadow-lg transition-all",
        "pointer-events-auto bg-white border-2",
        styles.container
      )}
    >
      <span className={cn("absolute left-0 top-0 h-full w-1.5", styles.accentBar)} aria-hidden />
      <div className={cn("mt-0.5 flex h-9 w-9 flex-shrink-0 items-center justify-center rounded-full", styles.iconWrap)}>
        <Icon className={cn("h-4 w-4", styles.icon)} />
      </div>
      <div className="flex min-w-0 flex-1 flex-col gap-1">
        {title && <p className={cn("text-sm font-semibold", styles.title)}>{title}</p>}
        {description && (
          <p className={cn("text-sm leading-snug break-words", styles.description)}>{description}</p>
        )}
        {action && <div className={cn("text-xs font-medium", styles.action)}>{action}</div>}
      </div>
      {onClose && (
        <button
          onClick={onClose}
          className="ml-2 inline-flex h-7 w-7 items-center justify-center rounded-full text-slate-400 transition hover:bg-slate-100 hover:text-slate-800"
          aria-label="Dismiss notification"
        >
          <X className="h-4 w-4" />
        </button>
      )}
    </output>
  )
}

export function ToastContainer({ children }: Readonly<{ children: React.ReactNode }>) {
  const count = React.Children.count(children)
  if (count === 0) return null

  return (
    <div className="pointer-events-none fixed right-6 top-20 z-[999] flex max-h-[70vh] w-full max-w-sm flex-col gap-3 overflow-y-auto pr-1 sm:right-10">
      {React.Children.map(children, (child) => (
        <div className="pointer-events-auto w-full animate-notification-drawer">
          {child}
        </div>
      ))}
    </div>
  )
}
===ENDFILE
===FILE: ./src/components/ui/toggle-group.tsx
import * as React from 'react'
import * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group'
import { VariantProps } from 'class-variance-authority'

import { cn } from '../../lib/utils'
import { toggleVariants } from './toggle'

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: 'default',
  variant: 'default',
})

const ToggleGroup = React.forwardRef<
  React.ComponentRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => {
  const contextValue = React.useMemo(() => ({ variant, size }), [variant, size])
  return (
    <ToggleGroupPrimitive.Root
      ref={ref}
      className={cn('flex items-center justify-center gap-1', className)}
      {...props}
    >
      <ToggleGroupContext.Provider value={contextValue}>
        {children}
      </ToggleGroupContext.Provider>
    </ToggleGroupPrimitive.Root>
  )
})

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ComponentRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }
===ENDFILE
===FILE: ./src/components/ui/toggle.tsx
import * as React from 'react'
import * as TogglePrimitive from '@radix-ui/react-toggle'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '../../lib/utils'

const toggleVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground',
  {
    variants: {
      variant: {
        default: 'bg-transparent',
        outline:
          'border border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
      },
      size: {
        default: 'h-10 px-3',
        sm: 'h-9 px-2.5',
        lg: 'h-11 px-5',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

const Toggle = React.forwardRef<
  React.ComponentRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }
===ENDFILE
===FILE: ./src/components/ui/tooltip.tsx
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"
import { cn } from "../../lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ComponentRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
===ENDFILE
===FILE: ./src/constants/__tests__/permission-levels.test.ts
import { describe, expect, it } from 'vitest'
import { permissionLevels } from '../permission-levels'

describe('permissionLevels', () => {
  it('exports exactly 2 sections', () => {
    const sections = Object.keys(permissionLevels)
    expect(sections).toEqual(['capabilities', 'workspacePreferences'])
  })

  it('each section has required config properties', () => {
    Object.entries(permissionLevels).forEach(([key, config]) => {
      expect(config.title).toBeTruthy()
      expect(typeof config.title).toBe('string')
      expect(config.description).toBeTruthy()
      expect(typeof config.description).toBe('string')
      expect(config.icon).toBeDefined()
      expect(['function', 'object']).toContain(typeof config.icon)
      expect(config.businessNames).toBeDefined()
      expect(typeof config.businessNames).toBe('object')
    })
  })

  it('businessNames values are non-empty strings', () => {
    Object.entries(permissionLevels).forEach(([, config]) => {
      Object.entries(config.businessNames).forEach(([key, name]) => {
        expect(typeof name).toBe('string')
        expect(name.length).toBeGreaterThan(0)
      })
    })
  })

  it('capabilities section contains column and micro_frontends prefixed keys only', () => {
    const businessNames = permissionLevels.capabilities.businessNames
    const keys = Object.keys(businessNames)

    const columnKeys = keys.filter(k => k.startsWith('columns.'))
    const mfKeys = keys.filter(k => k.startsWith('micro_frontends.'))

    expect(columnKeys.length).toBeGreaterThan(0)
    expect(mfKeys.length).toBeGreaterThan(0)
    // No features.* keys (those are linked, not displayed)
    expect(keys.filter(k => k.startsWith('features.')).length).toBe(0)
  })

  it('workspacePreferences section contains only settings_options keys', () => {
    const businessNames = permissionLevels.workspacePreferences.businessNames
    const keys = Object.keys(businessNames)

    const optionKeys = keys.filter(k => k.startsWith('settings_options.'))
    expect(optionKeys.length).toBe(keys.length)
    // No widgets.* or settings_tabs.* keys
    expect(keys.filter(k => k.startsWith('widgets.')).length).toBe(0)
    expect(keys.filter(k => k.startsWith('settings_tabs.')).length).toBe(0)
  })

  it('each section has a unique icon', () => {
    const icons = Object.values(permissionLevels).map(c => c.icon)
    const uniqueIcons = new Set(icons)
    expect(uniqueIcons.size).toBe(icons.length)
  })

  it('capabilities has 5 business names', () => {
    expect(Object.keys(permissionLevels.capabilities.businessNames).length).toBe(5)
  })

  it('workspacePreferences has 5 business names', () => {
    expect(Object.keys(permissionLevels.workspacePreferences.businessNames).length).toBe(5)
  })
})
===ENDFILE
===FILE: ./src/constants/permission-levels.ts
import {
  Shield,
  Sliders,
  type LucideIcon
} from 'lucide-react'

interface PermissionLevelConfig {
  title: string
  description: string
  icon: LucideIcon
  businessNames: Record<string, string>
}

export const permissionLevels: Record<string, PermissionLevelConfig> = {
  capabilities: {
    title: 'Access Controls',
    description: 'Platform capabilities, dashboard panels, and applications',
    icon: Shield,
    businessNames: {
      'columns.kms': 'Knowledge Base',
      'columns.embeddedApps': 'Banking Applications',
      'columns.spaceCopilot': 'AI Assistant',
      'columns.chat': 'Chat Interface',
      'micro_frontends.mediaBar': 'Media Controls'
    }
  },

  workspacePreferences: {
    title: 'Workspace & Preferences',
    description: 'User preferences and workspace configuration',
    icon: Sliders,
    businessNames: {
      'settings_options.calls.autoAccept': 'Auto-Accept Calls',
      'settings_options.calls.doNotDisturb.duration': 'Do Not Disturb',
      'settings_options.interface.showTranscript': 'Show Transcripts',
      'settings_options.interface.autoCloseKnowledgeOnCallEnd': 'Auto-Close Knowledge',
      'settings_options.interface.spaceCopilotMode': 'AI Assistant Mode'
    }
  }
}
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-ad-group-form.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: (fn: () => void) => fn(),
  useCallback: (fn: (...args: unknown[]) => unknown) => fn
}))

const mockFetchAdGroupData = vi.fn()
const mockUpdateAdGroupConfig = vi.fn()
const mockApplyRoleTemplate = vi.fn()
const mockGetRoleTemplateByName = vi.fn()

vi.mock('../../api/use-ad-group-api', () => ({
  useAdGroupApi: () => ({
    isLoading: false,
    fetchAdGroupData: (...args: unknown[]) => mockFetchAdGroupData(...args),
    updateAdGroupConfig: (...args: unknown[]) => mockUpdateAdGroupConfig(...args),
    applyRoleTemplate: (...args: unknown[]) => mockApplyRoleTemplate(...args)
  })
}))

vi.mock('../../../services/api/role-template.service', () => ({
  getRoleTemplateByName: (...args: unknown[]) => mockGetRoleTemplateByName(...args)
}))

vi.mock('../../../utils/core/debug', () => ({
  createLogger: () => ({
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
    debug: vi.fn()
  })
}))

const { useAdGroupForm } = await import('../use-ad-group-form')

const baseGroup = {
  id: 'g1',
  groupIdentifier: 'CN=test-group',
  logicalName: 'Test Group',
  roleName: 'voice_agent',
  isActive: true,
  market: 'HK',
  region: 'APAC',
  country: 'HK'
}

const roleTemplateResponse = {
  roleNameCode: 'voice_agent',
  roleDisplayName: 'Voice Agent',
  columns: { kms: { stateText: 'enabled' } },
  widgets: { timer: { stateText: 'disabled' } },
  features: { 'search.knowledgeBase': { stateText: 'enabled' } },
  settingsTabs: { help: { stateText: 'enabled' } },
  settingsOptions: { 'calls.autoAccept': { stateText: 'disabled' } },
  microFrontends: { mediaBar: { stateText: 'enabled' } }
}

function callHook(overrides: Record<string, unknown> = {}) {
  stateIndex = 0
  return useAdGroupForm({
    initialGroup: { ...baseGroup, ...overrides } as any,
    open: true,
    ...overrides
  } as any)
}

describe('useAdGroupForm', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
    mockFetchAdGroupData.mockResolvedValue(null)
    mockGetRoleTemplateByName.mockResolvedValue(roleTemplateResponse)
  })

  it('initializes form data from initialGroup', () => {
    const result = callHook()
    expect(result.formData.groupIdentifier).toBe('CN=test-group')
    expect(result.formData.logicalName).toBe('Test Group')
  })

  it('initializes with empty permission overrides', () => {
    const result = callHook()
    expect(result.permissionOverrides).toEqual({})
  })

  it('initializes pending changes with empty permissions', () => {
    const result = callHook()
    expect(result.pendingChanges).toEqual({ permissions: {} })
  })

  it('loads and transforms role template when roleName is set', async () => {
    callHook()

    await vi.waitFor(() => {
      expect(callHook().roleTemplate?.roleName).toBe('voice_agent')
    })

    const result = callHook()
    expect(result.roleTemplate?.roleName).toBe('voice_agent')
    expect(result.roleTemplate?.roleDisplayName).toBe('Voice Agent')
    expect(result.roleTemplate?.columns?.kms?.state).toBe('enabled')
    expect(result.roleTemplate?.widgets?.timer?.state).toBe('disabled')
    expect(result.roleTemplate?.settings_tabs?.help?.state).toBe('enabled')
    expect(result.roleTemplate?.settings_options?.['calls.autoAccept']?.state).toBe('disabled')
    expect(result.roleTemplate?.micro_frontends?.mediaBar?.state).toBe('enabled')
  })

  it('sets roleTemplate to null when no roleName', () => {
    const result = callHook({ roleName: undefined })
    expect(result.roleTemplate).toBeNull()
  })

  describe('updateFormData', () => {
    it('updates form data with partial updates', () => {
      callHook()
      const { updateFormData } = callHook()
      updateFormData({ logicalName: 'Updated Name' })
      const result = callHook()
      expect(result.formData.logicalName).toBe('Updated Name')
    })
  })

  describe('updatePermissionOverrides', () => {
    it('updates permission overrides', () => {
      callHook()
      const { updatePermissionOverrides } = callHook()
      updatePermissionOverrides({ columns: { kms: true, search: false } })
      const result = callHook()
      expect(result.permissionOverrides.columns).toEqual({ kms: true, search: false })
    })

    it('merges with existing overrides', () => {
      callHook()
      const { updatePermissionOverrides: update1 } = callHook()
      update1({ columns: { kms: true } })
      const { updatePermissionOverrides: update2 } = callHook()
      update2({ widgets: { timer: false } })
      const result = callHook()
      expect(result.permissionOverrides.columns).toEqual({ kms: true })
      expect(result.permissionOverrides.widgets).toEqual({ timer: false })
    })
  })

  describe('handleApplyRoleTemplate', () => {
    it('clears overrides and pending changes on success', async () => {
      mockApplyRoleTemplate.mockResolvedValue({ groupIdentifier: 'CN=test-group' })
      mockGetRoleTemplateByName.mockResolvedValue({
        ...roleTemplateResponse,
        roleNameCode: 'chat_agent',
        roleDisplayName: 'Chat Agent'
      })

      callHook()
      const { updatePermissionOverrides } = callHook()
      updatePermissionOverrides({ columns: { kms: true } })
      const { handleApplyRoleTemplate } = callHook()
      await handleApplyRoleTemplate('chat_agent')

      await vi.waitFor(() => {
        callHook()
        expect(mockGetRoleTemplateByName).toHaveBeenCalledWith('chat_agent')
      })

      const result = callHook()
      expect(result.formData.roleName).toBe('chat_agent')
      expect(result.permissionOverrides).toEqual({})
      expect(result.pendingChanges).toEqual({ permissions: {} })
      expect(result.roleTemplate?.roleName).toBe('chat_agent')
    })

    it('does not clear overrides when apply returns null', async () => {
      mockApplyRoleTemplate.mockResolvedValue(null)

      callHook()
      const { updatePermissionOverrides } = callHook()
      updatePermissionOverrides({ columns: { kms: true } })
      const { handleApplyRoleTemplate } = callHook()
      await handleApplyRoleTemplate('chat_agent')

      const result = callHook()
      expect(result.permissionOverrides).toEqual({ columns: { kms: true } })
    })
  })

  describe('fetchAdGroupData on open', () => {
    it('loads saved group data and converts assignments to overrides', async () => {
      mockFetchAdGroupData.mockResolvedValue({
        ...baseGroup,
        roleName: 'chat_agent',
        columnAssignments: {
          kms: { state: 'enabled' },
          search: { state: 'disabled' }
        },
        widgetAssignments: {
          timer: { state: 'enabled' }
        }
      })

      callHook()

      await vi.waitFor(() => {
        expect(mockFetchAdGroupData).toHaveBeenCalledWith('CN=test-group')
      })
    })

    it('does not fetch when dialog is closed', () => {
      callHook({ open: false } as any)
      expect(mockFetchAdGroupData).not.toHaveBeenCalled()
    })
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-ad-groups-data.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useRef: (init: unknown) => ({ current: init }),
  useCallback: (fn: (...args: unknown[]) => unknown) => fn
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}
vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockApiFetch = vi.fn()
vi.mock('../../../services/core/api-client', () => ({
  apiFetch: (...args: unknown[]) => mockApiFetch(...args)
}))

const { useAdGroupsData } = await import('../use-ad-groups-data')

describe('useAdGroupsData', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  function callHook() {
    stateIndex = 0
    return useAdGroupsData()
  }

  it('initializes with empty state', () => {
    const result = callHook()
    expect(result.adGroups).toEqual([])
    expect(result.loading).toBe(true)
    expect(result.totalCount).toBe(0)
    expect(result.totalPages).toBe(1)
  })

  it('fetchAdGroups transforms response items', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: {
          items: [{
            groupIdentifier: 'CN=test-group',
            logicalName: 'Test Group',
            roleName: 'voice_agent',
            activeIndicator: true,
            marketCode: 'HK',
            regionCode: 'APAC',
            countryCode: 'HK'
          }],
          totalCount: 1,
          limitNumber: 20
        }
      })
    })

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result).toHaveLength(1)
    expect(result[0].groupIdentifier).toBe('CN=test-group')
    expect(result[0].logicalName).toBe('Test Group')
    expect(result[0].isActive).toBe(true)
    expect(result[0].market).toBe('HK')
    expect(result[0].region).toBe('APAC')
  })

  it('fetchAdGroups builds correct query string with filters', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: { items: [], totalCount: 0 } })
    })

    const { fetchAdGroups } = callHook()
    await fetchAdGroups({
      page: 2,
      size: 10,
      search: 'test',
      role: 'voice_agent',
      status: 'active',
      market: 'HK',
      region: 'APAC',
      country: 'SG',
      businessUnit: 'WPB'
    })

    const calledUrl = mockApiFetch.mock.calls[0][0] as string
    expect(calledUrl).toContain('offset=10')
    expect(calledUrl).toContain('limit=10')
    expect(calledUrl).toContain('search=test')
    expect(calledUrl).toContain('roleText=voice_agent')
    expect(calledUrl).toContain('statusCode=active')
    expect(calledUrl).toContain('marketText=HK')
    expect(calledUrl).toContain('regionText=APAC')
    expect(calledUrl).toContain('countryText=SG')
    expect(calledUrl).toContain('businessUnitText=WPB')
  })

  it('fetchAdGroups excludes "all" filter values', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: { items: [], totalCount: 0 } })
    })

    const { fetchAdGroups } = callHook()
    await fetchAdGroups({ page: 1, size: 20, role: 'all', status: 'all' })

    const calledUrl = mockApiFetch.mock.calls[0][0] as string
    expect(calledUrl).not.toContain('roleText')
    expect(calledUrl).not.toContain('statusCode')
  })

  it('fetchAdGroups shows error notification on failure', async () => {
    mockApiFetch.mockRejectedValue(new Error('Network error'))

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result).toEqual([])
    expect(mockNotifications.error).toHaveBeenCalled()
  })

  it('fetchAdGroups throws on non-ok response', async () => {
    mockApiFetch.mockResolvedValue({
      ok: false,
      status: 500
    })

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result).toEqual([])
    expect(mockNotifications.error).toHaveBeenCalled()
  })

  it('fetchAdGroups throws on unexpected format', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: {} })
    })

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result).toEqual([])
    expect(mockNotifications.error).toHaveBeenCalled()
  })

  it('transforms group with permission assignments', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: {
          items: [{
            groupIdentifier: 'CN=g1',
            activeIndicator: true,
            currentConfig: {
              permissionChanges: {
                columnPermissions: {
                  kms: { enabledIndicator: true },
                  search: { enabledIndicator: false }
                }
              }
            }
          }],
          totalCount: 1
        }
      })
    })

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result[0].columnAssignments).toEqual({
      kms: { state: 'enabled' },
      search: { state: 'disabled' }
    })
  })

  it('defaults isActive to true and pendingChangeIndicator to false', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: {
          items: [{ groupIdentifier: 'CN=g1' }],
          totalCount: 1
        }
      })
    })

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result[0].isActive).toBe(true)
    expect(result[0].pendingChangeIndicator).toBe(false)
  })

  it('resolves userCount from string', async () => {
    mockApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: {
          items: [{ groupIdentifier: 'CN=g1', userCountNumber: '42' }],
          totalCount: 1
        }
      })
    })

    const { fetchAdGroups } = callHook()
    const result = await fetchAdGroups({ page: 1, size: 20 })

    expect(result[0].userCount).toBe(42)
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-ad-groups-loader.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: vi.fn(),
  useCallback: (fn: unknown) => fn,
  useRef: (init: unknown) => ({ current: init })
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}

vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockSearchAdGroups = vi.fn()

vi.mock('../../../services/api/admin.service', () => ({
  adminService: {
    searchAdGroups: (...args: unknown[]) => mockSearchAdGroups(...args)
  }
}))

vi.mock('../../../utils/admin/notice-validators', () => ({
  isConfiguredGroup: ({ group }: { group: Record<string, unknown> }) => {
    return Boolean(group.groupIdentifier && group.roleName)
  }
}))

const { useAdGroupsLoader } = await import('../use-ad-groups-loader')

function callHook(overrides: Record<string, unknown> = {}) {
  stateIndex = 0
  return useAdGroupsLoader({
    open: true,
    searchTerm: '',
    debounceMs: 0,
    ...overrides
  } as any)
}

describe('useAdGroupsLoader', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  it('initializes with empty groups and not loading', () => {
    const result = callHook()
    expect(result.adGroups).toEqual([])
    expect(result.isLoadingGroups).toBe(false)
  })

  it('loadGroups fetches and filters configured groups', async () => {
    mockSearchAdGroups.mockResolvedValue([
      { id: 'g1', groupIdentifier: 'CN=g1', roleName: 'voice_agent' },
      { id: 'g2', groupIdentifier: 'CN=g2', roleName: 'chat_agent' },
      { id: 'g3', groupIdentifier: 'CN=g3', roleName: undefined } // not configured
    ])

    // The hook exposes loadGroups via useCallback
    // We test it by directly calling the internal loadGroups function
    // which is returned via useCallback mock (identity function)
    callHook({ open: true })

    // Get the loadGroups function from the hook internals
    // Since useCallback returns identity, the loadGroups from the hook is directly accessible
    // We need to access it through the hook - it's exposed only internally via useEffect
    // Instead, test via the useEffect mock
    const { useEffect } = await import('react')
    const effectFn = (useEffect as ReturnType<typeof vi.fn>).mock.calls[0]?.[0]
    if (effectFn) {
      effectFn()
    }

    // Wait for the async loadGroups to complete
    await vi.waitFor(() => {
      expect(mockSearchAdGroups).toHaveBeenCalledWith('', 750)
    })

    // Re-call hook to read updated state
    const result = callHook({ open: true })
    expect(result.adGroups).toHaveLength(2)
  })

  it('does not fetch when closed', () => {
    callHook({ open: false })
    // useEffect is mocked as vi.fn() so the effect body is never called
    // The test verifies initialization state is correct when closed
    expect(mockSearchAdGroups).not.toHaveBeenCalled()
  })

  it('handles search errors gracefully', async () => {
    mockSearchAdGroups.mockRejectedValue(new Error('Search failed'))

    callHook({ open: true })

    const { useEffect } = await import('react')
    const effectFn = (useEffect as ReturnType<typeof vi.fn>).mock.calls[0]?.[0]
    if (effectFn) {
      effectFn()
    }

    await vi.waitFor(() => {
      expect(mockNotifications.error).toHaveBeenCalled()
    })

    const result = callHook({ open: true })
    expect(result.adGroups).toEqual([])
  })

  it('returns cleanup function from effect', async () => {
    callHook({ open: true })

    const { useEffect } = await import('react')
    const effectFn = (useEffect as ReturnType<typeof vi.fn>).mock.calls[0]?.[0]
    const cleanup = effectFn?.()
    // The effect returns a cleanup function (clearTimeout + cancel ref)
    expect(typeof cleanup).toBe('function')
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-ad-groups-selection.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useRef: (init: unknown) => ({ current: init }),
  useCallback: (fn: unknown) => fn,
  useEffect: (fn: () => void | (() => void)) => { fn() }
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}

vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockSearchAdGroups = vi.fn()
const mockUpdateAdGroup = vi.fn()
const mockCopyAdGroupConfiguration = vi.fn()

vi.mock('../../../services/api/admin.service', () => ({
  adminService: {
    searchAdGroups: (...args: unknown[]) => mockSearchAdGroups(...args),
    updateAdGroup: (...args: unknown[]) => mockUpdateAdGroup(...args),
    copyAdGroupConfiguration: (...args: unknown[]) => mockCopyAdGroupConfiguration(...args)
  }
}))

const { useAdGroupsSelection } = await import('../use-ad-groups-selection')

const mockGroup1 = {
  id: 'g1',
  groupIdentifier: 'CN=group-1',
  logicalName: 'Group 1',
  isActive: true,
  roleName: 'voice_agent'
}

const mockGroup2 = {
  id: 'g2',
  groupIdentifier: 'CN=group-2',
  logicalName: 'Group 2',
  isActive: false,
  roleName: 'chat_agent'
}

const mockGroup3 = {
  id: 'g3',
  groupIdentifier: 'CN=group-3',
  logicalName: 'Group 3',
  isActive: true
}

function callHook(overrides: Record<string, unknown> = {}) {
  stateIndex = 0
  return useAdGroupsSelection({
    currentGroups: [mockGroup1, mockGroup2] as any[],
    getGroupById: (id: string) => [mockGroup1, mockGroup2, mockGroup3].find(g => g.id === id) as any,
    onRefresh: vi.fn().mockResolvedValue(undefined),
    saveScrollPosition: vi.fn(),
    restoreScrollPosition: vi.fn(),
    ...overrides
  } as any)
}

describe('useAdGroupsSelection', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
    mockSearchAdGroups.mockResolvedValue([])
  })

  it('initializes with empty selection', () => {
    const result = callHook()
    expect(result.selectedGroups).toBeInstanceOf(Set)
    expect(result.selectedGroups.size).toBe(0)
  })

  it('initializes with toggle confirm closed', () => {
    const result = callHook()
    expect(result.toggleConfirmOpen).toBe(false)
    expect(result.groupToToggle).toBeNull()
  })

  describe('handleSelectGroup', () => {
    it('adds a group to selection', () => {
      callHook()
      const { handleSelectGroup } = callHook()
      handleSelectGroup('g1')
      const result = callHook()
      expect(result.selectedGroups.has('g1')).toBe(true)
    })

    it('removes a group from selection when already selected', () => {
      callHook()
      const { handleSelectGroup: select1 } = callHook()
      select1('g1')
      const { handleSelectGroup: select2 } = callHook()
      select2('g1')
      const result = callHook()
      expect(result.selectedGroups.has('g1')).toBe(false)
    })
  })

  describe('handleSelectAll', () => {
    it('selects all current groups', () => {
      callHook()
      const { handleSelectAll } = callHook()
      handleSelectAll()
      const result = callHook()
      expect(result.selectedGroups.has('g1')).toBe(true)
      expect(result.selectedGroups.has('g2')).toBe(true)
    })

    it('does nothing when currentGroups is empty', () => {
      callHook({ currentGroups: [] })
      const { handleSelectAll } = callHook({ currentGroups: [] })
      handleSelectAll()
      const result = callHook({ currentGroups: [] })
      expect(result.selectedGroups.size).toBe(0)
    })
  })

  describe('handleDeselectAll', () => {
    it('clears all selections', () => {
      callHook()
      const { handleSelectAll } = callHook()
      handleSelectAll()
      const { handleDeselectAll } = callHook()
      handleDeselectAll()
      const result = callHook()
      expect(result.selectedGroups.size).toBe(0)
    })
  })

  describe('handleSelectGroups', () => {
    it('adds multiple groups to selection', () => {
      callHook()
      const { handleSelectGroups } = callHook()
      handleSelectGroups([mockGroup1, mockGroup3] as any[])
      const result = callHook()
      expect(result.selectedGroups.has('g1')).toBe(true)
      expect(result.selectedGroups.has('g3')).toBe(true)
    })

    it('does nothing with empty array', () => {
      callHook()
      const { handleSelectGroups } = callHook()
      handleSelectGroups([])
      const result = callHook()
      expect(result.selectedGroups.size).toBe(0)
    })
  })

  describe('handleDeselectGroups', () => {
    it('removes specific groups from selection', () => {
      callHook()
      const { handleSelectAll } = callHook()
      handleSelectAll()
      const { handleDeselectGroups } = callHook()
      handleDeselectGroups(['g1'])
      const result = callHook()
      expect(result.selectedGroups.has('g1')).toBe(false)
      expect(result.selectedGroups.has('g2')).toBe(true)
    })
  })

  describe('handleToggleActive', () => {
    it('sets groupToToggle and opens confirm dialog', () => {
      callHook()
      const { handleToggleActive } = callHook()
      handleToggleActive(mockGroup1 as any)
      const result = callHook()
      expect(result.toggleConfirmOpen).toBe(true)
      expect(result.groupToToggle).not.toBeNull()
    })
  })

  describe('confirmToggleActive', () => {
    it('toggles the active status and refreshes', async () => {
      mockUpdateAdGroup.mockResolvedValue({})
      const onRefresh = vi.fn().mockResolvedValue(undefined)
      const saveScrollPosition = vi.fn()
      const restoreScrollPosition = vi.fn()

      callHook({ onRefresh, saveScrollPosition, restoreScrollPosition })
      const { handleToggleActive } = callHook({ onRefresh, saveScrollPosition, restoreScrollPosition })
      handleToggleActive(mockGroup1 as any)
      const { confirmToggleActive } = callHook({ onRefresh, saveScrollPosition, restoreScrollPosition })
      await confirmToggleActive()

      expect(mockUpdateAdGroup).toHaveBeenCalledWith('CN=group-1', { isActive: false })
      expect(mockNotifications.success).toHaveBeenCalled()
    })

    it('shows error on failure', async () => {
      mockUpdateAdGroup.mockRejectedValue(new Error('Update failed'))
      const onRefresh = vi.fn().mockResolvedValue(undefined)

      callHook({ onRefresh })
      const { handleToggleActive } = callHook({ onRefresh })
      handleToggleActive(mockGroup1 as any)
      const { confirmToggleActive } = callHook({ onRefresh })
      await confirmToggleActive()

      expect(mockNotifications.error).toHaveBeenCalled()
    })

    it('does nothing when no group to toggle', async () => {
      callHook()
      const { confirmToggleActive } = callHook()
      await confirmToggleActive()
      expect(mockUpdateAdGroup).not.toHaveBeenCalled()
    })
  })

  describe('notifyCopyResult', () => {
    it('notifies success when all copies succeed', async () => {
      mockCopyAdGroupConfiguration.mockResolvedValue({ success: true })
      const onRefresh = vi.fn().mockResolvedValue(undefined)

      callHook({ onRefresh })
      // Select groups to get them in selection details
      const { handleSelectGroup } = callHook({ onRefresh })
      handleSelectGroup('g2')

      const { handleCopyFrom } = callHook({ onRefresh })
      await handleCopyFrom(
        mockGroup1 as any,
        ['g2'],
        {
          copyRoleAndPermissionsFlag: true,
          copyBusinessInfoFlag: true,
          copyApplicationsFlag: false,
          copyWorkflowModeCode: 'DIRECT_SAVE',
          functionMismatchPolicyCode: 'SKIP_UNAVAILABLE'
        }
      )

      expect(mockNotifications.success).toHaveBeenCalled()
    })

    it('notifies error when all copies fail', async () => {
      mockCopyAdGroupConfiguration.mockResolvedValue({ success: false })
      const onRefresh = vi.fn().mockResolvedValue(undefined)

      callHook({ onRefresh })
      const { handleSelectGroup } = callHook({ onRefresh })
      handleSelectGroup('g2')

      const { handleCopyFrom } = callHook({ onRefresh })
      await handleCopyFrom(
        mockGroup1 as any,
        ['g2'],
        {
          copyRoleAndPermissionsFlag: true,
          copyBusinessInfoFlag: true,
          copyApplicationsFlag: false,
          copyWorkflowModeCode: 'DIRECT_SAVE',
          functionMismatchPolicyCode: 'SKIP_UNAVAILABLE'
        }
      )

      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })

  describe('searchAdGroups (fetchLookup)', () => {
    it('searches and returns configured groups', async () => {
      mockSearchAdGroups.mockResolvedValue([
        { id: 'g1', groupIdentifier: 'CN=g1' },
        { id: 'g2', groupIdentifier: 'CN=g2' },
        { id: '', groupIdentifier: '' }
      ])

      const { searchAdGroups } = callHook()
      const result = await searchAdGroups('test')

      expect(mockSearchAdGroups).toHaveBeenCalledWith('test', 750)
      expect(result).toHaveLength(2) // filters out empty groupIdentifier
    })

    it('returns empty array and shows error on failure', async () => {
      mockSearchAdGroups.mockRejectedValue(new Error('Search failed'))

      const { searchAdGroups } = callHook()
      const result = await searchAdGroups('test')

      expect(result).toEqual([])
      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-application-assignment.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number
let effectCallbacks: Array<() => void>

function resetState() {
  stateStore = new Map()
  stateIndex = 0
  effectCallbacks = []
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: (fn: () => void) => { effectCallbacks.push(fn) },
  useCallback: (fn: (...args: unknown[]) => unknown) => fn,
  useRef: (init: unknown) => ({ current: init })
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}
vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockLoadEmbeddedAppsData = vi.fn()
const mockSaveAppAssignment = vi.fn()

vi.mock('../../api/use-embedded-apps-api', () => ({
  useEmbeddedAppsApi: () => ({
    isLoadingApps: false,
    isSavingAppAssignment: false,
    loadEmbeddedAppsData: mockLoadEmbeddedAppsData,
    saveAppAssignment: mockSaveAppAssignment
  })
}))

const { useApplicationAssignment } = await import('../use-application-assignment')

describe('useApplicationAssignment', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  function callHook(overrides: Record<string, unknown> = {}) {
    stateIndex = 0
    return useApplicationAssignment({
      groupIdentifier: 'CN=test-group',
      groupDisplayName: 'Test Group',
      open: true,
      activeTab: 'applications',
      canDirectSave: true,
      ...overrides
    } as any)
  }

  it('initializes with empty state', () => {
    const result = callHook()
    expect(result.availableApps).toEqual([])
    expect(result.selectedApp).toBeNull()
    expect(result.appSearchTerm).toBe('')
    expect(result.stagedAppChanges).toEqual([])
  })

  it('handleAppSelect sets selectedApp', () => {
    callHook()
    const { handleAppSelect } = callHook()
    const testApp = { appIdentifier: 'app1', titleText: 'App 1' }
    handleAppSelect(testApp as any)
    const result = callHook()
    expect(result.selectedApp).toEqual(testApp)
  })

  it('handleAppCancel clears selectedApp', () => {
    callHook()
    const { handleAppSelect, handleAppCancel } = callHook()
    handleAppSelect({ appIdentifier: 'app1' } as any)
    handleAppCancel()
    const result = callHook()
    expect(result.selectedApp).toBeNull()
  })

  it('clearStagedAppChanges resets staged changes', () => {
    callHook()
    const { clearStagedAppChanges } = callHook()
    clearStagedAppChanges()
    const result = callHook()
    expect(result.stagedAppChanges).toEqual([])
  })

  it('handleSaveAppAssignment calls API directly when canDirectSave', async () => {
    mockSaveAppAssignment.mockResolvedValue(undefined)
    mockLoadEmbeddedAppsData.mockResolvedValue([])

    callHook({ canDirectSave: true })
    const { handleSaveAppAssignment } = callHook({ canDirectSave: true })
    await handleSaveAppAssignment('app1', 'App 1', ['fn1', 'fn2'], 'fn1')

    expect(mockSaveAppAssignment).toHaveBeenCalledWith(
      'app1', 'App 1', 'CN=test-group', 'Test Group', ['fn1', 'fn2'], 'fn1'
    )
  })

  it('handleSaveAppAssignment stages change when canDirectSave is false', async () => {
    // Setup with an existing app in availableApps
    callHook({ canDirectSave: false })
    // manually set availableApps
    stateStore.set(0, [{ appIdentifier: 'app1', titleText: 'App 1', assignedFunctionKeys: ['fn1'] }])
    const { handleSaveAppAssignment } = callHook({ canDirectSave: false })
    await handleSaveAppAssignment('app1', 'App 1', ['fn1', 'fn2'])

    const result = callHook({ canDirectSave: false })
    expect(result.stagedAppChanges).toHaveLength(1)
    expect(result.stagedAppChanges[0].appKey).toBe('app1')
    expect(result.stagedAppChanges[0].newFunctions).toEqual(['fn1', 'fn2'])
    expect(mockNotifications.success).toHaveBeenCalled()
  })

  it('filteredApps returns all apps when no search term', () => {
    callHook()
    stateStore.set(0, [
      { appIdentifier: 'app1', titleText: 'Banking', descriptionText: 'Banking app', categoryName: 'Finance' },
      { appIdentifier: 'app2', titleText: 'Search', descriptionText: 'Search app', categoryName: 'Tools' }
    ])
    const result = callHook()
    expect(result.filteredApps).toHaveLength(2)
  })

  it('filteredApps filters by search term', () => {
    callHook()
    stateStore.set(0, [
      { appIdentifier: 'app1', titleText: 'Banking', descriptionText: 'Banking app', categoryName: 'Finance' },
      { appIdentifier: 'app2', titleText: 'Search', descriptionText: 'Search app', categoryName: 'Tools' }
    ])
    stateStore.set(2, 'banking') // appSearchTerm is the 3rd useState call (index 2)
    const result = callHook()
    expect(result.filteredApps).toHaveLength(1)
    expect(result.filteredApps[0].appIdentifier).toBe('app1')
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-config-save.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  }
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}

vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockSubmitChange = vi.fn()
const mockDirectSave = vi.fn()

vi.mock('../../../services/api/admin-approval.service', () => ({
  adminApprovalService: {
    submitChange: (...args: unknown[]) => mockSubmitChange(...args),
    directSave: (...args: unknown[]) => mockDirectSave(...args)
  }
}))

vi.mock('../../../components/admin/ad-group-config/utils/permission-helpers', () => ({
  convertOverridesToAssignments: (overrides: Record<string, unknown>) => {
    const result: Record<string, unknown> = {}
    for (const [key, value] of Object.entries(overrides)) {
      if (value && typeof value === 'object' && Object.keys(value as object).length > 0) {
        result[`${key}Assignments`] = value
      }
    }
    return result
  }
}))

const { useConfigSave } = await import('../use-config-save')

describe('useConfigSave', () => {
  const baseGroup = {
    id: 'g1',
    groupIdentifier: 'CN=test-group',
    logicalName: 'Test Group',
    roleName: 'voice_agent',
    isActive: true,
    region: 'APAC',
    country: 'HK'
  }

  let updateAdGroupConfig: ReturnType<typeof vi.fn>
  let updatePermissionOverrides: ReturnType<typeof vi.fn>
  let setPendingChanges: ReturnType<typeof vi.fn>
  let clearStagedAppChanges: ReturnType<typeof vi.fn>
  let onSave: ReturnType<typeof vi.fn>
  let onClose: ReturnType<typeof vi.fn>

  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
    updateAdGroupConfig = vi.fn().mockResolvedValue(null)
    updatePermissionOverrides = vi.fn()
    setPendingChanges = vi.fn()
    clearStagedAppChanges = vi.fn()
    onSave = vi.fn()
    onClose = vi.fn()
  })

  function callHook(overrides: Record<string, unknown> = {}) {
    stateIndex = 0
    return useConfigSave({
      formData: { ...baseGroup } as any,
      group: { ...baseGroup } as any,
      permissionOverrides: {},
      pendingChanges: { permissions: {} },
      stagedAppChanges: [],
      canDirectSave: false,
      updateAdGroupConfig,
      updatePermissionOverrides,
      setPendingChanges,
      clearStagedAppChanges,
      onSave,
      onClose,
      ...overrides
    })
  }

  it('initializes showSaveDialog as false', () => {
    const result = callHook()
    expect(result.showSaveDialog).toBe(false)
  })

  it('handleSaveClick opens save dialog', () => {
    callHook()
    const { handleSaveClick } = callHook()
    handleSaveClick()
    const result = callHook()
    expect(result.showSaveDialog).toBe(true)
    expect(result.isDirectSave).toBe(false)
  })

  it('handleDirectSaveClick opens dialog with direct save flag', () => {
    callHook()
    const { handleDirectSaveClick } = callHook()
    handleDirectSaveClick()
    const result = callHook()
    expect(result.showSaveDialog).toBe(true)
    expect(result.isDirectSave).toBe(true)
  })

  it('handleConfirmSave submits change via approval workflow', async () => {
    mockSubmitChange.mockResolvedValue({})

    callHook()
    const { handleConfirmSave } = callHook()
    await handleConfirmSave()

    expect(mockSubmitChange).toHaveBeenCalledWith(
      'CN=test-group',
      expect.objectContaining({
        changeType: 'CONFIG_UPDATE',
        currentState: expect.any(Object),
        proposedState: expect.any(Object)
      })
    )
    expect(updatePermissionOverrides).toHaveBeenCalled()
    expect(setPendingChanges).toHaveBeenCalledWith({ permissions: {} })
    expect(onClose).toHaveBeenCalled()
    expect(mockNotifications.success).toHaveBeenCalled()
  })

  it('handleConfirmSave uses direct save when isDirectSave and canDirectSave', async () => {
    mockDirectSave.mockResolvedValue({})

    callHook({ canDirectSave: true })
    const { handleDirectSaveClick } = callHook({ canDirectSave: true })
    handleDirectSaveClick()
    const { handleConfirmSave } = callHook({ canDirectSave: true })
    await handleConfirmSave()

    expect(mockDirectSave).toHaveBeenCalledWith(
      'CN=test-group',
      expect.objectContaining({
        currentState: expect.any(Object),
        proposedState: expect.any(Object)
      })
    )
    expect(onClose).toHaveBeenCalled()
  })

  it('handleConfirmSave handles errors gracefully', async () => {
    mockSubmitChange.mockRejectedValue(new Error('Network error'))

    callHook()
    const { handleConfirmSave } = callHook()
    await handleConfirmSave()

    expect(mockNotifications.error).toHaveBeenCalled()
    expect(onClose).not.toHaveBeenCalled()
  })

  it('includes business info changes when form data differs', async () => {
    mockSubmitChange.mockResolvedValue({})

    const modifiedFormData = {
      ...baseGroup,
      logicalName: 'Updated Group Name'
    }

    callHook({ formData: modifiedFormData, group: baseGroup })
    const { handleConfirmSave } = callHook({ formData: modifiedFormData, group: baseGroup })
    await handleConfirmSave()

    expect(mockSubmitChange).toHaveBeenCalledWith(
      'CN=test-group',
      expect.objectContaining({
        proposedState: expect.objectContaining({
          businessInfoChanges: expect.objectContaining({
            logicalName: 'Updated Group Name'
          })
        })
      })
    )
  })

  it('includes permission changes when overrides exist', async () => {
    mockSubmitChange.mockResolvedValue({})

    callHook({
      pendingChanges: { permissions: { columns: { kms: false } } }
    })
    const { handleConfirmSave } = callHook({
      pendingChanges: { permissions: { columns: { kms: false } } }
    })
    await handleConfirmSave()

    expect(mockSubmitChange).toHaveBeenCalledWith(
      'CN=test-group',
      expect.objectContaining({
        proposedState: expect.objectContaining({
          permissionChanges: expect.objectContaining({
            columns: expect.any(Object)
          })
        })
      })
    )
  })

  it('sets changeType to APP_UPDATE when only app changes exist', async () => {
    mockSubmitChange.mockResolvedValue({})

    const stagedAppChanges = [{
      appKey: 'testApp',
      appTitle: 'Test App',
      previousFunctions: [],
      newFunctions: ['fn1']
    }]

    callHook({ stagedAppChanges })
    const { handleConfirmSave } = callHook({ stagedAppChanges })
    await handleConfirmSave()

    expect(mockSubmitChange).toHaveBeenCalledWith(
      'CN=test-group',
      expect.objectContaining({
        changeType: 'APP_UPDATE'
      })
    )
  })

  it('clears staged app changes on successful save', async () => {
    mockSubmitChange.mockResolvedValue({})

    callHook()
    const { handleConfirmSave } = callHook()
    await handleConfirmSave()

    expect(clearStagedAppChanges).toHaveBeenCalled()
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-function-selection.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

// Track state across useState calls
let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: (fn: () => void) => fn()
}))

const { useFunctionSelection } = await import('../use-function-selection')

function callHook(appOverrides: Record<string, unknown> = {}) {
  stateIndex = 0 // reset index for each hook call
  const baseApp = {
    appKey: 'myApp',
    displayName: 'My App',
    isAssignedIndicator: true,
    assignedFunctionKeys: ['fn1', 'fn2'],
    defaultFunctionKey: 'fn1',
    availableFunctions: [],
    ...appOverrides
  }
  return useFunctionSelection({ app: baseApp as any })
}

describe('useFunctionSelection', () => {
  beforeEach(() => {
    resetState()
  })

  it('initializes with assigned functions when assigned', () => {
    callHook()
    // After useEffect runs, selectedFunctions should be set
    const result = callHook() // re-call to read updated state
    expect(result.selectedFunctions).toEqual(['fn1', 'fn2'])
  })

  it('initializes with default function only when not assigned', () => {
    callHook({ isAssignedIndicator: false, assignedFunctionKeys: [] })
    const result = callHook({ isAssignedIndicator: false, assignedFunctionKeys: [] })
    expect(result.selectedFunctions).toEqual(['fn1'])
  })

  it('adds default function if missing from assigned', () => {
    callHook({ assignedFunctionKeys: ['fn2'] })
    const result = callHook({ assignedFunctionKeys: ['fn2'] })
    expect(result.selectedFunctions).toContain('fn1')
    expect(result.selectedFunctions).toContain('fn2')
  })

  it('handleFunctionToggle adds a function', () => {
    callHook() // init
    const { handleFunctionToggle } = callHook() // read
    handleFunctionToggle({ functionKey: 'fn3', checked: true })
    const result = callHook() // read updated
    expect(result.selectedFunctions).toContain('fn3')
  })

  it('handleFunctionToggle does not remove default function', () => {
    callHook()
    const { handleFunctionToggle } = callHook()
    handleFunctionToggle({ functionKey: 'fn1', checked: false })
    const result = callHook()
    // fn1 is defaultFunctionKey, should still be there
    expect(result.selectedFunctions).toContain('fn1')
  })

  it('handleClearSelection keeps only default', () => {
    callHook()
    const { handleClearSelection } = callHook()
    handleClearSelection()
    const result = callHook()
    expect(result.selectedFunctions).toEqual(['fn1'])
  })

  it('handleReset restores assigned functions', () => {
    callHook()
    const { handleClearSelection } = callHook()
    handleClearSelection()
    const { handleReset } = callHook()
    handleReset()
    const result = callHook()
    expect(result.selectedFunctions).toEqual(['fn1', 'fn2'])
  })

  it('hasChanges returns false when no changes made', () => {
    callHook()
    const { hasChanges } = callHook()
    expect(hasChanges()).toBe(false)
  })

  it('hasChanges returns true after clear', () => {
    callHook()
    const { handleClearSelection } = callHook()
    handleClearSelection()
    const { hasChanges } = callHook()
    expect(hasChanges()).toBe(true)
  })

  it('handleSelectAllFiltered adds filtered functions', () => {
    callHook()
    const { handleSelectAllFiltered } = callHook()
    handleSelectAllFiltered({ filteredFunctions: ['fn3', 'fn4'] })
    const result = callHook()
    expect(result.selectedFunctions).toContain('fn3')
    expect(result.selectedFunctions).toContain('fn4')
  })

  it('handles app with no defaultFunctionKey', () => {
    resetState()
    callHook({ defaultFunctionKey: undefined, isAssignedIndicator: false, assignedFunctionKeys: [] })
    const result = callHook({ defaultFunctionKey: undefined, isAssignedIndicator: false, assignedFunctionKeys: [] })
    expect(result.selectedFunctions).toEqual([])
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-notice-form.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: (fn: () => void) => fn(),
  useMemo: (fn: () => unknown) => fn()
}))

vi.mock('../../../utils/admin/notice-validators', () => ({
  isEndDateValid: ({ startAt, endAt }: { startAt?: string; endAt?: string }) => {
    if (!startAt || !endAt) return true
    return new Date(endAt) > new Date(startAt)
  }
}))

vi.mock('date-fns', () => ({
  startOfDay: (d: Date) => d
}))

const { useNoticeForm } = await import('../use-notice-form')

function callHook(params: { open: boolean; editNotice?: Record<string, unknown> } = { open: true }) {
  stateIndex = 0
  return useNoticeForm(params as any)
}

describe('useNoticeForm', () => {
  beforeEach(() => {
    resetState()
  })

  it('initializes with default form data when no editNotice', () => {
    callHook({ open: true })
    const result = callHook({ open: true })

    expect(result.formData.title).toBe('')
    expect(result.formData.message).toBe('')
    expect(result.formData.severity).toBe('INFO')
    expect(result.formData.broadcastToAll).toBe(true)
    expect(result.formData.targetRoles).toEqual([])
    expect(result.formData.targetAdGroups).toEqual([])
    expect(result.formData.requiresAcknowledgement).toBe(false)
  })

  it('populates form data from editNotice when open', () => {
    const editNotice = {
      id: 'n1',
      title: 'Test Notice',
      message: 'Test body',
      severity: 'WARNING',
      broadcastToAll: false,
      targetRoles: ['voice_agent'],
      targetAdGroups: ['CN=group1'],
      requiresAcknowledgement: true,
      startAt: '2025-01-01T00:00:00Z',
      endAt: '2025-12-31T00:00:00Z',
      status: 'ACTIVE',
      createdAt: '2025-01-01T00:00:00Z',
      createdBy: 'admin'
    }

    callHook({ open: true, editNotice })
    const result = callHook({ open: true, editNotice })

    expect(result.formData.title).toBe('Test Notice')
    expect(result.formData.message).toBe('Test body')
    expect(result.formData.severity).toBe('WARNING')
    expect(result.formData.broadcastToAll).toBe(false)
    expect(result.formData.targetRoles).toEqual(['voice_agent'])
    expect(result.formData.targetAdGroups).toEqual(['CN=group1'])
    expect(result.formData.requiresAcknowledgement).toBe(true)
  })

  it('toggleRole adds a role when not present', () => {
    callHook({ open: true })
    const { toggleRole } = callHook({ open: true })
    toggleRole({ roleValue: 'voice_agent' })
    const result = callHook({ open: true })

    expect(result.formData.targetRoles).toContain('voice_agent')
  })

  it('toggleRole removes a role when present', () => {
    const editNotice = {
      id: 'n1',
      title: 'T',
      message: 'M',
      severity: 'INFO',
      broadcastToAll: false,
      targetRoles: ['voice_agent', 'chat_agent'],
      targetAdGroups: [],
      requiresAcknowledgement: false,
      status: 'ACTIVE',
      createdAt: '2025-01-01T00:00:00Z',
      createdBy: 'admin'
    }

    callHook({ open: true, editNotice })
    const { toggleRole } = callHook({ open: true, editNotice })
    toggleRole({ roleValue: 'voice_agent' })
    const result = callHook({ open: true, editNotice })

    expect(result.formData.targetRoles).not.toContain('voice_agent')
    expect(result.formData.targetRoles).toContain('chat_agent')
  })

  it('isRoleSelected returns correct boolean', () => {
    const editNotice = {
      id: 'n1',
      title: 'T',
      message: 'M',
      severity: 'INFO',
      broadcastToAll: false,
      targetRoles: ['voice_agent'],
      targetAdGroups: [],
      requiresAcknowledgement: false,
      status: 'ACTIVE',
      createdAt: '2025-01-01T00:00:00Z',
      createdBy: 'admin'
    }

    callHook({ open: true, editNotice })
    const result = callHook({ open: true, editNotice })

    expect(result.isRoleSelected({ roleValue: 'voice_agent' })).toBe(true)
    expect(result.isRoleSelected({ roleValue: 'chat_agent' })).toBe(false)
  })

  it('toggleAdGroup adds a group when not present', () => {
    callHook({ open: true })
    const { toggleAdGroup } = callHook({ open: true })
    toggleAdGroup({ groupIdentifier: 'CN=test-group' })
    const result = callHook({ open: true })

    expect(result.formData.targetAdGroups).toContain('CN=test-group')
  })

  it('toggleAdGroup removes a group when present', () => {
    const editNotice = {
      id: 'n1',
      title: 'T',
      message: 'M',
      severity: 'INFO',
      broadcastToAll: false,
      targetRoles: [],
      targetAdGroups: ['CN=group1', 'CN=group2'],
      requiresAcknowledgement: false,
      status: 'ACTIVE',
      createdAt: '2025-01-01T00:00:00Z',
      createdBy: 'admin'
    }

    callHook({ open: true, editNotice })
    const { toggleAdGroup } = callHook({ open: true, editNotice })
    toggleAdGroup({ groupIdentifier: 'CN=group1' })
    const result = callHook({ open: true, editNotice })

    expect(result.formData.targetAdGroups).not.toContain('CN=group1')
    expect(result.formData.targetAdGroups).toContain('CN=group2')
  })

  it('isAdGroupSelected returns correct boolean', () => {
    const editNotice = {
      id: 'n1',
      title: 'T',
      message: 'M',
      severity: 'INFO',
      broadcastToAll: false,
      targetRoles: [],
      targetAdGroups: ['CN=group1'],
      requiresAcknowledgement: false,
      status: 'ACTIVE',
      createdAt: '2025-01-01T00:00:00Z',
      createdBy: 'admin'
    }

    callHook({ open: true, editNotice })
    const result = callHook({ open: true, editNotice })

    expect(result.isAdGroupSelected({ groupIdentifier: 'CN=group1' })).toBe(true)
    expect(result.isAdGroupSelected({ groupIdentifier: 'CN=other' })).toBe(false)
  })

  it('resetForm restores default values', () => {
    const editNotice = {
      id: 'n1',
      title: 'Test',
      message: 'Body',
      severity: 'CRITICAL',
      broadcastToAll: false,
      targetRoles: ['voice_agent'],
      targetAdGroups: ['CN=group1'],
      requiresAcknowledgement: true,
      status: 'ACTIVE',
      createdAt: '2025-01-01T00:00:00Z',
      createdBy: 'admin'
    }

    callHook({ open: true, editNotice })
    const hook = callHook({ open: true, editNotice })
    expect(hook.formData.title).toBe('Test')

    hook.resetForm()
    const result = callHook({ open: true, editNotice })

    expect(result.formData.title).toBe('')
    expect(result.formData.severity).toBe('INFO')
    expect(result.formData.broadcastToAll).toBe(true)
    expect(result.formData.targetRoles).toEqual([])
  })

  it('isEndDateValid returns true when no dates', () => {
    callHook({ open: true })
    const result = callHook({ open: true })
    expect(result.isEndDateValid).toBe(true)
  })

  it('isEndDateValid returns true when end is after start', () => {
    callHook({ open: true })
    const { setFormData, formData } = callHook({ open: true })
    setFormData({
      ...formData,
      startAt: '2025-01-01T00:00:00Z',
      endAt: '2025-12-31T00:00:00Z'
    })
    const result = callHook({ open: true })
    expect(result.isEndDateValid).toBe(true)
  })

  it('isEndDateValid returns false when end is before start', () => {
    callHook({ open: true })
    const { setFormData, formData } = callHook({ open: true })
    setFormData({
      ...formData,
      startAt: '2025-12-31T00:00:00Z',
      endAt: '2025-01-01T00:00:00Z'
    })
    const result = callHook({ open: true })
    expect(result.isEndDateValid).toBe(false)
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-notice-save.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

const mockCreateNotice = vi.fn()
const mockUpdateNotice = vi.fn()
const mockSuccess = vi.fn()
const mockError = vi.fn()
let isSavingValue = false

vi.mock('react', () => ({
  useState: (init: unknown) => {
    isSavingValue = init as boolean
    return [isSavingValue, (v: boolean) => { isSavingValue = v }]
  }
}))

vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => ({
    success: mockSuccess,
    error: mockError
  })
}))

vi.mock('../../../services/api/admin.service', () => ({
  adminService: {
    createNotice: (...args: unknown[]) => mockCreateNotice(...args),
    updateNotice: (...args: unknown[]) => mockUpdateNotice(...args)
  }
}))

vi.mock('../../../utils/admin/notice-validators', () => ({
  validateNoticeForm: ({ title, message }: { title?: string; message?: string }) => {
    if (!title) return { valid: false, error: 'titleRequired' }
    if (!message) return { valid: false, error: 'messageRequired' }
    return { valid: true }
  }
}))

const { useNoticeSave } = await import('../use-notice-save')

describe('useNoticeSave', () => {
  const onSuccess = vi.fn()

  beforeEach(() => {
    vi.clearAllMocks()
    mockCreateNotice.mockResolvedValue({})
    mockUpdateNotice.mockResolvedValue({})
  })

  it('shows validation error for missing title', async () => {
    const { handleSave } = useNoticeSave({
      formData: { message: 'Body' },
      isEndDateValid: true,
      onSuccess
    })
    await handleSave({ asDraft: false })
    expect(mockError).toHaveBeenCalledWith(expect.objectContaining({
      title: 'Validation failed'
    }))
    expect(mockCreateNotice).not.toHaveBeenCalled()
  })

  it('shows validation error for missing message', async () => {
    const { handleSave } = useNoticeSave({
      formData: { title: 'Title' },
      isEndDateValid: true,
      onSuccess
    })
    await handleSave({ asDraft: false })
    expect(mockError).toHaveBeenCalled()
  })

  it('shows error for invalid end date', async () => {
    const { handleSave } = useNoticeSave({
      formData: { title: 'Title', message: 'Body' },
      isEndDateValid: false,
      onSuccess
    })
    await handleSave({ asDraft: false })
    expect(mockError).toHaveBeenCalledWith(expect.objectContaining({
      title: 'Invalid date range'
    }))
  })

  it('creates notice when no editNotice', async () => {
    const { handleSave } = useNoticeSave({
      formData: { title: 'Title', message: 'Body' },
      isEndDateValid: true,
      onSuccess
    })
    await handleSave({ asDraft: false })
    expect(mockCreateNotice).toHaveBeenCalledWith(expect.objectContaining({
      title: 'Title',
      message: 'Body',
      status: 'ACTIVE'
    }))
    expect(mockSuccess).toHaveBeenCalled()
    expect(onSuccess).toHaveBeenCalled()
  })

  it('creates draft notice', async () => {
    const { handleSave } = useNoticeSave({
      formData: { title: 'Title', message: 'Body' },
      isEndDateValid: true,
      onSuccess
    })
    await handleSave({ asDraft: true })
    expect(mockCreateNotice).toHaveBeenCalledWith(expect.objectContaining({
      status: 'DRAFT'
    }))
  })

  it('updates notice when editNotice provided', async () => {
    const { handleSave } = useNoticeSave({
      formData: { title: 'Updated', message: 'Body' },
      editNotice: { id: 'n1' } as any,
      isEndDateValid: true,
      onSuccess
    })
    await handleSave({ asDraft: false })
    expect(mockUpdateNotice).toHaveBeenCalledWith('n1', expect.objectContaining({
      title: 'Updated'
    }))
    expect(mockSuccess).toHaveBeenCalled()
  })

  it('shows error on save failure', async () => {
    mockCreateNotice.mockRejectedValue(new Error('Network error'))
    const { handleSave } = useNoticeSave({
      formData: { title: 'Title', message: 'Body' },
      isEndDateValid: true,
      onSuccess
    })
    await handleSave({ asDraft: false })
    expect(mockError).toHaveBeenCalledWith(expect.objectContaining({
      title: 'Failed to save notice'
    }))
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-pending-changes.test.ts
import { beforeEach, describe, expect, it, vi } from 'vitest'
import type { PendingChangeFilters } from '../../../types/features/approval-workflow.types'

const useQueryMock = vi.fn()
const useMutationMock = vi.fn()
const useQueryClientMock = vi.fn()

vi.mock('@tanstack/react-query', () => ({
  useQuery: (...args: unknown[]) => useQueryMock(...args),
  useMutation: (...args: unknown[]) => useMutationMock(...args),
  useQueryClient: (...args: unknown[]) => useQueryClientMock(...args)
}))

vi.mock('../../../services/api/admin-approval.service', () => ({
  adminApprovalService: {
    listPendingChanges: vi.fn(),
    getPendingChange: vi.fn(),
    getPendingChangesCount: vi.fn(),
    submitChange: vi.fn(),
    directSave: vi.fn(),
    approveChange: vi.fn(),
    rejectChange: vi.fn(),
    getMyActivity: vi.fn(),
    cancelChange: vi.fn()
  }
}))

const {
  MY_ACTIVITY_QUERY_KEY,
  PENDING_CHANGES_COUNT_KEY,
  PENDING_CHANGES_QUERY_KEY,
  useApproveChange,
  useCancelChange,
  useDirectSave,
  useMyActivity,
  usePendingChange,
  usePendingChanges,
  usePendingChangesCount,
  useRejectChange,
  useSubmitChange
} = await import('../use-pending-changes')
const { adminApprovalService } = await import('../../../services/api/admin-approval.service')

describe('use-pending-changes hooks', () => {
  const invalidateQueries = vi.fn()

  beforeEach(() => {
    vi.clearAllMocks()

    useQueryMock.mockReset()
    useMutationMock.mockReset()
    useQueryClientMock.mockReset()

    useQueryMock.mockImplementation((options) => options)
    useMutationMock.mockImplementation((options) => options)
    useQueryClientMock.mockReturnValue({ invalidateQueries })
  })

  it('builds pending changes list query config', async () => {
    const filters: PendingChangeFilters = { status: ['PENDING_LEVEL_ONE'] }
    usePendingChanges(filters)
    const queryConfig = useQueryMock.mock.calls[0][0]

    expect(queryConfig.queryKey).toEqual([PENDING_CHANGES_QUERY_KEY, filters])
    expect(queryConfig.staleTime).toBe(30 * 1000)
    expect(queryConfig.refetchOnWindowFocus).toBe(true)

    await queryConfig.queryFn()
    expect(adminApprovalService.listPendingChanges).toHaveBeenCalledWith(filters)
  })

  it('builds pending change query config with enabled guard', async () => {
    usePendingChange(null)
    const disabledConfig = useQueryMock.mock.calls[0][0]
    expect(disabledConfig.enabled).toBe(false)
    expect(disabledConfig.queryKey).toEqual([PENDING_CHANGES_QUERY_KEY, null])

    usePendingChange('change-123')
    const enabledConfig = useQueryMock.mock.calls[1][0]
    expect(enabledConfig.enabled).toBe(true)
    expect(enabledConfig.staleTime).toBe(30 * 1000)

    await enabledConfig.queryFn()
    expect(adminApprovalService.getPendingChange).toHaveBeenCalledWith('change-123')
  })

  it('builds pending changes count query config', async () => {
    usePendingChangesCount()
    const enabledConfig = useQueryMock.mock.calls[0][0]
    expect(enabledConfig.queryKey).toEqual([PENDING_CHANGES_COUNT_KEY])
    expect(enabledConfig.enabled).toBe(true)
    expect(enabledConfig.refetchInterval).toBe(60 * 1000)

    await enabledConfig.queryFn()
    expect(adminApprovalService.getPendingChangesCount).toHaveBeenCalledTimes(1)

    usePendingChangesCount(false)
    const disabledConfig = useQueryMock.mock.calls[1][0]
    expect(disabledConfig.enabled).toBe(false)
  })

  it('builds my activity query config for all and filtered ranges', async () => {
    useMyActivity()
    const allConfig = useQueryMock.mock.calls[0][0]
    expect(allConfig.queryKey).toEqual([MY_ACTIVITY_QUERY_KEY, 1, 'all'])

    await allConfig.queryFn()
    expect(adminApprovalService.getMyActivity).toHaveBeenCalledWith(1, 25, undefined)

    useMyActivity(2, 'week')
    const filteredConfig = useQueryMock.mock.calls[1][0]
    expect(filteredConfig.queryKey).toEqual([MY_ACTIVITY_QUERY_KEY, 2, 'week'])

    await filteredConfig.queryFn()
    expect(adminApprovalService.getMyActivity).toHaveBeenCalledWith(2, 25, 'week')
  })

  it('submits changes and invalidates related queries', async () => {
    useSubmitChange()
    const mutationConfig = useMutationMock.mock.calls[0][0]

    const payload = {
      groupId: 'group-1',
      request: { changeType: 'UPDATE' }
    } as never

    await mutationConfig.mutationFn(payload)
    expect(adminApprovalService.submitChange).toHaveBeenCalledWith('group-1', { changeType: 'UPDATE' })

    mutationConfig.onSuccess?.()
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: ['adminAdGroups'] })
  })

  it('direct saves and invalidates ad group cache', async () => {
    useDirectSave()
    const mutationConfig = useMutationMock.mock.calls[0][0]

    const payload = {
      groupId: 'group-2',
      request: { reason: 'force-save' }
    } as never

    await mutationConfig.mutationFn(payload)
    expect(adminApprovalService.directSave).toHaveBeenCalledWith('group-2', { reason: 'force-save' })

    mutationConfig.onSuccess?.()
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: ['adminAdGroups'] })
  })

  it('approves changes and invalidates related queries', async () => {
    useApproveChange()
    const mutationConfig = useMutationMock.mock.calls[0][0]

    await mutationConfig.mutationFn({ changeId: 'change-1', request: { comment: 'ok' } } as never)
    expect(adminApprovalService.approveChange).toHaveBeenCalledWith('change-1', { comment: 'ok' })

    mutationConfig.onSuccess?.()
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: ['adminAdGroups'] })
  })

  it('rejects changes and invalidates pending caches', async () => {
    useRejectChange()
    const mutationConfig = useMutationMock.mock.calls[0][0]

    await mutationConfig.mutationFn({ changeId: 'change-2', request: { reason: 'invalid' } } as never)
    expect(adminApprovalService.rejectChange).toHaveBeenCalledWith('change-2', { reason: 'invalid' })

    mutationConfig.onSuccess?.()
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
  })

  it('cancels changes and invalidates pending caches', async () => {
    useCancelChange()
    const mutationConfig = useMutationMock.mock.calls[0][0]

    await mutationConfig.mutationFn('change-3')
    expect(adminApprovalService.cancelChange).toHaveBeenCalledWith('change-3')

    mutationConfig.onSuccess?.()
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
    expect(invalidateQueries).toHaveBeenCalledWith({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-permission-aggregators.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('react', () => ({
  default: {
    useCallback: (fn: (...args: unknown[]) => unknown) => fn,
    useMemo: (fn: () => unknown) => fn()
  },
  useCallback: (fn: (...args: unknown[]) => unknown) => fn,
  useMemo: (fn: () => unknown) => fn()
}))

vi.mock('../../../constants/permission-levels', () => ({
  permissionLevels: {
    capabilities: {
      title: 'Access Controls',
      description: 'Core actions',
      icon: () => null,
      businessNames: {
        'columns.kms': 'Knowledge Base',
        'columns.embeddedApps': 'Banking Applications',
        'columns.spaceCopilot': 'AI Assistant',
        'columns.chat': 'Chat Interface',
        'micro_frontends.mediaBar': 'Media Controls'
      }
    },
    workspacePreferences: {
      title: 'Workspace & Preferences',
      description: 'User preferences',
      icon: () => null,
      businessNames: {
        'settings_options.calls.autoAccept': 'Auto-Accept Calls',
        'settings_options.calls.doNotDisturb.duration': 'Do Not Disturb',
        'settings_options.interface.showTranscript': 'Show Transcripts',
        'settings_options.interface.autoCloseKnowledgeOnCallEnd': 'Auto-Close Knowledge',
        'settings_options.interface.spaceCopilotMode': 'AI Assistant Mode'
      }
    }
  }
}))

vi.mock('../../../components/admin/ad-group-config/utils/permission-helpers', () => ({
  getTemplateSection: (template: Record<string, unknown> | null, level: string) => {
    if (!template) return {}
    const section = template[level]
    if (section && typeof section === 'object') return section
    return {}
  }
}))

vi.mock('../../../components/admin/business-relevant-toggles', () => ({
  businessRelevantToggles: {
    capabilities: {
      toggles: {
        'columns.kms': { visible: true, businessName: 'Knowledge Base', description: 'Access to knowledge base', section: 'Dashboard Access' },
        'columns.embeddedApps': { visible: true, businessName: 'Banking Applications', description: 'Access to banking apps', section: 'Dashboard Access' },
        'columns.spaceCopilot': { visible: true, businessName: 'AI Assistant', description: 'Access to AI features', section: 'Dashboard Access' },
        'columns.chat': { visible: true, businessName: 'Chat Interface', description: 'Access to chat', section: 'Dashboard Access' },
        'micro_frontends.mediaBar': { visible: true, businessName: 'Media Controls', description: 'Voice and video controls', section: 'Platform Apps' }
      }
    },
    workspacePreferences: {
      toggles: {
        'settings_options.calls.autoAccept': { visible: true, businessName: 'Auto-Accept Calls', description: 'Auto accept calls', section: 'Call Preferences' },
        'settings_options.calls.doNotDisturb.duration': { visible: true, businessName: 'Do Not Disturb', description: 'Set break duration', section: 'Call Preferences' },
        'settings_options.interface.showTranscript': { visible: true, businessName: 'Show Transcripts', description: 'Display transcripts', section: 'Privacy & Display' },
        'settings_options.interface.autoCloseKnowledgeOnCallEnd': { visible: true, businessName: 'Auto-Close Knowledge', description: 'Auto close knowledge', section: 'Privacy & Display' },
        'settings_options.interface.spaceCopilotMode': { visible: true, businessName: 'AI Assistant Mode', description: 'Choose AI level', section: 'AI Preference' }
      }
    }
  },
  isToggleBusinessRelevant: (_level: string, _key: string) => true
}))

vi.mock('../../../utils/admin/permission-level-resolver', () => ({
  COMPOUND_LEVELS: {
    capabilities: ['columns', 'features', 'micro_frontends'],
    workspacePreferences: ['widgets', 'settings_tabs', 'settings_options']
  }
}))

vi.mock('../../../utils/admin/permission-hierarchy-sorter', () => ({
  sortWithHierarchy: ({ keys }: { keys: string[] }) => keys
}))

const { usePermissionAggregators } = await import('../use-permission-aggregators')

describe('usePermissionAggregators', () => {
  const baseTemplate = {
    roleName: 'voice_agent',
    columns: {
      kms: { state: 'enabled' },
      embeddedApps: { state: 'enabled' },
      spaceCopilot: { state: 'enabled' },
      chat: { state: 'enabled' }
    },
    micro_frontends: {
      mediaBar: { state: 'enabled' }
    },
    settings_options: {
      'calls.autoAccept': { state: 'enabled' },
      'calls.doNotDisturb.duration': { state: 'enabled' },
      'interface.showTranscript': { state: 'enabled' },
      'interface.autoCloseKnowledgeOnCallEnd': { state: 'enabled' },
      'interface.spaceCopilotMode': { state: 'enabled' }
    }
  }

  describe('getPermissionCount', () => {
    it('returns 0 when no role template', () => {
      const { getPermissionCount } = usePermissionAggregators({
        roleTemplate: null,
        searchTerm: '',
        isPermissionEnabled: () => false
      })

      expect(getPermissionCount({ level: 'capabilities' })).toBe(0)
    })

    it('counts enabled capabilities (columns + micro_frontends)', () => {
      const { getPermissionCount } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      expect(getPermissionCount({ level: 'capabilities' })).toBe(5)
    })

    it('counts enabled workspacePreferences (settings_options)', () => {
      const { getPermissionCount } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      expect(getPermissionCount({ level: 'workspacePreferences' })).toBe(5)
    })
  })

  describe('getAllPermissions', () => {
    it('returns empty array when no role template', () => {
      const { getAllPermissions } = usePermissionAggregators({
        roleTemplate: null,
        searchTerm: '',
        isPermissionEnabled: () => false
      })

      expect(getAllPermissions({ level: 'capabilities' })).toEqual([])
    })

    it('returns all capabilities keys with prefixes', () => {
      const { getAllPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      const caps = getAllPermissions({ level: 'capabilities' })
      expect(caps).toContain('columns.kms')
      expect(caps).toContain('columns.spaceCopilot')
      expect(caps).toContain('micro_frontends.mediaBar')
    })

    it('returns workspacePreferences keys with settings_options prefix', () => {
      const { getAllPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      const prefs = getAllPermissions({ level: 'workspacePreferences' })
      expect(prefs).toContain('settings_options.calls.autoAccept')
      expect(prefs).toContain('settings_options.interface.spaceCopilotMode')
    })

    it('returns empty array for unknown level', () => {
      const { getAllPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      expect(getAllPermissions({ level: 'nonexistent' })).toEqual([])
    })
  })

  describe('getEnabledPermissions', () => {
    it('returns only enabled permissions', () => {
      const enabledKeys = new Set(['columns.kms'])
      const { getEnabledPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: ({ key }: { key: string }) => enabledKeys.has(key)
      })

      const enabled = getEnabledPermissions({ level: 'capabilities' })
      expect(enabled).toContain('columns.kms')
      expect(enabled).not.toContain('micro_frontends.mediaBar')
    })

    it('returns empty array when no template', () => {
      const { getEnabledPermissions } = usePermissionAggregators({
        roleTemplate: null,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      expect(getEnabledPermissions({ level: 'capabilities' })).toEqual([])
    })
  })

  describe('getFilteredPermissions', () => {
    it('returns all permissions when no search term', () => {
      const { getFilteredPermissions, getAllPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: '',
        isPermissionEnabled: () => true
      })

      expect(getFilteredPermissions({ level: 'capabilities' }))
        .toEqual(getAllPermissions({ level: 'capabilities' }))
    })

    it('filters by business name', () => {
      const { getFilteredPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: 'knowledge',
        isPermissionEnabled: () => true
      })

      const filtered = getFilteredPermissions({ level: 'capabilities' })
      expect(filtered).toContain('columns.kms')
    })

    it('returns empty when search matches nothing', () => {
      const { getFilteredPermissions } = usePermissionAggregators({
        roleTemplate: baseTemplate as any,
        searchTerm: 'xyznonexistent',
        isPermissionEnabled: () => true
      })

      const filtered = getFilteredPermissions({ level: 'capabilities' })
      expect(filtered).toEqual([])
    })
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-permission-state.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('react', () => ({
  default: { useCallback: (fn: (...args: unknown[]) => unknown) => fn },
  useCallback: (fn: (...args: unknown[]) => unknown) => fn
}))

vi.mock('../../../components/admin/ad-group-config/utils/permission-helpers', () => ({
  getTemplateSection: (template: Record<string, unknown> | null, level: string) => {
    if (!template) return {}
    const section = template[level]
    if (section && typeof section === 'object') return section
    return {}
  }
}))

vi.mock('../../../utils/admin/permission-level-resolver', () => ({
  resolvePermissionLevel: ({ level, key }: { level: string; key: string }) => {
    const COMPOUND: Record<string, string[]> = {
      capabilities: ['columns', 'features', 'micro_frontends'],
      workspacePreferences: ['widgets', 'settings_tabs', 'settings_options']
    }
    const prefixes = COMPOUND[level]
    if (!prefixes) return { actualLevel: level, actualKey: key }
    for (const prefix of prefixes) {
      if (key.startsWith(prefix + '.')) {
        return { actualLevel: prefix, actualKey: key.slice(prefix.length + 1) }
      }
    }
    const [p, ...rest] = key.split('.')
    return { actualLevel: p, actualKey: rest.join('.') }
  },
  COMPOUND_LEVELS: {
    capabilities: ['columns', 'features', 'micro_frontends'],
    workspacePreferences: ['widgets', 'settings_tabs', 'settings_options']
  }
}))

const { usePermissionState } = await import('../use-permission-state')

describe('usePermissionState', () => {
  const baseTemplate = {
    roleName: 'voice_agent',
    columns: {
      kms: { state: 'enabled' },
      chat: { state: 'disabled' }
    },
    widgets: {
      'customer.info': { state: 'enabled' }
    },
    features: {
      'search.knowledgeBase': { state: 'enabled' }
    },
    micro_frontends: {
      mediaBar: { state: 'enabled' }
    },
    settings_tabs: {
      help: { state: 'enabled' }
    },
    settings_options: {
      'calls.autoAccept': { state: 'enabled' }
    }
  }

  describe('isPermissionEnabled', () => {
    it('returns false when no role template', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: null,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'columns', key: 'kms' })).toBe(false)
    })

    it('returns template value when no overrides', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'columns', key: 'kms' })).toBe(true)
      expect(isPermissionEnabled({ level: 'columns', key: 'chat' })).toBe(false)
    })

    it('override takes precedence over template', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: { columns: { kms: false } },
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'columns', key: 'kms' })).toBe(false)
    })

    it('pending change takes precedence over override', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: { columns: { kms: false } },
        pendingChanges: { permissions: { columns: { kms: true } } }
      })
      expect(isPermissionEnabled({ level: 'columns', key: 'kms' })).toBe(true)
    })

    it('handles capabilities level (columns prefix)', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'capabilities', key: 'columns.kms' })).toBe(true)
    })

    it('handles capabilities level (features prefix)', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'capabilities', key: 'features.search.knowledgeBase' })).toBe(true)
    })

    it('handles capabilities level (micro_frontends prefix)', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'capabilities', key: 'micro_frontends.mediaBar' })).toBe(true)
    })

    it('handles capabilities with pending change', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: { columns: { kms: false } } }
      })
      expect(isPermissionEnabled({ level: 'capabilities', key: 'columns.kms' })).toBe(false)
    })

    it('handles workspacePreferences level (widgets prefix)', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'workspacePreferences', key: 'widgets.customer.info' })).toBe(true)
    })

    it('handles workspacePreferences level (settings_tabs prefix)', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'workspacePreferences', key: 'settings_tabs.help' })).toBe(true)
    })

    it('handles workspacePreferences level (settings_options prefix)', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'workspacePreferences', key: 'settings_options.calls.autoAccept' })).toBe(true)
    })

    it('handles workspacePreferences with override', () => {
      const { isPermissionEnabled } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: { settings_tabs: { help: false } },
        pendingChanges: { permissions: {} }
      })
      expect(isPermissionEnabled({ level: 'workspacePreferences', key: 'settings_tabs.help' })).toBe(false)
    })
  })

  describe('hasUnsavedChanges', () => {
    it('returns false when no role template', () => {
      const { hasUnsavedChanges } = usePermissionState({
        roleTemplate: null,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(hasUnsavedChanges({ level: 'columns', key: 'kms' })).toBe(false)
    })

    it('returns false when no pending change', () => {
      const { hasUnsavedChanges } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: {} }
      })
      expect(hasUnsavedChanges({ level: 'columns', key: 'kms' })).toBe(false)
    })

    it('returns true when pending differs from saved', () => {
      const { hasUnsavedChanges } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: { columns: { kms: false } } }
      })
      expect(hasUnsavedChanges({ level: 'columns', key: 'kms' })).toBe(true)
    })

    it('returns false when pending matches saved override', () => {
      const { hasUnsavedChanges } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: { columns: { kms: false } },
        pendingChanges: { permissions: { columns: { kms: false } } }
      })
      expect(hasUnsavedChanges({ level: 'columns', key: 'kms' })).toBe(false)
    })

    it('handles capabilities level', () => {
      const { hasUnsavedChanges } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: { columns: { kms: false } } }
      })
      expect(hasUnsavedChanges({ level: 'capabilities', key: 'columns.kms' })).toBe(true)
    })

    it('handles workspacePreferences level', () => {
      const { hasUnsavedChanges } = usePermissionState({
        roleTemplate: baseTemplate as any,
        permissionOverrides: {},
        pendingChanges: { permissions: { settings_tabs: { help: false } } }
      })
      expect(hasUnsavedChanges({ level: 'workspacePreferences', key: 'settings_tabs.help' })).toBe(true)
    })
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/__tests__/use-permission-toggle.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  }
}))

vi.mock('../../../components/admin/business-relevant-toggles', () => ({
  businessRelevantToggles: {
    capabilities: {
      toggles: {
        'columns.kms': { businessName: 'Knowledge Base', linkedKeys: ['features.search.knowledgeBase'] },
        'columns.embeddedApps': { businessName: 'Banking Applications', linkedKeys: ['features.search.embeddedApps'] },
        'columns.spaceCopilot': { businessName: 'AI Assistant', linkedKeys: ['micro_frontends.spaceCopilot'] },
        'columns.chat': { businessName: 'Chat Interface' },
        'micro_frontends.mediaBar': { businessName: 'Media Controls', linkedKeys: ['widgets.mediaBar.callControls'] }
      }
    },
    workspacePreferences: {
      toggles: {
        'settings_options.calls.autoAccept': { businessName: 'Auto-Accept Calls' },
        'settings_options.calls.doNotDisturb.duration': { businessName: 'Do Not Disturb' },
        'settings_options.interface.showTranscript': { businessName: 'Show Transcripts' },
        'settings_options.interface.autoCloseKnowledgeOnCallEnd': { businessName: 'Auto-Close Knowledge' },
        'settings_options.interface.spaceCopilotMode': { businessName: 'AI Assistant Mode' }
      }
    }
  }
}))

vi.mock('../../../components/admin/ad-group-config/utils/permission-helpers', () => ({
  getTemplateSection: (template: Record<string, unknown> | null, level: string) => {
    if (!template) return {}
    const section = template[level]
    if (section && typeof section === 'object') return section
    return {}
  }
}))

vi.mock('../../../utils/admin/permission-level-resolver', () => ({
  resolvePermissionLevel: ({ level, key }: { level: string; key: string }) => {
    const COMPOUND: Record<string, string[]> = {
      capabilities: ['columns', 'features', 'micro_frontends'],
      workspacePreferences: ['widgets', 'settings_tabs', 'settings_options']
    }
    const prefixes = COMPOUND[level]
    if (!prefixes) return { actualLevel: level, actualKey: key }
    for (const prefix of prefixes) {
      if (key.startsWith(prefix + '.')) {
        return { actualLevel: prefix, actualKey: key.slice(prefix.length + 1) }
      }
    }
    const [p, ...rest] = key.split('.')
    return { actualLevel: p, actualKey: rest.join('.') }
  },
  resolveLinkedKey: (linkedKey: string) => {
    const allSections = ['columns', 'features', 'micro_frontends', 'widgets', 'settings_tabs', 'settings_options']
    for (const section of allSections) {
      if (linkedKey.startsWith(section + '.')) {
        return { actualLevel: section, actualKey: linkedKey.slice(section.length + 1) }
      }
    }
    const [level, ...rest] = linkedKey.split('.')
    return { actualLevel: level, actualKey: rest.join('.') }
  }
}))

const { usePermissionToggle } = await import('../use-permission-toggle')

describe('usePermissionToggle', () => {
  const baseTemplate = {
    roleName: 'voice_agent',
    columns: {
      kms: { state: 'enabled' },
      embeddedApps: { state: 'enabled' },
      spaceCopilot: { state: 'enabled' }
    },
    features: {
      'search.knowledgeBase': { state: 'enabled' },
      'search.embeddedApps': { state: 'enabled' }
    },
    micro_frontends: {
      mediaBar: { state: 'enabled' },
      spaceCopilot: { state: 'enabled' }
    },
    widgets: {
      'mediaBar.callControls': { state: 'enabled' }
    },
    settings_options: {
      'calls.autoAccept': { state: 'enabled' },
      'interface.showTranscript': { state: 'enabled' },
      'interface.autoCloseKnowledgeOnCallEnd': { state: 'enabled' },
      'interface.spaceCopilotMode': { state: 'enabled' }
    }
  }

  let setPendingChangesSpy: ReturnType<typeof vi.fn>

  beforeEach(() => {
    resetState()
    setPendingChangesSpy = vi.fn()
  })

  function callHook(overrides: Record<string, unknown> = {}) {
    stateIndex = 0
    return usePermissionToggle({
      roleTemplate: baseTemplate as any,
      permissionOverrides: {},
      pendingChanges: { permissions: {} },
      setPendingChanges: setPendingChangesSpy,
      ...overrides
    })
  }

  it('initializes loadingPermission as null', () => {
    const result = callHook()
    expect(result.loadingPermission).toBeNull()
  })

  it('toggles a capabilities column permission', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'capabilities', key: 'columns.kms', value: false })

    expect(setPendingChangesSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        permissions: expect.objectContaining({
          columns: expect.objectContaining({
            kms: false
          })
        })
      })
    )
  })

  it('toggles a workspacePreferences permission', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'workspacePreferences', key: 'settings_options.calls.autoAccept', value: false })

    expect(setPendingChangesSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        permissions: expect.objectContaining({
          settings_options: expect.objectContaining({
            'calls.autoAccept': false
          })
        })
      })
    )
  })

  it('toggles a micro_frontends capability', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'capabilities', key: 'micro_frontends.mediaBar', value: false })

    expect(setPendingChangesSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        permissions: expect.objectContaining({
          micro_frontends: expect.objectContaining({
            mediaBar: false
          })
        })
      })
    )
  })

  it('removes pending change when value matches saved override', () => {
    const result = callHook({
      permissionOverrides: { columns: { kms: false } }
    })
    result.handleTogglePermission({ level: 'capabilities', key: 'columns.kms', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    expect(call.permissions.columns?.kms).toBeUndefined()
  })

  it('cascades AI Assistant toggle to micro_frontends.spaceCopilot via linkedKeys', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'capabilities', key: 'columns.spaceCopilot', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    // Linked key: micro_frontends.spaceCopilot should also be set to false
    expect(call.permissions.micro_frontends?.spaceCopilot).toBe(false)
  })

  it('cascades Knowledge Base toggle to features.search.knowledgeBase via linkedKeys', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'capabilities', key: 'columns.kms', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    // Linked key: features.search.knowledgeBase should also be set to false
    expect(call.permissions.features?.['search.knowledgeBase']).toBe(false)
  })

  it('cascades Media Controls toggle to widgets.mediaBar.callControls via linkedKeys', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'capabilities', key: 'micro_frontends.mediaBar', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    // Linked key: widgets.mediaBar.callControls should also be set to false
    expect(call.permissions.widgets?.['mediaBar.callControls']).toBe(false)
  })

  it('does not cascade linkedKeys for toggles without them', () => {
    const result = callHook()
    result.handleTogglePermission({ level: 'capabilities', key: 'columns.chat', value: false })

    const call = setPendingChangesSpy.mock.calls[0][0]
    // Only columns.chat should be affected, no other sections
    expect(call.permissions.columns?.chat).toBe(false)
    expect(call.permissions.features).toBeUndefined()
    expect(call.permissions.micro_frontends).toBeUndefined()
    expect(call.permissions.widgets).toBeUndefined()
  })
})
===ENDFILE
===FILE: ./src/hooks/admin/use-ad-group-form.ts
import { useState, useEffect, useCallback } from 'react'
import { useAdGroupApi } from '../api/use-ad-group-api'
import { getRoleTemplateByName, type RoleTemplateDto } from '../../services/api/role-template.service'
import { createLogger } from '../../utils/core/debug'
import type {
  AdGroup,
  PermissionOverrides,
  PendingChanges,
  RoleTemplate,
  PermissionState
} from '../../types/features/ad-group-config'

interface UseAdGroupFormProps {
  initialGroup: AdGroup
  open: boolean
}

const logger = createLogger('useAdGroupForm')

function toPermissionStateMap(
  section: Record<string, { stateText: string } | undefined> | undefined
): Record<string, PermissionState> {
  if (!section) {
    return {}
  }

  return Object.fromEntries(
    Object.entries(section).map(([key, value]) => {
      const normalizedState = value?.stateText?.toLowerCase() === 'enabled' ? 'enabled' : 'disabled'
      return [key, { state: normalizedState }]
    })
  )
}

function transformApiTemplate(dto: RoleTemplateDto): RoleTemplate {
  return {
    roleName: dto.roleNameCode,
    roleDisplayName: dto.roleDisplayName,
    columns: toPermissionStateMap(dto.columns),
    widgets: toPermissionStateMap(dto.widgets),
    features: toPermissionStateMap(dto.features),
    settings_tabs: toPermissionStateMap(dto.settingsTabs),
    settings_options: toPermissionStateMap(dto.settingsOptions),
    micro_frontends: toPermissionStateMap(dto.microFrontends)
  }
}

const ASSIGNMENT_LEVELS = [
  'columnAssignments',
  'widgetAssignments',
  'featureAssignments',
  'settingsTabAssignments',
  'settingsOptionAssignments',
  'microFrontendAssignments'
] as const

function buildOverridesFromAssignments(savedData: AdGroup): PermissionOverrides {
  const overrides: PermissionOverrides = {}
  for (const level of ASSIGNMENT_LEVELS) {
    const assignmentBlock = savedData[level]
    if (!assignmentBlock) continue
    const levelKey = mapAssignmentKeyToLevel(level)
    const assignments = assignmentBlock as Record<string, PermissionState>
    if (!overrides[levelKey]) overrides[levelKey] = {}
    for (const [key, assignment] of Object.entries(assignments)) {
      overrides[levelKey][key] = assignment.state === 'enabled'
    }
  }
  return overrides
}

export function useAdGroupForm({ initialGroup, open }: UseAdGroupFormProps) {
  const [formData, setFormData] = useState<AdGroup>({ ...initialGroup })
  const [roleTemplate, setRoleTemplate] = useState<RoleTemplate | null>(null)
  const [isLoadingRoleTemplate, setIsLoadingRoleTemplate] = useState(false)
  const [permissionOverrides, setPermissionOverrides] = useState<PermissionOverrides>({})
  const [pendingChanges, setPendingChanges] = useState<PendingChanges>({ permissions: {} })

  const {
    isLoading: isLoadingAdGroup,
    fetchAdGroupData,
    updateAdGroupConfig,
    applyRoleTemplate: applyRoleTemplateApi
  } = useAdGroupApi()

  const loadRoleTemplate = useCallback(async (roleNameCode: string): Promise<RoleTemplate> => {
    const templateDto = await getRoleTemplateByName(roleNameCode)
    return transformApiTemplate(templateDto)
  }, [])

  useEffect(() => {
    const roleNameCode = formData.roleName

    if (!roleNameCode) {
      setRoleTemplate(null)
      setIsLoadingRoleTemplate(false)
      return undefined
    }

    let active = true

    const fetchTemplate = async () => {
      setIsLoadingRoleTemplate(true)
      try {
        const template = await loadRoleTemplate(roleNameCode)
        if (active) {
          setRoleTemplate(template)
        }
      } catch (error) {
        logger.error('Failed to load role template', { roleNameCode, error })
        if (active) {
          setRoleTemplate(null)
        }
      } finally {
        if (active) {
          setIsLoadingRoleTemplate(false)
        }
      }
    }

    fetchTemplate()

    return () => {
      active = false
    }
  }, [formData.roleName, loadRoleTemplate])

  // Fetch saved AD group data when modal opens
  useEffect(() => {
    const loadSavedGroupData = async () => {
      if (!open) return

      const savedData = await fetchAdGroupData(initialGroup.groupIdentifier).catch(() => null)
      if (savedData) {
          setFormData(savedData)

          setPermissionOverrides(buildOverridesFromAssignments(savedData))
        }
    }

    loadSavedGroupData()
  }, [open, initialGroup.groupIdentifier, fetchAdGroupData])

  const updateFormData = (updates: Partial<AdGroup>) => {
    setFormData(prev => ({ ...prev, ...updates }))
  }

  const updatePermissionOverrides = (updates: Partial<PermissionOverrides>) => {
    setPermissionOverrides(prev => {
      const result: PermissionOverrides = { ...prev }
      Object.keys(updates).forEach(key => {
        const value = updates[key]
        if (value !== undefined) {
          result[key] = value
        }
      })
      return result
    })
  }

  const handleApplyRoleTemplate = async (roleName: string): Promise<void> => {
    const result = await applyRoleTemplateApi(formData.groupIdentifier, roleName)

    if (result) {
      setFormData(prev => ({ ...prev, roleName }))
      setPermissionOverrides({})
      setPendingChanges({ permissions: {} })
      setRoleTemplate(null)
    }
  }

  return {
    formData,
    roleTemplate,
    isLoadingRoleTemplate,
    permissionOverrides,
    pendingChanges,
    isLoadingAdGroup,
    updateFormData,
    updatePermissionOverrides,
    setPendingChanges,
    handleApplyRoleTemplate,
    updateAdGroupConfig,
  }
}

// Helper function
function mapAssignmentKeyToLevel(key: string): string {
  const mapping: Record<string, string> = {
    columnAssignments: 'columns',
    widgetAssignments: 'widgets',
    featureAssignments: 'features',
    settingsTabAssignments: 'settings_tabs',
    settingsOptionAssignments: 'settings_options',
    microFrontendAssignments: 'micro_frontends'
  }
  return mapping[key] || key
}
===ENDFILE
===FILE: ./src/hooks/admin/use-ad-groups-data.ts
import { useState, useRef, useCallback } from 'react'
import { useNotifications } from '../features/use-notifications'
import type { AdGroup, AdGroupSummaryCounts, UserAccessLevel } from '../../types/features/ad-group-config'
import { apiFetch } from '../../services/core/api-client'

interface FetchParams {
  page: number
  size: number
  search?: string
  role?: string
  status?: string
  market?: string
  region?: string
  country?: string
  businessUnit?: string
}

const toAssignments = (
  permissions: Record<string, unknown> | undefined
): Record<string, { state: 'enabled' | 'disabled' }> | undefined => {
  if (!permissions) return undefined

  return Object.fromEntries(
    Object.entries(permissions).map(([key, value]) => {
      const enabled = Boolean((value as { enabledIndicator?: boolean })?.enabledIndicator)
      return [key, { state: enabled ? 'enabled' : 'disabled' as const }]
    })
  )
}

const resolveUserCount = (raw: number | string | undefined): number | undefined => {
  const parsed = typeof raw === 'string' ? Number.parseInt(raw, 10) : raw
  if (typeof parsed === 'number' && !Number.isNaN(parsed)) return parsed
  return undefined
}

const mapGroupIdentity = (group: Record<string, unknown>, fallbackIndex: number) => ({
  id: (group.groupIdentifier as string) || String(fallbackIndex + 1),
  groupIdentifier: (group.groupIdentifier as string) || 'Unknown',
  logicalName: (group.logicalName as string | null) || undefined,
  roleName: (group.roleName as string | null) || undefined,
  market: (group.marketCode as string | null) || undefined,
  region: (group.regionCode as string | null) || undefined,
  businessUnit: (group.businessUnitName as string | null) || undefined,
  country: (group.countryCode as string | null) || undefined,
})

const mapGroupMetadata = (group: Record<string, unknown>) => ({
  isActive: (group.activeIndicator as boolean | undefined) ?? true,
  accessLevel: (group.userAccessCode as UserAccessLevel | undefined),
  pendingChangeIndicator: (group.pendingChangeIndicator as boolean | undefined) ?? false,
  versionNumber: (group.versionNumber as number | undefined),
  userCount: resolveUserCount(group.userCountNumber as number | string | undefined),
  permissionCount: (group.permissionCount as number | undefined) || undefined,
  overrideCount: (group.overrideCount as number | undefined) || 0,
  lastModified: (group.updatedAtDatetime as string | undefined) || undefined,
})

const transformGroup = (group: Record<string, unknown>, fallbackIndex: number): AdGroup => {
  const currentConfig = group.currentConfig as Record<string, unknown> | undefined
  const permissionChanges = currentConfig?.permissionChanges as Record<string, unknown> | undefined

  return {
    ...mapGroupIdentity(group, fallbackIndex),
    ...mapGroupMetadata(group),
    columnAssignments: toAssignments(
      permissionChanges?.columnPermissions as Record<string, unknown> | undefined
    ),
    widgetAssignments: toAssignments(
      permissionChanges?.widgetPermissions as Record<string, unknown> | undefined
    )
  }
}

function parseAdGroupsResponse(payload: {
  data?: {
    items?: Record<string, unknown>[]
    totalCount?: number
    limitNumber?: number
  }
}): { groups: AdGroup[]; total: number; pageSize: number } {
  const responseData = payload.data
  if (!responseData || !Array.isArray(responseData.items)) {
    throw new Error('Unexpected AD groups response format')
  }

  const groups = responseData.items.map((group, index) => transformGroup(group, index))
  return {
    groups,
    total: responseData.totalCount ?? groups.length,
    pageSize: responseData.limitNumber ?? 25
  }
}

export function useAdGroupsData() {
  const [adGroups, setAdGroups] = useState<AdGroup[]>([])
  const [loading, setLoading] = useState(true)
  const [totalCount, setTotalCount] = useState(0)
  const [totalPages, setTotalPages] = useState(1)
  const [summary, setSummary] = useState<AdGroupSummaryCounts>({})
  const notifications = useNotifications()

  const groupCacheRef = useRef<Map<string, AdGroup>>(new Map())

  // Scroll position preservation
  const tableContainerRef = useRef<HTMLDivElement | null>(null)
  const lastScrollPosition = useRef<{ source: 'container' | 'window'; value: number }>({
    source: 'window',
    value: 0
  })

  const saveScrollPosition = () => {
    const container = tableContainerRef.current
    const isContainerScrollable = container && container.scrollHeight > container.clientHeight + 1

    if (isContainerScrollable && container) {
      lastScrollPosition.current = {
        source: 'container',
        value: container.scrollTop
      }
      return
    }

    if (typeof window !== 'undefined') {
      lastScrollPosition.current = {
        source: 'window',
        value: window.scrollY ?? 0
      }
    }
  }

  const restoreScrollPosition = () => {
    const { source, value } = lastScrollPosition.current
    if (value <= 0) {
      return
    }

    if (source === 'container') {
      const container = tableContainerRef.current
      if (container) {
        setTimeout(() => {
          if (tableContainerRef.current) {
            tableContainerRef.current.scrollTop = value
          }
        }, 0)
      }
      return
    }

    if (typeof window !== 'undefined') {
      requestAnimationFrame(() => {
        window.scrollTo({
          top: value,
          behavior: 'auto'
        })
      })
    }
  }

  const buildQueryString = (params: FetchParams): string => {
    const query = new URLSearchParams()
    query.set('offset', String((params.page - 1) * params.size))
    query.set('limit', String(params.size))

    if (params.search) {
      query.set('search', params.search)
    }

    const filterMappings: Array<[string | undefined, string]> = [
      [params.role, 'roleText'],
      [params.status, 'statusCode'],
      [params.market, 'marketText'],
      [params.region, 'regionText'],
      [params.country, 'countryText'],
      [params.businessUnit, 'businessUnitText']
    ]
    for (const [value, paramName] of filterMappings) {
      if (value && value !== 'all') {
        query.set(paramName, value)
      }
    }

    return query.toString()
  }

  const fetchAdGroups = useCallback(async (params: FetchParams) => {
    try {
      setLoading(true)
      const queryString = buildQueryString(params)
      const response = await apiFetch(`/papi/v1/ad-groups?${queryString}`, {
        method: 'GET'
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const payload = await response.json() as {
        data?: {
          items?: Record<string, unknown>[]
          totalCount?: number
          limitNumber?: number
        }
      }

      const { groups: transformedGroups, total, pageSize } = parseAdGroupsResponse(payload)

      // Cache most recent representation for each group
      const cache = new Map(groupCacheRef.current)
      transformedGroups.forEach(group => {
        cache.set(group.id, group)
      })
      groupCacheRef.current = cache

      setAdGroups(transformedGroups)
      setTotalCount(total)
      setTotalPages(Math.max(1, Math.ceil(total / pageSize)))
      setSummary({})

      return transformedGroups
    } catch {
      notifications.error({
        title: 'Unable to load AD groups',
        description: 'Please refresh the page or try again later.',
        metaKey: 'ad-groups-fetch-error'
      })
      setAdGroups([])
      setTotalCount(0)
      setTotalPages(1)
      setSummary({})
      return []
    } finally {
      setLoading(false)
    }
  }, [notifications])

  const getGroupById = useCallback((id: string) => groupCacheRef.current.get(id), [])

  return {
    adGroups,
    loading,
    totalCount,
    totalPages,
    summary,
    fetchAdGroups,
    saveScrollPosition,
    restoreScrollPosition,
    tableContainerRef,
    getGroupById
  }
}
===ENDFILE
===FILE: ./src/hooks/admin/use-ad-groups-loader.ts
import { useEffect, useState, useCallback, useRef } from 'react'
import type { AdGroup } from '../../types/features/ad-group-config'
import { adminService } from '../../services/api/admin.service'
import { useNotifications } from '../features/use-notifications'
import { isConfiguredGroup } from '../../utils/admin/notice-validators'

interface UseAdGroupsLoaderParams {
  open: boolean
  searchTerm: string
  debounceMs?: number
}

export function useAdGroupsLoader({ open, searchTerm, debounceMs = 250 }: UseAdGroupsLoaderParams) {
  const notifications = useNotifications()
  const [adGroups, setAdGroups] = useState<AdGroup[]>([])
  const [isLoadingGroups, setIsLoadingGroups] = useState(false)
  const cancelledRef = useRef(false)
  const notificationsRef = useRef(notifications)
  notificationsRef.current = notifications
  const searchTermRef = useRef(searchTerm)
  searchTermRef.current = searchTerm

  const loadGroups = useCallback(async () => {
    cancelledRef.current = false
    setIsLoadingGroups(true)
    try {
      const groups = await adminService.searchAdGroups(searchTermRef.current, 750)
      if (cancelledRef.current) return
      setAdGroups(groups.filter(group => isConfiguredGroup({ group })))
    } catch (error) {
      if (cancelledRef.current) return
      notificationsRef.current.error({
        title: 'Unable to load AD groups',
        description: error instanceof Error ? error.message : 'Please try again later.'
      })
      setAdGroups([])
    } finally {
      if (!cancelledRef.current) {
        setIsLoadingGroups(false)
      }
    }
  }, [])

  useEffect(() => {
    if (!open) return undefined

    const handle = setTimeout(() => { loadGroups() }, debounceMs)

    return () => {
      cancelledRef.current = true
      clearTimeout(handle)
    }
  }, [open, searchTerm, debounceMs, loadGroups])

  return {
    adGroups,
    isLoadingGroups
  }
}
===ENDFILE
===FILE: ./src/hooks/admin/use-ad-groups-selection.ts
import { useCallback, useEffect, useRef, useState } from 'react'
import { useNotifications } from '../features/use-notifications'
import { adminService } from '../../services/api/admin.service'
import type { AdGroup } from '../../types/features/ad-group-config'
import type { CopyOptions, CopyResult } from '../../types/features/admin.types'

interface UseAdGroupsSelectionProps {
  currentGroups: AdGroup[]
  getGroupById: (id: string) => AdGroup | undefined
  onRefresh: () => Promise<void>
  saveScrollPosition: () => void
  restoreScrollPosition: () => void
}

export interface BulkCopyExecutionOptions {
  copyRoleAndPermissionsFlag: boolean
  copyBusinessInfoFlag: boolean
  copyApplicationsFlag: boolean
  copyWorkflowModeCode: NonNullable<CopyOptions['copyWorkflowModeCode']>
  functionMismatchPolicyCode: NonNullable<CopyOptions['functionMismatchPolicyCode']>
}

export function useAdGroupsSelection({
  currentGroups,
  getGroupById,
  onRefresh,
  saveScrollPosition,
  restoreScrollPosition
}: UseAdGroupsSelectionProps) {
  const [selectedGroups, setSelectedGroups] = useState<Set<string>>(new Set())
  const [toggleConfirmOpen, setToggleConfirmOpen] = useState(false)
  const [groupToToggle, setGroupToToggle] = useState<AdGroup | null>(null)
  const [allAdGroups, setAllAdGroups] = useState<AdGroup[]>([])
  const [isLookupLoading, setIsLookupLoading] = useState(false)
  const selectedDetailsRef = useRef<Map<string, AdGroup>>(new Map())
  const notifications = useNotifications()

  const fetchLookup = useCallback(async (query: string) => {
    setIsLookupLoading(true)
    try {
      const groups = await adminService.searchAdGroups(query || undefined, 750)
      const configuredGroups = groups.filter(group => group?.groupIdentifier)

      const cache = new Map(selectedDetailsRef.current)
      configuredGroups.forEach(group => {
        if (group?.id) {
          cache.set(group.id, group)
        }
      })
      selectedDetailsRef.current = cache

      setAllAdGroups(configuredGroups)

      return configuredGroups
    } catch (error) {
      notifications.error({
        title: 'Unable to load AD groups',
        description: error instanceof Error ? error.message : 'Please refresh the page or try again later.',
        metaKey: 'ad-group-search-error'
      })
      return []
    } finally {
      setIsLookupLoading(false)
    }
  }, [notifications])

  useEffect(() => {
    let mounted = true

    const loadInitialData = async () => {
      if (mounted) {
        await fetchLookup('')
      }
    }

    loadInitialData()

    return () => {
      mounted = false
    }
  }, [fetchLookup])

  const cacheGroup = (group: AdGroup | undefined) => {
    if (!group) return
    const cache = new Map(selectedDetailsRef.current)
    cache.set(group.id, group)
    selectedDetailsRef.current = cache
  }

  const removeGroupFromCache = (groupId: string) => {
    const cache = new Map(selectedDetailsRef.current)
    cache.delete(groupId)
    selectedDetailsRef.current = cache
  }

  const handleSelectGroup = (groupId: string) => {
    setSelectedGroups(prev => {
      const updated = new Set(prev)
      if (updated.has(groupId)) {
        updated.delete(groupId)
        removeGroupFromCache(groupId)
      } else {
        updated.add(groupId)
        const group = getGroupById(groupId) || currentGroups.find(g => g.id === groupId)
        cacheGroup(group)
      }
      return updated
    })
  }

  const handleSelectAll = () => {
    if (currentGroups.length === 0) {
      return
    }
    const cache = new Map(selectedDetailsRef.current)
    currentGroups.forEach(group => {
      cache.set(group.id, group)
    })
    selectedDetailsRef.current = cache
    setSelectedGroups(prev => {
      const updated = new Set(prev)
      currentGroups.forEach(group => updated.add(group.id))
      return updated
    })
  }

  const handleDeselectAll = () => {
    setSelectedGroups(new Set())
    selectedDetailsRef.current = new Map()
  }

  const handleSelectGroups = (groups: AdGroup[]) => {
    if (!groups || groups.length === 0) return
    const cache = new Map(selectedDetailsRef.current)
    groups.forEach(group => {
      cache.set(group.id, group)
    })
    selectedDetailsRef.current = cache
    setSelectedGroups(prev => {
      const updated = new Set(prev)
      groups.forEach(group => updated.add(group.id))
      return updated
    })
  }

  const handleDeselectGroups = (groupIds: string[]) => {
    if (groupIds.length === 0) return
    const cache = new Map(selectedDetailsRef.current)
    groupIds.forEach(id => cache.delete(id))
    selectedDetailsRef.current = cache
    setSelectedGroups(prev => {
      const updated = new Set(prev)
      groupIds.forEach(id => updated.delete(id))
      return updated
    })
  }

  const notifyCopyResult = (
    successCount: number,
    failCount: number,
    approvalSubmissionCount: number,
    criticalCount: number
  ) => {
    if (successCount > 0 && failCount === 0) {
      const plural = successCount !== 1 ? 's' : ''
      const submittedSuffix = approvalSubmissionCount > 0
        ? ` ${approvalSubmissionCount} submitted for approval.`
        : ''
      const criticalSuffix = criticalCount > 0
        ? ` ${criticalCount} need L2 after L1 approval.`
        : ''
      notifications.success({
        title: 'Configuration copied',
        description: `Copied settings to ${successCount} group${plural}.${submittedSuffix}${criticalSuffix}`
      })
      return
    }
    if (successCount > 0) {
      const successPlural = successCount !== 1 ? 's' : ''
      notifications.warning({
        title: 'Partial copy complete',
        description: `Success for ${successCount} group${successPlural}; ${failCount} failed.`
      })
      return
    }
    notifications.error({
      title: 'Copy failed',
      description: 'No group configurations were updated.',
      metaKey: 'ad-group-copy-error'
    })
  }

  const copyToTarget = async (
    sourceIdentifier: string,
    targetIdentifier: string,
    executionOptions: BulkCopyExecutionOptions
  ): Promise<CopyResult> => {
    try {
      return await adminService.copyAdGroupConfiguration(sourceIdentifier, targetIdentifier, {
        copyRoleAndPermissionsFlag: executionOptions.copyRoleAndPermissionsFlag,
        copyBusinessInfoFlag: executionOptions.copyBusinessInfoFlag,
        copyApplicationsFlag: executionOptions.copyApplicationsFlag,
        overwriteExistingFlag: true,
        copyWorkflowModeCode: executionOptions.copyWorkflowModeCode,
        functionMismatchPolicyCode: executionOptions.functionMismatchPolicyCode
      })
    } catch {
      return {
        success: false,
        message: 'Copy request failed',
        error: 'COPY_FAILED'
      }
    }
  }

  const handleCopyFrom = async (
    sourceGroup: AdGroup,
    targetGroupIds: string[],
    executionOptions: BulkCopyExecutionOptions
  ) => {
    const targetGroups = targetGroupIds
      .map(id => selectedDetailsRef.current.get(id) || getGroupById(id))
      .filter((group): group is AdGroup => !!group)

    let successCount = 0
    let failCount = 0
    let approvalSubmissionCount = 0
    let criticalCount = 0
    for (const targetGroup of targetGroups) {
      const result = await copyToTarget(
        sourceGroup.groupIdentifier,
        targetGroup.groupIdentifier,
        executionOptions
      )
      if (result.success) {
        successCount++
        if (result.workflowStatusCode === 'SUBMITTED_FOR_APPROVAL') {
          approvalSubmissionCount++
        }
        if (result.criticalIndicator) {
          criticalCount++
        }
      } else {
        failCount++
      }
    }

    notifyCopyResult(successCount, failCount, approvalSubmissionCount, criticalCount)
    await onRefresh()
    handleDeselectAll()
  }

  const handleToggleActive = (group: AdGroup) => {
    setGroupToToggle(group)
    cacheGroup(group)
    setToggleConfirmOpen(true)
  }

  const confirmToggleActive = async () => {
    if (!groupToToggle) return

    saveScrollPosition()

    try {
      const newStatus = !groupToToggle.isActive
      await adminService.updateAdGroup(groupToToggle.groupIdentifier, { isActive: newStatus })

      const groupName = groupToToggle.logicalName || groupToToggle.groupIdentifier
      notifications.success({
        title: newStatus ? 'Group enabled' : 'Group disabled',
        description: `${groupName} was updated successfully.`
      })

      await onRefresh()

      setToggleConfirmOpen(false)
      setGroupToToggle(null)
    } catch {
      notifications.error({
        title: 'Status update failed',
        description: 'We could not update the selected AD group. Please try again.',
        metaKey: 'ad-group-toggle-error'
      })
    } finally {
      restoreScrollPosition()
    }
  }

  const availableGroupsForSelection = Array.from(
    (() => {
      const combined = new Map<string, AdGroup>()
      allAdGroups.forEach(group => {
        if (group?.id) {
          combined.set(group.id, group)
        }
      })
      currentGroups.forEach(group => combined.set(group.id, group))
      selectedDetailsRef.current.forEach((group, id) => combined.set(id, group))
      return combined
    })().values()
  )

  return {
    selectedGroups,
    handleSelectGroup,
    handleSelectAll,
    handleDeselectAll,
    handleSelectGroups,
    handleDeselectGroups,
    handleCopyFrom,
    handleToggleActive,
    confirmToggleActive,
    toggleConfirmOpen,
    setToggleConfirmOpen,
    groupToToggle,
    availableGroupsForSelection,
    searchAdGroups: fetchLookup,
    isLookupLoading
  }
}
===ENDFILE
===FILE: ./src/hooks/admin/use-application-assignment.ts
import { useState, useEffect, useCallback, useRef } from 'react'
import { useEmbeddedAppsApi } from '../api/use-embedded-apps-api'
import { useNotifications } from '../features/use-notifications'
import type { EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'
import type { StagedAppChange } from '../../types/features/ad-group-config'

interface UseApplicationAssignmentProps {
  groupIdentifier: string
  groupDisplayName: string
  open: boolean
  activeTab: string
  canDirectSave?: boolean
}

function hasFunctionSetChanged(previousFunctions: string[], newFunctions: string[]): boolean {
  const prevSet = new Set(previousFunctions)
  const newSet = new Set(newFunctions)
  if (prevSet.size !== newSet.size) return true
  return [...prevSet].some(f => !newSet.has(f)) || [...newSet].some(f => !prevSet.has(f))
}

export function useApplicationAssignment({
  groupIdentifier,
  groupDisplayName,
  open,
  activeTab,
  canDirectSave = true
}: UseApplicationAssignmentProps) {
  const notifications = useNotifications()
  const [availableApps, setAvailableApps] = useState<EmbeddedAppWithStatus[]>([])
  const [selectedApp, setSelectedApp] = useState<EmbeddedAppWithStatus | null>(null)
  const [appSearchTerm, setAppSearchTerm] = useState('')
  const [stagedAppChanges, setStagedAppChanges] = useState<StagedAppChange[]>([])
  const loadedForGroupRef = useRef<string | null>(null)
  const [unsavedFunctionSelection, setUnsavedFunctionSelection] = useState<{
    appKey: string
    appTitle: string
    functions: string[]
    defaultFunction?: string
  } | null>(null)

  const {
    isLoadingApps,
    isSavingAppAssignment,
    loadEmbeddedAppsData,
    saveAppAssignment: saveAppAssignmentApi
  } = useEmbeddedAppsApi()

  const handleLoadEmbeddedAppsData = useCallback(async () => {
    try {
      const apps = await loadEmbeddedAppsData(groupIdentifier)
      setAvailableApps(apps)
    } catch {
      // Load failure handled silently
    }
  }, [loadEmbeddedAppsData, groupIdentifier])

  useEffect(() => {
    if (!open || activeTab !== 'applications') {
      if (!open) {
        loadedForGroupRef.current = null
      }
      return undefined
    }

    // Skip if already loaded for this group in this modal session
    if (loadedForGroupRef.current === groupIdentifier) return undefined
    loadedForGroupRef.current = groupIdentifier

    let ignore = false
    loadEmbeddedAppsData(groupIdentifier).then(apps => {
      if (!ignore) setAvailableApps(apps)
    }).catch(() => {
      // Load failure handled silently
    })

    return () => { ignore = true }
  }, [open, activeTab, groupIdentifier, loadEmbeddedAppsData])

  const refreshAndUpdateSelected = async (selectedAppIdentifier: string | undefined) => {
    try {
      const apps = await loadEmbeddedAppsData(groupIdentifier)
      setAvailableApps(apps)
      if (!selectedAppIdentifier) return
      const updatedApp = apps.find(app => app.appIdentifier === selectedAppIdentifier)
      if (updatedApp) {
        setSelectedApp(updatedApp)
      }
    } catch {
      // Reload failure handled silently
    }
  }

  const stageAppChange = (appKey: string, appTitle: string, functions: string[]) => {
    const currentApp = availableApps.find(a => a.appIdentifier === appKey)
    const previousFunctions = currentApp?.assignedFunctionKeys ?? []

    setStagedAppChanges(prev => {
      const existing = prev.filter(c => c.appKey !== appKey)
      if (!hasFunctionSetChanged(previousFunctions, functions)) return existing
      return [...existing, { appKey, appTitle, previousFunctions, newFunctions: functions }]
    })

    setAvailableApps(prev => prev.map(app => {
      if (app.appIdentifier !== appKey) return app
      return { ...app, isAssignedIndicator: functions.length > 0, assignedFunctionKeys: functions }
    }))

    if (selectedApp?.appIdentifier === appKey) {
      setSelectedApp(prev => prev ? {
        ...prev, isAssignedIndicator: functions.length > 0, assignedFunctionKeys: functions
      } : null)
    }

    notifications.success({
      title: 'App Changes Staged',
      description: `Changes to ${appTitle} will be included when you submit for approval.`
    })
  }

  const handleSaveAppAssignment = async (
    appKey: string,
    appTitle: string,
    functions: string[],
    defaultFunction?: string
  ): Promise<void> => {
    if (canDirectSave) {
      await saveAppAssignmentApi(appKey, appTitle, groupIdentifier, groupDisplayName, functions, defaultFunction)
      await refreshAndUpdateSelected(selectedApp?.appIdentifier)
      return
    }
    stageAppChange(appKey, appTitle, functions)
  }

  const handleAppSelect = (app: EmbeddedAppWithStatus) => {
    setSelectedApp(app)
  }

  const handleAppCancel = () => {
    setSelectedApp(null)
  }

  const clearStagedAppChanges = useCallback(() => {
    setStagedAppChanges([])
  }, [])

  const handleFunctionSelectionChange = useCallback((
    appKey: string,
    appTitle: string,
    functions: string[],
    defaultFunction?: string
  ) => {
    // Empty functions array means the selection was saved/reset (no pending changes)
    if (functions.length === 0 && !defaultFunction) {
      setUnsavedFunctionSelection(null)
      return
    }
    setUnsavedFunctionSelection({ appKey, appTitle, functions, defaultFunction })
  }, [])

  const flushUnsavedFunctions = async () => {
    if (!unsavedFunctionSelection) return
    const { appKey, appTitle, functions, defaultFunction } = unsavedFunctionSelection
    if (canDirectSave) {
      await saveAppAssignmentApi(appKey, appTitle, groupIdentifier, groupDisplayName, functions, defaultFunction)
    } else {
      stageAppChange(appKey, appTitle, functions)
    }
    setUnsavedFunctionSelection(null)
  }

  const filteredApps = availableApps.filter(app =>
    !appSearchTerm ||
    app.titleText.toLowerCase().includes(appSearchTerm.toLowerCase()) ||
    app.descriptionText.toLowerCase().includes(appSearchTerm.toLowerCase()) ||
    app.categoryName.toLowerCase().includes(appSearchTerm.toLowerCase())
  )

  return {
    availableApps,
    selectedApp,
    appSearchTerm,
    filteredApps,
    isLoadingApps,
    isSavingAppAssignment,
    stagedAppChanges,
    unsavedFunctionSelection,
    setAppSearchTerm,
    handleAppSelect,
    handleAppCancel,
    handleSaveAppAssignment,
    handleFunctionSelectionChange,
    flushUnsavedFunctions,
    handleLoadEmbeddedAppsData,
    clearStagedAppChanges
  }
}
===ENDFILE
===FILE: ./src/hooks/admin/use-config-save.ts
import { useState } from 'react'
import type { AdGroup, PermissionOverrides, PendingChanges, StagedAppChange } from '../../types/features/ad-group-config'
import { convertOverridesToAssignments } from '../../components/admin/ad-group-config/utils/permission-helpers'
import { useNotifications } from '../features/use-notifications'
import { adminApprovalService } from '../../services/api/admin-approval.service'
import type { ChangeType } from '../../types/features/approval-workflow.types'

interface UseConfigSaveParams {
  formData: AdGroup
  group: AdGroup
  permissionOverrides: PermissionOverrides
  pendingChanges: PendingChanges
  stagedAppChanges?: StagedAppChange[]
  canDirectSave?: boolean  // Super Admin can bypass approval workflow
  updateAdGroupConfig: (
    groupIdentifier: string,
    data: Partial<AdGroup>,
    options?: { suppressSuccessToast?: boolean }
  ) => Promise<AdGroup | null>
  updatePermissionOverrides: (overrides: PermissionOverrides) => void
  setPendingChanges: (changes: PendingChanges) => void
  clearStagedAppChanges?: () => void
  flushUnsavedFunctions?: () => Promise<void>
  onSave: (group: AdGroup) => void
  onClose: () => void
}

function classifyAppChange(prevSize: number, newSize: number): 'added' | 'removed' | 'unchanged' {
  if (prevSize === 0 && newSize > 0) return 'added'
  if (prevSize > 0 && newSize === 0) return 'removed'
  return 'unchanged'
}

function collectFunctionChanges(
  change: StagedAppChange,
  prevSet: Set<string>,
  newSet: Set<string>
) {
  const added: Array<{ appIdentifier: string; functionIdentifier: string }> = []
  const removed: Array<{ appIdentifier: string; functionIdentifier: string }> = []
  const unchanged: Array<{ appIdentifier: string; functionIdentifier: string }> = []
  const changedKeys: string[] = []

  for (const fn of change.newFunctions) {
    const entry = { appIdentifier: change.appKey, functionIdentifier: fn }
    if (!prevSet.has(fn)) {
      added.push(entry)
      changedKeys.push(`${change.appKey}:${fn}`)
    } else {
      unchanged.push(entry)
    }
  }
  for (const fn of change.previousFunctions) {
    if (newSet.has(fn)) continue
    removed.push({ appIdentifier: change.appKey, functionIdentifier: fn })
    changedKeys.push(`${change.appKey}:${fn}`)
  }

  return { added, removed, unchanged, changedKeys }
}

function buildAppChangePayload(stagedAppChanges: StagedAppChange[]) {
  const addedApps: string[] = []
  const removedApps: string[] = []
  const unchangedApps: string[] = []
  const addedFunctions: Array<{ appIdentifier: string; functionIdentifier: string }> = []
  const removedFunctions: Array<{ appIdentifier: string; functionIdentifier: string }> = []
  const unchangedFunctions: Array<{ appIdentifier: string; functionIdentifier: string }> = []
  const changedApps: string[] = []
  const changedFunctionKeys: string[] = []

  for (const change of stagedAppChanges) {
    const prevSet = new Set(change.previousFunctions)
    const newSet = new Set(change.newFunctions)
    changedApps.push(change.appKey)

    const appBucket = { added: addedApps, removed: removedApps, unchanged: unchangedApps }
    appBucket[classifyAppChange(prevSet.size, newSet.size)].push(change.appKey)

    const fns = collectFunctionChanges(change, prevSet, newSet)
    addedFunctions.push(...fns.added)
    removedFunctions.push(...fns.removed)
    unchangedFunctions.push(...fns.unchanged)
    changedFunctionKeys.push(...fns.changedKeys)
  }

  return {
    applicationChanges: { added: addedApps, removed: removedApps, unchanged: unchangedApps },
    appFunctionChanges: { added: addedFunctions, removed: removedFunctions, unchanged: unchangedFunctions },
    changedApps,
    changedFunctions: changedFunctionKeys
  }
}

function mergeOverrides(permissionOverrides: PermissionOverrides, pendingChanges: PendingChanges): PermissionOverrides {
  const merged = { ...permissionOverrides }
  if (!pendingChanges.permissions) return merged
  for (const [level, changes] of Object.entries(pendingChanges.permissions)) {
    if (!merged[level]) {
      merged[level] = {}
    }
    Object.assign(merged[level], changes)
  }
  return merged
}

function buildCurrentState(group: AdGroup): Record<string, unknown> {
  const state: Record<string, unknown> = {}
  const fields = ['logicalName', 'roleName', 'region', 'country', 'market', 'businessUnit'] as const
  for (const field of fields) {
    if (group[field]) {
      state[field] = group[field]
    }
  }
  return state
}

function computeBusinessInfoChanges(group: AdGroup, formData: AdGroup): Record<string, unknown> {
  const changes: Record<string, unknown> = {}
  const fields = ['logicalName', 'roleName', 'region', 'country', 'market', 'businessUnit'] as const
  for (const field of fields) {
    const original = group[field as keyof AdGroup]
    const proposed = formData[field as keyof AdGroup]
    if (original !== proposed && proposed !== undefined) {
      changes[field] = proposed
    }
  }
  return changes
}

function computePermissionChanges(mergedOverrides: PermissionOverrides): Record<string, unknown> {
  const changes: Record<string, unknown> = {}
  for (const [level, levelChanges] of Object.entries(mergedOverrides)) {
    if (levelChanges && Object.keys(levelChanges).length > 0) {
      changes[level] = levelChanges
    }
  }
  return changes
}

function hasEntries(obj: Record<string, unknown>): boolean {
  return Object.keys(obj).length > 0
}

function buildSavePayload(
  group: AdGroup,
  formData: AdGroup,
  permissionOverrides: PermissionOverrides,
  pendingChanges: PendingChanges,
  stagedAppChanges: StagedAppChange[]
) {
  const mergedOverrides = mergeOverrides(permissionOverrides, pendingChanges)
  const assignments = convertOverridesToAssignments(mergedOverrides)

  const { id: _id, lastModified: _lastModified, ...formDataWithoutMetadata } = formData
  const proposedState: Record<string, unknown> = {
    ...formDataWithoutMetadata,
    ...assignments
  }

  const currentState = buildCurrentState(group)
  const businessInfoChanges = computeBusinessInfoChanges(group, formData)
  const permissionChanges = computePermissionChanges(mergedOverrides)

  if (hasEntries(businessInfoChanges)) {
    proposedState.businessInfoChanges = businessInfoChanges
  }
  if (hasEntries(permissionChanges)) {
    proposedState.permissionChanges = permissionChanges
  }

  const hasAppChanges = stagedAppChanges.length > 0
  let appPayload: ReturnType<typeof buildAppChangePayload> | null = null
  if (hasAppChanges) {
    appPayload = buildAppChangePayload(stagedAppChanges)
    // Transform diff format into SAPI's flat array format
    const { applicationChanges, appFunctionChanges } = appPayload
    proposedState.applicationChanges = [
      ...applicationChanges.added.map(app => ({ appCode: app, proposedStateIndicator: true, currentStateIndicator: false })),
      ...applicationChanges.removed.map(app => ({ appCode: app, proposedStateIndicator: false, currentStateIndicator: true })),
      ...applicationChanges.unchanged.map(app => ({ appCode: app, proposedStateIndicator: true, currentStateIndicator: true }))
    ]
    proposedState.appFunctionChanges = [
      ...appFunctionChanges.added.map(fn => ({ appCode: fn.appIdentifier, functionCode: fn.functionIdentifier, enabledIndicator: true })),
      ...appFunctionChanges.removed.map(fn => ({ appCode: fn.appIdentifier, functionCode: fn.functionIdentifier, enabledIndicator: false })),
      ...appFunctionChanges.unchanged.map(fn => ({ appCode: fn.appIdentifier, functionCode: fn.functionIdentifier, enabledIndicator: true }))
    ]
  }

  const hasConfigChanges = hasEntries(businessInfoChanges) || hasEntries(permissionChanges)

  let changeType: ChangeType = 'CONFIG_UPDATE'
  if (hasAppChanges && !hasConfigChanges) {
    changeType = 'APP_UPDATE'
  }

  const changedFields = [
    ...Object.keys(businessInfoChanges),
    ...Object.keys(permissionChanges)
  ]

  return { mergedOverrides, currentState, proposedState, changeType, changedFields, appPayload }
}

export function useConfigSave({
  formData,
  group,
  permissionOverrides,
  pendingChanges,
  stagedAppChanges = [],
  canDirectSave = false,
  updateAdGroupConfig: _updateAdGroupConfig,
  updatePermissionOverrides,
  setPendingChanges,
  clearStagedAppChanges,
  flushUnsavedFunctions,
  onSave: _onSave,
  onClose
}: UseConfigSaveParams) {
  const notifications = useNotifications()
  const [showSaveDialog, setShowSaveDialog] = useState(false)
  const [isDirectSave, setIsDirectSave] = useState(false)

  const handleSaveClick = () => {
    setIsDirectSave(false)
    setShowSaveDialog(true)
  }

  const handleDirectSaveClick = () => {
    setIsDirectSave(true)
    setShowSaveDialog(true)
  }

  const handleConfirmSave = async () => {
    setShowSaveDialog(false)

    try {
      // Flush any unsaved function panel changes before saving
      if (flushUnsavedFunctions) {
        await flushUnsavedFunctions()
      }

      const { mergedOverrides, currentState, proposedState, changeType, changedFields, appPayload } =
        buildSavePayload(group, formData, permissionOverrides, pendingChanges, stagedAppChanges)

      if (isDirectSave && canDirectSave) {
        await adminApprovalService.directSave(group.groupIdentifier, {
          currentState,
          proposedState,
          changedApps: appPayload?.changedApps,
          changedFunctions: appPayload?.changedFunctions
        })
      } else {
        await adminApprovalService.submitChange(group.groupIdentifier, {
          changeType,
          currentState,
          proposedState,
          changedFields: changedFields.length > 0 ? changedFields : undefined,
          changedApps: appPayload?.changedApps,
          changedFunctions: appPayload?.changedFunctions
        })
      }

      updatePermissionOverrides(mergedOverrides)
      setPendingChanges({ permissions: {} })
      clearStagedAppChanges?.()

      const groupName = formData.logicalName || group.logicalName || group.groupIdentifier
      if (isDirectSave && canDirectSave) {
        notifications.success({
          title: 'Changes Applied',
          description: `Configuration changes have been applied immediately to ${groupName}.`
        })
      } else {
        notifications.success({
          title: 'Submitted for Approval',
          description: `Your changes to ${groupName} have been submitted and are awaiting review.`
        })
      }

      onClose()
    } catch {
      if (isDirectSave) {
        notifications.error({
          title: 'Save failed',
          description: 'We could not apply the configuration changes. Please review and try again.'
        })
      } else {
        notifications.error({
          title: 'Submission Failed',
          description: 'We could not submit the configuration changes for approval. Please try again.'
        })
      }
    }
  }

  return {
    showSaveDialog,
    setShowSaveDialog,
    handleSaveClick,
    handleDirectSaveClick,
    handleConfirmSave,
    isDirectSave
  }
}
===ENDFILE
===FILE: ./src/hooks/admin/use-function-selection.ts
import { useState, useEffect } from 'react'
import { EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'

interface UseFunctionSelectionParams {
  app: EmbeddedAppWithStatus
}

export function useFunctionSelection({ app }: UseFunctionSelectionParams) {
  const [selectedFunctions, setSelectedFunctions] = useState<string[]>([])
  const [defaultFunction, setDefaultFunction] = useState<string | undefined>(
    app.defaultFunctionKey
  )

  useEffect(() => {
    const assigned = app.assignedFunctionKeys || []
    const defaultKey = app.defaultFunctionKey

    if (!app.isAssignedIndicator || assigned.length === 0) {
      // Not assigned - start with default function if exists
      setSelectedFunctions(defaultKey ? [defaultKey] : [])
    } else if (defaultKey && !assigned.includes(defaultKey)) {
      // Assigned but missing default - add default
      setSelectedFunctions([...assigned, defaultKey])
    } else {
      setSelectedFunctions(assigned)
    }
    setDefaultFunction(defaultKey)
  }, [app.assignedFunctionKeys, app.defaultFunctionKey, app.isAssignedIndicator])

  const applySelection = (functions: string[]) => {
    const unique = Array.from(new Set(functions))
    const defaultKey = app.defaultFunctionKey
    if (defaultKey && !unique.includes(defaultKey)) {
      unique.push(defaultKey)
    }
    setSelectedFunctions(Array.from(new Set(unique)))
  }

  const hasChanges = () => {
    const assigned = app.assignedFunctionKeys || []
    const stringCompare = (a: string, b: string) => a.localeCompare(b)
    const functionsChanged = JSON.stringify([...selectedFunctions].sort(stringCompare)) !==
                           JSON.stringify([...assigned].sort(stringCompare))
    const defaultChanged = defaultFunction !== app.defaultFunctionKey
    return functionsChanged || defaultChanged
  }

  const handleFunctionToggle = ({ functionKey, checked }: { functionKey: string; checked: boolean }) => {
    const isDefaultFunction = app.defaultFunctionKey === functionKey
    if (!checked && isDefaultFunction) {
      return
    }

    if (checked) {
      applySelection([...selectedFunctions, functionKey])
    } else {
      setSelectedFunctions(selectedFunctions.filter(f => f !== functionKey))
    }
  }

  const handleSelectAllFiltered = ({ filteredFunctions }: { filteredFunctions: string[] }) => {
    const defaultKey = app.defaultFunctionKey
    const filteredKeys = filteredFunctions.filter(fk => {
      return fk !== defaultKey
    })
    applySelection([...selectedFunctions, ...filteredKeys])
  }

  const handleClearSelection = () => {
    const defaultKey = app.defaultFunctionKey
    setSelectedFunctions(defaultKey ? [defaultKey] : [])
  }

  const handleReset = () => {
    const assigned = app.assignedFunctionKeys || []
    const defaultKey = app.defaultFunctionKey

    if (!app.isAssignedIndicator || assigned.length === 0) {
      setSelectedFunctions(defaultKey ? [defaultKey] : [])
    } else if (defaultKey && !assigned.includes(defaultKey)) {
      setSelectedFunctions([...assigned, defaultKey])
    } else {
      setSelectedFunctions(assigned)
    }
    setDefaultFunction(defaultKey)
  }

  return {
    selectedFunctions,
    defaultFunction,
    setDefaultFunction,
    hasChanges,
    handleFunctionToggle,
    handleSelectAllFiltered,
    handleClearSelection,
    handleReset
  }
}
===ENDFILE
===FILE: ./src/hooks/admin/use-notice-form.ts
import { useEffect, useMemo, useState } from 'react'
import type { AdminNoticeRequest, AdminNoticeResponse } from '../../services/api/admin.service'
import { startOfDay } from 'date-fns'
import { isEndDateValid as validateEndDate } from '../../utils/admin/notice-validators'

interface UseNoticeFormParams {
  open: boolean
  editNotice?: AdminNoticeResponse | null
}

const DEFAULT_FORM_DATA: Partial<AdminNoticeRequest> = {
  title: '',
  message: '',
  severity: 'INFO',
  broadcastToAll: true,
  targetRoles: [],
  targetAdGroups: [],
  requiresAcknowledgement: false
}

export function useNoticeForm({ open, editNotice }: UseNoticeFormParams) {
  const [formData, setFormData] = useState<Partial<AdminNoticeRequest>>(DEFAULT_FORM_DATA)

  useEffect(() => {
    if (open && editNotice) {
      setFormData({
        title: editNotice.title,
        message: editNotice.message,
        severity: editNotice.severity,
        broadcastToAll: editNotice.broadcastToAll,
        targetRoles: editNotice.targetRoles || [],
        targetAdGroups: editNotice.targetAdGroups || [],
        requiresAcknowledgement: editNotice.requiresAcknowledgement,
        startAt: editNotice.startAt || undefined,
        endAt: editNotice.endAt || undefined
      })
    } else if (open && !editNotice) {
      setFormData(DEFAULT_FORM_DATA)
    }
  }, [open, editNotice])

  const minScheduleDate = useMemo(() => startOfDay(new Date()), [])
  const parsedStartDate = useMemo(() => (formData.startAt ? new Date(formData.startAt) : undefined), [formData.startAt])

  const isEndDateValid = useMemo(() => {
    return validateEndDate({ startAt: formData.startAt, endAt: formData.endAt })
  }, [formData.startAt, formData.endAt])

  const toggleRole = ({ roleValue }: { roleValue: string }) => {
    const currentRoles = formData.targetRoles || []
    const newRoles = currentRoles.includes(roleValue)
      ? currentRoles.filter(r => r !== roleValue)
      : [...currentRoles, roleValue]
    setFormData({ ...formData, targetRoles: newRoles })
  }

  const isRoleSelected = ({ roleValue }: { roleValue: string }) => {
    return (formData.targetRoles || []).includes(roleValue)
  }

  const toggleAdGroup = ({ groupIdentifier }: { groupIdentifier: string }) => {
    const currentGroups = formData.targetAdGroups || []
    const newGroups = currentGroups.includes(groupIdentifier)
      ? currentGroups.filter(g => g !== groupIdentifier)
      : [...currentGroups, groupIdentifier]
    setFormData({ ...formData, targetAdGroups: newGroups })
  }

  const isAdGroupSelected = ({ groupIdentifier }: { groupIdentifier: string }) => {
    return (formData.targetAdGroups || []).includes(groupIdentifier)
  }

  const resetForm = () => {
    setFormData(DEFAULT_FORM_DATA)
  }

  return {
    formData,
    setFormData,
    minScheduleDate,
    parsedStartDate,
    isEndDateValid,
    toggleRole,
    isRoleSelected,
    toggleAdGroup,
    isAdGroupSelected,
    resetForm
  }
}
===ENDFILE
===FILE: ./src/hooks/admin/use-notice-save.ts
import { useState } from 'react'
import type { AdminNoticeRequest, AdminNoticeResponse } from '../../services/api/admin.service'
import { adminService } from '../../services/api/admin.service'
import { useNotifications } from '../features/use-notifications'
import { validateNoticeForm } from '../../utils/admin/notice-validators'

const noticeValidationMessages: Record<string, string> = {
  titleMessageRequired: 'Title and message are required'
}

function buildSaveSuccessNotification(isUpdate: boolean, asDraft: boolean): { title: string; description: string } {
  if (isUpdate) {
    return { title: 'Notice updated', description: 'Draft notice has been updated successfully' }
  }
  return {
    title: asDraft ? 'Draft saved' : 'Notice published',
    description: asDraft ? 'Notice saved as draft' : 'Notice is now active and visible to users'
  }
}

interface UseNoticeSaveParams {
  formData: Partial<AdminNoticeRequest>
  editNotice?: AdminNoticeResponse | null
  isEndDateValid: boolean
  onSuccess: () => void
}

export function useNoticeSave({ formData, editNotice, isEndDateValid, onSuccess }: UseNoticeSaveParams) {
  const notifications = useNotifications()
  const [isSaving, setIsSaving] = useState(false)

  const handleSave = async ({ asDraft }: { asDraft: boolean }) => {
    const validation = validateNoticeForm({ title: formData.title, message: formData.message })
    if (!validation.valid) {
      notifications.error({
        title: 'Validation failed',
        description: noticeValidationMessages[validation.error ?? ''] ?? 'Validation error'
      })
      return
    }

    if (!isEndDateValid) {
      notifications.error({
        title: 'Invalid date range',
        description: 'End date and time must be after start date and time'
      })
      return
    }

    setIsSaving(true)
    try {
      const requestData = {
        ...formData,
        status: asDraft ? 'DRAFT' : 'ACTIVE'
      } as AdminNoticeRequest

      if (editNotice) {
        await adminService.updateNotice(editNotice.id, requestData)
      } else {
        await adminService.createNotice(requestData)
      }
      notifications.success(buildSaveSuccessNotification(!!editNotice, asDraft))

      onSuccess()
    } catch (error) {
      notifications.error({
        title: editNotice ? 'Failed to update notice' : 'Failed to save notice',
        description: error instanceof Error ? error.message : 'An error occurred'
      })
    } finally {
      setIsSaving(false)
    }
  }

  return {
    isSaving,
    handleSave
  }
}
===ENDFILE
===FILE: ./src/hooks/admin/use-pending-changes.ts
/**
 * React Query hooks for pending changes approval workflow
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { adminApprovalService } from '../../services/api/admin-approval.service'
import type {
  PendingChangeFilters,
  SubmitChangeRequest,
  DirectSaveRequest,
  ApproveChangeRequest,
  RejectChangeRequest,
  ActivityTimeRange
} from '../../types/features/approval-workflow.types'

export const PENDING_CHANGES_QUERY_KEY = 'pendingChanges'
export const PENDING_CHANGES_COUNT_KEY = 'pendingChangesCount'
export const MY_ACTIVITY_QUERY_KEY = 'myActivity'

/**
 * Hook to fetch list of pending changes
 */
export function usePendingChanges(filters?: PendingChangeFilters) {
  return useQuery({
    queryKey: [PENDING_CHANGES_QUERY_KEY, filters],
    queryFn: () => adminApprovalService.listPendingChanges(filters),
    staleTime: 30 * 1000, // 30 seconds
    refetchOnWindowFocus: true
  })
}

/**
 * Hook to fetch a single pending change by ID
 */
export function usePendingChange(changeId: string | null) {
  return useQuery({
    queryKey: [PENDING_CHANGES_QUERY_KEY, changeId],
    queryFn: () => adminApprovalService.getPendingChange(changeId!),
    enabled: !!changeId,
    staleTime: 30 * 1000
  })
}

/**
 * Hook to fetch pending changes count for sidebar badge
 */
export function usePendingChangesCount(enabled: boolean = true) {
  return useQuery({
    queryKey: [PENDING_CHANGES_COUNT_KEY],
    queryFn: () => adminApprovalService.getPendingChangesCount(),
    enabled,
    staleTime: 60 * 1000, // 1 minute
    refetchInterval: 60 * 1000 // Poll every minute
  })
}

/**
 * Hook to submit a configuration change for review
 */
export function useSubmitChange() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({
      groupId,
      request
    }: {
      groupId: string
      request: SubmitChangeRequest
    }) => adminApprovalService.submitChange(groupId, request),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
      queryClient.invalidateQueries({ queryKey: ['adminAdGroups'] })
    }
  })
}

/**
 * Hook to direct save configuration (Super Admin only)
 */
export function useDirectSave() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({
      groupId,
      request
    }: {
      groupId: string
      request: DirectSaveRequest
    }) => adminApprovalService.directSave(groupId, request),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['adminAdGroups'] })
    }
  })
}

/**
 * Hook to approve a pending change
 */
export function useApproveChange() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({
      changeId,
      request
    }: {
      changeId: string
      request?: ApproveChangeRequest
    }) => adminApprovalService.approveChange(changeId, request),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
      queryClient.invalidateQueries({ queryKey: ['adminAdGroups'] })
    }
  })
}

/**
 * Hook to reject a pending change
 */
export function useRejectChange() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({
      changeId,
      request
    }: {
      changeId: string
      request: RejectChangeRequest
    }) => adminApprovalService.rejectChange(changeId, request),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
    }
  })
}

/**
 * Hook to fetch current user's activity history (approvals, rejections, submissions, etc.)
 */
export function useMyActivity(page: number = 1, timeRange: ActivityTimeRange = 'all', enabled: boolean = true) {
  return useQuery({
    queryKey: [MY_ACTIVITY_QUERY_KEY, page, timeRange],
    queryFn: () => adminApprovalService.getMyActivity(page, 25, timeRange === 'all' ? undefined : timeRange),
    enabled,
    staleTime: 30 * 1000
  })
}

/**
 * Hook to cancel a pending change (submitter only)
 */
export function useCancelChange() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (changeId: string) => adminApprovalService.cancelChange(changeId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_QUERY_KEY] })
      queryClient.invalidateQueries({ queryKey: [PENDING_CHANGES_COUNT_KEY] })
    }
  })
}
===ENDFILE
===FILE: ./src/hooks/admin/use-permission-aggregators.ts
import React from 'react'
import type { RoleTemplate } from '../../types/features/ad-group-config'
import { permissionLevels } from '../../constants/permission-levels'
import { getTemplateSection } from '../../components/admin/ad-group-config/utils/permission-helpers'
import {
  businessRelevantToggles,
  isToggleBusinessRelevant
} from '../../components/admin/business-relevant-toggles'
import { COMPOUND_LEVELS } from '../../utils/admin/permission-level-resolver'
import { sortWithHierarchy } from '../../utils/admin/permission-hierarchy-sorter'

interface UsePermissionAggregatorsParams {
  roleTemplate: RoleTemplate | null
  searchTerm: string
  isPermissionEnabled: ({ level, key }: { level: string; key: string }) => boolean
}

export function usePermissionAggregators({
  roleTemplate,
  searchTerm,
  isPermissionEnabled
}: UsePermissionAggregatorsParams) {
  const getPermissionCount = React.useCallback(({ level }: { level: string }) => {
    if (!roleTemplate) return 0

    const templateSections = COMPOUND_LEVELS[level]
    if (templateSections) {
      return templateSections.reduce((total, section) => {
        const sectionData = getTemplateSection(roleTemplate, section)
        return total + Object.keys(sectionData).filter(key =>
          isToggleBusinessRelevant(level, `${section}.${key}`) && sectionData[key]?.state === 'enabled'
        ).length
      }, 0)
    }

    const templateLevel = getTemplateSection(roleTemplate, level)
    return Object.keys(templateLevel).filter(key =>
      isToggleBusinessRelevant(level, key) && templateLevel[key]?.state === 'enabled'
    ).length
  }, [roleTemplate])

  const enabledPermissionsCache = React.useMemo(() => {
    if (!roleTemplate) return {}

    const cache: Record<string, string[]> = {}

    Object.keys(permissionLevels).forEach(level => {
      const templateSections = COMPOUND_LEVELS[level]
      if (templateSections) {
        const enabledKeys: string[] = []

        for (const section of templateSections) {
          const sectionData = getTemplateSection(roleTemplate, section)
          const sectionEnabled = Object.keys(sectionData)
            .filter(key => isToggleBusinessRelevant(level, `${section}.${key}`))
            .map(key => `${section}.${key}`)
            .filter(prefixedKey => {
              const businessConfig = businessRelevantToggles[level]?.toggles[prefixedKey]
              const parentKey = businessConfig?.parent
              const parentEnabled = parentKey ? isPermissionEnabled({ level, key: parentKey }) : true
              return isPermissionEnabled({ level, key: prefixedKey }) && parentEnabled
            })
          enabledKeys.push(...sectionEnabled)
        }

        cache[level] = enabledKeys
      } else {
        const templateLevel = getTemplateSection(roleTemplate, level)
        cache[level] = Object.keys(templateLevel).filter(key =>
          isToggleBusinessRelevant(level, key) && isPermissionEnabled({ level, key })
        )
      }
    })

    return cache
  }, [roleTemplate, isPermissionEnabled])

  const getEnabledPermissions = React.useCallback(({ level }: { level: string }) => {
    return enabledPermissionsCache[level] || []
  }, [enabledPermissionsCache])

  const allPermissionsCache = React.useMemo(() => {
    if (!roleTemplate) return {}

    const cache: Record<string, string[]> = {}

    Object.keys(permissionLevels).forEach(level => {
      const templateSections = COMPOUND_LEVELS[level]
      if (templateSections) {
        const allKeys: string[] = []

        for (const section of templateSections) {
          const sectionData = getTemplateSection(roleTemplate, section)
          const sectionKeys = Object.keys(sectionData)
            .filter(key => isToggleBusinessRelevant(level, `${section}.${key}`))
            .map(key => `${section}.${key}`)
          allKeys.push(...sectionKeys)
        }

        cache[level] = sortWithHierarchy({ keys: allKeys, levelKey: level })
      } else {
        const templateLevel = getTemplateSection(roleTemplate, level)
        cache[level] = Object.keys(templateLevel).filter(key =>
          isToggleBusinessRelevant(level, key)
        )
      }
    })

    return cache
  }, [roleTemplate])

  const getAllPermissions = React.useCallback(({ level }: { level: string }) => {
    return allPermissionsCache[level] || []
  }, [allPermissionsCache])

  const filteredPermissionsCache = React.useMemo(() => {
    const cache: Record<string, string[]> = {}

    Object.keys(permissionLevels).forEach(level => {
      const allPermissions = getAllPermissions({ level })
      if (!searchTerm) {
        cache[level] = allPermissions
        return
      }

      cache[level] = allPermissions.filter(key => {
        const businessConfig = businessRelevantToggles[level]?.toggles[key]
        const businessName = businessConfig?.businessName || key
        const description = businessConfig?.description || ''

        const searchLower = searchTerm.toLowerCase()
        return businessName.toLowerCase().includes(searchLower) ||
               description.toLowerCase().includes(searchLower) ||
               key.toLowerCase().includes(searchLower)
      })
    })

    return cache
  }, [searchTerm, getAllPermissions])

  const getFilteredPermissions = React.useCallback(({ level }: { level: string }) => {
    return filteredPermissionsCache[level] || []
  }, [filteredPermissionsCache])

  return {
    getPermissionCount,
    getEnabledPermissions,
    getAllPermissions,
    getFilteredPermissions
  }
}
===ENDFILE
===FILE: ./src/hooks/admin/use-permission-state.ts
import React from 'react'
import type {
  RoleTemplate,
  PermissionOverrides,
  PendingChanges
} from '../../types/features/ad-group-config'
import { getTemplateSection } from '../../components/admin/ad-group-config/utils/permission-helpers'
import { resolvePermissionLevel, COMPOUND_LEVELS } from '../../utils/admin/permission-level-resolver'

interface UsePermissionStateParams {
  roleTemplate: RoleTemplate | null
  permissionOverrides: PermissionOverrides
  pendingChanges: PendingChanges
}

export function usePermissionState({
  roleTemplate,
  permissionOverrides,
  pendingChanges
}: UsePermissionStateParams) {
  const isPermissionEnabled = React.useCallback(({ level, key }: { level: string; key: string }) => {
    if (!roleTemplate) return false

    if (COMPOUND_LEVELS[level]) {
      const { actualLevel, actualKey } = resolvePermissionLevel({ level, key })

      const compoundPendingChange = pendingChanges?.permissions?.[actualLevel]?.[actualKey]
      if (compoundPendingChange !== undefined) {
        return compoundPendingChange
      }

      const compoundOverride = permissionOverrides[actualLevel]?.[actualKey]
      if (compoundOverride !== undefined) {
        return compoundOverride
      }

      const compoundTemplateLevel = getTemplateSection(roleTemplate, actualLevel)
      return compoundTemplateLevel[actualKey]?.state === 'enabled'
    }

    const templateLevel = getTemplateSection(roleTemplate, level)
    const templatePermission = templateLevel[key]

    const pendingChange = pendingChanges?.permissions?.[level]?.[key]
    if (pendingChange !== undefined) {
      return pendingChange
    }

    const override = permissionOverrides[level]?.[key]
    if (override !== undefined) {
      return override
    }

    return templatePermission?.state === 'enabled'
  }, [roleTemplate, permissionOverrides, pendingChanges])

  const hasUnsavedChanges = React.useCallback(({ level, key }: { level: string; key: string }) => {
    if (!roleTemplate) return false

    if (COMPOUND_LEVELS[level]) {
      const { actualLevel, actualKey } = resolvePermissionLevel({ level, key })

      const compoundPendingValue = pendingChanges.permissions?.[actualLevel]?.[actualKey]
      if (compoundPendingValue === undefined) return false

      const compoundTemplateSection = getTemplateSection(roleTemplate, actualLevel)
      const compoundTemplateValue = compoundTemplateSection[actualKey]?.state === 'enabled'
      const compoundSavedOverride = permissionOverrides[actualLevel]?.[actualKey]
      const compoundCurrentSavedValue = compoundSavedOverride !== undefined ? compoundSavedOverride : compoundTemplateValue

      return compoundPendingValue !== compoundCurrentSavedValue
    }

    const pendingValue = pendingChanges.permissions?.[level]?.[key]
    if (pendingValue === undefined) return false

    const templateSection = getTemplateSection(roleTemplate, level)
    const templateValue = templateSection[key]?.state === 'enabled'
    const savedOverride = permissionOverrides[level]?.[key]
    const currentSavedValue = savedOverride !== undefined ? savedOverride : templateValue

    return pendingValue !== currentSavedValue
  }, [roleTemplate, permissionOverrides, pendingChanges])

  return {
    isPermissionEnabled,
    hasUnsavedChanges
  }
}
===ENDFILE
===FILE: ./src/hooks/admin/use-permission-toggle.ts
import { useState } from 'react'
import type { RoleTemplate, PermissionOverrides, PendingChanges } from '../../types/features/ad-group-config'
import { businessRelevantToggles } from '../../components/admin/business-relevant-toggles'
import { getTemplateSection } from '../../components/admin/ad-group-config/utils/permission-helpers'
import { resolvePermissionLevel, resolveLinkedKey } from '../../utils/admin/permission-level-resolver'

interface UsePermissionToggleParams {
  roleTemplate: RoleTemplate | null
  permissionOverrides: PermissionOverrides
  pendingChanges: PendingChanges
  setPendingChanges: (changes: PendingChanges) => void
}

function getAllChildren({ parentKey, displayLevel }: { parentKey: string; displayLevel: string }): string[] {
  const config = businessRelevantToggles[displayLevel]
  if (!config) return []

  return Object.keys(config.toggles).filter(key =>
    config.toggles[key].parent === parentKey
  )
}

function isToggleEnabled({
  level,
  key,
  pendingChanges,
  permissionOverrides,
  roleTemplate
}: {
  level: string
  key: string
  pendingChanges: PendingChanges
  permissionOverrides: PermissionOverrides
  roleTemplate: RoleTemplate | null
}): boolean {
  if (pendingChanges.permissions?.[level]?.[key] !== undefined) {
    return pendingChanges.permissions[level][key]
  }

  if (permissionOverrides[level]?.[key] !== undefined) {
    return permissionOverrides[level][key]
  }

  const templateLevel = getTemplateSection(roleTemplate, level)
  return templateLevel[key]?.state === 'enabled'
}

function ensureLevelExists(permissions: Record<string, Record<string, boolean>>, level: string) {
  if (!permissions[level]) {
    permissions[level] = {}
  }
}

function applyPendingValue(
  pendingChanges: PendingChanges,
  actualLevel: string,
  actualKey: string,
  value: boolean,
  permissionOverrides: PermissionOverrides
) {
  const savedValue = permissionOverrides[actualLevel]?.[actualKey]
  if (savedValue !== undefined && savedValue === value) {
    delete pendingChanges.permissions[actualLevel][actualKey]
    if (Object.keys(pendingChanges.permissions[actualLevel]).length === 0) {
      delete pendingChanges.permissions[actualLevel]
    }
    return
  }
  pendingChanges.permissions[actualLevel][actualKey] = value
}

function cascadeToChildren(
  pendingPermissions: Record<string, Record<string, boolean>>,
  displayKey: string,
  displayLevel: string,
  value: boolean
) {
  const children = getAllChildren({ parentKey: displayKey, displayLevel })
  for (const childKey of children) {
    const { actualLevel, actualKey } = resolvePermissionLevel({ level: displayLevel, key: childKey })
    ensureLevelExists(pendingPermissions, actualLevel)
    pendingPermissions[actualLevel][actualKey] = value
  }
}

function autoEnableParent(
  pendingPermissions: Record<string, Record<string, boolean>>,
  parentKey: string,
  level: string,
  pendingChanges: PendingChanges,
  permissionOverrides: PermissionOverrides,
  roleTemplate: RoleTemplate | null
) {
  const { actualLevel, actualKey } = resolvePermissionLevel({ level, key: parentKey })
  const parentEnabled = isToggleEnabled({
    level: actualLevel, key: actualKey, pendingChanges, permissionOverrides, roleTemplate
  })
  if (parentEnabled) return
  ensureLevelExists(pendingPermissions, actualLevel)
  pendingPermissions[actualLevel][actualKey] = true
}

function autoDisableParent(
  pendingPermissions: Record<string, Record<string, boolean>>,
  parentKey: string,
  level: string,
  current: { actualLevel: string; actualKey: string },
  context: { pendingChanges: PendingChanges; permissionOverrides: PermissionOverrides; roleTemplate: RoleTemplate | null }
) {
  const allChildren = getAllChildren({ parentKey, displayLevel: level })
  const hasEnabledSibling = allChildren.some(childKey => {
    const { actualLevel: resolvedLevel, actualKey: resolvedKey } = resolvePermissionLevel({ level, key: childKey })
    if (resolvedLevel === current.actualLevel && resolvedKey === current.actualKey) return false
    if (pendingPermissions[resolvedLevel]?.[resolvedKey] !== undefined) {
      return pendingPermissions[resolvedLevel][resolvedKey]
    }
    return isToggleEnabled({
      level: resolvedLevel, key: resolvedKey, ...context
    })
  })
  if (hasEnabledSibling) return

  const { actualLevel, actualKey } = resolvePermissionLevel({ level, key: parentKey })
  ensureLevelExists(pendingPermissions, actualLevel)
  pendingPermissions[actualLevel][actualKey] = false
}

export function usePermissionToggle({
  roleTemplate,
  permissionOverrides,
  pendingChanges,
  setPendingChanges
}: UsePermissionToggleParams) {
  const [loadingPermission, setLoadingPermission] = useState<string | null>(null)

  const handleTogglePermission = ({ level, key, value }: { level: string; key: string; value: boolean }) => {
    setLoadingPermission(`${level}.${key}`)

    const { actualLevel, actualKey } = resolvePermissionLevel({ level, key })

    const newPendingChanges: PendingChanges = {
      ...pendingChanges,
      permissions: {
        ...pendingChanges.permissions,
        [actualLevel]: {
          ...(pendingChanges.permissions[actualLevel] ?? {})
        }
      }
    }

    applyPendingValue(newPendingChanges, actualLevel, actualKey, value, permissionOverrides)

    cascadeToChildren(newPendingChanges.permissions, key, level, value)

    const toggleConfig = businessRelevantToggles[level]?.toggles[key]
    if (toggleConfig?.parent && value) {
      autoEnableParent(
        newPendingChanges.permissions, toggleConfig.parent, level,
        pendingChanges, permissionOverrides, roleTemplate
      )
    }
    if (toggleConfig?.parent && !value) {
      autoDisableParent(
        newPendingChanges.permissions, toggleConfig.parent, level,
        { actualLevel, actualKey },
        { pendingChanges, permissionOverrides, roleTemplate }
      )
    }

    // Linked key cascade: auto-sync dependent technical keys
    if (toggleConfig?.linkedKeys) {
      for (const lk of toggleConfig.linkedKeys) {
        const { actualLevel: lkLevel, actualKey: lkKey } = resolveLinkedKey(lk)
        ensureLevelExists(newPendingChanges.permissions, lkLevel)
        newPendingChanges.permissions[lkLevel][lkKey] = value
      }
    }

    setPendingChanges(newPendingChanges)
    setLoadingPermission(null)
  }

  return {
    loadingPermission,
    handleTogglePermission
  }
}
===ENDFILE
===FILE: ./src/hooks/api/__tests__/use-ad-group-api.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useCallback: (fn: unknown) => fn
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}

vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockApiFetch = vi.fn()

vi.mock('../../../services/core/api-client', () => ({
  apiFetch: (...args: unknown[]) => mockApiFetch(...args)
}))

const { useAdGroupApi } = await import('../use-ad-group-api')

function callHook() {
  stateIndex = 0
  return useAdGroupApi()
}

describe('useAdGroupApi', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  it('initializes with isLoading false', () => {
    const result = callHook()
    expect(result.isLoading).toBe(false)
  })

  describe('fetchAdGroupData', () => {
    it('fetches and transforms AD group data', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            groupIdentifier: 'CN=test-group',
            logicalName: 'Test Group',
            roleName: 'voice_agent',
            marketCode: 'HK',
            regionCode: 'APAC',
            countryCode: 'HK',
            businessUnitName: 'WPB',
            activeIndicator: true,
            userAccessCode: 'FULL',
            pendingChangeIndicator: false,
            versionNumber: 3,
            userCountNumber: 42,
            updatedAtDatetime: '2025-01-01T00:00:00Z',
            currentConfig: {
              permissionChanges: {
                columnPermissions: {
                  kms: { enabledIndicator: true }
                },
                widgetPermissions: {
                  search: { enabledIndicator: false }
                }
              }
            }
          }
        })
      })

      const { fetchAdGroupData } = callHook()
      const result = await fetchAdGroupData('CN=test-group')

      expect(result).not.toBeNull()
      expect(result!.groupIdentifier).toBe('CN=test-group')
      expect(result!.logicalName).toBe('Test Group')
      expect(result!.roleName).toBe('voice_agent')
      expect(result!.market).toBe('HK')
      expect(result!.region).toBe('APAC')
      expect(result!.country).toBe('HK')
      expect(result!.businessUnit).toBe('WPB')
      expect(result!.isActive).toBe(true)
      expect(result!.accessLevel).toBe('FULL')
      expect(result!.userCount).toBe(42)
      expect(result!.columnAssignments).toEqual({ kms: { state: 'enabled' } })
      expect(result!.widgetAssignments).toEqual({ search: { state: 'disabled' } })
    })

    it('returns null for 404 response', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 404
      })

      const { fetchAdGroupData } = callHook()
      const result = await fetchAdGroupData('CN=nonexistent')
      expect(result).toBeNull()
    })

    it('throws on 403 response', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 403
      })

      const { fetchAdGroupData } = callHook()
      await expect(fetchAdGroupData('CN=forbidden')).rejects.toThrow('Access denied')
    })

    it('throws on other error statuses', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 500
      })

      const { fetchAdGroupData } = callHook()
      await expect(fetchAdGroupData('CN=error')).rejects.toThrow('Failed to fetch AD group data: 500')
    })

    it('throws on missing data in response', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({})
      })

      const { fetchAdGroupData } = callHook()
      await expect(fetchAdGroupData('CN=bad')).rejects.toThrow('Unexpected AD group lookup response')
    })

    it('wraps network errors', async () => {
      const fetchError = new TypeError('fetch failed')
      mockApiFetch.mockRejectedValue(fetchError)

      const { fetchAdGroupData } = callHook()
      await expect(fetchAdGroupData('CN=network')).rejects.toThrow('Network error')
    })

    it('re-throws non-network errors', async () => {
      mockApiFetch.mockRejectedValue(new Error('Something else'))

      const { fetchAdGroupData } = callHook()
      await expect(fetchAdGroupData('CN=other')).rejects.toThrow('Something else')
    })

    it('defaults isActive to true when missing', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: { groupIdentifier: 'CN=g1' }
        })
      })

      const { fetchAdGroupData } = callHook()
      const result = await fetchAdGroupData('CN=g1')
      expect(result!.isActive).toBe(true)
    })
  })

  describe('updateAdGroupConfig', () => {
    it('sends update and fetches refreshed data', async () => {
      // First call: update POST
      // Second call: fetchAdGroupData POST (re-fetch)
      mockApiFetch
        .mockResolvedValueOnce({ ok: true })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: { groupIdentifier: 'CN=g1', activeIndicator: true }
          })
        })

      const { updateAdGroupConfig } = callHook()
      const result = await updateAdGroupConfig('CN=g1', { logicalName: 'Updated' })

      expect(result).not.toBeNull()
      expect(mockNotifications.success).toHaveBeenCalled()
      expect(mockApiFetch).toHaveBeenCalledTimes(2)
    })

    it('suppresses success toast when option set', async () => {
      mockApiFetch
        .mockResolvedValueOnce({ ok: true })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: { groupIdentifier: 'CN=g1' }
          })
        })

      const { updateAdGroupConfig } = callHook()
      await updateAdGroupConfig('CN=g1', { logicalName: 'Updated' }, { suppressSuccessToast: true })

      expect(mockNotifications.success).not.toHaveBeenCalled()
    })

    it('shows error notification on failure', async () => {
      mockApiFetch.mockResolvedValue({ ok: false, status: 500 })

      const { updateAdGroupConfig } = callHook()
      await expect(updateAdGroupConfig('CN=g1', {})).rejects.toThrow()

      expect(mockNotifications.error).toHaveBeenCalled()
    })

    it('converts isActive to activeIndicator in payload', async () => {
      mockApiFetch
        .mockResolvedValueOnce({ ok: true })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: { groupIdentifier: 'CN=g1' }
          })
        })

      const { updateAdGroupConfig } = callHook()
      await updateAdGroupConfig('CN=g1', { isActive: false })

      const body = JSON.parse(mockApiFetch.mock.calls[0][1].body)
      expect(body.data.proposedState.activeIndicator).toBe(false)
      expect(body.data.proposedState.isActive).toBeUndefined()
    })

    it('includes configVersionNumber when versionNumber provided', async () => {
      mockApiFetch
        .mockResolvedValueOnce({ ok: true })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: { groupIdentifier: 'CN=g1' }
          })
        })

      const { updateAdGroupConfig } = callHook()
      await updateAdGroupConfig('CN=g1', { versionNumber: 5 })

      const body = JSON.parse(mockApiFetch.mock.calls[0][1].body)
      expect(body.data.configVersionNumber).toBe(5)
    })
  })

  describe('applyRoleTemplate', () => {
    it('applies role template and shows success', async () => {
      mockApiFetch
        .mockResolvedValueOnce({ ok: true })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: { groupIdentifier: 'CN=g1', roleName: 'chat_agent' }
          })
        })

      const { applyRoleTemplate } = callHook()
      const result = await applyRoleTemplate('CN=g1', 'chat_agent')

      expect(result).not.toBeNull()
      expect(mockNotifications.success).toHaveBeenCalled()
    })

    it('shows error notification on failure', async () => {
      mockApiFetch.mockResolvedValue({ ok: false, status: 500 })

      const { applyRoleTemplate } = callHook()
      await expect(applyRoleTemplate('CN=g1', 'chat_agent')).rejects.toThrow()

      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })

  describe('copyFromAdGroup', () => {
    it('copies configuration and shows success', async () => {
      mockApiFetch
        .mockResolvedValueOnce({ ok: true })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: { groupIdentifier: 'CN=target' }
          })
        })

      const { copyFromAdGroup } = callHook()
      const result = await copyFromAdGroup('CN=target', 'CN=source')

      expect(result).not.toBeNull()
      expect(mockNotifications.success).toHaveBeenCalled()
      const body = JSON.parse(mockApiFetch.mock.calls[0][1].body)
      expect(body.data.sourceGroupIdentifier).toBe('CN=source')
      expect(body.data.targetGroupIdentifier).toBe('CN=target')
    })

    it('shows error notification on failure', async () => {
      mockApiFetch.mockResolvedValue({ ok: false, status: 500 })

      const { copyFromAdGroup } = callHook()
      await expect(copyFromAdGroup('CN=target', 'CN=source')).rejects.toThrow()

      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })

  describe('fetchAllAdGroups', () => {
    it('fetches and transforms all groups', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            items: [
              { groupIdentifier: 'CN=g1', logicalName: 'Group 1', activeIndicator: true },
              { groupIdentifier: 'CN=g2', logicalName: 'Group 2', activeIndicator: false }
            ]
          }
        })
      })

      const { fetchAllAdGroups } = callHook()
      const result = await fetchAllAdGroups()

      expect(result).toHaveLength(2)
      expect(result[0].groupIdentifier).toBe('CN=g1')
      expect(result[1].isActive).toBe(false)
    })

    it('returns empty array on error', async () => {
      mockApiFetch.mockRejectedValue(new Error('Network error'))

      const { fetchAllAdGroups } = callHook()
      const result = await fetchAllAdGroups()

      expect(result).toEqual([])
      expect(mockNotifications.error).toHaveBeenCalled()
    })

    it('returns empty array when no items', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: {} })
      })

      const { fetchAllAdGroups } = callHook()
      const result = await fetchAllAdGroups()

      expect(result).toEqual([])
    })
  })
})
===ENDFILE
===FILE: ./src/hooks/api/__tests__/use-embedded-apps-api.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useCallback: (fn: (...args: unknown[]) => unknown) => fn,
  useMemo: (fn: () => unknown) => fn()
}))

const mockNotifications = {
  success: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  info: vi.fn()
}
vi.mock('../../features/use-notifications', () => ({
  useNotifications: () => mockNotifications
}))

const mockApiFetch = vi.fn()
vi.mock('../../../services/core/api-client', () => ({
  apiFetch: (...args: unknown[]) => mockApiFetch(...args)
}))

vi.mock('@/utils/core/debug', () => ({
  createLogger: () => ({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  })
}))

vi.mock('@/utils/core/error-tracking', () => ({
  logErrorToTracking: vi.fn()
}))

const { useEmbeddedAppsApi } = await import('../use-embedded-apps-api')

describe('useEmbeddedAppsApi', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  function callHook() {
    stateIndex = 0
    return useEmbeddedAppsApi()
  }

  describe('fetchAllEmbeddedApps', () => {
    it('fetches and transforms embedded apps from PAPI', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            embeddedApps: [{
              appKey: 'testApp',
              titleText: 'Test App',
              description: 'A test app',
              categoryText: 'Tools',
              isActiveFlag: true,
              functionDefinitionMap: {
                fn1: { displayName: 'Function 1', description: 'Desc 1' }
              }
            }]
          }
        })
      })

      const { fetchAllEmbeddedApps } = callHook()
      const apps = await fetchAllEmbeddedApps()

      expect(apps).toHaveLength(1)
      expect(apps[0].appIdentifier).toBe('testApp')
      expect(apps[0].titleText).toBe('Test App')
      expect(apps[0].descriptionText).toBe('A test app')
      expect(apps[0].categoryName).toBe('Tools')
      expect(apps[0].isActiveIndicator).toBe(true)
      expect(apps[0].functionDefinitionsObject.fn1.displayName).toBe('Function 1')
    })

    it('throws on non-ok response', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 500
      })

      const { fetchAllEmbeddedApps } = callHook()
      await expect(fetchAllEmbeddedApps()).rejects.toThrow('Failed to fetch embedded apps')
    })

    it('handles alternate field names in function definitions', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            embeddedApps: [{
              appKey: 'app1',
              titleText: 'App',
              description: 'Desc',
              categoryText: 'Cat',
              functionDefinitionMap: {
                fn1: { displayNameText: 'Alt Name', descriptionText: 'Alt Desc', categoryName: 'AltCat' }
              }
            }]
          }
        })
      })

      const { fetchAllEmbeddedApps } = callHook()
      const apps = await fetchAllEmbeddedApps()

      expect(apps[0].functionDefinitionsObject.fn1.displayName).toBe('Alt Name')
      expect(apps[0].functionDefinitionsObject.fn1.description).toBe('Alt Desc')
    })

    it('returns empty function definitions for invalid input', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            embeddedApps: [{
              appKey: 'app1',
              titleText: 'App',
              description: 'Desc',
              categoryText: 'Cat',
              functionDefinitionMap: null
            }]
          }
        })
      })

      const { fetchAllEmbeddedApps } = callHook()
      const apps = await fetchAllEmbeddedApps()

      expect(apps[0].functionDefinitionsObject).toEqual({})
    })
  })

  describe('fetchAssignedApps', () => {
    it('fetches assigned apps for a group', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            embeddedApps: [{
              appKey: 'assignedApp',
              titleText: 'Assigned App',
              description: 'Desc',
              categoryText: 'Cat'
            }]
          }
        })
      })

      const { fetchAssignedApps } = callHook()
      const apps = await fetchAssignedApps('CN=test-group')

      expect(apps).toHaveLength(1)
      expect(apps[0].appIdentifier).toBe('assignedApp')
      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/embedded-apps-ad-groups', expect.objectContaining({
        method: 'POST',
        body: expect.stringContaining('CN=test-group')
      }))
    })

    it('returns empty array on 404', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 404
      })

      const { fetchAssignedApps } = callHook()
      const apps = await fetchAssignedApps('CN=test-group')

      expect(apps).toEqual([])
    })

    it('throws on non-404 error', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 500
      })

      const { fetchAssignedApps } = callHook()
      await expect(fetchAssignedApps('CN=test-group')).rejects.toThrow('Failed to fetch assigned apps')
    })
  })

  describe('loadEmbeddedAppsData', () => {
    it('merges all apps with assigned status', async () => {
      // Mock fetchAllEmbeddedApps
      mockApiFetch
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: {
              embeddedApps: [
                { appKey: 'app1', titleText: 'App 1', description: 'D', categoryText: 'C' },
                { appKey: 'app2', titleText: 'App 2', description: 'D', categoryText: 'C' }
              ]
            }
          })
        })
        // Mock fetchAssignedApps
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            data: {
              embeddedApps: [{
                appKey: 'app1',
                titleText: 'App 1',
                description: 'D',
                categoryText: 'C',
                adGroupAccess: {
                  'CN=test-group': { functionValues: ['fn1', 'fn2'] }
                }
              }]
            }
          })
        })

      const { loadEmbeddedAppsData } = callHook()
      const apps = await loadEmbeddedAppsData('CN=test-group')

      expect(apps).toHaveLength(2)
      const assignedApp = apps.find(a => a.appIdentifier === 'app1')
      const unassignedApp = apps.find(a => a.appIdentifier === 'app2')
      expect(assignedApp?.isAssignedIndicator).toBe(true)
      expect(assignedApp?.assignedFunctionKeys).toEqual(['fn1', 'fn2'])
      expect(unassignedApp?.isAssignedIndicator).toBe(false)
      expect(unassignedApp?.assignedFunctionKeys).toEqual([])
    })

    it('shows error notification on failure', async () => {
      mockApiFetch.mockRejectedValue(new Error('Network error'))

      const { loadEmbeddedAppsData } = callHook()
      await expect(loadEmbeddedAppsData('CN=test-group')).rejects.toThrow()

      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })

  describe('saveAppAssignment', () => {
    it('saves assignment and shows success notification', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: {} })
      })

      const { saveAppAssignment } = callHook()
      await saveAppAssignment('app1', 'App 1', 'CN=test-group', 'Test Group', ['fn1', 'fn2'], 'fn1')

      expect(mockApiFetch).toHaveBeenCalledWith('/papi/v1/embedded-apps-ad-groups/app1', expect.objectContaining({
        method: 'PUT',
        body: expect.stringContaining('fn1')
      }))
      expect(mockNotifications.success).toHaveBeenCalled()
    })

    it('shows remove success notification when functions empty', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: {} })
      })

      const { saveAppAssignment } = callHook()
      await saveAppAssignment('app1', 'App 1', 'CN=test-group', 'Test Group', [])

      expect(mockNotifications.success).toHaveBeenCalledWith(
        expect.objectContaining({
          title: 'App assignment removed'
        })
      )
    })

    it('throws and shows error notification on failure', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 500
      })

      const { saveAppAssignment } = callHook()
      await expect(
        saveAppAssignment('app1', 'App 1', 'CN=test-group', 'Test Group', ['fn1'])
      ).rejects.toThrow('Failed to save app assignment')

      expect(mockNotifications.error).toHaveBeenCalled()
    })
  })
})
===ENDFILE
===FILE: ./src/hooks/api/__tests__/use-reference-data.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

let stateStore: Map<number, unknown>
let stateIndex: number

function resetState() {
  stateStore = new Map()
  stateIndex = 0
}

vi.mock('react', () => ({
  useState: (init: unknown) => {
    const idx = stateIndex++
    if (!stateStore.has(idx)) {
      stateStore.set(idx, typeof init === 'function' ? (init as () => unknown)() : init)
    }
    const setState = (val: unknown) => {
      stateStore.set(idx, typeof val === 'function' ? (val as (prev: unknown) => unknown)(stateStore.get(idx)) : val)
    }
    return [stateStore.get(idx), setState]
  },
  useEffect: vi.fn(),
  useCallback: (fn: (...args: unknown[]) => unknown) => fn
}))

const mockGetAllRegions = vi.fn()
const mockGetAllBusinessUnits = vi.fn()
const mockGetAllCountries = vi.fn()
const mockGetAllRoleTemplates = vi.fn()
const mockGetCountriesByRegion = vi.fn()
const mockGetMarketsByRegion = vi.fn()
const mockGetCountriesByMarket = vi.fn()

vi.mock('../../../services/api/reference-data.service', () => ({
  getAllRegions: (...args: unknown[]) => mockGetAllRegions(...args),
  getAllBusinessUnits: (...args: unknown[]) => mockGetAllBusinessUnits(...args),
  getAllCountries: (...args: unknown[]) => mockGetAllCountries(...args),
  getCountriesByRegion: (...args: unknown[]) => mockGetCountriesByRegion(...args),
  getMarketsByRegion: (...args: unknown[]) => mockGetMarketsByRegion(...args),
  getCountriesByMarket: (...args: unknown[]) => mockGetCountriesByMarket(...args)
}))

vi.mock('../../../services/api/role-template.service', () => ({
  getAllRoleTemplates: (...args: unknown[]) => mockGetAllRoleTemplates(...args)
}))

vi.mock('../../../utils/core/debug', () => ({
  createLogger: () => ({
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  })
}))

const { useReferenceData } = await import('../use-reference-data')

describe('useReferenceData', () => {
  beforeEach(() => {
    resetState()
    vi.clearAllMocks()
  })

  function callHook() {
    stateIndex = 0
    return useReferenceData()
  }

  it('initializes with empty arrays and no error', () => {
    const result = callHook()
    expect(result.regions).toEqual([])
    expect(result.businessUnits).toEqual([])
    expect(result.countries).toEqual([])
    expect(result.roleTemplates).toEqual([])
    expect(result.isLoading).toBe(false)
    expect(result.error).toBeNull()
  })

  it('fetchAllData populates state when called directly', async () => {
    const mockRegions = [{ regionCode: 'APAC', regionName: 'Asia Pacific', displayOrder: 1, isActive: true }]
    const mockBUs = [{ unitCode: 'WPB', unitName: 'Wealth', description: '', effectiveDate: '', displayOrder: 1, isActive: true }]
    const mockCountries = [{ countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true }]
    const mockRoleTemplates = [{ roleNameCode: 'voice_agent', roleDisplayName: 'Voice Agent' }]

    mockGetAllRegions.mockResolvedValue(mockRegions)
    mockGetAllBusinessUnits.mockResolvedValue(mockBUs)
    mockGetAllCountries.mockResolvedValue(mockCountries)
    mockGetAllRoleTemplates.mockResolvedValue(mockRoleTemplates)

    // Call refetch which clears module caches and calls fetchAllData
    const { refetch } = callHook()
    await refetch()

    const result = callHook()
    expect(result.regions).toEqual(mockRegions)
    expect(result.businessUnits).toEqual(mockBUs)
    expect(result.countries).toEqual(mockCountries)
    expect(result.roleTemplates).toEqual(mockRoleTemplates)
  })

  it('fetchAllData sets error on failure', async () => {
    mockGetAllRegions.mockRejectedValue(new Error('Network error'))
    mockGetAllBusinessUnits.mockResolvedValue([])
    mockGetAllCountries.mockResolvedValue([])
    mockGetAllRoleTemplates.mockResolvedValue([])

    const { refetch } = callHook()
    await refetch()

    const result = callHook()
    expect(result.error).toBe('Network error')
  })

  it('refetch clears caches and re-fetches', async () => {
    const mockRegions = [{ regionCode: 'APAC', regionName: 'Asia', displayOrder: 1, isActive: true }]
    mockGetAllRegions.mockResolvedValue(mockRegions)
    mockGetAllBusinessUnits.mockResolvedValue([])
    mockGetAllCountries.mockResolvedValue([])
    mockGetAllRoleTemplates.mockResolvedValue([])

    const { refetch } = callHook()
    await refetch()

    // Second refetch should call APIs again since caches were cleared
    await refetch()
    expect(mockGetAllRegions).toHaveBeenCalledTimes(2)
  })

  it('getCountriesForRegion fetches and returns countries', async () => {
    const mockCountries = [{ countryCode: 'SG', countryName: 'Singapore', regionCode: 'APAC', marketCode: 'SG', displayOrder: 1, isActive: true }]
    mockGetCountriesByRegion.mockResolvedValue(mockCountries)

    const { getCountriesForRegion } = callHook()
    const result = await getCountriesForRegion('APAC')

    expect(result).toEqual(mockCountries)
    expect(mockGetCountriesByRegion).toHaveBeenCalledWith('APAC')
  })

  it('getMarketsForRegion fetches and returns markets', async () => {
    const mockMarkets = [{ marketCode: 'SG', marketName: 'Singapore', regionCode: 'APAC', displayOrder: 1, isActive: true }]
    mockGetMarketsByRegion.mockResolvedValue(mockMarkets)

    const { getMarketsForRegion } = callHook()
    const result = await getMarketsForRegion('APAC')

    expect(result).toEqual(mockMarkets)
    expect(mockGetMarketsByRegion).toHaveBeenCalledWith('APAC')
  })

  it('getCountriesForMarket fetches and returns countries', async () => {
    const mockCountries = [{ countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true }]
    mockGetCountriesByMarket.mockResolvedValue(mockCountries)

    const { getCountriesForMarket } = callHook()
    const result = await getCountriesForMarket('HK')

    expect(result).toEqual(mockCountries)
    expect(mockGetCountriesByMarket).toHaveBeenCalledWith('HK')
  })

  it('getCountriesForRegion throws on error', async () => {
    mockGetCountriesByRegion.mockRejectedValue(new Error('API error'))

    const { getCountriesForRegion } = callHook()
    await expect(getCountriesForRegion('BAD')).rejects.toThrow('API error')
  })

  it('getMarketsForRegion throws on error', async () => {
    mockGetMarketsByRegion.mockRejectedValue(new Error('Market error'))

    const { getMarketsForRegion } = callHook()
    await expect(getMarketsForRegion('BAD')).rejects.toThrow('Market error')
  })

  it('getCountriesForMarket throws on error', async () => {
    mockGetCountriesByMarket.mockRejectedValue(new Error('Market lookup error'))

    const { getCountriesForMarket } = callHook()
    await expect(getCountriesForMarket('BAD')).rejects.toThrow('Market lookup error')
  })
})
===ENDFILE
===FILE: ./src/hooks/api/use-ad-group-api.ts
import { useState, useCallback } from 'react'
import { useNotifications } from '../features/use-notifications'
import type { AdGroupData, UserAccessLevel } from '../../types/features/ad-group-config'
import { apiFetch } from '../../services/core/api-client'


export interface UpdateAdGroupOptions {
  suppressSuccessToast?: boolean
}

interface UseAdGroupApiReturn {
  isLoading: boolean
  fetchAdGroupData: (groupIdentifier: string) => Promise<AdGroupData | null>
  updateAdGroupConfig: (groupIdentifier: string, updatePayload: Partial<AdGroupData>, options?: UpdateAdGroupOptions) => Promise<AdGroupData | null>
  applyRoleTemplate: (groupIdentifier: string, roleName: string) => Promise<AdGroupData | null>
  copyFromAdGroup: (targetGroupIdentifier: string, sourceGroupIdentifier: string) => Promise<AdGroupData | null>
  fetchAllAdGroups: () => Promise<AdGroupData[]>
}

/**
 * Maps PAPI response fields to frontend AdGroupData fields.
 * PAPI returns: marketCode, regionCode, countryCode, activeIndicator, userCountNumber, userAccessCode, etc.
 * Frontend expects: market, region, country, isActive, userCount, accessLevel, etc.
 */
function transformAdGroupResponse(raw: Record<string, unknown>): AdGroupData {
  const currentConfig = raw.currentConfig as Record<string, unknown> | undefined
  const permissionChanges = currentConfig?.permissionChanges as Record<string, unknown> | undefined
  const toAssignments = (permissions: Record<string, unknown> | undefined): Record<string, { state: 'enabled' | 'disabled' }> | undefined => {
    if (!permissions) {
      return undefined
    }
    return Object.fromEntries(
      Object.entries(permissions).map(([key, value]) => {
        const enabled = Boolean((value as { enabledIndicator?: boolean })?.enabledIndicator)
        return [key, { state: enabled ? 'enabled' : 'disabled' as const }]
      })
    )
  }

  return {
    id: (raw.groupIdentifier as string) ?? '',
    groupIdentifier: (raw.groupIdentifier as string) ?? '',
    logicalName: (raw.logicalName as string | undefined) ?? undefined,
    roleName: (raw.roleName as string | undefined) ?? undefined,
    market: raw.marketCode as string | undefined,
    region: raw.regionCode as string | undefined,
    country: raw.countryCode as string | undefined,
    businessUnit: raw.businessUnitName as string | undefined,
    isActive: (raw.activeIndicator as boolean | undefined) ?? true,
    accessLevel: raw.userAccessCode as UserAccessLevel | undefined,
    pendingChangeIndicator: (raw.pendingChangeIndicator as boolean | undefined) ?? false,
    versionNumber: (raw.versionNumber as number | undefined),
    userCount: raw.userCountNumber as number | undefined,
    lastModified: raw.updatedAtDatetime as string | undefined,
    columnAssignments: toAssignments(
      permissionChanges?.columnPermissions as Record<string, unknown> | undefined
    ),
    widgetAssignments: toAssignments(
      permissionChanges?.widgetPermissions as Record<string, unknown> | undefined
    )
  }
}

function toDirectSaveProposedState(payload: Partial<AdGroupData>): Record<string, unknown> {
  const proposedState: Record<string, unknown> = { ...payload }
  if ('isActive' in proposedState && typeof proposedState.isActive === 'boolean') {
    proposedState.activeIndicator = proposedState.isActive
    delete proposedState.isActive
  }
  return Object.fromEntries(Object.entries(proposedState).filter(([, value]) => value !== undefined))
}

export function useAdGroupApi(): UseAdGroupApiReturn {
  const [isLoading, setIsLoading] = useState(false)
  const notifications = useNotifications()

  const fetchAdGroupData = useCallback(async (groupIdentifier: string): Promise<AdGroupData | null> => {
    try {
      const response = await apiFetch('/papi/v1/ad-groups/lookup', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          data: {
            groupIdentifier
          }
        })
      })

      if (!response.ok) {
        if (response.status === 404) {
          return null
        } else if (response.status === 403) {
          throw new Error('Access denied: Admin privileges required')
        } else {
          throw new Error(`Failed to fetch AD group data: ${response.status}`)
        }
      }

      const raw = await response.json() as {
        data?: Record<string, unknown>
      }
      if (!raw.data) {
        throw new Error('Unexpected AD group lookup response')
      }
      return transformAdGroupResponse(raw.data)
    } catch (error) {
      if (error instanceof TypeError && error.message.includes('fetch')) {
        throw new Error('Network error: Unable to connect to server')
      }
      throw error
    }
  }, [])

  const updateAdGroupConfig = useCallback(async (
    groupIdentifier: string,
    updatePayload: Partial<AdGroupData>,
    options: UpdateAdGroupOptions = {}
  ): Promise<AdGroupData | null> => {
    setIsLoading(true)
    try {
      const response = await apiFetch('/papi/v1/ad-group-configs', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          data: {
            targetGroupIdentifier: groupIdentifier,
            proposedState: toDirectSaveProposedState(updatePayload),
            ...(typeof updatePayload.versionNumber === 'number'
              ? { configVersionNumber: updatePayload.versionNumber }
              : {})
          }
        })
      })

      if (!response.ok) {
        throw new Error(`Failed to update configuration: ${response.status}`)
      }

      const updatedConfig = await fetchAdGroupData(groupIdentifier)
      if (!options.suppressSuccessToast) {
        notifications.success({
          title: 'Configuration saved',
          description: 'AD group settings were updated successfully.'
        })
      }
      return updatedConfig
    } catch (error) {
      notifications.error({
        title: 'Unable to save configuration',
        description: 'Please review the details and try again.',
        metaKey: `ad-group-save-${groupIdentifier}`
      })
      throw error
    } finally {
      setIsLoading(false)
    }
  }, [fetchAdGroupData, notifications])

  const applyRoleTemplate = useCallback(async (
    groupIdentifier: string,
    roleName: string
  ): Promise<AdGroupData | null> => {
    setIsLoading(true)
    try {
      const response = await apiFetch('/papi/v1/ad-group-configs', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          data: {
            targetGroupIdentifier: groupIdentifier,
            proposedState: { roleName }
          }
        })
      })

      if (!response.ok) {
        throw new Error(`Failed to apply role template: ${response.status}`)
      }

      const updatedConfig = await fetchAdGroupData(groupIdentifier)
      notifications.success({
        title: 'Role template applied',
        description: `${roleName} permissions have been applied to this AD group.`
      })
      return updatedConfig
    } catch (error) {
      notifications.error({
        title: 'Role template failed',
        description: 'We could not apply the selected template. Please try again.',
        metaKey: `ad-group-template-${groupIdentifier}`
      })
      throw error
    } finally {
      setIsLoading(false)
    }
  }, [fetchAdGroupData, notifications])

  const copyFromAdGroup = useCallback(async (
    targetGroupIdentifier: string,
    sourceGroupIdentifier: string
  ): Promise<AdGroupData | null> => {
    setIsLoading(true)
    try {
      // Copy the configuration to the target group
      const response = await apiFetch('/papi/v1/ad-group-configuration-copies', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          data: {
            sourceGroupIdentifier,
            targetGroupIdentifier
          }
        })
      })

      if (!response.ok) {
        throw new Error(`Failed to copy configuration: ${response.status}`)
      }

      const updatedConfig = await fetchAdGroupData(targetGroupIdentifier)
      notifications.success({
        title: 'Configuration copied',
        description: `${sourceGroupIdentifier} settings are now active for ${targetGroupIdentifier}.`
      })
      return updatedConfig
    } catch (error) {
      notifications.error({
        title: 'Copy operation failed',
        description: 'We could not copy the configuration. Please try again.',
        metaKey: `ad-group-copy-${targetGroupIdentifier}`
      })
      throw error
    } finally {
      setIsLoading(false)
    }
  }, [fetchAdGroupData, notifications])

  const fetchAllAdGroups = useCallback(async (): Promise<AdGroupData[]> => {
    try {
      const response = await apiFetch('/papi/v1/ad-groups', {
        method: 'GET',
        headers: {}
      })

      if (!response.ok) {
        throw new Error(`Failed to fetch AD groups: ${response.status}`)
      }

      const raw = await response.json() as {
        data?: { items?: Record<string, unknown>[] }
      }
      const items = raw.data?.items ?? []
      return items.map(transformAdGroupResponse)
    } catch {
      notifications.error({
        title: 'Unable to load AD groups',
        description: 'Check your connection and try refreshing the page.',
        metaKey: 'ad-groups-load-error'
      })
      return []
    }
  }, [notifications])

  return {
    isLoading,
    fetchAdGroupData,
    updateAdGroupConfig,
    applyRoleTemplate,
    copyFromAdGroup,
    fetchAllAdGroups
  }
}
===ENDFILE
===FILE: ./src/hooks/api/use-embedded-apps-api.ts
import { useState, useCallback, useMemo } from 'react'
import { useNotifications } from '../features/use-notifications'
import { EmbeddedApp, EmbeddedAppWithStatus } from '../../types/integration/embedded-apps'
import { apiFetch } from '../../services/core/api-client'
import { createLogger } from '@/utils/core/debug'
import { logErrorToTracking } from '@/utils/core/error-tracking'

/**
 * Maps PAPI response fields to frontend EmbeddedApp fields.
 * PAPI returns: appKey, description, categoryText, baseUrlText, isActiveFlag, etc.
 * Frontend keeps app-level aliases, while function definitions use contract keys.
 */
function mapDefinitionFields(definition: Record<string, unknown>, functionKey: string) {
  return {
    displayName:
      (definition.displayName as string) ??
      (definition.displayNameText as string) ??
      functionKey,
    description:
      (definition.description as string) ??
      (definition.descriptionText as string),
    categoryText:
      (definition.categoryText as string) ??
      (definition.categoryName as string),
    searchKeywordValues:
      (definition.searchKeywordValues as string[]) ??
      (definition.searchKeywords as string[]),
    requiresApprovalFlag: (definition.requiresApprovalFlag as boolean) ?? undefined,
    mfeConfig:
      (definition.mfeConfig as Record<string, unknown>) ??
      (definition.mfeConfigObject as Record<string, unknown>)
  }
}

function transformFunctionDefinitions(rawDefinitions: unknown): EmbeddedApp['functionDefinitionsObject'] {
  if (!rawDefinitions || typeof rawDefinitions !== 'object' || Array.isArray(rawDefinitions)) {
    return {}
  }

  return Object.entries(rawDefinitions as Record<string, unknown>).reduce((acc, [functionKey, rawDefinition]) => {
    if (!rawDefinition || typeof rawDefinition !== 'object' || Array.isArray(rawDefinition)) {
      return acc
    }

    acc[functionKey] = mapDefinitionFields(rawDefinition as Record<string, unknown>, functionKey)
    return acc
  }, {} as EmbeddedApp['functionDefinitionsObject'])
}

function resolveString(raw: Record<string, unknown>, primary: string, fallback: string, defaultValue = ''): string {
  return (raw[primary] as string) ?? (raw[fallback] as string) ?? defaultValue
}

function mapAppResponseFields(raw: Record<string, unknown>) {
  return {
    baseUrlAddress: (raw.baseUrlText as string) ?? (raw.baseUrlAddress as string),
    loadingStrategyCode: (raw.loadingStrategyText as string) ?? (raw.loadingStrategyCode as string),
    primaryKeywordsText: (raw.primaryKeywordValues as string[]) ?? (raw.primaryKeywordsText as string[]),
    secondaryKeywordsText: (raw.secondaryKeywordValues as string[]) ?? (raw.secondaryKeywordsText as string[]),
    mfeConfigObject: (raw.mfeConfig as Record<string, unknown>) ?? (raw.mfeConfigObject as Record<string, unknown>),
    regionalUrlsObject: (raw.regionalUrls as Record<string, unknown>) ?? (raw.regionalUrlsObject as Record<string, unknown>),
    isActiveIndicator: (raw.isActiveFlag as boolean) ?? (raw.isActiveIndicator as boolean) ?? true,
  }
}

function transformPapiApp(raw: Record<string, unknown>): EmbeddedApp {
  const rawFunctionDefinitions = raw.functionDefinitionMap ?? raw.functionDefinitionsObject

  return {
    appIdentifier: resolveString(raw, 'appKey', 'appIdentifier'),
    titleText: (raw.titleText as string) ?? '',
    descriptionText: resolveString(raw, 'description', 'descriptionText'),
    categoryName: resolveString(raw, 'categoryText', 'categoryName'),
    ...mapAppResponseFields(raw),
    functionDefinitionsObject: transformFunctionDefinitions(rawFunctionDefinitions),
    adGroupAccessObject: (raw.adGroupAccess ?? raw.adGroupAccessObject) as EmbeddedApp['adGroupAccessObject'],
    appFunctionKeys: (raw.appFunctionValues as string[]) ?? (raw.appFunctionKeys as string[])
  }
}

interface UseEmbeddedAppsApiReturn {
  isLoadingApps: boolean
  isSavingAppAssignment: boolean
  fetchAllEmbeddedApps: () => Promise<EmbeddedApp[]>
  fetchAssignedApps: (groupIdentifier: string) => Promise<EmbeddedApp[]>
  loadEmbeddedAppsData: (groupIdentifier: string) => Promise<EmbeddedAppWithStatus[]>
  saveAppAssignment: (
    appKey: string,
    appTitle: string,
    groupIdentifier: string,
    groupDisplayName: string,
    functions: string[],
    defaultFunction?: string
  ) => Promise<void>
}

export function useEmbeddedAppsApi(): UseEmbeddedAppsApiReturn {
  const [isLoadingApps, setIsLoadingApps] = useState(false)
  const [isSavingAppAssignment, setIsSavingAppAssignment] = useState(false)
  const notifications = useNotifications()
  const logger = useMemo(() => createLogger('EMBEDDED_APPS_API'), [])

  const fetchAllEmbeddedApps = useCallback(async (): Promise<EmbeddedApp[]> => {
    try {
      const response = await apiFetch('/papi/v1/embedded-apps', {
        method: 'GET'
      })

      if (!response.ok) {
        throw new Error(`Failed to fetch embedded apps: ${response.status}`)
      }

      const raw = await response.json() as Record<string, unknown>
      // PAPI returns envelope: { data: { embeddedApps: [...] } }
      const dataObj = raw.data as Record<string, unknown> | undefined
      const apps = (dataObj?.embeddedApps ?? (Array.isArray(raw) ? raw : [])) as Record<string, unknown>[]
      return apps.map(transformPapiApp)
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error)
      logger.error('Failed to fetch embedded apps catalogue', { error })
      logErrorToTracking('EMBEDDED_APPS_FETCH_FAILED', { error: message })

      const typedError = new Error(`Failed to fetch embedded apps: ${message}`)
      ;(typedError as Error & { cause?: unknown }).cause = error
      throw typedError
    }
  }, [logger])

  const fetchAssignedApps = useCallback(async (groupIdentifier: string): Promise<EmbeddedApp[]> => {
    try {
      const response = await apiFetch('/papi/v1/embedded-apps-ad-groups', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          data: {
            groupIdentifier
          }
        })
      })

      if (!response.ok) {
        if (response.status === 404) {
          // No apps assigned to this group yet
          return []
        }
        throw new Error(`Failed to fetch assigned apps: ${response.status}`)
      }

      const raw = await response.json() as Record<string, unknown>
      // PAPI returns envelope: { data: { embeddedApps: [...] } }
      const dataObj = raw.data as Record<string, unknown> | undefined
      const assignedApps = (dataObj?.embeddedApps ?? (Array.isArray(raw) ? raw : [])) as Record<string, unknown>[]
      return assignedApps.map(transformPapiApp)
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error)
      logger.error('Failed to fetch assigned embedded apps', {
        error,
        groupIdentifier
      })
      logErrorToTracking('EMBEDDED_APPS_ASSIGNED_FETCH_FAILED', {
        error: message,
        groupIdentifier
      })

      const typedError = new Error(`Failed to fetch assigned apps: ${message}`)
      ;(typedError as Error & { cause?: unknown }).cause = error
      throw typedError
    }
  }, [logger])

  const loadEmbeddedAppsData = useCallback(async (groupIdentifier: string): Promise<EmbeddedAppWithStatus[]> => {
    setIsLoadingApps(true)
    try {
      // Load both all apps and assigned apps in parallel
      const [allApps, assignedApps] = await Promise.all([
        fetchAllEmbeddedApps(),
        fetchAssignedApps(groupIdentifier)
      ])

      // Create a map of assigned apps for quick lookup
      const assignedAppsMap = new Map(
        assignedApps.map(app => [app.appIdentifier, app])
      )

      // Merge the data to show assignment status
      const appsWithStatus: EmbeddedAppWithStatus[] = allApps.map(app => {
        const assignedApp = assignedAppsMap.get(app.appIdentifier)
        const assignedAccess = assignedApp?.adGroupAccessObject?.[groupIdentifier]
        const assignedFunctionKeys = assignedAccess?.functionValues || []
        const isAssignedIndicator = assignedFunctionKeys.length > 0

        return {
          ...app,
          isAssignedIndicator,
          assignedFunctionKeys,
          defaultFunctionKey: undefined // eslint-disable-line typescript:S2138
        }
      })

      return appsWithStatus
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error)
      logger.error('Failed to load embedded apps data', {
        error,
        groupIdentifier
      })
      logErrorToTracking('EMBEDDED_APPS_DATA_FAILED', {
        error: message,
        groupIdentifier
      })
      notifications.error({
        title: 'Application data unavailable',
        description: 'We could not load the embedded app configuration for this group.',
        persistent: true,
        metaKey: 'embedded-apps-data-unavailable'
      })

      const typedError = new Error(`Failed to load embedded apps data: ${message}`)
      ;(typedError as Error & { cause?: unknown }).cause = error
      throw typedError
    } finally {
      setIsLoadingApps(false)
    }
  }, [fetchAllEmbeddedApps, fetchAssignedApps, logger, notifications])

  const saveAppAssignment = useCallback(async (
    appKey: string,
    appTitle: string,
    groupIdentifier: string,
    groupDisplayName: string,
    functions: string[],
    defaultFunction?: string
  ): Promise<void> => {
    setIsSavingAppAssignment(true)
    try {
      const response = await apiFetch(`/papi/v1/embedded-apps-ad-groups/${appKey}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          data: {
            groupIdentifier,
            functionValues: functions,
            defaultFunctionText: defaultFunction
          }
        })
      })

      if (!response.ok) {
        throw new Error(`Failed to save app assignment: ${response.status}`)
      }

      await response.json()
      const displayName = appTitle || appKey
      const targetGroup = groupDisplayName || groupIdentifier
      const isAssigned = functions.length > 0

      notifications.success({
        title: isAssigned ? 'App assignment saved' : 'App assignment removed',
        description: isAssigned
          ? `${displayName} access has been updated for ${targetGroup}.`
          : `${displayName} has been unassigned from ${targetGroup}.`
      })
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error)
      logger.error('Failed to save app assignment', {
        error,
        appKey,
        groupIdentifier
      })
      logErrorToTracking('EMBEDDED_APPS_ASSIGNMENT_SAVE_FAILED', {
        error: message,
        appKey,
        groupIdentifier
      })

      notifications.error({
        title: 'Unable to save app assignment',
        description: 'Please review the selections and try saving again.'
      })

      const typedError = new Error(`Failed to save app assignment: ${message}`)
      ;(typedError as Error & { cause?: unknown }).cause = error
      throw typedError
    } finally {
      setIsSavingAppAssignment(false)
    }
  }, [logger, notifications])

  return {
    isLoadingApps,
    isSavingAppAssignment,
    fetchAllEmbeddedApps,
    fetchAssignedApps,
    loadEmbeddedAppsData,
    saveAppAssignment
  }
}
===ENDFILE
===FILE: ./src/hooks/api/use-reference-data.ts
import { useState, useEffect, useCallback } from 'react'
import { getAllRegions, getAllBusinessUnits, getAllCountries, getCountriesByRegion, getMarketsByRegion, getCountriesByMarket } from '../../services/api/reference-data.service'
import { getAllRoleTemplates } from '../../services/api/role-template.service'
import { createLogger } from '../../utils/core/debug'
import type { RegionDto, BusinessUnitDto, CountryDto, MarketDto } from '../../services/api/reference-data.service'
import type { RoleTemplateSummaryDto } from '../../services/api/role-template.service'

interface UseReferenceDataReturn {
  regions: RegionDto[]
  businessUnits: BusinessUnitDto[]
  countries: CountryDto[]
  roleTemplates: RoleTemplateSummaryDto[]
  isLoading: boolean
  error: string | null
  getCountriesForRegion: (regionNameOrCode: string) => Promise<CountryDto[]>
  getMarketsForRegion: (regionCode: string) => Promise<MarketDto[]>
  getCountriesForMarket: (marketCode: string) => Promise<CountryDto[]>
  refetch: () => Promise<void>
}

let cachedRegions: RegionDto[] | null = null
let cachedBusinessUnits: BusinessUnitDto[] | null = null
let cachedCountries: CountryDto[] | null = null
let cachedRoleTemplates: RoleTemplateSummaryDto[] | null = null
const cachedCountriesByRegion = new Map<string, CountryDto[]>()
const cachedMarketsByRegion = new Map<string, MarketDto[]>()
const cachedCountriesByMarket = new Map<string, CountryDto[]>()
const logger = createLogger('useReferenceData')

export function useReferenceData(): UseReferenceDataReturn {
  const [regions, setRegions] = useState<RegionDto[]>(cachedRegions || [])
  const [businessUnits, setBusinessUnits] = useState<BusinessUnitDto[]>(cachedBusinessUnits || [])
  const [countries, setCountries] = useState<CountryDto[]>(cachedCountries || [])
  const [roleTemplates, setRoleTemplates] = useState<RoleTemplateSummaryDto[]>(cachedRoleTemplates || [])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const fetchAllData = useCallback(async () => {
    if (cachedRegions && cachedBusinessUnits && cachedCountries && cachedRoleTemplates) {
      return
    }

    setIsLoading(true)
    setError(null)

    try {
      const roleTemplatesPromise = cachedRoleTemplates
        ? Promise.resolve(cachedRoleTemplates)
        : getAllRoleTemplates().catch((roleTemplateError) => {
          logger.warn('Role templates fetch failed; continuing with empty list', roleTemplateError)
          return [] as RoleTemplateSummaryDto[]
        })

      const [regionsData, businessUnitsData, countriesData, roleTemplatesData] = await Promise.all([
        cachedRegions ? Promise.resolve(cachedRegions) : getAllRegions(),
        cachedBusinessUnits ? Promise.resolve(cachedBusinessUnits) : getAllBusinessUnits(),
        cachedCountries ? Promise.resolve(cachedCountries) : getAllCountries(),
        roleTemplatesPromise
      ])

      cachedRegions = regionsData
      cachedBusinessUnits = businessUnitsData
      cachedCountries = countriesData
      cachedRoleTemplates = roleTemplatesData

      setRegions(regionsData)
      setBusinessUnits(businessUnitsData)
      setCountries(countriesData)
      setRoleTemplates(roleTemplatesData)
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch reference data'
      setError(errorMessage)
      logger.error('Error fetching reference data', err)
    } finally {
      setIsLoading(false)
    }
  }, [])

  const getCountriesForRegion = useCallback(async (regionNameOrCode: string): Promise<CountryDto[]> => {
    const region = cachedRegions?.find(r => r.regionName === regionNameOrCode || r.regionCode === regionNameOrCode)
    const regionCode = region?.regionCode || regionNameOrCode

    if (cachedCountriesByRegion.has(regionCode)) {
      return cachedCountriesByRegion.get(regionCode)!
    }

    try {
      const countriesData = await getCountriesByRegion(regionCode)
      cachedCountriesByRegion.set(regionCode, countriesData)
      return countriesData
    } catch (err) {
      logger.error('Error fetching countries for region', { regionNameOrCode, regionCode, error: err })
      throw err
    }
  }, [])

  const getMarketsForRegion = useCallback(async (regionCode: string): Promise<MarketDto[]> => {
    if (cachedMarketsByRegion.has(regionCode)) {
      return cachedMarketsByRegion.get(regionCode)!
    }

    try {
      const marketsData = await getMarketsByRegion(regionCode)
      cachedMarketsByRegion.set(regionCode, marketsData)
      return marketsData
    } catch (err) {
      logger.error('Error fetching markets for region', { regionCode, error: err })
      throw err
    }
  }, [])

  const getCountriesForMarket = useCallback(async (marketCode: string): Promise<CountryDto[]> => {
    if (cachedCountriesByMarket.has(marketCode)) {
      return cachedCountriesByMarket.get(marketCode)!
    }

    try {
      const countriesData = await getCountriesByMarket(marketCode)
      cachedCountriesByMarket.set(marketCode, countriesData)
      return countriesData
    } catch (err) {
      logger.error('Error fetching countries for market', { marketCode, error: err })
      throw err
    }
  }, [])

  const refetch = useCallback(async () => {
    cachedRegions = null
    cachedBusinessUnits = null
    cachedCountries = null
    cachedRoleTemplates = null
    cachedCountriesByRegion.clear()
    cachedMarketsByRegion.clear()
    cachedCountriesByMarket.clear()
    await fetchAllData()
  }, [fetchAllData])

  useEffect(() => {
    fetchAllData()
  }, [fetchAllData])

  return {
    regions,
    businessUnits,
    countries,
    roleTemplates,
    isLoading,
    error,
    getCountriesForRegion,
    getMarketsForRegion,
    getCountriesForMarket,
    refetch
  }
}
===ENDFILE
===FILE: ./src/hooks/common/__tests__/use-toast.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('react', () => ({
  createContext: vi.fn(() => ({})),
  useContext: vi.fn(),
  useState: vi.fn(() => [[], vi.fn()]),
  useCallback: (fn: unknown) => fn,
  useRef: (init: unknown) => ({ current: init })
}))

describe('use-toast module', () => {
  it('exports ToastProvider and useToast', async () => {
    const mod = await import('../use-toast')
    expect(mod.ToastProvider).toBeDefined()
    expect(typeof mod.ToastProvider).toBe('function')
    expect(mod.useToast).toBeDefined()
    expect(typeof mod.useToast).toBe('function')
  })
})
===ENDFILE
===FILE: ./src/hooks/common/use-toast.tsx
import React, { createContext, useContext, useState, useCallback, useRef } from 'react'
import { Toast, ToastContainer, ToastProps, ToastVariant } from '../../components/ui/toast'

interface ToastContextValue {
  notify: (props: Omit<ToastProps, 'id' | 'onClose'>) => void
  dismiss: (id: string) => void
}

const ToastContext = createContext<ToastContextValue | null>(null)

const DEFAULT_DURATIONS: Record<ToastVariant, number> = {
  info: 3000,
  success: 2500,
  warning: 4000,
  error: 4000,
  critical: 5000
}

export function ToastProvider({ children }: Readonly<{ children: React.ReactNode }>) {
  const [toasts, setToasts] = useState<ToastProps[]>([])
  const timersRef = useRef<Map<string, number>>(new Map())
  const metaKeyIndexRef = useRef<Map<string, string>>(new Map())
  const idToMetaKeyRef = useRef<Map<string, string>>(new Map())
 
  const dismiss = useCallback((id: string) => {
    setToasts((prev) => prev.filter((t) => t.id !== id))
    const timeoutId = timersRef.current.get(id)
    if (timeoutId) {
      window.clearTimeout(timeoutId)
      timersRef.current.delete(id)
    }
    const metaKey = idToMetaKeyRef.current.get(id)
    if (metaKey) {
      metaKeyIndexRef.current.delete(metaKey)
      idToMetaKeyRef.current.delete(id)
    }
  }, [])
  
  const notify = useCallback((props: Omit<ToastProps, 'id' | 'onClose'>) => {
    if (props.metaKey) {
      const existingId = metaKeyIndexRef.current.get(props.metaKey)
      if (existingId) {
        dismiss(existingId)
      }
    }

    const id = `${Date.now()}-${Math.random().toString(16).slice(2)}`
    const variant: ToastVariant = props.variant ?? 'info'
    const duration = props.persistent ? undefined : props.duration ?? DEFAULT_DURATIONS[variant]
    const newToast: ToastProps = {
      ...props,
      id,
      onClose: () => dismiss(id),
      variant
    }
    
    setToasts((prev) => [...prev, newToast])

    if (props.metaKey) {
      metaKeyIndexRef.current.set(props.metaKey, id)
      idToMetaKeyRef.current.set(id, props.metaKey)
    }
    
    if (duration) {
      const timeoutId = window.setTimeout(() => {
        dismiss(id)
      }, duration)
      timersRef.current.set(id, timeoutId)
    }
  }, [dismiss])
  
  const contextValue = React.useMemo(() => ({ notify, dismiss }), [notify, dismiss])

  return (
    <ToastContext.Provider value={contextValue}>
      {children}
      <ToastContainer>
        {toasts.map((toastProps) => (
          <Toast key={toastProps.id} {...toastProps} />
        ))}
      </ToastContainer>
    </ToastContext.Provider>
  )
}

export function useToast() {
  const context = useContext(ToastContext)
  if (!context) {
    throw new Error('useToast must be used within ToastProvider')
  }
  return context
}
===ENDFILE
===FILE: ./src/hooks/features/__tests__/use-business-terminology.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('react', () => ({
  useMemo: (fn: () => unknown) => fn()
}))

const { useBusinessRoles, useBusinessStatus, getBusinessField } = await import('../use-business-terminology')

describe('useBusinessRoles', () => {
  it('returns all expected role keys', () => {
    const roles = useBusinessRoles()
    expect(roles).toHaveProperty('voice_agent')
    expect(roles).toHaveProperty('chat_agent')
    expect(roles).toHaveProperty('supervisor')
    expect(roles).toHaveProperty('admin')
    expect(roles).toHaveProperty('maker')
    expect(roles).toHaveProperty('checker')
    expect(roles).toHaveProperty('super_admin')
  })

  it('each role has displayName, description, category', () => {
    const roles = useBusinessRoles()
    for (const role of Object.values(roles)) {
      expect(role).toHaveProperty('displayName')
      expect(role).toHaveProperty('description')
      expect(role).toHaveProperty('category')
    }
  })

  it('assigns correct categories', () => {
    const roles = useBusinessRoles()
    expect(roles.voice_agent.category).toBe('Agent')
    expect(roles.supervisor.category).toBe('Management')
    expect(roles.admin.category).toBe('Administration')
    expect(roles.maker.category).toBe('Approval Workflow')
  })
})

describe('useBusinessStatus', () => {
  it('returns all expected status keys', () => {
    const statuses = useBusinessStatus()
    expect(statuses).toHaveProperty('active')
    expect(statuses).toHaveProperty('disabled')
    expect(statuses).toHaveProperty('needs_setup')
    expect(statuses).toHaveProperty('pending')
  })

  it('each status has label, description, variant', () => {
    const statuses = useBusinessStatus()
    for (const status of Object.values(statuses)) {
      expect(status).toHaveProperty('label')
      expect(status).toHaveProperty('variant')
    }
  })

  it('assigns correct variants', () => {
    const statuses = useBusinessStatus()
    expect(statuses.active.variant).toBe('success')
    expect(statuses.disabled.variant).toBe('error')
    expect(statuses.needs_setup.variant).toBe('warning')
    expect(statuses.pending.variant).toBe('info')
  })
})

describe('getBusinessField', () => {
  it('returns mapped business name for known fields', () => {
    expect(getBusinessField('groupName')).toBe('Team Group')
    expect(getBusinessField('role')).toBe('Role')
    expect(getBusinessField('userCount')).toBe('Members')
    expect(getBusinessField('businessUnit')).toBe('Department')
  })

  it('returns original field name for unknown fields', () => {
    expect(getBusinessField('someRandomField')).toBe('someRandomField')
  })
})
===ENDFILE
===FILE: ./src/hooks/features/__tests__/use-dropdown-options.test.ts
import { beforeEach, describe, expect, it, vi } from 'vitest'

const mockUseReferenceData = vi.fn(() => ({
  roleTemplates: [] as Array<{ roleNameCode: string; roleDisplayName: string }>
}))

vi.mock('react', () => ({
  useMemo: (fn: () => unknown) => fn()
}))

vi.mock('../../api/use-reference-data', () => ({
  useReferenceData: () => mockUseReferenceData()
}))

const { useDropdownOptions } = await import('../use-dropdown-options')

describe('useDropdownOptions', () => {
  beforeEach(() => {
    mockUseReferenceData.mockReturnValue({ roleTemplates: [] })
  })

  it('returns API roles and filters admin role', () => {
    mockUseReferenceData.mockReturnValue({
      roleTemplates: [
        { roleNameCode: 'chat_agent', roleDisplayName: 'Chat Agent' },
        { roleNameCode: 'admin', roleDisplayName: 'Administrator' },
        { roleNameCode: 'voice_agent', roleDisplayName: 'Voice Agent' }
      ]
    })

    const options = useDropdownOptions()
    expect(options.roles).toHaveLength(2)
    expect(options.roles.map(r => r.value)).toEqual(['chat_agent', 'voice_agent'])
  })

  it('falls back to static roles when API roles are unavailable', () => {
    mockUseReferenceData.mockReturnValue({ roleTemplates: [] })

    const options = useDropdownOptions()
    expect(options.roles).toHaveLength(3)
    expect(options.roles.map(r => r.value)).toEqual(['chat_agent', 'voice_agent', 'supervisor'])
  })

  it('returns empty markets array', () => {
    const options = useDropdownOptions()
    expect(options.markets).toEqual([])
  })

  it('returns regions dropdown options', () => {
    const options = useDropdownOptions()
    expect(options.regions).toHaveLength(3)
    expect(options.regions.map(r => r.value)).toEqual(['EMEA', 'AMER', 'APAC'])
  })

  it('returns businessUnits dropdown options', () => {
    const options = useDropdownOptions()
    expect(options.businessUnits.length).toBeGreaterThan(0)
    expect(options.businessUnits[0]).toHaveProperty('value')
    expect(options.businessUnits[0]).toHaveProperty('label')
  })

  it('returns countries dropdown options', () => {
    const options = useDropdownOptions()
    expect(options.countries.length).toBeGreaterThan(0)
    expect(options.countries.map(c => c.value)).toContain('United Kingdom')
    expect(options.countries.map(c => c.value)).toContain('United States')
  })
})
===ENDFILE
===FILE: ./src/hooks/features/__tests__/use-feature-mapping.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('react', () => ({
  useCallback: (fn: unknown) => fn
}))

const { useExtractEnabledFeatures } = await import('../use-feature-mapping')

describe('useExtractEnabledFeatures', () => {
  const extract = useExtractEnabledFeatures()

  it('returns empty array for empty template', () => {
    expect(extract({})).toEqual([])
  })

  it('extracts enabled features from columns', () => {
    const result = extract({
      columns: {
        kms: { state: 'enabled' },
        customer: { state: 'enabled' }
      }
    })
    expect(result).toContain('Knowledge Base')
    expect(result).toContain('Customer Info')
  })

  it('ignores disabled features', () => {
    const result = extract({
      columns: {
        kms: { state: 'disabled' },
        customer: { state: 'enabled' }
      }
    })
    expect(result).not.toContain('Knowledge Base')
    expect(result).toContain('Customer Info')
  })

  it('ignores unmapped feature keys', () => {
    const result = extract({
      columns: {
        unknownKey: { state: 'enabled' }
      }
    })
    expect(result).toEqual([])
  })

  it('extracts from multiple categories', () => {
    const result = extract({
      columns: { kms: { state: 'enabled' } },
      widgets: { embeddedApps: { state: 'enabled' } },
      features: { 'search.knowledgeBase': { state: 'enabled' } }
    })
    expect(result).toContain('Knowledge Base')
    expect(result).toContain('Banking Tools')
    expect(result).toContain('Knowledge Search')
  })

  it('returns sorted, unique results', () => {
    const result = extract({
      columns: { kms: { state: 'enabled' } },
      widgets: { kms: { state: 'enabled' } }
    })
    // 'kms' from both categories but same label
    expect(result.filter(f => f === 'Knowledge Base')).toHaveLength(1)
    // Result should be sorted
    const sorted = [...result].sort()
    expect(result).toEqual(sorted)
  })
})
===ENDFILE
===FILE: ./src/hooks/features/__tests__/use-notice-config.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('react', () => ({
  useMemo: (fn: () => unknown) => fn()
}))

vi.mock('lucide-react', () => ({
  Bell: 'Bell',
  Info: 'Info',
  CircleCheck: 'CircleCheck',
  TriangleAlert: 'TriangleAlert',
  CircleX: 'CircleX',
  OctagonAlert: 'OctagonAlert'
}))

const { useNoticeSeverities, useTargetRoles } = await import('../use-notice-config')

describe('useNoticeSeverities', () => {
  it('returns 5 severity options', () => {
    const severities = useNoticeSeverities()
    expect(severities).toHaveLength(5)
  })

  it('each severity has value, label, icon', () => {
    const severities = useNoticeSeverities()
    for (const s of severities) {
      expect(s).toHaveProperty('value')
      expect(s).toHaveProperty('label')
      expect(s).toHaveProperty('icon')
    }
  })

  it('includes expected severity values', () => {
    const severities = useNoticeSeverities()
    const values = severities.map(s => s.value)
    expect(values).toEqual(['INFO', 'SUCCESS', 'WARNING', 'ERROR', 'CRITICAL'])
  })
})

describe('useTargetRoles', () => {
  it('returns 3 role options', () => {
    const roles = useTargetRoles()
    expect(roles).toHaveLength(3)
  })

  it('includes expected role values', () => {
    const roles = useTargetRoles()
    const values = roles.map(r => r.value)
    expect(values).toEqual(['supervisor', 'chat_agent', 'voice_agent'])
  })
})
===ENDFILE
===FILE: ./src/hooks/features/__tests__/use-notifications.test.ts
import { describe, expect, it, vi } from 'vitest'

const mockNotify = vi.fn()
const mockDismiss = vi.fn()

vi.mock('../../common/use-toast', () => ({
  useToast: () => ({
    notify: mockNotify,
    dismiss: mockDismiss
  })
}))

vi.mock('react', () => ({
  useCallback: (fn: (...args: unknown[]) => unknown) => fn,
  useMemo: (fn: () => unknown) => fn()
}))

const { useNotifications } = await import('../use-notifications')

describe('useNotifications', () => {
  it('returns all notification methods', () => {
    const n = useNotifications()
    expect(n).toHaveProperty('push')
    expect(n).toHaveProperty('dismiss')
    expect(n).toHaveProperty('success')
    expect(n).toHaveProperty('error')
    expect(n).toHaveProperty('warning')
    expect(n).toHaveProperty('info')
    expect(n).toHaveProperty('critical')
  })

  it('success calls notify with success variant', () => {
    const n = useNotifications()
    n.success({ title: 'Done' })
    expect(mockNotify).toHaveBeenCalledWith({ title: 'Done', variant: 'success' })
  })

  it('error calls notify with error variant', () => {
    const n = useNotifications()
    n.error({ title: 'Failed', description: 'Something went wrong' })
    expect(mockNotify).toHaveBeenCalledWith({ title: 'Failed', description: 'Something went wrong', variant: 'error' })
  })

  it('warning calls notify with warning variant', () => {
    const n = useNotifications()
    n.warning({ title: 'Caution' })
    expect(mockNotify).toHaveBeenCalledWith({ title: 'Caution', variant: 'warning' })
  })

  it('info calls notify with info variant', () => {
    const n = useNotifications()
    n.info({ title: 'Note' })
    expect(mockNotify).toHaveBeenCalledWith({ title: 'Note', variant: 'info' })
  })

  it('critical calls notify with critical variant', () => {
    const n = useNotifications()
    n.critical({ title: 'Alert' })
    expect(mockNotify).toHaveBeenCalledWith({ title: 'Alert', variant: 'critical' })
  })

  it('dismiss is exposed', () => {
    const n = useNotifications()
    expect(n.dismiss).toBe(mockDismiss)
  })
})
===ENDFILE
===FILE: ./src/hooks/features/use-business-terminology.ts
import { useMemo } from 'react'

interface BusinessRole {
  displayName: string
  description: string
  category: string
}

interface BusinessStatus {
  label: string
  description: string
  variant: 'success' | 'warning' | 'error' | 'info'
}

const CATEGORY_APPROVAL_WORKFLOW = 'Approval Workflow'

export function useBusinessRoles(): Record<string, BusinessRole> {
  return useMemo(() => {
    return {
      voice_agent: {
        displayName: 'Voice Agent',
        description: '',
        category: 'Agent'
      },
      chat_agent: {
        displayName: 'Chat Agent',
        description: '',
        category: 'Agent'
      },
      agent: {
        displayName: 'Agent',
        description: '',
        category: 'Agent'
      },
      supervisor: {
        displayName: 'Supervisor',
        description: '',
        category: 'Management'
      },
      manager: {
        displayName: 'Manager',
        description: '',
        category: 'Management'
      },
      admin: {
        displayName: 'Administrator',
        description: '',
        category: 'Administration'
      },
      maker: {
        displayName: 'Maker',
        description: '',
        category: CATEGORY_APPROVAL_WORKFLOW
      },
      checker: {
        displayName: 'Checker',
        description: '',
        category: CATEGORY_APPROVAL_WORKFLOW
      },
      super_admin: {
        displayName: 'Super Admin',
        description: '',
        category: CATEGORY_APPROVAL_WORKFLOW
      }
    }
  }, [])
}

export function useBusinessStatus(): Record<string, BusinessStatus> {
  return useMemo(() => {
    return {
      active: {
        label: 'Enabled',
        description: '',
        variant: 'success' as const
      },
      disabled: {
        label: 'Disabled',
        description: '',
        variant: 'error' as const
      },
      needs_setup: {
        label: 'Configuration Required',
        description: '',
        variant: 'warning' as const
      },
      pending: {
        label: 'Pending Setup',
        description: '',
        variant: 'info' as const
      }
    }
  }, [])
}

// Internal field labels (used only by getBusinessField)
const businessFields: Record<string, string> = {
  groupName: 'Team Group',
  role: 'Role',
  location: 'Location',
  users: 'Members',
  userCount: 'Members',
  status: 'Status',
  lastModified: 'Last Updated',
  businessUnit: 'Department',
  actions: 'Manage',
  groupIdentifier: 'Group Identifier',
  logicalName: 'Group Name',
  roleName: 'Role',
  market: 'Market',
  region: 'Region',
  country: 'Country',
  isActive: 'Active Status',
  searchPlaceholder: 'Search team groups...',
  allRoles: 'All Roles',
  allStatus: 'All Status',
  allMarkets: 'All Markets',
  allRegions: 'All Regions',
  allCountries: 'All Countries',
  allBusinessUnits: 'All Departments'
}

export const getBusinessField = (technicalField: string): string => {
  return businessFields[technicalField] || technicalField
}
===ENDFILE
===FILE: ./src/hooks/features/use-dropdown-options.ts
import { useMemo } from 'react'
import { useReferenceData } from '../api/use-reference-data'
import type { RoleTemplateSummaryDto } from '../../services/api/role-template.service'

interface DropdownOption {
  value: string
  label: string
}

interface DropdownOptions {
  roles: DropdownOption[]
  markets: DropdownOption[]
  regions: DropdownOption[]
  businessUnits: DropdownOption[]
  countries: DropdownOption[]
}

interface UseDropdownOptionsParams {
  roleTemplates?: RoleTemplateSummaryDto[]
}

export function useDropdownOptions(params: UseDropdownOptionsParams = {}): DropdownOptions {
  const { roleTemplates } = useReferenceData()
  const resolvedRoleTemplates = params.roleTemplates ?? roleTemplates

  const roles = useMemo(() => {
    const apiRoles = resolvedRoleTemplates
      .filter(template => template.roleNameCode.toLowerCase() !== 'admin')
      .map(template => ({
        value: template.roleNameCode,
        label: template.roleDisplayName || template.roleNameCode
      }))

    if (apiRoles.length > 0) {
      return apiRoles
    }

    return [
      { value: 'chat_agent', label: 'Chat Agent' },
      { value: 'voice_agent', label: 'Voice Agent' },
      { value: 'supervisor', label: 'Supervisor' }
    ]
  }, [resolvedRoleTemplates])

  return useMemo(() => ({
    roles,
    markets: [],
    regions: [
      { value: 'EMEA', label: 'EMEA' },
      { value: 'AMER', label: 'Americas' },
      { value: 'APAC', label: 'Asia Pacific' }
    ],
    businessUnits: [
      { value: 'Retail Banking', label: 'Retail Banking' },
      { value: 'Commercial Banking', label: 'Commercial Banking' },
      { value: 'Investment Banking', label: 'Investment Banking' },
      { value: 'Private Banking', label: 'Private Banking' },
      { value: 'IT Services', label: 'IT Services' }
    ],
    countries: [
      { value: 'United Kingdom', label: 'United Kingdom' },
      { value: 'United States', label: 'United States' },
      { value: 'Canada', label: 'Canada' },
      { value: 'Australia', label: 'Australia' },
      { value: 'Germany', label: 'Germany' },
      { value: 'France', label: 'France' }
    ]
  }), [roles])
}
===ENDFILE
===FILE: ./src/hooks/features/use-feature-mapping.ts
import { useCallback } from 'react'

export function useExtractEnabledFeatures() {
  return useCallback((roleTemplate: Record<string, unknown>): string[] => {
    const keyFeatures: string[] = []

    // Only show high-level capabilities that business users care about
    const importantFeatures: Record<string, string> = {
      'kms': 'Knowledge Base',
      'customer': 'Customer Info',
      'embeddedApps': 'Banking Tools',
      'spaceCopilot': 'AI Assistant',
      'header.layoutManager': 'Layout Customization',
      'search.knowledgeBase': 'Knowledge Search',
      'search.embeddedApps': 'Application Search',
      'mediaBar.callControls': 'Call Controls',
      'supervisor.teamStatus': 'Team Monitor',
      'calls': 'Call Management',
      'calls.autoAccept': 'Auto Accept Calls'
    }

    // Check all categories for these important features only
    const categories = ['columns', 'widgets', 'features', 'settingsTabs', 'settingsOptions', 'microFrontends']

    categories.forEach(category => {
      if (roleTemplate[category]) {
        Object.entries(roleTemplate[category] as Record<string, unknown>).forEach(([key, value]: [string, unknown]) => {
          if ((value as { state?: string })?.state === 'enabled' && importantFeatures[key]) {
            const label = importantFeatures[key]
            if (!keyFeatures.includes(label)) {
              keyFeatures.push(label)
            }
          }
        })
      }
    })

    // Return sorted unique key features only
    return Array.from(new Set(keyFeatures)).sort((a, b) => a.localeCompare(b))
  }, [])
}
===ENDFILE
===FILE: ./src/hooks/features/use-notice-config.ts
import { useMemo } from 'react'
import { Bell, Info, CircleCheck, TriangleAlert, CircleX, OctagonAlert, type LucideIcon } from 'lucide-react'

interface SeverityOption {
  value: string
  label: string
  icon: LucideIcon
}

interface RoleOption {
  value: string
  label: string
}

export function useNoticeSeverities() {
  return useMemo<readonly SeverityOption[]>(() => [
    { value: 'INFO', label: 'Information', icon: Info },
    { value: 'SUCCESS', label: 'Success', icon: CircleCheck },
    { value: 'WARNING', label: 'Warning', icon: TriangleAlert },
    { value: 'ERROR', label: 'Error', icon: CircleX },
    { value: 'CRITICAL', label: 'Critical', icon: OctagonAlert }
  ] as const, [])
}

export function useTargetRoles() {
  return useMemo<readonly RoleOption[]>(() => [
    { value: 'supervisor', label: 'Supervisor' },
    { value: 'chat_agent', label: 'Chat Agent' },
    { value: 'voice_agent', label: 'Voice Agent' }
  ] as const, [])
}

export { Bell }
===ENDFILE
===FILE: ./src/hooks/features/use-notifications.ts
import { useCallback, useMemo } from 'react'
import { useToast } from '../common/use-toast'
import type { ToastVariant } from '../../components/ui/toast'

interface NotificationParams {
  title: string
  description?: string
  action?: React.ReactNode
  duration?: number
  persistent?: boolean
  metaKey?: string
}

export function useNotifications() {
  const { notify, dismiss } = useToast()

  const push = useCallback((variant: ToastVariant, params: NotificationParams) => {
    notify({ ...params, variant })
  }, [notify])

  return useMemo(() => ({
    push,
    dismiss,
    success: (params: NotificationParams) => push('success', params),
    error: (params: NotificationParams) => push('error', params),
    warning: (params: NotificationParams) => push('warning', params),
    info: (params: NotificationParams) => push('info', params),
    critical: (params: NotificationParams) => push('critical', params)
  }), [dismiss, push])
}
===ENDFILE
===FILE: ./src/index.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  .admin-mfe-root {
    --background: 0 0% 100%;
    --foreground: 0 0% 13%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 13%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 13%;
    --primary: 356 100% 43%;
    --primary-foreground: 0 0% 100%;
    --secondary: 0 0% 96%;
    --secondary-foreground: 0 0% 13%;
    --muted: 0 0% 96%;
    --muted-foreground: 0 0% 45%;
    --accent: 356 100% 43%;
    --accent-foreground: 0 0% 100%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89%;
    --input: 0 0% 89%;
    --ring: 356 100% 43%;
    --radius: 0.375rem;

    /* Sidebar */
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 0 0% 13%;
    --sidebar-accent: 0 0% 94%;
    --sidebar-accent-foreground: 0 0% 13%;

    /* Status Colors */
    --status-pending: 45 93% 47%;
    --status-approved: 142 71% 45%;
    --status-rejected: 0 84% 60%;

    background-color: hsl(var(--background));
    color: hsl(var(--foreground));
    font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    -webkit-font-smoothing: antialiased;
    height: 100%;
    width: 100%;
    min-height: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .admin-mfe-root.dark,
  .dark .admin-mfe-root {
    --background: 0 0% 9%;
    --foreground: 0 0% 95%;
    --card: 0 0% 12%;
    --card-foreground: 0 0% 95%;
    --popover: 0 0% 9%;
    --popover-foreground: 0 0% 95%;
    --primary: 356 100% 43%;
    --primary-foreground: 0 0% 100%;
    --secondary: 0 0% 17%;
    --secondary-foreground: 0 0% 95%;
    --muted: 0 0% 17%;
    --muted-foreground: 0 0% 65%;
    --accent: 356 100% 43%;
    --accent-foreground: 0 0% 100%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 17%;
    --input: 0 0% 17%;
    --ring: 356 100% 43%;

    /* Sidebar Dark */
    --sidebar-background: 0 0% 7%;
    --sidebar-foreground: 0 0% 95%;
    --sidebar-accent: 0 0% 15%;
    --sidebar-accent-foreground: 0 0% 95%;
  }
}

@layer utilities {
  .admin-mfe-root .scrollbar-visible {
    scrollbar-width: thin;
    scrollbar-color: hsl(var(--border)) transparent;
  }

  .admin-mfe-root .scrollbar-visible::-webkit-scrollbar {
    width: 10px;
    height: 10px;
  }

  .admin-mfe-root .scrollbar-visible::-webkit-scrollbar-thumb {
    background-color: hsl(var(--border));
    border: 2px solid transparent;
    border-radius: 9999px;
    background-clip: padding-box;
  }

  .admin-mfe-root .scrollbar-visible::-webkit-scrollbar-track {
    background-color: transparent;
    border-radius: 9999px;
  }
}
===ENDFILE
===FILE: ./src/index.ts
export { AdminMFE, default } from './AdminMFE'
export type {
  AdminMFEProps,
  AdminPermissions,
  AdminView,
  ErrorInfo,
  RoleTemplate,
  AdGroup,
  PendingApproval,
  SystemNotice
} from './types'
===ENDFILE
===FILE: ./src/lib/query-client.ts
import { QueryClient } from '@tanstack/react-query'

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,
      gcTime: 15 * 60 * 1000,
      refetchOnWindowFocus: true,
      refetchOnReconnect: true,
      retry: 2
    }
  }
})

queryClient.setQueryDefaults(['entitlements'], {
  staleTime: 2 * 60 * 1000,
  gcTime: 15 * 60 * 1000,
  retry: 1,
  refetchOnWindowFocus: false
})
===ENDFILE
===FILE: ./src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
===ENDFILE
===FILE: ./src/main.tsx
/**
 * Admin MFE - Main entry point
 * For standalone development and testing
 */

import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'

import { AdminMFE } from './AdminMFE'
import type { AdminPermissions } from './types'
import { createLogger } from './utils/core/debug'

const logger = createLogger('AdminMFE:Dev')

;(globalThis as { __ADMIN_MFE_BASE_PATH__?: string }).__ADMIN_MFE_BASE_PATH__ = ''

// Mock permissions for development
const mockPermissions: AdminPermissions = {
  canPreviewDashboards: true,
  canViewRoleTemplates: true,
  canViewAdGroups: true,
  canViewPendingApprovals: true,
  canApproveChanges: true,
  canEditBusinessInfo: true,
  canEditPermissions: true,
  canEditApplications: true,
  canEnableDisableGroups: true,
  canDirectSave: true,
  canViewNotices: true,
  canCreateNotice: true,
  canEditNotice: true,
  canPublishNotice: true,
  canArchiveNotice: true,
  canSaveDraft: true
}

// Mock props for development
const mockProps = {
  authToken: 'ADMIN_GLOBAL_DEMO',
  language: 'en' as const,
  permissions: mockPermissions,
  onNavigate: (path: string) => {
    logger.info('Navigate to:', path)
  },
  onError: (error: { code: string; message: string; context?: Record<string, unknown> }) => {
    logger.error('Error:', error)
  }
}

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <div className="h-screen flex flex-col">
      <header className="h-12 bg-primary text-primary-foreground flex items-center px-4">
        <h1 className="text-lg font-semibold">Admin MFE - Development Mode</h1>
      </header>
      <div className="flex-1 overflow-hidden">
        <AdminMFE {...mockProps} />
      </div>
    </div>
  </React.StrictMode>
)
===ENDFILE
===FILE: ./src/services/__tests__/mock-data.test.ts
import { describe, expect, it } from 'vitest'
import {
  mockRoleTemplates,
  mockAdGroups,
  mockPendingApprovals,
  mockSystemNotices,
  delay,
  mockApi
} from '../mock-data'

describe('mock-data', () => {
  describe('static data exports', () => {
    it('exports role templates with expected shape', () => {
      expect(mockRoleTemplates).toHaveLength(4)
      expect(mockRoleTemplates[0]).toMatchObject({
        id: 'voice_agent',
        name: 'Voice Agent'
      })
      expect(mockRoleTemplates[0].permissions).toBeInstanceOf(Array)
      expect(mockRoleTemplates[0].widgets).toBeInstanceOf(Array)
    })

    it('exports AD groups with expected shape', () => {
      expect(mockAdGroups.length).toBeGreaterThan(0)
      expect(mockAdGroups[0]).toHaveProperty('id')
      expect(mockAdGroups[0]).toHaveProperty('distinguishedName')
      expect(mockAdGroups[0]).toHaveProperty('memberCount')
      expect(mockAdGroups[0]).toHaveProperty('isActive')
    })

    it('exports pending approvals with expected shape', () => {
      expect(mockPendingApprovals.length).toBeGreaterThan(0)
      expect(mockPendingApprovals[0]).toHaveProperty('id')
      expect(mockPendingApprovals[0]).toHaveProperty('type')
      expect(mockPendingApprovals[0]).toHaveProperty('status')
    })

    it('exports system notices with expected shape', () => {
      expect(mockSystemNotices.length).toBeGreaterThan(0)
      expect(mockSystemNotices[0]).toHaveProperty('id')
      expect(mockSystemNotices[0]).toHaveProperty('title')
      expect(mockSystemNotices[0]).toHaveProperty('type')
    })

    it('contains both active and inactive AD groups', () => {
      const active = mockAdGroups.filter(g => g.isActive)
      const inactive = mockAdGroups.filter(g => !g.isActive)
      expect(active.length).toBeGreaterThan(0)
      expect(inactive.length).toBeGreaterThan(0)
    })

    it('contains both active and inactive notices', () => {
      const active = mockSystemNotices.filter(n => n.isActive)
      const inactive = mockSystemNotices.filter(n => !n.isActive)
      expect(active.length).toBeGreaterThan(0)
      expect(inactive.length).toBeGreaterThan(0)
    })
  })

  describe('delay', () => {
    it('resolves after specified ms', async () => {
      const start = Date.now()
      await delay(10)
      const elapsed = Date.now() - start
      expect(elapsed).toBeGreaterThanOrEqual(5)
    })
  })

  describe('mockApi', () => {
    it('getRoleTemplates returns mock data', async () => {
      const result = await mockApi.getRoleTemplates()
      expect(result).toEqual(mockRoleTemplates)
    })

    it('getAdGroups returns mock data', async () => {
      const result = await mockApi.getAdGroups()
      expect(result).toEqual(mockAdGroups)
    })

    it('getPendingApprovals returns mock data', async () => {
      const result = await mockApi.getPendingApprovals()
      expect(result).toEqual(mockPendingApprovals)
    })

    it('getSystemNotices returns mock data', async () => {
      const result = await mockApi.getSystemNotices()
      expect(result).toEqual(mockSystemNotices)
    })

    it('approveChange returns success', async () => {
      const result = await mockApi.approveChange('pa-001')
      expect(result).toEqual({ success: true })
    })

    it('rejectChange returns success', async () => {
      const result = await mockApi.rejectChange('pa-001', 'invalid')
      expect(result).toEqual({ success: true })
    })

    it('createNotice returns notice with generated id', async () => {
      const result = await mockApi.createNotice({ title: 'Test', message: 'Msg' })
      expect(result.id).toContain('notice-')
      expect(result.createdBy).toBe('Current User')
    })

    it('updateNotice merges updates', async () => {
      const result = await mockApi.updateNotice('notice-001', { title: 'Updated' })
      expect(result.title).toBe('Updated')
      expect(result.id).toBe('notice-001')
    })

    it('toggleAdGroup returns success', async () => {
      const result = await mockApi.toggleAdGroup('adg-001', false)
      expect(result).toEqual({ success: true })
    })
  })
})
===ENDFILE
===FILE: ./src/services/api/__tests__/admin-approval.service.test.ts
import { beforeEach, describe, expect, it, vi } from 'vitest'

vi.mock('../../core/api-client', () => ({
  apiFetch: vi.fn()
}))

vi.mock('../../../utils/auth/auth-token-manager', () => ({
  getAuthToken: vi.fn(() => 'test-token')
}))

const { apiFetch } = await import('../../core/api-client')
const { getAuthToken } = await import('../../../utils/auth/auth-token-manager')
const { adminApprovalService } = await import('../admin-approval.service')

describe('AdminApprovalService', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    vi.mocked(getAuthToken).mockReturnValue('test-token')
  })

  describe('getMyActivity', () => {
    it('uses OpenAPI query params and maps activityValues response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            activityValues: [
              {
                actionCode: 'L1_APPROVE',
                changeType: 'APP_UPDATE',
                targetGroupIdentifier: 'CN=APAC-TEAM,OU=ADMIN,DC=hsbc,DC=com',
                targetGroupName: 'APAC Team',
                isCriticalIndicator: true,
                createdAtDatetime: '2026-02-09T10:00:00Z',
                performedByRoleCode: 'CHECKER',
                completionReasonText: 'Approved after review',
                changeIdentifier: 'chg-001'
              }
            ]
          },
          meta: { pagination: { offset: 25, limit: 25, total: 60, hasMore: true } }
        })
      } as Response)

      const result = await adminApprovalService.getMyActivity(2, 25, 'week')

      const requestUrl = vi.mocked(apiFetch).mock.calls[0][0] as string
      const parsedUrl = new URL(requestUrl, 'http://localhost')
      expect(parsedUrl.searchParams.get('offset')).toBe('25')
      expect(parsedUrl.searchParams.get('limit')).toBe('25')
      expect(parsedUrl.searchParams.get('timeRange')).toBe('WEEK')

      expect(result.totalCount).toBe(60)
      expect(result.items).toHaveLength(1)
      expect(result.items[0]).toMatchObject({
        id: 'chg-001',
        action: 'L1_APPROVE',
        changeType: 'APP_UPDATE',
        targetGroupName: 'APAC Team',
        criticalIndicator: true
      })
    })

    it('falls back safely when optional activity fields are missing', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: { activityValues: [{ actionCode: 'UNKNOWN_ACTION', changeType: 'UNKNOWN_CHANGE', targetGroupIdentifier: 'CN=FALLBACK-GROUP,DC=hsbc,DC=com' }] },
          meta: { pagination: { offset: 0, limit: 25, total: 1, hasMore: false } }
        })
      } as Response)

      const result = await adminApprovalService.getMyActivity(1, 25)

      expect(result.items[0].action).toBe('SUBMIT')
      expect(result.items[0].changeType).toBe('CONFIG_UPDATE')
      expect(result.items[0].targetGroupName).toBe('CN=FALLBACK-GROUP,DC=hsbc,DC=com')
    })

    it('throws on non-ok response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 500, statusText: 'Internal Server Error'
      } as Response)

      await expect(adminApprovalService.getMyActivity()).rejects.toThrow('HTTP 500')
    })
  })

  describe('submitChange', () => {
    it('submits change for approval successfully', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            pendingChange: {
              changeIdentifier: 'chg-001',
              statusCode: 'PENDING_LEVEL_ONE',
              isCriticalIndicator: false
            }
          }
        })
      } as Response)

      const result = await adminApprovalService.submitChange('CN=GROUP', {
        changeType: 'CONFIG_UPDATE',
        currentState: {},
        changeDescription: 'Test change',
        proposedState: { logicalName: 'New Name' }
      })

      expect(result.successIndicator).toBe(true)
      expect(result.pendingChangeId).toBe('chg-001')
      expect(result.status).toBe('PENDING_LEVEL_ONE')
    })

    it('throws on 409 conflict with BERR_20024', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 409, statusText: 'Conflict',
        json: async () => ({ errorInfo: [{ code: 'BERR_20024', causes: ['existing change'] }] })
      } as unknown as Response)

      await expect(
        adminApprovalService.submitChange('CN=GROUP', {
          changeType: 'CONFIG_UPDATE',
          currentState: {},
          proposedState: {}
        })
      ).rejects.toThrow('A pending change already exists')
    })

    it('throws on 409 conflict with BERR_20025', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 409, statusText: 'Conflict',
        json: async () => ({ errorInfo: [{ code: 'BERR_20025', causes: ['version conflict'] }] })
      } as unknown as Response)

      await expect(
        adminApprovalService.submitChange('CN=GROUP', {
          changeType: 'CONFIG_UPDATE',
          currentState: {},
          proposedState: {}
        })
      ).rejects.toThrow('modified by another user')
    })

    it('throws generic error for other failures', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 400, statusText: 'Bad Request',
        json: async () => ({ errorInfo: [{ code: 'ERR', causes: ['invalid input'] }] })
      } as unknown as Response)

      await expect(
        adminApprovalService.submitChange('CN=GROUP', {
          changeType: 'CONFIG_UPDATE',
          currentState: {},
          proposedState: {}
        })
      ).rejects.toThrow('invalid input')
    })
  })

  describe('directSave', () => {
    it('saves directly and returns success', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({ data: { successIndicator: true, messageText: 'Saved' } })
      } as Response)

      const result = await adminApprovalService.directSave('CN=GROUP', {
        currentState: {},
        proposedState: { logicalName: 'Updated' }
      })

      expect(result.successIndicator).toBe(true)
      expect(result.message).toBe('Saved')
    })

    it('throws on non-ok response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 403, statusText: 'Forbidden'
      } as Response)

      await expect(
        adminApprovalService.directSave('CN=GROUP', { currentState: {}, proposedState: {} })
      ).rejects.toThrow('HTTP 403')
    })
  })

  describe('listPendingChanges', () => {
    it('fetches pending changes with filters', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            pendingChanges: [
              {
                changeIdentifier: 'pc-1',
                targetGroupIdentifier: 'CN=GROUP,DC=hsbc',
                targetGroupName: 'Test Group',
                changeType: 'CONFIG_UPDATE',
                currentConfig: null,
                proposedConfig: { businessInfoChanges: { roleName: 'supervisor' } },
                isCriticalIndicator: true,
                statusCode: 'PENDING_LEVEL_ONE',
                createdByText: 'user1',
                createdAtDatetime: '2026-01-01T00:00:00Z'
              }
            ]
          },
          meta: { pagination: { offset: 0, limit: 25, total: 1, hasMore: false } }
        })
      } as Response)

      const result = await adminApprovalService.listPendingChanges({
        status: ['PENDING_LEVEL_ONE'],
        offset: 0,
        limit: 25
      })

      expect(result.items).toHaveLength(1)
      expect(result.items[0].id).toBe('pc-1')
      expect(result.items[0].criticalIndicator).toBe(true)
      expect(result.items[0].status).toBe('PENDING_LEVEL_ONE')
      expect(result.counts.pendingLevelOne).toBe(1)
    })

    it('handles empty response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: { pendingChanges: [] },
          meta: { pagination: { offset: 0, limit: 25, total: 0, hasMore: false } }
        })
      } as Response)

      const result = await adminApprovalService.listPendingChanges()
      expect(result.items).toHaveLength(0)
      expect(result.totalCount).toBe(0)
    })

    it('throws on non-ok response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 500, statusText: 'Server Error'
      } as Response)

      await expect(adminApprovalService.listPendingChanges()).rejects.toThrow('HTTP 500')
    })

    it('unwraps nested config for diff', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            pendingChanges: [{
              changeIdentifier: 'pc-2',
              targetGroupIdentifier: 'CN=X,DC=hsbc',
              changeType: 'CONFIG_UPDATE',
              currentConfig: { businessInfoChanges: { roleName: 'agent' } },
              proposedConfig: { businessInfoChanges: { roleName: 'supervisor' } },
              isCriticalIndicator: false,
              statusCode: 'PENDING_LEVEL_ONE',
              createdAtDatetime: '2026-01-01T00:00:00Z'
            }]
          },
          meta: { pagination: { offset: 0, limit: 25, total: 1, hasMore: false } }
        })
      } as Response)

      const result = await adminApprovalService.listPendingChanges()
      expect(result.items[0].currentState.roleName).toBe('agent')
      expect(result.items[0].proposedState.roleName).toBe('supervisor')
    })

    it('computes app changes from current/proposed configs', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            pendingChanges: [{
              changeIdentifier: 'pc-3',
              targetGroupIdentifier: 'CN=X,DC=hsbc',
              changeType: 'APP_UPDATE',
              currentConfig: { applicationChanges: [{ appCode: 'APP_A' }] },
              proposedConfig: { applicationChanges: [{ appCode: 'APP_A' }, { appCode: 'APP_B' }] },
              isCriticalIndicator: false,
              statusCode: 'PENDING_LEVEL_ONE',
              createdAtDatetime: '2026-01-01T00:00:00Z'
            }]
          },
          meta: { pagination: { offset: 0, limit: 25, total: 1, hasMore: false } }
        })
      } as Response)

      const result = await adminApprovalService.listPendingChanges()
      expect(result.items[0].appsChanges?.added).toContain('APP_B')
      expect(result.items[0].appsChanges?.unchanged).toContain('APP_A')
    })
  })

  describe('getPendingChange', () => {
    it('fetches a single pending change', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            pendingChange: {
              changeIdentifier: 'pc-1',
              targetGroupIdentifier: 'CN=GROUP,DC=hsbc',
              targetGroupName: 'Group',
              statusCode: 'PENDING_LEVEL_ONE',
              createdAtDatetime: '2026-01-01T00:00:00Z'
            }
          }
        })
      } as Response)

      const result = await adminApprovalService.getPendingChange('pc-1')
      expect(result.id).toBe('pc-1')
      expect(result.canApproveIndicator).toBe(true)
    })

    it('throws when pending change not found', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({ data: {} })
      } as Response)

      await expect(adminApprovalService.getPendingChange('missing')).rejects.toThrow('Pending change not found')
    })

    it('throws on non-ok response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 404, statusText: 'Not Found'
      } as Response)

      await expect(adminApprovalService.getPendingChange('pc-1')).rejects.toThrow('HTTP 404')
    })
  })

  describe('approveChange', () => {
    it('approves a change successfully', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            approval: {
              changeIdentifier: 'pc-1',
              statusCode: 'APPROVED',
              messageText: 'Approved',
              approvedAtDatetime: '2026-01-01T10:00:00Z'
            }
          }
        })
      } as Response)

      const result = await adminApprovalService.approveChange('pc-1', { comment: 'Looks good' })

      expect(result.successIndicator).toBe(true)
      expect(result.changeId).toBe('pc-1')
      expect(result.newStatus).toBe('APPROVED')
    })

    it('throws self-approval error on 403 with self message', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 403, statusText: 'Forbidden',
        json: async () => ({ errorInfo: [{ code: 'ERR', causes: ['Cannot self-approve'] }] })
      } as unknown as Response)

      await expect(adminApprovalService.approveChange('pc-1')).rejects.toThrow('self-approval')
    })

    it('throws generic error for non-403 failures', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 400, statusText: 'Bad Request',
        json: async () => ({ errorInfo: [{ code: 'ERR', causes: ['Bad request'] }] })
      } as unknown as Response)

      await expect(adminApprovalService.approveChange('pc-1')).rejects.toThrow('Bad request')
    })
  })

  describe('rejectChange', () => {
    it('rejects a change successfully', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            rejection: {
              changeIdentifier: 'pc-1',
              statusCode: 'REJECTED',
              messageText: 'Rejected',
              rejectedAtDatetime: '2026-01-01T10:00:00Z'
            }
          }
        })
      } as Response)

      const result = await adminApprovalService.rejectChange('pc-1', { rejectionReason: 'Not valid' })

      expect(result.successIndicator).toBe(true)
      expect(result.newStatus).toBe('REJECTED')
    })

    it('throws on non-ok response', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 400, statusText: 'Bad Request',
        json: async () => ({ errorInfo: [{ code: 'ERR', causes: ['Invalid'] }] })
      } as unknown as Response)

      await expect(
        adminApprovalService.rejectChange('pc-1', { rejectionReason: 'Bad' })
      ).rejects.toThrow('Invalid')
    })
  })

  describe('cancelChange', () => {
    it('cancels a change successfully', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: { statusCode: 'CANCELLED', messageText: 'Cancelled' }
        })
      } as Response)

      const result = await adminApprovalService.cancelChange('pc-1')

      expect(result.successIndicator).toBe(true)
      expect(result.newStatus).toBe('CANCELLED')
      expect(result.changeId).toBe('pc-1')
    })

    it('throws 403 with ownership message', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 403, statusText: 'Forbidden',
        json: async () => ({ errorInfo: [] })
      } as unknown as Response)

      await expect(adminApprovalService.cancelChange('pc-1')).rejects.toThrow('only cancel your own')
    })

    it('throws on other non-ok responses', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: false, status: 500, statusText: 'Server Error',
        json: async () => ({ errorInfo: [{ code: 'ERR', causes: ['Server failure'] }] })
      } as unknown as Response)

      await expect(adminApprovalService.cancelChange('pc-1')).rejects.toThrow('Server failure')
    })
  })

  describe('getPendingChangesCount', () => {
    it('returns counts from listPendingChanges', async () => {
      vi.mocked(apiFetch).mockResolvedValue({
        ok: true,
        json: async () => ({
          data: {
            pendingChanges: [
              { changeIdentifier: 'pc-1', targetGroupIdentifier: 'CN=X', statusCode: 'PENDING_LEVEL_ONE', isCriticalIndicator: false, createdAtDatetime: '2026-01-01' },
              { changeIdentifier: 'pc-2', targetGroupIdentifier: 'CN=Y', statusCode: 'PENDING_LEVEL_TWO', isCriticalIndicator: false, createdAtDatetime: '2026-01-01' }
            ]
          },
          meta: { pagination: { offset: 0, limit: 1, total: 2, hasMore: true } }
        })
      } as Response)

      const result = await adminApprovalService.getPendingChangesCount()
      expect(result.total).toBe(2)
      expect(result.levelOne).toBe(1)
      expect(result.levelTwo).toBe(1)
    })

    it('returns zeros on error', async () => {
      vi.mocked(apiFetch).mockRejectedValue(new Error('Network error'))

      const result = await adminApprovalService.getPendingChangesCount()
      expect(result).toEqual({ total: 0, levelOne: 0, levelTwo: 0 })
    })
  })

  describe('ensureToken', () => {
    it('throws when no token available', async () => {
      vi.mocked(getAuthToken).mockReturnValue(null)

      await expect(
        adminApprovalService.submitChange('CN=X', {
          changeType: 'CONFIG_UPDATE',
          currentState: {},
          proposedState: {}
        })
      ).rejects.toThrow('No authentication token found')
    })
  })
})
===ENDFILE
===FILE: ./src/services/api/__tests__/admin.service.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

const mockApiFetch = vi.fn()
vi.mock('../../core/api-client', () => ({
  apiFetch: (...args: unknown[]) => mockApiFetch(...args)
}))

vi.mock('../../../utils/auth/auth-token-manager', () => ({
  getAuthToken: () => 'test-token'
}))

vi.mock('../../../utils/api/response-handler', () => ({
  handleApiResponse: async ({ response }: { response: Response }) => {
    if (!response.ok) throw new Error(`HTTP error: ${response.status}`)
    return response.json()
  }
}))

const { adminService } = await import('../admin.service')

describe('AdminService', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('getAllAdGroups', () => {
    it('returns mapped AD groups', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            items: [{
              groupIdentifier: 'CN=test-group',
              logicalName: 'Test Group',
              roleName: 'voice_agent',
              activeIndicator: true,
              marketCode: 'HK',
              regionCode: 'APAC'
            }]
          }
        })
      })

      const result = await adminService.getAllAdGroups()
      expect(result).toHaveLength(1)
      expect(result[0].groupIdentifier).toBe('CN=test-group')
      expect(result[0].logicalName).toBe('Test Group')
      expect(result[0].isActive).toBe(true)
    })

    it('throws on unexpected format', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: {} })
      })

      await expect(adminService.getAllAdGroups()).rejects.toThrow('Unexpected response format')
    })
  })

  describe('lookupAdGroup', () => {
    it('looks up and maps AD group', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            groupIdentifier: 'CN=test-group',
            logicalName: 'Test',
            activeIndicator: true
          }
        })
      })

      const result = await adminService.lookupAdGroup('CN=test-group')
      expect(result.groupIdentifier).toBe('CN=test-group')
      expect(mockApiFetch).toHaveBeenCalledWith(
        '/papi/v1/ad-groups/lookup',
        expect.objectContaining({ method: 'POST' })
      )
    })

    it('throws when group not found', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({})
      })

      await expect(adminService.lookupAdGroup('CN=missing')).rejects.toThrow('AD group not found')
    })
  })

  describe('searchAdGroups', () => {
    it('searches with search param and limit', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            items: [{ groupIdentifier: 'CN=g1', activeIndicator: true }]
          }
        })
      })

      const result = await adminService.searchAdGroups('test', 50)
      expect(result).toHaveLength(1)
      const calledUrl = mockApiFetch.mock.calls[0][0] as string
      expect(calledUrl).toContain('search=test')
      expect(calledUrl).toContain('limit=50')
    })

    it('clamps limit to valid range', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: { items: [] } })
      })

      await adminService.searchAdGroups('', 5000)
      const calledUrl = mockApiFetch.mock.calls[0][0] as string
      expect(calledUrl).toContain('limit=1000')
    })
  })

  describe('updateAdGroup', () => {
    it('normalizes isActive to activeIndicator', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: {} })
      })

      await adminService.updateAdGroup('CN=g1', { isActive: false })
      const body = JSON.parse(mockApiFetch.mock.calls[0][1].body)
      expect(body.data.proposedState.activeIndicator).toBe(false)
      expect(body.data.proposedState.isActive).toBeUndefined()
    })
  })

  describe('copyAdGroupConfiguration', () => {
    it('copies configuration successfully', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            copyResult: {
              successFlag: true,
              messageText: 'Copied',
              workflowStatusCode: 'DIRECT_APPLIED'
            }
          }
        })
      })

      const result = await adminService.copyAdGroupConfiguration('CN=source', 'CN=target')
      expect(result.success).toBe(true)
      expect(result.message).toBe('Copied')
      expect(result.workflowStatusCode).toBe('DIRECT_APPLIED')
    })

    it('returns failure on non-ok response', async () => {
      mockApiFetch.mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        json: () => Promise.resolve({
          data: {
            copyResult: {
              successFlag: false,
              errorText: 'Server error'
            }
          }
        })
      })

      const result = await adminService.copyAdGroupConfiguration('CN=source', 'CN=target')
      expect(result.success).toBe(false)
    })

    it('returns failure on network error', async () => {
      mockApiFetch.mockRejectedValue(new Error('Network failure'))

      const result = await adminService.copyAdGroupConfiguration('CN=source', 'CN=target')
      expect(result.success).toBe(false)
      expect(result.error).toBe('NETWORK_ERROR')
      expect(result.message).toBe('Network failure')
    })
  })

  describe('notice operations', () => {
    it('createNotice maps request and response fields', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            notice: {
              identifier: 'n1',
              titleText: 'Test Notice',
              messageText: 'Hello',
              severityValue: 'WARNING',
              statusCode: 'DRAFT',
              broadcastToAllFlag: true,
              requiresAckFlag: false,
              targetRoleValues: ['voice_agent'],
              createdByText: 'admin',
              createdAtDate: '2025-01-01'
            }
          }
        })
      })

      const result = await adminService.createNotice({
        title: 'Test Notice',
        message: 'Hello',
        severity: 'WARNING',
        broadcastToAll: true,
        requiresAcknowledgement: false,
        targetRoles: ['voice_agent']
      })

      expect(result.id).toBe('n1')
      expect(result.title).toBe('Test Notice')
      expect(result.severity).toBe('WARNING')
      expect(result.broadcastToAll).toBe(true)
      expect(result.targetRoles).toEqual(['voice_agent'])
    })

    it('listNotices returns mapped notices', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            notices: [
              { identifier: 'n1', titleText: 'Notice 1', messageText: 'Msg', severityValue: 'INFO', statusCode: 'ACTIVE', broadcastToAllFlag: false, requiresAckFlag: false, createdByText: '', createdAtDate: '' }
            ]
          }
        })
      })

      const result = await adminService.listNotices('ACTIVE')
      expect(result).toHaveLength(1)
      expect(result[0].id).toBe('n1')

      const calledUrl = mockApiFetch.mock.calls[0][0] as string
      expect(calledUrl).toContain('statusCode=ACTIVE')
    })

    it('listNotices without status filter', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: { notices: [] } })
      })

      await adminService.listNotices()
      const calledUrl = mockApiFetch.mock.calls[0][0] as string
      expect(calledUrl).not.toContain('statusCode')
    })

    it('updateNotice maps fields correctly', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            notice: {
              identifier: 'n1',
              titleText: 'Updated',
              messageText: 'Updated msg',
              severityValue: 'INFO',
              statusCode: 'DRAFT',
              broadcastToAllFlag: false,
              requiresAckFlag: false,
              createdByText: '',
              createdAtDate: ''
            }
          }
        })
      })

      const result = await adminService.updateNotice('n1', {
        title: 'Updated',
        message: 'Updated msg',
        severity: 'INFO',
        broadcastToAll: false,
        requiresAcknowledgement: false
      })

      expect(result.title).toBe('Updated')
      expect(mockApiFetch).toHaveBeenCalledWith(
        '/papi/v1/notices/n1',
        expect.objectContaining({ method: 'PUT' })
      )
    })

    it('updateNoticeStatus sends PATCH request', async () => {
      mockApiFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          data: {
            notice: {
              identifier: 'n1',
              titleText: 'Notice',
              messageText: 'Msg',
              severityValue: 'INFO',
              statusCode: 'ACTIVE',
              broadcastToAllFlag: false,
              requiresAckFlag: false,
              createdByText: '',
              createdAtDate: ''
            }
          }
        })
      })

      const result = await adminService.updateNoticeStatus('n1', 'ACTIVE')
      expect(result.status).toBe('ACTIVE')
      expect(mockApiFetch).toHaveBeenCalledWith(
        '/papi/v1/notices/n1/status',
        expect.objectContaining({ method: 'PATCH' })
      )
    })
  })
})
===ENDFILE
===FILE: ./src/services/api/__tests__/reference-data.service.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

const mockApiFetchJson = vi.fn()

vi.mock('../../core/api-client', () => ({
  apiFetchJson: (...args: unknown[]) => mockApiFetchJson(...args)
}))

const {
  getAllRegions,
  getAllBusinessUnits,
  getAllCountries,
  getCountriesByRegion,
  getAllMarkets,
  getMarketsByRegion,
  getCountriesByMarket
} = await import('../reference-data.service')

describe('reference-data.service', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('getAllRegions', () => {
    it('maps canonical fields correctly', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          regions: [
            { regionCode: 'APAC', regionName: 'Asia Pacific', displayOrder: 1, isActive: true }
          ]
        }
      })

      const result = await getAllRegions()
      expect(result).toEqual([
        { regionCode: 'APAC', regionName: 'Asia Pacific', displayOrder: 1, isActive: true }
      ])
    })

    it('maps alternate contract fields (displayOrderNumber/isActiveFlag)', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          regions: [
            { regionCode: 'EMEA', regionName: 'Europe', displayOrderNumber: 2, isActiveFlag: false }
          ]
        }
      })

      const result = await getAllRegions()
      expect(result).toEqual([
        { regionCode: 'EMEA', regionName: 'Europe', displayOrder: 2, isActive: false }
      ])
    })

    it('defaults displayOrder to 0 and isActive to true when missing', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          regions: [{ regionCode: 'NA', regionName: 'North America' }]
        }
      })

      const result = await getAllRegions()
      expect(result[0].displayOrder).toBe(0)
      expect(result[0].isActive).toBe(true)
    })

    it('returns empty array when no regions data', async () => {
      mockApiFetchJson.mockResolvedValue({ data: {} })
      const result = await getAllRegions()
      expect(result).toEqual([])
    })
  })

  describe('getAllBusinessUnits', () => {
    it('maps business unit fields correctly', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          businessUnits: [
            { unitCode: 'WPB', unitName: 'Wealth & PB', description: 'Wealth', effectiveDate: '2025-01-01', displayOrder: 1, isActive: true }
          ]
        }
      })

      const result = await getAllBusinessUnits()
      expect(result).toEqual([
        { unitCode: 'WPB', unitName: 'Wealth & PB', description: 'Wealth', effectiveDate: '2025-01-01', displayOrder: 1, isActive: true }
      ])
    })

    it('maps alternate contract fields', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          businessUnits: [
            { unitCode: 'CMB', unitName: 'Commercial', description: 'Desc', effectiveDate: '2025-01-01', displayOrderNumber: 3, isActiveFlag: true }
          ]
        }
      })

      const result = await getAllBusinessUnits()
      expect(result[0].displayOrder).toBe(3)
      expect(result[0].isActive).toBe(true)
    })
  })

  describe('getAllCountries', () => {
    it('maps country fields correctly', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          countries: [
            { countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true }
          ]
        }
      })

      const result = await getAllCountries()
      expect(result).toEqual([
        { countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true }
      ])
    })
  })

  describe('getCountriesByRegion', () => {
    it('fetches countries by region code', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          countries: [
            { countryCode: 'SG', countryName: 'Singapore', regionCode: 'APAC', marketCode: 'SG', displayOrder: 2, isActive: true }
          ]
        }
      })

      const result = await getCountriesByRegion('APAC')
      expect(mockApiFetchJson).toHaveBeenCalledWith('/papi/v1/regions-countries/APAC')
      expect(result[0].countryCode).toBe('SG')
    })

    it('encodes region code in URL', async () => {
      mockApiFetchJson.mockResolvedValue({ data: { countries: [] } })
      await getCountriesByRegion('A&B')
      expect(mockApiFetchJson).toHaveBeenCalledWith('/papi/v1/regions-countries/A%26B')
    })
  })

  describe('getAllMarkets', () => {
    it('maps market fields correctly', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          markets: [
            { marketCode: 'HK', marketName: 'Hong Kong', regionCode: 'APAC', displayOrder: 1, isActive: true }
          ]
        }
      })

      const result = await getAllMarkets()
      expect(result).toEqual([
        { marketCode: 'HK', marketName: 'Hong Kong', regionCode: 'APAC', displayOrder: 1, isActive: true }
      ])
    })
  })

  describe('getMarketsByRegion', () => {
    it('fetches markets by region code', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          markets: [
            { marketCode: 'SG', marketName: 'Singapore', regionCode: 'APAC', displayOrder: 1, isActive: true }
          ]
        }
      })

      const result = await getMarketsByRegion('APAC')
      expect(mockApiFetchJson).toHaveBeenCalledWith('/papi/v1/regions-markets/APAC')
      expect(result[0].marketCode).toBe('SG')
    })
  })

  describe('getCountriesByMarket', () => {
    it('filters all countries by market code', async () => {
      mockApiFetchJson.mockResolvedValue({
        data: {
          countries: [
            { countryCode: 'HK', countryName: 'Hong Kong', regionCode: 'APAC', marketCode: 'HK', displayOrder: 1, isActive: true },
            { countryCode: 'SG', countryName: 'Singapore', regionCode: 'APAC', marketCode: 'SG', displayOrder: 2, isActive: true }
          ]
        }
      })

      const result = await getCountriesByMarket('HK')
      expect(result).toHaveLength(1)
      expect(result[0].countryCode).toBe('HK')
    })
  })
})
===ENDFILE
===FILE: ./src/services/api/__tests__/role-template.service.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'

const mockApiFetchJson = vi.fn()

vi.mock('../../core/api-client', () => ({
  apiFetchJson: (...args: unknown[]) => mockApiFetchJson(...args)
}))

const {
  getAllRoleTemplates,
  getRoleTemplateByName
} = await import('../role-template.service')

describe('role-template.service', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('getAllRoleTemplates returns list from envelope', async () => {
    mockApiFetchJson.mockResolvedValue({
      data: {
        roleLayoutTemplates: [
          { roleNameCode: 'voice_agent', roleDisplayName: 'Voice Agent' },
          { roleNameCode: 'chat_agent', roleDisplayName: 'Chat Agent' }
        ]
      }
    })

    const result = await getAllRoleTemplates()
    expect(result).toHaveLength(2)
    expect(result[0].roleNameCode).toBe('voice_agent')
    expect(mockApiFetchJson).toHaveBeenCalledWith('/papi/v1/role-layout-templates')
  })

  it('getAllRoleTemplates returns empty array when payload missing', async () => {
    mockApiFetchJson.mockResolvedValue({ data: {} })
    const result = await getAllRoleTemplates()
    expect(result).toEqual([])
  })

  it('getRoleTemplateByName returns template from envelope', async () => {
    mockApiFetchJson.mockResolvedValue({
      data: {
        roleNameCode: 'voice_agent',
        roleDisplayName: 'Voice Agent',
        columns: { chat: { stateText: 'ENABLED' } },
        widgets: {},
        features: {},
        settingsTabs: {},
        settingsOptions: {},
        microFrontends: {}
      }
    })

    const result = await getRoleTemplateByName('voice_agent')
    expect(result.roleNameCode).toBe('voice_agent')
    expect(result.columns.chat.stateText).toBe('ENABLED')
    expect(mockApiFetchJson).toHaveBeenCalledWith('/papi/v1/role-layout-templates/voice_agent')
  })

  it('getRoleTemplateByName URL-encodes role name code', async () => {
    mockApiFetchJson.mockResolvedValue({ data: {} })
    await getRoleTemplateByName('voice/agent')
    expect(mockApiFetchJson).toHaveBeenCalledWith('/papi/v1/role-layout-templates/voice%2Fagent')
  })
})
===ENDFILE
===FILE: ./src/services/api/admin-approval.service.ts
/**
 * Admin Approval Service - Handles Maker/Checker approval workflow operations
 * All requests go through the AMToken proxy at :8095 via Vite proxy config
 */

import { apiFetch } from '../core/api-client'
import { getAuthToken } from '../../utils/auth/auth-token-manager'
import type {
  PendingChangeDto,
  PendingChangeListResponse,
  PendingChangeFilters,
  SubmitChangeRequest,
  SubmitChangeResponse,
  DirectSaveRequest,
  DirectSaveResponse,
  ApproveChangeRequest,
  ApproveChangeResponse,
  RejectChangeRequest,
  RejectChangeResponse,
  CancelChangeResponse,
  ActivityListResponse,
  ActivityLogDto
} from '../../types/features/approval-workflow.types'

const SAPI_FIELD_MAP: Record<string, string> = {
  regionCode: 'region',
  countryCode: 'country',
  marketCode: 'market',
  businessUnitName: 'businessUnit'
}

const PERM_LEVEL_MAP: Record<string, string> = {
  columnPermissions: 'columns',
  widgetPermissions: 'widgets',
  featurePermissions: 'features',
  settingsTabPermissions: 'settingsTabs',
  settingsOptionPermissions: 'settingsOptions',
  microFrontendPermissions: 'microFrontends'
}

const NESTED_WRAPPER_KEYS = new Set(['businessInfoChanges', 'permissionChanges', 'applicationChanges', 'appFunctionChanges'])

function unwrapBusinessInfo(businessInfo: Record<string, unknown>, result: Record<string, unknown>): void {
  for (const [key, value] of Object.entries(businessInfo)) {
    if (value !== null && value !== undefined) {
      result[SAPI_FIELD_MAP[key] ?? key] = value
    }
  }
}

function unwrapPermissions(permChanges: Record<string, unknown>, result: Record<string, unknown>): void {
  for (const [level, changes] of Object.entries(permChanges)) {
    if (!changes || typeof changes !== 'object') continue
    const mappedLevel = PERM_LEVEL_MAP[level] ?? level
    for (const [key, value] of Object.entries(changes as Record<string, unknown>)) {
      result[`permissions.${mappedLevel}.${key}`] = value
    }
  }
}

const FLAT_CONFIG_MARKERS = ['roleName', 'logicalName', 'region'] as const

function isAlreadyFlat(config: Record<string, unknown>): boolean {
  return FLAT_CONFIG_MARKERS.some(key => key in config)
}

function copyNonWrapperKeys(config: Record<string, unknown>, result: Record<string, unknown>): void {
  for (const [key, value] of Object.entries(config)) {
    if (!NESTED_WRAPPER_KEYS.has(key) && !(key in result)) {
      result[key] = value
    }
  }
}

function unwrapConfig(config: Record<string, unknown> | null): Record<string, unknown> {
  if (!config) return {}

  if (isAlreadyFlat(config)) {
    return config
  }

  const result: Record<string, unknown> = {}

  const businessInfo = config.businessInfoChanges as Record<string, unknown> | null | undefined
  if (businessInfo && typeof businessInfo === 'object') {
    unwrapBusinessInfo(businessInfo, result)
  }

  const permChanges = config.permissionChanges as Record<string, unknown> | null | undefined
  if (permChanges && typeof permChanges === 'object') {
    unwrapPermissions(permChanges, result)
  }

  copyNonWrapperKeys(config, result)

  return Object.keys(result).length > 0 ? result : config
}

/**
 * Extract structured app changes from proposedConfig.applicationChanges
 * when the PAPI doesn't return top-level appsChanges.
 */
/**
 * Extract app-level changes by computing diff between currentConfig and proposedConfig.
 * SAPI stores flat arrays: applicationChanges: [{appCode: "X"}, ...] in both states.
 */
function extractAppsChanges(
  currentConfig: Record<string, unknown> | null,
  proposedConfig: Record<string, unknown> | null
): { added: string[]; removed: string[]; unchanged: string[] } | null {
  if (!proposedConfig) return null
  const proposedApps = proposedConfig.applicationChanges as Array<{ appCode?: string }> | null | undefined
  const currentApps = currentConfig?.applicationChanges as Array<{ appCode?: string }> | null | undefined
  if ((!Array.isArray(proposedApps) || proposedApps.length === 0) &&
      (!Array.isArray(currentApps) || currentApps.length === 0)) {
    return null
  }

  const currentSet = new Set((currentApps ?? []).map(a => a.appCode).filter(Boolean) as string[])
  const proposedSet = new Set((proposedApps ?? []).map(a => a.appCode).filter(Boolean) as string[])

  const added = [...proposedSet].filter(a => !currentSet.has(a))
  const removed = [...currentSet].filter(a => !proposedSet.has(a))
  const unchanged = [...proposedSet].filter(a => currentSet.has(a))

  if (added.length === 0 && removed.length === 0) return null
  return { added, removed, unchanged }
}

/**
 * Extract function-level changes by computing diff between currentConfig and proposedConfig.
 * SAPI stores flat arrays: appFunctionChanges: [{appCode: "X", functionCode: "y"}, ...] in both states.
 */
type FunctionDiffResult = { added: Array<{ app: string; function: string }>; removed: Array<{ app: string; function: string }>; unchanged: Array<{ app: string; function: string }> }

function mapTopLevelFunctions(topLevel: {
  added: Array<{ appIdentifier: string; functionIdentifier: string }>
  removed: Array<{ appIdentifier: string; functionIdentifier: string }>
  unchanged: Array<{ appIdentifier: string; functionIdentifier: string }>
}): FunctionDiffResult {
  const mapFn = (f: { appIdentifier: string; functionIdentifier: string }) => ({ app: f.appIdentifier, function: f.functionIdentifier })
  return {
    added: topLevel.added.map(mapFn),
    removed: topLevel.removed.map(mapFn),
    unchanged: topLevel.unchanged.map(mapFn)
  }
}

type FunctionChangeEntry = { appCode?: string; functionCode?: string }

function toFunctionKey(f: FunctionChangeEntry): string {
  return `${f.appCode}:${f.functionCode}`
}

function toFunctionDiffEntry(f: FunctionChangeEntry): { app: string; function: string } {
  return { app: f.appCode ?? '', function: f.functionCode ?? '' }
}

function buildFunctionsDiff(
  currentFuncs: FunctionChangeEntry[],
  proposedFuncs: FunctionChangeEntry[]
): FunctionDiffResult | null {
  const currentSet = new Set(currentFuncs.map(toFunctionKey))
  const proposedSet = new Set(proposedFuncs.map(toFunctionKey))

  const added = proposedFuncs.filter(f => !currentSet.has(toFunctionKey(f))).map(toFunctionDiffEntry)
  const removed = currentFuncs.filter(f => !proposedSet.has(toFunctionKey(f))).map(toFunctionDiffEntry)
  const unchanged = proposedFuncs.filter(f => currentSet.has(toFunctionKey(f))).map(toFunctionDiffEntry)

  if (added.length === 0 && removed.length === 0) return null
  return { added, removed, unchanged }
}

function computeFunctionsDiff(
  currentConfig: Record<string, unknown> | null,
  proposedConfig: Record<string, unknown> | null
): FunctionDiffResult | null {
  if (!proposedConfig) return null

  const proposedFuncs = proposedConfig.appFunctionChanges as FunctionChangeEntry[] | null | undefined
  const currentFuncs = currentConfig?.appFunctionChanges as FunctionChangeEntry[] | null | undefined

  if ((!Array.isArray(proposedFuncs) || proposedFuncs.length === 0) &&
      (!Array.isArray(currentFuncs) || currentFuncs.length === 0)) {
    return null
  }

  return buildFunctionsDiff(currentFuncs ?? [], proposedFuncs ?? [])
}

function extractFunctionsChanges(
  topLevel: {
    added: Array<{ appIdentifier: string; functionIdentifier: string }>
    removed: Array<{ appIdentifier: string; functionIdentifier: string }>
    unchanged: Array<{ appIdentifier: string; functionIdentifier: string }>
  } | null | undefined,
  currentConfig: Record<string, unknown> | null,
  proposedConfig: Record<string, unknown> | null
): FunctionDiffResult | null {
  if (topLevel) return mapTopLevelFunctions(topLevel)
  return computeFunctionsDiff(currentConfig, proposedConfig)
}

interface PapiPendingChange {
  changeIdentifier: string
  targetGroupIdentifier: string
  targetGroupName: string | null
  changeType: string
  currentConfig: Record<string, unknown> | null
  proposedConfig: Record<string, unknown> | null
  isCriticalIndicator: boolean
  statusCode: string
  createdByText: string | null
  createdAtDatetime: string
  approvedByText?: string | null
  approvedAtDatetime?: string | null
  commentText?: string | null
  rejectedByText?: string | null
  rejectedAtDatetime?: string | null
  rejectionReasonText?: string | null
  updatedAtDatetime?: string | null
}

function extractGroupName(item: { targetGroupName?: string | null; targetGroupIdentifier: string }): string {
  return item.targetGroupName ?? item.targetGroupIdentifier.split(',')[0].replace('CN=', '')
}

function mapApprovalInfo(item: PapiPendingChange): PendingChangeDto['levelOneApproval'] {
  if (!item.approvedByText) return undefined
  return {
    approverUserId: item.approvedByText,
    approverName: item.approvedByText,
    approvalDateTime: item.approvedAtDatetime ?? '',
    comment: item.commentText ?? undefined // eslint-disable-line typescript:S2138
  }
}

function mapRejectionInfo(item: PapiPendingChange) {
  if (!item.rejectedByText) return { rejectedBy: undefined, rejectedDateTime: undefined, rejectionReason: undefined }
  return {
    rejectedBy: { userId: item.rejectedByText, displayName: item.rejectedByText, email: '' },
    rejectedDateTime: item.rejectedAtDatetime ?? undefined,
    rejectionReason: item.rejectionReasonText ?? undefined
  }
}

function resolveActionPermissions(isPending: boolean, isMySubmissions: boolean) {
  return {
    canApproveIndicator: isPending && !isMySubmissions,
    canRejectIndicator: isPending && !isMySubmissions,
    canCancelIndicator: isPending && isMySubmissions
  }
}

function mapPapiItemToDto(item: PapiPendingChange, isMySubmissions: boolean): PendingChangeDto {
  const isPending = item.statusCode === 'PENDING_LEVEL_ONE' || item.statusCode === 'PENDING_LEVEL_TWO'
  const submittedAt = item.createdAtDatetime ?? new Date().toISOString()
  const rejection = mapRejectionInfo(item)

  return {
    id: item.changeIdentifier,
    targetGroupIdentifier: item.targetGroupIdentifier,
    targetGroupName: extractGroupName(item),
    changeType: (item.changeType as 'CONFIG_UPDATE' | 'APP_UPDATE') ?? 'CONFIG_UPDATE',
    status: item.statusCode as PendingChangeDto['status'],
    criticalIndicator: item.isCriticalIndicator ?? false,
    matchedRules: [],
    submittedBy: {
      userId: item.createdByText ?? 'Unknown',
      displayName: item.createdByText ?? 'Unknown User',
      email: ''
    },
    submittedDateTime: submittedAt,
    expiresDateTime: item.updatedAtDatetime ?? submittedAt,
    currentState: unwrapConfig(item.currentConfig),
    proposedState: unwrapConfig(item.proposedConfig),
    appsChanges: extractAppsChanges(item.currentConfig, item.proposedConfig),
    functionsChanges: extractFunctionsChanges(null, item.currentConfig, item.proposedConfig),
    levelOneApproval: mapApprovalInfo(item),
    ...rejection,
    ...resolveActionPermissions(isPending, isMySubmissions)
  }
}

interface PapiActivityLogItem {
  changeIdentifier?: string
  actionCode?: string
  changeType?: string
  targetGroupIdentifier?: string
  targetGroupName?: string
  isCriticalIndicator?: boolean
  createdAtDatetime?: string
  performedByRoleCode?: string
  completionReasonText?: string
}

const VALID_ACTIONS = new Set<ActivityLogDto['action']>([
  'SUBMIT', 'L1_APPROVE', 'L2_APPROVE', 'REJECT', 'CANCEL', 'DIRECT_SAVE'
])

function resolveActivityAction(actionCode: string | undefined): ActivityLogDto['action'] {
  if (actionCode && VALID_ACTIONS.has(actionCode as ActivityLogDto['action'])) {
    return actionCode as ActivityLogDto['action']
  }
  return 'SUBMIT'
}

function resolveActivityId(item: PapiActivityLogItem, performedAt: string, index: number): string {
  return item.changeIdentifier ?? `${performedAt}:${item.actionCode ?? 'SUBMIT'}:${index}`
}

function mapActivityItem(item: PapiActivityLogItem, index: number): ActivityLogDto {
  const performedAt = item.createdAtDatetime ?? new Date().toISOString()

  return {
    id: resolveActivityId(item, performedAt, index),
    action: resolveActivityAction(item.actionCode),
    targetGroupName: item.targetGroupName ?? item.targetGroupIdentifier ?? 'Unknown group',
    changeType: item.changeType === 'APP_UPDATE' ? 'APP_UPDATE' : 'CONFIG_UPDATE',
    criticalIndicator: Boolean(item.isCriticalIndicator),
    performedAt,
    performedByRole: item.performedByRoleCode ?? 'MAKER',
    completionReason: item.completionReasonText ?? undefined
  }
}

async function parseApiError(response: Response): Promise<{ errorCode: string; errorMessage: string }> {
  const errorBody = await response.json().catch(() => ({})) as Record<string, unknown>
  const errorInfo = (errorBody.errorInfo as Array<{ code: string; causes: string[] }>) ?? []
  return {
    errorCode: errorInfo[0]?.code ?? '',
    errorMessage: errorInfo[0]?.causes?.[0] ?? `HTTP ${response.status}: ${response.statusText}`
  }
}

class AdminApprovalService {
  private static instance: AdminApprovalService
  private readonly baseUrl: string

  constructor() {
    this.baseUrl = ''
  }

  static getInstance(): AdminApprovalService {
    if (!AdminApprovalService.instance) {
      AdminApprovalService.instance = new AdminApprovalService()
    }
    return AdminApprovalService.instance
  }

  private ensureToken(): string {
    const token = getAuthToken()
    if (!token) {
      throw new Error('No authentication token found')
    }
    return token
  }

  private generateCorrelationId(): string {
    return crypto.randomUUID()
  }

  private handleSubmitError(status: number, errorCode: string, errorMessage: string): never {
    if (status === 409 && errorCode === 'BERR_20024') {
      throw new Error('A pending change already exists for this AD group. Please wait for it to be resolved.')
    }
    if (status === 409 && errorCode === 'BERR_20025') {
      throw new Error('This configuration was modified by another user. Please reload and try again.')
    }
    throw new Error(errorMessage)
  }

  /**
   * Submit a configuration change for approval
   * POST /papi/v1/pending-changes
   */
  async submitChange(
    groupId: string,
    request: SubmitChangeRequest
  ): Promise<SubmitChangeResponse> {
    this.ensureToken()

    const response = await apiFetch(
      `${this.baseUrl}/papi/v1/pending-changes`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Correlation-Id': this.generateCorrelationId()
        },
        body: JSON.stringify({
          data: {
            targetGroupIdentifier: groupId,
            changeDescription: request.changeDescription ?? 'Configuration update',
            proposedConfig: request.proposedState,
            changedFields: request.changedFields,
            ...(request.configVersionNumber !== undefined ? { configVersionNumber: request.configVersionNumber } : {})
          }
        })
      }
    )

    if (!response.ok) {
      const { errorCode, errorMessage } = await parseApiError(response)
      this.handleSubmitError(response.status, errorCode, errorMessage)
    }

    const result = await response.json() as { data: { pendingChange: Record<string, unknown> } }
    const pc = result.data?.pendingChange ?? {}

    return {
      successIndicator: true,
      directSavedIndicator: false,
      pendingChangeId: pc.changeIdentifier as string | null,
      status: (pc.statusCode as string) ?? 'PENDING_LEVEL_ONE',
      criticalApprovalIndicator: (pc.isCriticalIndicator as boolean) ?? false,
      message: 'Change submitted for approval',
      matchedRules: []
    } as SubmitChangeResponse
  }

  /**
   * Direct save configuration (Super Admin only, bypasses approval)
   * POST /papi/v1/ad-group-configs
   */
  async directSave(
    groupId: string,
    request: DirectSaveRequest
  ): Promise<DirectSaveResponse> {
    this.ensureToken()

    const response = await apiFetch(
      `${this.baseUrl}/papi/v1/ad-group-configs`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Correlation-Id': this.generateCorrelationId()
        },
        body: JSON.stringify({
          data: {
            targetGroupIdentifier: groupId,
            currentState: request.currentState,
            proposedState: request.proposedState,
            ...(request.changedApps?.length ? { changedApps: request.changedApps } : {}),
            ...(request.changedFunctions?.length ? { changedFunctions: request.changedFunctions } : {})
          }
        })
      }
    )

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }

    const result = await response.json() as {
      data?: {
        successIndicator?: boolean
        messageText?: string
      }
    }
    const success = result.data?.successIndicator ?? true
    return {
      successIndicator: success,
      message: result.data?.messageText ?? (success ? 'Configuration saved directly' : 'Direct save failed')
    }
  }

  /**
   * List pending changes
   * GET /papi/v1/pending-changes
   */
  async listPendingChanges(
    filters?: PendingChangeFilters
  ): Promise<PendingChangeListResponse> {
    this.ensureToken()

    const params = new URLSearchParams()

    const supportedStatusFilters = new Set([
      'PENDING_LEVEL_ONE',
      'PENDING_LEVEL_TWO',
      'APPROVED',
      'REJECTED',
      'CANCELLED',
      'MY_SUBMISSIONS'
    ])
    const requestedStatus = filters?.status?.[0]
    if (requestedStatus && supportedStatusFilters.has(requestedStatus)) {
      params.append('statusCode', requestedStatus)
    }

    if (filters?.offset !== undefined) {
      params.append('offset', String(filters.offset))
    }
    if (filters?.limit !== undefined) {
      params.append('limit', String(filters.limit))
    }

    const queryString = params.toString()
    const url = queryString
      ? `${this.baseUrl}/papi/v1/pending-changes?${queryString}`
      : `${this.baseUrl}/papi/v1/pending-changes`

    const response = await apiFetch(url, {
      method: 'GET',
      headers: {
        'X-Correlation-Id': this.generateCorrelationId()
      }
    })

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }

    const rawResponse = await response.json() as {
      data: { pendingChanges: PapiPendingChange[] }
      meta: { pagination: { offset: number; limit: number; total: number; hasMore: boolean } }
    }

    const rawItems = rawResponse.data?.pendingChanges ?? []
    const pagination = rawResponse.meta?.pagination ?? { offset: 0, limit: 25, total: 0, hasMore: false }
    const isMySubmissions = filters?.status?.[0] === 'MY_SUBMISSIONS'

    const items: PendingChangeDto[] = rawItems.map(item => mapPapiItemToDto(item, isMySubmissions))

    // Calculate counts based on items' status
    const pendingLevelOne = items.filter(item => item.status === 'PENDING_LEVEL_ONE').length
    const pendingLevelTwo = items.filter(item => item.status === 'PENDING_LEVEL_TWO').length

    return {
      items,
      counts: {
        pendingLevelOne,
        pendingLevelTwo
      },
      totalCount: pagination.total,
      offset: pagination.offset,
      limit: pagination.limit,
      links: {
        self: url,
        first: url,
        last: url,
        prev: '',
        next: ''
      }
    }
  }

  /**
   * Get a single pending change by ID
   * GET /papi/v1/pending-changes/{changeIdentifier}
   */
  async getPendingChange(changeId: string): Promise<PendingChangeDto> {
    this.ensureToken()

    const response = await apiFetch(
      `${this.baseUrl}/papi/v1/pending-changes/${encodeURIComponent(changeId)}`,
      {
        method: 'GET',
        headers: {
          'X-Correlation-Id': this.generateCorrelationId()
        }
      }
    )

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }

    const result = await response.json() as {
      data: {
        pendingChange: {
          changeIdentifier: string
          targetGroupIdentifier: string
          targetGroupName?: string
          isCriticalIndicator?: boolean
          changeType?: string
          currentConfig?: Record<string, unknown>
          proposedConfig?: Record<string, unknown>
          statusCode: string
          createdByText?: string
          createdAtDatetime?: string
          approvedByText?: string
          approvedAtDatetime?: string
          commentText?: string
          rejectedByText?: string
          rejectedAtDatetime?: string
          rejectionReasonText?: string
          updatedAtDatetime?: string
        }
      }
    }

    const pc = result.data?.pendingChange
    if (!pc) {
      throw new Error('Pending change not found')
    }

    const papiItem: PapiPendingChange = {
      changeIdentifier: pc.changeIdentifier,
      targetGroupIdentifier: pc.targetGroupIdentifier,
      targetGroupName: pc.targetGroupName ?? null,
      changeType: pc.changeType ?? 'CONFIG_UPDATE',
      currentConfig: pc.currentConfig ?? null,
      proposedConfig: pc.proposedConfig ?? null,
      isCriticalIndicator: pc.isCriticalIndicator ?? false,
      statusCode: pc.statusCode,
      createdByText: pc.createdByText ?? null,
      createdAtDatetime: pc.createdAtDatetime ?? new Date().toISOString(),
      approvedByText: pc.approvedByText,
      approvedAtDatetime: pc.approvedAtDatetime,
      commentText: pc.commentText,
      rejectedByText: pc.rejectedByText,
      rejectedAtDatetime: pc.rejectedAtDatetime,
      rejectionReasonText: pc.rejectionReasonText,
      updatedAtDatetime: pc.updatedAtDatetime
    }

    return mapPapiItemToDto(papiItem, false)
  }

  /**
   * Approve a pending change (L1 by Checker, L2 by Super Admin)
   * POST /papi/v1/change-approvals
   */
  async approveChange(
    changeId: string,
    request?: ApproveChangeRequest
  ): Promise<ApproveChangeResponse> {
    this.ensureToken()

    const response = await apiFetch(
      `${this.baseUrl}/papi/v1/change-approvals`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Correlation-Id': this.generateCorrelationId()
        },
        body: JSON.stringify({
          data: {
            changeIdentifier: changeId,
            commentText: request?.comment ?? ''
          }
        })
      }
    )

    if (!response.ok) {
      const { errorMessage } = await parseApiError(response)

      if (response.status === 403) {
        throw new Error(errorMessage.toLowerCase().includes('self') ? 'self-approval: Cannot approve your own changes' : errorMessage)
      }
      throw new Error(errorMessage)
    }

    const result = await response.json() as {
      data: {
        approval: {
          changeIdentifier: string
          statusCode: string
          messageText: string
          approvedByText?: string
          approvedAtDatetime?: string
          commentText?: string
        }
      }
    }

    const approval = result.data?.approval
    return {
      successIndicator: true,
      changeId: approval?.changeIdentifier ?? changeId,
      newStatus: (approval?.statusCode ?? 'APPROVED') as ApproveChangeResponse['newStatus'],
      message: approval?.messageText ?? 'Change approved',
      appliedDateTime: approval?.approvedAtDatetime
    }
  }

  /**
   * Reject a pending change
   * POST /papi/v1/change-rejections
   */
  async rejectChange(
    changeId: string,
    request: RejectChangeRequest
  ): Promise<RejectChangeResponse> {
    this.ensureToken()

    const response = await apiFetch(
      `${this.baseUrl}/papi/v1/change-rejections`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Correlation-Id': this.generateCorrelationId()
        },
        body: JSON.stringify({
          data: {
            changeIdentifier: changeId,
            reasonText: request.rejectionReason ?? ''
          }
        })
      }
    )

    if (!response.ok) {
      const { errorMessage } = await parseApiError(response)
      throw new Error(errorMessage)
    }

    const result = await response.json() as {
      data: {
        rejection: {
          changeIdentifier: string
          statusCode: string
          messageText: string
          rejectedByText?: string
          rejectedAtDatetime?: string
          rejectionReasonText?: string
        }
      }
    }

    const rejection = result.data?.rejection
    return {
      successIndicator: true,
      changeId: rejection?.changeIdentifier ?? changeId,
      newStatus: 'REJECTED',
      message: rejection?.messageText ?? 'Change rejected',
      rejectedDateTime: rejection?.rejectedAtDatetime ?? new Date().toISOString(),
      notificationSentIndicator: true
    }
  }

  /**
   * Cancel own pending change
   * DELETE /papi/v1/pending-changes/{changeIdentifier}
   */
  async cancelChange(changeId: string): Promise<CancelChangeResponse> {
    this.ensureToken()

    const response = await apiFetch(
      `${this.baseUrl}/papi/v1/pending-changes/${encodeURIComponent(changeId)}`,
      {
        method: 'DELETE',
        headers: {
          'X-Correlation-Id': this.generateCorrelationId()
        }
      }
    )

    if (!response.ok) {
      const { errorMessage } = await parseApiError(response)

      if (response.status === 403) {
        throw new Error('You can only cancel your own pending changes')
      }
      throw new Error(errorMessage)
    }

    const result = await response.json() as {
      data: {
        statusCode?: string
        messageText?: string
      }
    }

    return {
      successIndicator: true,
      changeId,
      newStatus: 'CANCELLED' as const,
      message: result.data?.messageText ?? 'Pending change cancelled'
    }
  }

  /**
   * Fetch current user's activity history
   * GET /papi/v1/my-activity
   */
  async getMyActivity(page: number = 1, size: number = 25, timeRange?: 'today' | 'week' | 'month'): Promise<ActivityListResponse> {
    this.ensureToken()

    const normalizedPage = Math.max(1, Math.floor(page))
    const normalizedSize = Math.max(1, Math.floor(size))
    const offset = (normalizedPage - 1) * normalizedSize

    const params = new URLSearchParams({
      offset: String(offset),
      limit: String(normalizedSize)
    })
    if (timeRange) {
      params.append('timeRange', timeRange.toUpperCase())
    }

    const response = await apiFetch(
      `${this.baseUrl}/papi/v1/my-activity?${params.toString()}`,
      {
        method: 'GET',
        headers: {
          'X-Correlation-Id': this.generateCorrelationId()
        }
      }
    )

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }

    const rawResponse = await response.json() as {
      data?: { activityValues?: PapiActivityLogItem[] }
      meta?: { pagination?: { offset?: number; limit?: number; total?: number; hasMore?: boolean } }
    }

    const rawItems = rawResponse.data?.activityValues ?? []
    const pagination = rawResponse.meta?.pagination ?? {}
    const responseOffset = pagination.offset ?? offset
    const responseLimit = pagination.limit ?? normalizedSize
    const responseTotal = pagination.total ?? 0

    const items: ActivityLogDto[] = rawItems.map(mapActivityItem)

    const calculatedPage = responseLimit > 0 ? Math.floor(responseOffset / responseLimit) + 1 : 1

    return {
      items,
      totalCount: responseTotal,
      page: calculatedPage,
      size: responseLimit
    }
  }

  /**
   * Get pending changes count for sidebar badge
   */
  async getPendingChangesCount(): Promise<{ total: number; levelOne: number; levelTwo: number }> {
    try {
      const data = await this.listPendingChanges({ limit: 1 })
      return {
        total: data.counts.pendingLevelOne + data.counts.pendingLevelTwo,
        levelOne: data.counts.pendingLevelOne,
        levelTwo: data.counts.pendingLevelTwo
      }
    } catch {
      return { total: 0, levelOne: 0, levelTwo: 0 }
    }
  }
}

export const adminApprovalService = AdminApprovalService.getInstance()
===ENDFILE
===FILE: ./src/services/api/admin.service.ts
/**
 * Admin Service - Handles admin operations for AD Groups, Role Templates, and Notices
 */

/* eslint-disable no-console */
import { apiFetch } from '../core/api-client'
import { getAuthToken } from '../../utils/auth/auth-token-manager'
import { handleApiResponse } from '../../utils/api/response-handler'
import type { AdGroup } from '../../types/features/ad-group-config'
import type {
  CopyOptions,
  AdminNoticeRequest,
  AdminNoticeResponse,
  CopyResult
} from '../../types/features/admin.types'

export type { AdminNoticeRequest, AdminNoticeResponse }

interface PapiCopyResult {
  successFlag?: boolean
  messageText?: string
  errorText?: string
  updatedGroup?: Record<string, unknown>
  workflowStatusCode?: 'DIRECT_APPLIED' | 'SUBMITTED_FOR_APPROVAL'
  pendingChangeIdentifier?: string
  criticalIndicator?: boolean
  levelTwoApprovalRequiredIndicator?: boolean
  unavailableAppFunctionValues?: string[]
}

function toAssignmentMap(
  permissions: Record<string, unknown> | undefined
): Record<string, { state: 'enabled' | 'disabled' }> | undefined {
  if (!permissions) {
    return undefined;
  }

  return Object.fromEntries(
    Object.entries(permissions).map(([key, value]) => {
      const permission = value as { enabledIndicator?: boolean };
      return [key, { state: permission?.enabledIndicator ? 'enabled' : 'disabled' as const }];
    })
  );
}

function mapAdGroup(item: Record<string, unknown>): AdGroup {
  const currentConfig = item.currentConfig as Record<string, unknown> | undefined;
  const permissionChanges = currentConfig?.permissionChanges as Record<string, unknown> | undefined;

  return {
    id: (item.groupIdentifier as string | undefined) ?? '',
    groupIdentifier: (item.groupIdentifier as string | undefined) ?? '',
    logicalName: item.logicalName as string | undefined,
    roleName: item.roleName as string | undefined,
    market: item.marketCode as string | undefined,
    region: item.regionCode as string | undefined,
    country: item.countryCode as string | undefined,
    businessUnit: item.businessUnitName as string | undefined,
    isActive: (item.activeIndicator as boolean | undefined) ?? true,
    accessLevel: item.userAccessCode as AdGroup['accessLevel'] | undefined,
    pendingChangeIndicator: (item.pendingChangeIndicator as boolean | undefined) ?? false,
    versionNumber: item.versionNumber as number | undefined,
    userCount: item.userCountNumber as number | undefined,
    lastModified: item.updatedAtDatetime as string | undefined,
    columnAssignments: toAssignmentMap(
      permissionChanges?.columnPermissions as Record<string, unknown> | undefined
    ),
    widgetAssignments: toAssignmentMap(
      permissionChanges?.widgetPermissions as Record<string, unknown> | undefined
    )
  };
}

function normalizeProposedState(updateData: Record<string, unknown>): Record<string, unknown> {
  const proposedState: Record<string, unknown> = { ...updateData };

  if ('isActive' in proposedState && typeof proposedState.isActive === 'boolean') {
    proposedState.activeIndicator = proposedState.isActive;
    delete proposedState.isActive;
  }

  return Object.fromEntries(
    Object.entries(proposedState).filter(([, value]) => value !== undefined)
  );
}

function mapNoticeIdentityFields(raw: Record<string, unknown>) {
  return {
    id: (raw.identifier as string) ?? '',
    title: (raw.titleText as string) ?? '',
    message: (raw.messageText as string) ?? '',
    severity: (raw.severityValue as string) ?? 'INFO',
    status: (raw.statusCode as string) ?? '',
    broadcastToAll: Boolean(raw.broadcastToAllFlag),
  };
}

function mapNoticeTargetFields(raw: Record<string, unknown>) {
  return {
    targetRoles: (raw.targetRoleValues as string[]) ?? [],
    targetAdGroups: (raw.targetAdGroupValues as string[]) ?? [],
    requiresAcknowledgement: Boolean(raw.requiresAckFlag),
    startAt: (raw.startAtDate as string) ?? undefined,
    endAt: (raw.endAtDate as string) ?? undefined,
    createdBy: (raw.createdByText as string) ?? '',
    createdAt: (raw.createdAtDate as string) ?? '',
  };
}

class AdminService {
  private static instance: AdminService;
  private readonly baseUrl: string;

  constructor() {
    // Use relative URL to leverage Vite proxy
    this.baseUrl = '';
  }

  static getInstance(): AdminService {
    if (!AdminService.instance) {
      AdminService.instance = new AdminService();
    }
    return AdminService.instance;
  }

  /**
   * Retrieve current AM token from centralized manager
   */
  private ensureToken(): string {
    const token = getAuthToken();
    if (!token) {
      throw new Error('No authentication token found');
    }
    return token;
  }

  /**
   * Copy configuration from one AD group to another
   * @param sourceGroupIdentifier DN of source group to copy from
   * @param targetGroupIdentifier DN of target group to copy to
   * @param options Copy options controlling what gets copied
   * @returns Promise with copy result
   */
  async copyAdGroupConfiguration(
    sourceGroupIdentifier: string,
    targetGroupIdentifier: string,
    options?: CopyOptions
  ): Promise<CopyResult> {
    try {
      this.ensureToken();

      const requestBody = {
        sourceGroupIdentifier,
        targetGroupIdentifier,
        copyOptions: {
          copyRoleAndPermissionsFlag: true,
          copyBusinessInfoFlag: true,
          copyApplicationsFlag: true,
          overwriteExistingFlag: false,
          copyWorkflowModeCode: 'SUBMIT_FOR_APPROVAL',
          functionMismatchPolicyCode: 'FAIL_ON_MISMATCH',
          ...options
        }
      };

      const response = await apiFetch(`${this.baseUrl}/papi/v1/ad-group-configuration-copies`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ data: requestBody })
      });

      const payload = await response.json().catch(() => ({})) as {
        data?: { copyResult?: PapiCopyResult }
      };
      const copyResult = payload.data?.copyResult;

      if (!response.ok || copyResult?.successFlag === false) {
        const message = copyResult?.messageText
          ?? copyResult?.errorText
          ?? `HTTP ${response.status}: ${response.statusText}`;
        return {
          success: false,
          message,
          error: copyResult?.errorText ?? 'REQUEST_FAILED',
          errorDetails: {},
          workflowStatusCode: copyResult?.workflowStatusCode,
          pendingChangeIdentifier: copyResult?.pendingChangeIdentifier,
          criticalIndicator: copyResult?.criticalIndicator,
          levelTwoApprovalRequiredIndicator: copyResult?.levelTwoApprovalRequiredIndicator,
          unavailableAppFunctionValues: copyResult?.unavailableAppFunctionValues
        };
      }

      return {
        success: true,
        message: copyResult?.messageText ?? 'Configuration copied successfully',
        updatedGroup: copyResult?.updatedGroup,
        workflowStatusCode: copyResult?.workflowStatusCode,
        pendingChangeIdentifier: copyResult?.pendingChangeIdentifier,
        criticalIndicator: copyResult?.criticalIndicator,
        levelTwoApprovalRequiredIndicator: copyResult?.levelTwoApprovalRequiredIndicator,
        unavailableAppFunctionValues: copyResult?.unavailableAppFunctionValues
      };

    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Failed to copy configuration',
        error: 'NETWORK_ERROR',
        errorDetails: {}
      };
    }
  }

  /**
   * Get all AD groups
   * GET /papi/v1/ad-groups
   */
  async getAllAdGroups(): Promise<AdGroup[]> {
    this.ensureToken();

    const response = await apiFetch(`${this.baseUrl}/papi/v1/ad-groups`, {
      method: 'GET'
    });

    const data = await handleApiResponse<Record<string, unknown>>({
      response,
      context: 'AdminService.getAllAdGroups'
    });

    // Strict v1 PAPI list response shape: { data: { items: [...] } }
    const adGroupsData = data as { data?: { items?: Record<string, unknown>[] } };
    const items = adGroupsData.data?.items;

    if (!items || !Array.isArray(items)) {
      console.error('[AdminService] getAllAdGroups response has unexpected format:', data);
      throw new Error('Unexpected response format from AD groups endpoint');
    }

    return items.map(mapAdGroup);
  }

  /**
   * Look up AD group config by DN
   * POST /papi/v1/ad-groups/lookup
   */
  async lookupAdGroup(groupIdentifier: string): Promise<AdGroup> {
    this.ensureToken();

    const response = await apiFetch(`${this.baseUrl}/papi/v1/ad-groups/lookup`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        data: {
          groupIdentifier
        }
      })
    });

    const result = await handleApiResponse<{
      data?: Record<string, unknown>
    }>({
      response,
      context: 'AdminService.lookupAdGroup'
    });

    const item = result.data;
    if (!item) {
      throw new Error('AD group not found');
    }

    return mapAdGroup(item);
  }

  /**
   * Search AD groups (for bulk operations)
   * Uses GET /papi/v1/ad-groups with search param
   */
  async searchAdGroups(search?: string, limit = 500): Promise<AdGroup[]> {
    this.ensureToken();

    const safeLimit = Math.min(Math.max(limit, 1), 1000);
    const params = new URLSearchParams({ limit: String(safeLimit) });
    if (search && search.trim().length > 0) {
      params.set('search', search.trim());
    }

    const response = await apiFetch(`${this.baseUrl}/papi/v1/ad-groups?${params.toString()}`, {
      method: 'GET'
    });

    const rawData = await handleApiResponse<Record<string, unknown>>({
      response,
      context: 'AdminService.searchAdGroups'
    });

    // Strict v1 PAPI list response shape: { data: { items: [...] } }
    const dataObj = rawData as { data?: { items?: Record<string, unknown>[] } };
    const payload = dataObj.data?.items;

    if (!payload || !Array.isArray(payload)) {
      console.error('[AdminService] searchAdGroups response is not an array:', rawData);
      throw new Error('Unexpected response format from AD groups search endpoint');
    }

    return payload.map((item: Record<string, unknown>): AdGroup => {
      const mapped = mapAdGroup(item);
      return {
        ...mapped,
        id: typeof item.id === 'string' && item.id.length > 0 ? item.id : mapped.id
      };
    });
  }

  /**
   * Update an AD group
   */
  async updateAdGroup(groupIdentifier: string, updateData: Record<string, unknown>): Promise<Record<string, unknown>> {
    this.ensureToken();

    const proposedState = normalizeProposedState(updateData);
    const requestData: Record<string, unknown> = {
      targetGroupIdentifier: groupIdentifier,
      proposedState
    };
    if (typeof updateData.configVersionNumber === 'number') {
      requestData.configVersionNumber = updateData.configVersionNumber;
    }

    const response = await apiFetch(`${this.baseUrl}/papi/v1/ad-group-configs`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ data: requestData })
    });

    return handleApiResponse<Record<string, unknown>>({
      response,
      context: 'AdminService.updateAdGroup'
    });
  }

  /**
   * Map frontend notice request to PAPI contract field names.
   */
  private toPapiNoticePayload(data: AdminNoticeRequest & { status?: string }): Record<string, unknown> {
    const mapped: Record<string, unknown> = {
      titleText: data.title,
      messageText: data.message,
      severityValue: data.severity,
      broadcastToAllFlag: data.broadcastToAll,
      requiresAckFlag: data.requiresAcknowledgement
    };
    if (data.status) mapped.statusCode = data.status;
    if (data.targetRoles) mapped.targetRoleValues = data.targetRoles;
    if (data.targetAdGroups) mapped.targetAdGroupValues = data.targetAdGroups;
    if (data.startAt) mapped.startAtDate = data.startAt;
    if (data.endAt) mapped.endAtDate = data.endAt;
    if (data.createdBy) mapped.createdByText = data.createdBy;
    return mapped;
  }

  /**
   * Map PAPI notice payload to frontend AdminNoticeResponse.
   */
  private fromPapiNoticePayload(raw: Record<string, unknown>): AdminNoticeResponse {
    return {
      ...mapNoticeIdentityFields(raw),
      ...mapNoticeTargetFields(raw),
    };
  }

  /**
   * Create a new system notice
   * POST /papi/v1/notices
   */
  async createNotice(noticeData: AdminNoticeRequest): Promise<AdminNoticeResponse> {
    const amtoken = this.ensureToken();

    const noticePayload = this.toPapiNoticePayload({ ...noticeData, createdBy: amtoken });

    const response = await apiFetch(`${this.baseUrl}/papi/v1/notices`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ data: noticePayload })
    });

    const result = await handleApiResponse<{ data?: { notice?: Record<string, unknown> } }>({
      response,
      context: 'AdminService.createNotice'
    });

    const notice = result.data?.notice;
    if (!notice) {
      throw new Error('Unexpected response format from create notice endpoint');
    }
    return this.fromPapiNoticePayload(notice);
  }

  /**
   * List all notices with optional status filter
   * GET /papi/v1/notices
   */
  async listNotices(status?: string): Promise<AdminNoticeResponse[]> {
    this.ensureToken();

    const url = status
      ? `${this.baseUrl}/papi/v1/notices?statusCode=${encodeURIComponent(status)}`
      : `${this.baseUrl}/papi/v1/notices`;

    const response = await apiFetch(url, {
      method: 'GET'
    });

    const result = await handleApiResponse<{ data?: { notices?: Record<string, unknown>[] } }>({
      response,
      context: 'AdminService.listNotices'
    });

    const notices = result.data?.notices;
    if (!notices || !Array.isArray(notices)) {
      throw new Error('Unexpected response format from list notices endpoint');
    }
    return notices.map((n) => this.fromPapiNoticePayload(n));
  }

  /**
   * Update existing notice content (for drafts)
   * PUT /papi/v1/notices/{noticeIdentifier}
   */
  async updateNotice(noticeId: string, noticeData: AdminNoticeRequest): Promise<AdminNoticeResponse> {
    this.ensureToken();

    const noticePayload = this.toPapiNoticePayload(noticeData);

    const response = await apiFetch(`${this.baseUrl}/papi/v1/notices/${noticeId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ data: noticePayload })
    });

    const result = await handleApiResponse<{ data?: { notice?: Record<string, unknown> } }>({
      response,
      context: 'AdminService.updateNotice'
    });

    const notice = result.data?.notice;
    if (!notice) {
      throw new Error('Unexpected response format from update notice endpoint');
    }
    return this.fromPapiNoticePayload(notice);
  }

  /**
   * Update notice status (ACTIVE, DRAFT, ARCHIVED)
   * PATCH /papi/v1/notices/{noticeIdentifier}/status
   */
  async updateNoticeStatus(noticeId: string, status: string): Promise<AdminNoticeResponse> {
    this.ensureToken();

    const response = await apiFetch(`${this.baseUrl}/papi/v1/notices/${noticeId}/status`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ data: { statusCode: status } })
    });

    const result = await handleApiResponse<{ data?: { notice?: Record<string, unknown> } }>({
      response,
      context: 'AdminService.updateNoticeStatus'
    });

    const notice = result.data?.notice;
    if (!notice) {
      throw new Error('Unexpected response format from update notice status endpoint');
    }
    return this.fromPapiNoticePayload(notice);
  }
}

export const adminService = AdminService.getInstance();
===ENDFILE
===FILE: ./src/services/api/reference-data.service.ts
import { apiFetchJson } from '../core/api-client'

export interface RegionDto {
  regionCode: string
  regionName: string
  displayOrder: number
  isActive: boolean
}

export interface BusinessUnitDto {
  unitCode: string
  unitName: string
  description: string
  effectiveDate: string
  displayOrder: number
  isActive: boolean
}

export interface CountryDto {
  countryCode: string
  countryName: string
  regionCode: string
  marketCode: string
  displayOrder: number
  isActive: boolean
}

export interface MarketDto {
  marketCode: string
  marketName: string
  regionCode: string
  displayOrder: number
  isActive: boolean
}

// ---------------------------------------------------------------------------
// PAPI response -> frontend field mapping helpers
// PAPI can return either canonical fields (displayOrder/isActive) or
// alternate contract fields (displayOrderNumber/isActiveFlag).
// ---------------------------------------------------------------------------

interface PapiRegionResponse {
  regionCode: string
  regionName: string
  displayOrderNumber?: number
  displayOrder?: number
  isActiveFlag?: boolean
  isActive?: boolean
}

interface PapiMarketResponse {
  marketCode: string
  marketName: string
  regionCode: string
  displayOrderNumber?: number
  displayOrder?: number
  isActiveFlag?: boolean
  isActive?: boolean
}

interface PapiCountryResponse {
  countryCode: string
  countryName: string
  regionCode: string
  marketCode: string
  displayOrderNumber?: number
  displayOrder?: number
  isActiveFlag?: boolean
  isActive?: boolean
}

interface PapiBusinessUnitResponse {
  unitCode: string
  unitName: string
  description: string
  effectiveDate: string
  displayOrderNumber?: number
  displayOrder?: number
  isActiveFlag?: boolean
  isActive?: boolean
}

function mapRegion(r: PapiRegionResponse): RegionDto {
  return {
    regionCode: r.regionCode,
    regionName: r.regionName,
    displayOrder: r.displayOrder ?? r.displayOrderNumber ?? 0,
    isActive: r.isActive ?? r.isActiveFlag ?? true
  }
}

function mapMarket(m: PapiMarketResponse): MarketDto {
  return {
    marketCode: m.marketCode,
    marketName: m.marketName,
    regionCode: m.regionCode,
    displayOrder: m.displayOrder ?? m.displayOrderNumber ?? 0,
    isActive: m.isActive ?? m.isActiveFlag ?? true
  }
}

function mapCountry(c: PapiCountryResponse): CountryDto {
  return {
    countryCode: c.countryCode,
    countryName: c.countryName,
    regionCode: c.regionCode,
    marketCode: c.marketCode,
    displayOrder: c.displayOrder ?? c.displayOrderNumber ?? 0,
    isActive: c.isActive ?? c.isActiveFlag ?? true
  }
}

function mapBusinessUnit(b: PapiBusinessUnitResponse): BusinessUnitDto {
  return {
    unitCode: b.unitCode,
    unitName: b.unitName,
    description: b.description,
    effectiveDate: b.effectiveDate,
    displayOrder: b.displayOrder ?? b.displayOrderNumber ?? 0,
    isActive: b.isActive ?? b.isActiveFlag ?? true
  }
}

// ---------------------------------------------------------------------------
// API functions  aligned to actual PAPI endpoint paths
// PAPI wraps arrays in { data: { <collection>: [...] } }
// ---------------------------------------------------------------------------

export async function getAllRegions(): Promise<RegionDto[]> {
  const raw = await apiFetchJson<{ data: { regions: PapiRegionResponse[] } }>('/papi/v1/regions')
  return (raw.data?.regions ?? []).map(mapRegion)
}

export async function getAllBusinessUnits(): Promise<BusinessUnitDto[]> {
  const raw = await apiFetchJson<{ data: { businessUnits: PapiBusinessUnitResponse[] } }>('/papi/v1/business-units')
  return (raw.data?.businessUnits ?? []).map(mapBusinessUnit)
}

export async function getAllCountries(): Promise<CountryDto[]> {
  const raw = await apiFetchJson<{ data: { countries: PapiCountryResponse[] } }>('/papi/v1/countries')
  return (raw.data?.countries ?? []).map(mapCountry)
}

export async function getCountriesByRegion(regionCode: string): Promise<CountryDto[]> {
  const raw = await apiFetchJson<{ data: { countries: PapiCountryResponse[] } }>(
    `/papi/v1/regions-countries/${encodeURIComponent(regionCode)}`
  )
  return (raw.data?.countries ?? []).map(mapCountry)
}

export async function getAllMarkets(): Promise<MarketDto[]> {
  const raw = await apiFetchJson<{ data: { markets: PapiMarketResponse[] } }>('/papi/v1/markets')
  return (raw.data?.markets ?? []).map(mapMarket)
}

export async function getMarketsByRegion(regionCode: string): Promise<MarketDto[]> {
  const raw = await apiFetchJson<{ data: { markets: PapiMarketResponse[] } }>(
    `/papi/v1/regions-markets/${encodeURIComponent(regionCode)}`
  )
  return (raw.data?.markets ?? []).map(mapMarket)
}

export async function getCountriesByMarket(marketCode: string): Promise<CountryDto[]> {
  // PAPI has no /markets/{code}/countries endpoint  filter from all countries
  const all = await getAllCountries()
  return all.filter((c) => c.marketCode === marketCode)
}
===ENDFILE
===FILE: ./src/services/api/role-template.service.ts
import { apiFetchJson } from '../core/api-client'

export interface RoleTemplateStateDto {
  stateText: string
  reasonText?: string
}

export interface RoleTemplateSummaryDto {
  roleNameCode: string
  roleDisplayName: string
}

export interface RoleTemplateDto {
  roleNameCode: string
  roleDisplayName: string
  columns: Record<string, RoleTemplateStateDto>
  widgets: Record<string, RoleTemplateStateDto>
  features: Record<string, RoleTemplateStateDto>
  settingsTabs: Record<string, RoleTemplateStateDto>
  settingsOptions: Record<string, RoleTemplateStateDto>
  microFrontends: Record<string, RoleTemplateStateDto>
}

export async function getAllRoleTemplates(): Promise<RoleTemplateSummaryDto[]> {
  const raw = await apiFetchJson<{ data?: { roleLayoutTemplates?: RoleTemplateSummaryDto[] } }>(
    '/papi/v1/role-layout-templates'
  )
  return raw.data?.roleLayoutTemplates ?? []
}

export async function getRoleTemplateByName(roleNameCode: string): Promise<RoleTemplateDto> {
  const raw = await apiFetchJson<{ data: RoleTemplateDto }>(
    `/papi/v1/role-layout-templates/${encodeURIComponent(roleNameCode)}`
  )
  return raw.data
}
===ENDFILE
===FILE: ./src/services/core/__tests__/api-client.test.ts
// @vitest-environment jsdom
import { beforeEach, describe, expect, it, vi } from 'vitest'

vi.mock('../../../utils/auth/auth-token-manager', () => ({
  getAuthToken: vi.fn(),
  clearAuthToken: vi.fn()
}))

const { getAuthToken, clearAuthToken } = await import('../../../utils/auth/auth-token-manager')
const { apiFetch, apiFetchJson } = await import('../api-client')

describe('api-client', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    vi.mocked(getAuthToken).mockReturnValue('test-token')
    vi.stubGlobal('fetch', vi.fn())
    // Stub document.cookie
    Object.defineProperty(document, 'cookie', { writable: true, value: '' })
  })

  describe('apiFetch', () => {
    it('sets AMToken cookie and header for authenticated requests', async () => {
      vi.mocked(fetch).mockResolvedValue(new Response('{}', { status: 200 }))

      await apiFetch('/papi/v1/test')

      expect(fetch).toHaveBeenCalledTimes(1)
      const [, init] = vi.mocked(fetch).mock.calls[0]
      const headers = init?.headers as Headers
      expect(headers.get('AMToken')).toBe('test-token')
      expect(init?.credentials).toBe('include')
    })

    it('throws when no auth token and skipAuth is false', async () => {
      vi.mocked(getAuthToken).mockReturnValue(null)

      await expect(apiFetch('/papi/v1/test')).rejects.toThrow('AMToken unavailable')
    })

    it('skips auth when skipAuth is true', async () => {
      vi.mocked(getAuthToken).mockReturnValue(null)
      vi.mocked(fetch).mockResolvedValue(new Response('{}', { status: 200 }))

      await apiFetch('/papi/v1/test', { skipAuth: true })

      expect(fetch).toHaveBeenCalledTimes(1)
      const [, init] = vi.mocked(fetch).mock.calls[0]
      const headers = init?.headers as Headers
      expect(headers.get('AMToken')).toBeNull()
    })

    it('clears auth token on 401 response', async () => {
      vi.mocked(fetch).mockResolvedValue(new Response('', { status: 401 }))

      await apiFetch('/papi/v1/test')

      expect(clearAuthToken).toHaveBeenCalledTimes(1)
    })

    it('does not clear auth token on non-401 responses', async () => {
      vi.mocked(fetch).mockResolvedValue(new Response('{}', { status: 200 }))

      await apiFetch('/papi/v1/test')

      expect(clearAuthToken).not.toHaveBeenCalled()
    })

    it('passes through request init options', async () => {
      vi.mocked(fetch).mockResolvedValue(new Response('{}', { status: 200 }))

      await apiFetch('/papi/v1/test', {
        method: 'POST',
        body: JSON.stringify({ key: 'value' })
      })

      const [, init] = vi.mocked(fetch).mock.calls[0]
      expect(init?.method).toBe('POST')
      expect(init?.body).toBe('{"key":"value"}')
    })
  })

  describe('apiFetchJson', () => {
    it('returns parsed JSON on success', async () => {
      const data = { result: 'ok' }
      vi.mocked(fetch).mockResolvedValue(new Response(JSON.stringify(data), { status: 200 }))

      const result = await apiFetchJson<{ result: string }>('/papi/v1/test')

      expect(result).toEqual(data)
    })

    it('throws with response text on non-ok response', async () => {
      vi.mocked(fetch).mockResolvedValue(
        new Response('Server Error', { status: 500, statusText: 'Internal Server Error' })
      )

      await expect(apiFetchJson('/papi/v1/test')).rejects.toThrow('Server Error')
    })

    it('sets Content-Type header for non-GET requests with body', async () => {
      vi.mocked(fetch).mockResolvedValue(new Response('{}', { status: 200 }))

      await apiFetchJson('/papi/v1/test', {
        method: 'POST',
        body: JSON.stringify({ data: 'test' })
      })

      const [, init] = vi.mocked(fetch).mock.calls[0]
      const headers = init?.headers as Headers
      expect(headers.get('Content-Type')).toBe('application/json')
    })

    it('does not override existing Content-Type header', async () => {
      vi.mocked(fetch).mockResolvedValue(new Response('{}', { status: 200 }))

      await apiFetchJson('/papi/v1/test', {
        method: 'POST',
        body: 'data',
        headers: { 'Content-Type': 'text/plain' }
      })

      const [, init] = vi.mocked(fetch).mock.calls[0]
      const headers = init?.headers as Headers
      expect(headers.get('Content-Type')).toBe('text/plain')
    })

    it('handles empty response body on error', async () => {
      const response = new Response('', { status: 500 })
      vi.mocked(fetch).mockResolvedValue(response)

      await expect(apiFetchJson('/papi/v1/test')).rejects.toThrow('Request failed with status 500')
    })
  })
})
===ENDFILE
===FILE: ./src/services/core/api-client.ts
import { getAuthToken, clearAuthToken } from '../../utils/auth/auth-token-manager'

type RequestInfoType = RequestInfo | URL

interface ApiFetchOptions extends RequestInit {
  skipAuth?: boolean
}

function ensureAmTokenCookie(skipAuth?: boolean): void {
  if (skipAuth) return

  const token = getAuthToken()
  if (!token) {
    throw new Error('AMToken unavailable. Please log in again.')
  }

  // Set AMToken as a cookie so the proxy at :8095 can read it
  // and forward as X-HSBC-E2E-Trust-Token header to PAPI
  document.cookie = `AMToken=${encodeURIComponent(token)}; path=/; SameSite=Lax`
}

function buildHeaders(init?: RequestInit, skipAuth?: boolean): Headers {
  const headers = new Headers(init?.headers ?? undefined)

  if (!skipAuth) {
    const token = getAuthToken()
    if (!token) {
      throw new Error('AMToken unavailable. Please log in again.')
    }
    // Also set as header for backward compatibility with direct PAPI calls
    headers.set('AMToken', token)
  }

  return headers
}

export async function apiFetch(input: RequestInfoType, init: ApiFetchOptions = {}): Promise<Response> {
  const { skipAuth, ...rest } = init

  // Ensure AMToken cookie is set for proxy-based routing
  ensureAmTokenCookie(skipAuth)

  const headers = buildHeaders(rest, skipAuth)

  const response = await fetch(input, {
    ...rest,
    headers,
    credentials: 'include'
  })

  if (response.status === 401) {
    clearAuthToken()
  }

  return response
}

export async function apiFetchJson<T>(input: RequestInfoType, init: ApiFetchOptions = {}): Promise<T> {
  const headers = new Headers(init.headers ?? undefined)
  if (!headers.has('Content-Type') && init.body && init.method?.toUpperCase() !== 'GET') {
    headers.set('Content-Type', 'application/json')
  }

  const response = await apiFetch(input, { ...init, headers })

  if (!response.ok) {
    const message = await safeReadResponse(response)
    throw new Error(message)
  }

  return response.json() as Promise<T>
}

async function safeReadResponse(res: Response): Promise<string> {
  try {
    const text = (await res.text())?.trim() ?? ''
    return text || `Request failed with status ${res.status}`
  } catch {
    return `Request failed with status ${res.status}`
  }
}
===ENDFILE
===FILE: ./src/services/mock-data.ts
/**
 * Mock Data Service for Admin MFE
 * Provides simulated data for demonstration purposes
 */

import type { RoleTemplate, AdGroup, PendingApproval, SystemNotice } from '../types'

const MOCK_CREATED_TIMESTAMP = '2024-01-15T10:00:00Z'

// Role Templates Mock Data
export const mockRoleTemplates: RoleTemplate[] = [
  {
    id: 'voice_agent',
    name: 'Voice Agent',
    description: 'Handles inbound and outbound voice calls with full customer service capabilities',
    permissions: ['voice.calls', 'customer.view', 'knowledge.search', 'banking.apps'],
    widgets: ['mediaBar', 'customerInfo', 'knowledgeBase', 'embeddedApps'],
    createdAt: MOCK_CREATED_TIMESTAMP,
    updatedAt: '2024-03-20T14:30:00Z'
  },
  {
    id: 'chat_agent',
    name: 'Chat Agent',
    description: 'Manages digital chat interactions with customers across multiple channels',
    permissions: ['chat.conversations', 'customer.view', 'knowledge.search', 'templates.use'],
    widgets: ['chatConsole', 'customerInfo', 'knowledgeBase', 'responseTemplates'],
    createdAt: MOCK_CREATED_TIMESTAMP,
    updatedAt: '2024-03-18T09:15:00Z'
  },
  {
    id: 'supervisor',
    name: 'Supervisor',
    description: 'Team lead with monitoring capabilities and performance insights',
    permissions: ['team.monitor', 'metrics.view', 'escalations.handle', 'reports.access'],
    widgets: ['teamDashboard', 'performanceMetrics', 'escalationQueue', 'realTimeMonitor'],
    createdAt: MOCK_CREATED_TIMESTAMP,
    updatedAt: '2024-03-22T11:45:00Z'
  },
  {
    id: 'admin',
    name: 'Administrator',
    description: 'Full system administration with configuration and user management access',
    permissions: ['admin.full', 'config.manage', 'users.manage', 'audit.view'],
    widgets: ['adminPanel', 'configManager', 'userDirectory', 'auditLog'],
    createdAt: MOCK_CREATED_TIMESTAMP,
    updatedAt: '2024-03-25T16:00:00Z'
  }
]

// AD Groups Mock Data
export const mockAdGroups: AdGroup[] = [
  {
    id: 'adg-001',
    name: 'APAC Voice Team',
    distinguishedName: 'CN=CCAAS_APAC_VOICE,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 156,
    assignedLayouts: ['voice_agent'],
    isActive: true,
    createdAt: '2024-01-20T08:00:00Z',
    updatedAt: '2024-03-15T10:30:00Z'
  },
  {
    id: 'adg-002',
    name: 'EMEA Chat Support',
    distinguishedName: 'CN=CCAAS_EMEA_CHAT,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 89,
    assignedLayouts: ['chat_agent'],
    isActive: true,
    createdAt: '2024-01-22T09:15:00Z',
    updatedAt: '2024-03-18T14:20:00Z'
  },
  {
    id: 'adg-003',
    name: 'Americas Supervisors',
    distinguishedName: 'CN=CCAAS_AMER_SUPERVISORS,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 24,
    assignedLayouts: ['supervisor'],
    isActive: true,
    createdAt: '2024-02-01T11:00:00Z',
    updatedAt: '2024-03-20T09:45:00Z'
  },
  {
    id: 'adg-004',
    name: 'Global Admins',
    distinguishedName: 'CN=CCAAS_GLOBAL_ADMINS,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 8,
    assignedLayouts: ['admin'],
    isActive: true,
    createdAt: MOCK_CREATED_TIMESTAMP,
    updatedAt: '2024-03-22T16:30:00Z'
  },
  {
    id: 'adg-005',
    name: 'UK Voice Team',
    distinguishedName: 'CN=CCAAS_UK_VOICE,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 67,
    assignedLayouts: ['voice_agent'],
    isActive: true,
    createdAt: '2024-02-10T13:30:00Z',
    updatedAt: '2024-03-19T11:15:00Z'
  },
  {
    id: 'adg-006',
    name: 'HK Chat Team',
    distinguishedName: 'CN=CCAAS_HK_CHAT,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 45,
    assignedLayouts: ['chat_agent'],
    isActive: false,
    createdAt: '2024-02-15T14:00:00Z',
    updatedAt: '2024-03-10T08:30:00Z'
  },
  {
    id: 'adg-007',
    name: 'Singapore Multi-Channel',
    distinguishedName: 'CN=CCAAS_SG_MULTI,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 112,
    assignedLayouts: ['voice_agent', 'chat_agent'],
    isActive: true,
    createdAt: '2024-02-20T10:45:00Z',
    updatedAt: '2024-03-21T15:00:00Z'
  },
  {
    id: 'adg-008',
    name: 'New Team (Unconfigured)',
    distinguishedName: 'CN=CCAAS_NEW_TEAM,OU=CCaaS,DC=corp,DC=example,DC=com',
    memberCount: 0,
    assignedLayouts: [],
    isActive: false,
    createdAt: '2024-03-25T09:00:00Z',
    updatedAt: '2024-03-25T09:00:00Z'
  }
]

// Pending Approvals Mock Data
export const mockPendingApprovals: PendingApproval[] = [
  {
    id: 'pa-001',
    type: 'ad-group',
    action: 'update',
    entityId: 'adg-002',
    entityName: 'EMEA Chat Support',
    requestedBy: 'John Smith',
    requestedAt: '2024-03-24T14:30:00Z',
    changes: {
      permissions: { added: ['banking.transfer'], removed: [] },
      widgets: { added: ['transferWidget'], removed: [] }
    },
    status: 'pending'
  },
  {
    id: 'pa-002',
    type: 'role-template',
    action: 'update',
    entityId: 'voice_agent',
    entityName: 'Voice Agent',
    requestedBy: 'Sarah Johnson',
    requestedAt: '2024-03-23T10:15:00Z',
    changes: {
      permissions: { added: ['customer.edit'], removed: ['customer.delete'] }
    },
    status: 'pending'
  },
  {
    id: 'pa-003',
    type: 'system-notice',
    action: 'create',
    entityId: 'notice-new',
    entityName: 'System Maintenance Notice',
    requestedBy: 'Mike Chen',
    requestedAt: '2024-03-22T16:45:00Z',
    changes: {
      title: 'Scheduled Maintenance',
      message: 'System will be down for maintenance on Saturday',
      type: 'warning'
    },
    status: 'pending'
  },
  {
    id: 'pa-004',
    type: 'ad-group',
    action: 'update',
    entityId: 'adg-005',
    entityName: 'UK Voice Team',
    requestedBy: 'Emma Wilson',
    requestedAt: '2024-03-21T11:00:00Z',
    changes: {
      isActive: false,
      reason: 'Team restructuring'
    },
    status: 'pending'
  },
  {
    id: 'pa-005',
    type: 'ad-group',
    action: 'update',
    entityId: 'adg-007',
    entityName: 'Singapore Multi-Channel',
    requestedBy: 'David Lee',
    requestedAt: '2024-03-20T09:30:00Z',
    changes: {
      permissions: { added: ['escalation.create'], removed: [] }
    },
    status: 'pending'
  }
]

// System Notices Mock Data
export const mockSystemNotices: SystemNotice[] = [
  {
    id: 'notice-001',
    title: 'New Feature: AI Assistant',
    message: 'The AI-powered assistant is now available for all agents. Access it through the Space Copilot panel.',
    type: 'info',
    isActive: true,
    startDate: '2024-03-20T00:00:00Z',
    endDate: '2024-04-20T23:59:59Z',
    createdBy: 'System Admin',
    createdAt: '2024-03-19T15:00:00Z'
  },
  {
    id: 'notice-002',
    title: 'Scheduled Maintenance',
    message: 'The platform will undergo scheduled maintenance on Saturday, March 30th from 2:00 AM to 6:00 AM UTC.',
    type: 'warning',
    isActive: true,
    startDate: '2024-03-25T00:00:00Z',
    endDate: '2024-03-30T06:00:00Z',
    createdBy: 'IT Operations',
    createdAt: '2024-03-22T10:00:00Z'
  },
  {
    id: 'notice-003',
    title: 'Training Session Reminder',
    message: 'Mandatory compliance training must be completed by all agents before March 31st.',
    type: 'warning',
    isActive: true,
    startDate: '2024-03-15T00:00:00Z',
    endDate: '2024-03-31T23:59:59Z',
    createdBy: 'HR Department',
    createdAt: '2024-03-14T09:00:00Z'
  },
  {
    id: 'notice-004',
    title: 'System Update Complete',
    message: 'The latest system update has been successfully deployed. New features include improved call quality and faster search.',
    type: 'success',
    isActive: false,
    startDate: '2024-03-10T00:00:00Z',
    endDate: '2024-03-17T23:59:59Z',
    createdBy: 'System Admin',
    createdAt: '2024-03-10T08:00:00Z'
  },
  {
    id: 'notice-005',
    title: 'Critical: Database Migration',
    message: 'Database migration is in progress. Some features may be temporarily unavailable.',
    type: 'error',
    isActive: false,
    startDate: '2024-03-05T02:00:00Z',
    endDate: '2024-03-05T06:00:00Z',
    createdBy: 'IT Operations',
    createdAt: '2024-03-04T18:00:00Z'
  }
]

// Helper function to simulate API delay
export const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))

// Mock API functions
export const mockApi = {
  getRoleTemplates: async (): Promise<RoleTemplate[]> => {
    await delay(500)
    return mockRoleTemplates
  },

  getAdGroups: async (): Promise<AdGroup[]> => {
    await delay(600)
    return mockAdGroups
  },

  getPendingApprovals: async (): Promise<PendingApproval[]> => {
    await delay(400)
    return mockPendingApprovals
  },

  getSystemNotices: async (): Promise<SystemNotice[]> => {
    await delay(450)
    return mockSystemNotices
  },

  approveChange: async (_id: string): Promise<{ success: boolean }> => {
    await delay(800)
    return { success: true }
  },

  rejectChange: async (_id: string, _reason: string): Promise<{ success: boolean }> => {
    await delay(800)
    return { success: true }
  },

  createNotice: async (notice: Partial<SystemNotice>): Promise<SystemNotice> => {
    await delay(700)
    return {
      ...notice,
      id: `notice-${Date.now()}`,
      createdAt: new Date().toISOString(),
      createdBy: 'Current User'
    } as SystemNotice
  },

  updateNotice: async (id: string, updates: Partial<SystemNotice>): Promise<SystemNotice> => {
    await delay(600)
    const notice = mockSystemNotices.find(n => n.id === id)
    return { ...notice, ...updates } as SystemNotice
  },

  toggleAdGroup: async (_id: string, _isActive: boolean): Promise<{ success: boolean }> => {
    await delay(500)
    return { success: true }
  }
}
===ENDFILE
===FILE: ./src/test-setup.ts
import '@testing-library/jest-dom'

if (typeof globalThis.ResizeObserver === 'undefined') {
  class ResizeObserverMock {
    observe() { /* no-op: mock for testing */ }
    unobserve() { /* no-op: mock for testing */ }
    disconnect() { /* no-op: mock for testing */ }
  }

  // Radix ScrollArea relies on ResizeObserver; jsdom does not provide it.
  globalThis.ResizeObserver = ResizeObserverMock as unknown as typeof ResizeObserver
}
===ENDFILE
===FILE: ./src/types/features/ad-group-config.ts
// User access level for approval workflow
export type UserAccessLevel = 'VIEWER' | 'MAKER' | 'CHECKER' | 'SUPER_ADMIN'

// Base AD Group interface
export interface AdGroup {
  id: string
  groupIdentifier: string
  logicalName?: string
  roleName?: string
  market?: string
  region?: string
  businessUnit?: string
  country?: string
  isActive: boolean
  userCount?: number
  permissionCount?: number
  lastModified?: string
  accessLevel?: UserAccessLevel
  pendingChangeIndicator?: boolean
  versionNumber?: number
  [key: string]: unknown
}

type PermissionStateValue = 'enabled' | 'disabled' | 'hidden' | 'inherited'

// Permission assignment state
export interface PermissionState {
  state: PermissionStateValue
  [key: string]: unknown
}

type PermissionStateMap = Record<string, PermissionState>

// Permission assignments by category
interface PermissionAssignments {
  columnAssignments?: PermissionStateMap
  widgetAssignments?: PermissionStateMap
  featureAssignments?: PermissionStateMap
  settingsTabAssignments?: PermissionStateMap
  settingsOptionAssignments?: PermissionStateMap
  microFrontendAssignments?: PermissionStateMap
}

// Complete AD Group data structure from API
export interface AdGroupData extends AdGroup, PermissionAssignments {
  lastModifiedBy?: string
  success?: boolean
  [key: string]: unknown
}

export interface AdGroupSummaryCounts {
  activeConfigured?: number
  needsConfiguration?: number
}

export interface PagedAdGroupResponse {
  items: AdGroup[]
  page: number
  size: number
  totalElements: number
  totalPages: number
  summary?: AdGroupSummaryCounts
}

// Permission overrides and pending changes
export type PermissionOverrides = Record<string, Record<string, boolean>>

type PendingPermissionChanges = Record<string, Record<string, boolean>>

export interface StagedAppChange {
  appKey: string
  appTitle: string
  previousFunctions: string[]
  newFunctions: string[]
}

export interface PendingChanges {
  businessInfo?: Partial<AdGroup>
  permissions: PendingPermissionChanges
  appChanges?: StagedAppChange[]
}

// Role template structure
export interface RoleTemplate {
  roleName: string
  roleDisplayName?: string
  columns?: PermissionStateMap
  widgets?: PermissionStateMap
  features?: PermissionStateMap
  settings_tabs?: PermissionStateMap
  settings_options?: PermissionStateMap
  micro_frontends?: PermissionStateMap
  [key: string]: unknown
}

// Component props interfaces
export interface AdGroupConfigModalProps {
  group: AdGroup
  open: boolean
  onClose: () => void
  onSave: (group: AdGroup) => void
}
===ENDFILE
===FILE: ./src/types/features/admin.types.ts
export interface CopyOptions {
  copyRoleAndPermissionsFlag?: boolean
  copyBusinessInfoFlag?: boolean
  copyApplicationsFlag?: boolean
  overwriteExistingFlag?: boolean
  copyWorkflowModeCode?: 'SUBMIT_FOR_APPROVAL' | 'DIRECT_SAVE'
  functionMismatchPolicyCode?: 'FAIL_ON_MISMATCH' | 'SKIP_UNAVAILABLE'
}

export interface AdminNoticeRequest {
  title: string
  message: string
  severity: string
  broadcastToAll: boolean
  targetRoles?: string[]
  targetAdGroups?: string[]
  requiresAcknowledgement?: boolean
  startAt?: string
  endAt?: string
  createdBy?: string
}

export interface AdminNoticeResponse {
  id: string
  title: string
  message: string
  severity: string
  status: string
  broadcastToAll: boolean
  targetRoles?: string[]
  targetAdGroups?: string[]
  requiresAcknowledgement: boolean
  startAt?: string
  endAt?: string
  createdBy: string
  createdAt: string
}

export interface CopyResult {
  success: boolean
  message: string
  updatedGroup?: Record<string, unknown>
  error?: string
  errorDetails?: Record<string, unknown>
  workflowStatusCode?: 'DIRECT_APPLIED' | 'SUBMITTED_FOR_APPROVAL'
  pendingChangeIdentifier?: string
  criticalIndicator?: boolean
  levelTwoApprovalRequiredIndicator?: boolean
  unavailableAppFunctionValues?: string[]
}
===ENDFILE
===FILE: ./src/types/features/approval-workflow.types.ts
/**
 * Approval Workflow Types
 * Types for the Maker/Checker admin approval workflow
 */

export type UserAccessLevel = 'VIEWER' | 'MAKER' | 'CHECKER' | 'SUPER_ADMIN'

export type PendingChangeStatus =
  | 'PENDING_LEVEL_ONE'
  | 'PENDING_LEVEL_TWO'
  | 'APPROVED'
  | 'REJECTED'
  | 'CANCELLED'
  | 'EXPIRED'
  | 'MY_SUBMISSIONS'

export type ChangeType = 'CONFIG_UPDATE' | 'APP_UPDATE'

export interface MatchedRule {
  entityType: 'FIELD' | 'APP' | 'FUNCTION'
  entityKey: string
  reason: string
}

export interface AppsChangeDetail {
  added: string[]
  removed: string[]
  unchanged: string[]
}

export interface FunctionChange {
  app: string
  function: string
}

export interface FunctionsChangeDetail {
  added: FunctionChange[]
  removed: FunctionChange[]
  unchanged: FunctionChange[]
}

export interface SubmitterInfo {
  userId: string
  displayName: string
  email: string
}

export interface ApprovalInfo {
  approverUserId: string
  approverName: string
  approvalDateTime: string
  comment?: string
}

export interface PendingChangeDto {
  id: string
  targetGroupIdentifier: string
  targetGroupName: string
  changeType: ChangeType
  status: PendingChangeStatus
  criticalIndicator: boolean
  matchedRules: MatchedRule[]
  submittedBy: SubmitterInfo
  submittedDateTime: string
  expiresDateTime: string
  currentState: Record<string, unknown>
  proposedState: Record<string, unknown>
  appsChanges?: AppsChangeDetail | null
  functionsChanges?: FunctionsChangeDetail | null
  canApproveIndicator: boolean
  canRejectIndicator: boolean
  canCancelIndicator?: boolean
  levelOneApproval?: ApprovalInfo
  levelTwoApproval?: ApprovalInfo
  rejectionReason?: string
  rejectedBy?: SubmitterInfo
  rejectedDateTime?: string
}

export interface PendingChangeCounts {
  pendingLevelOne: number
  pendingLevelTwo: number
  mySubmissions?: number
}

export interface PaginationLinks {
  self: string
  first: string
  prev: string | null
  next: string | null
  last: string
}

export interface PendingChangeListResponse {
  items: PendingChangeDto[]
  counts: PendingChangeCounts
  totalCount: number
  offset: number
  limit: number
  links: PaginationLinks
}

export interface SubmitChangeRequest {
  changeType: ChangeType
  currentState: Record<string, unknown>
  proposedState: Record<string, unknown>
  changedApps?: string[]
  changedFunctions?: string[]
  changedFields?: string[]
  changeDescription?: string
  configVersionNumber?: number
}

export interface SubmitChangeResponse {
  successIndicator: boolean
  directSavedIndicator: boolean
  pendingChangeId: string | null
  status: PendingChangeStatus | 'APPROVED'
  criticalApprovalIndicator: boolean
  message: string
  matchedRules?: MatchedRule[]
}

export interface DirectSaveRequest {
  currentState: Record<string, unknown>
  proposedState: Record<string, unknown>
  changedApps?: string[]
  changedFunctions?: string[]
  changedFields?: string[]
}

export interface DirectSaveResponse {
  successIndicator: boolean
  message: string
}

export interface ApproveChangeRequest {
  comment?: string
}

export interface ApproveChangeResponse {
  successIndicator: boolean
  changeId: string
  newStatus: PendingChangeStatus
  message: string
  appliedDateTime?: string
  escalatedDateTime?: string
}

export interface RejectChangeRequest {
  rejectionReason: string
}

export interface RejectChangeResponse {
  successIndicator: boolean
  changeId: string
  newStatus: 'REJECTED'
  message: string
  rejectedDateTime: string
  notificationSentIndicator: boolean
}

export interface CancelChangeResponse {
  successIndicator: boolean
  changeId: string
  newStatus: 'CANCELLED'
  message: string
}

export interface PendingChangeFilters {
  status?: PendingChangeStatus[]
  offset?: number
  limit?: number
}

export interface AdGroupWithAccess {
  id: string
  groupIdentifier: string
  logicalName: string
  roleName: string
  market?: string
  region?: string
  country?: string
  businessUnit?: string
  activeIndicator: boolean
  userCount?: number
  userAccess: UserAccessLevel
  pendingChangeIndicator: boolean
  pendingChangeId?: string
}

export interface AdGroupListResponse {
  items: AdGroupWithAccess[]
  totalCount: number
  offset: number
  limit: number
  links: PaginationLinks
}

export interface AdGroupFilters {
  market?: string
  role?: string
  status?: string
  search?: string
  offset?: number
  limit?: number
}

export type AuditAction = 'SUBMIT' | 'L1_APPROVE' | 'L2_APPROVE' | 'REJECT' | 'CANCEL' | 'DIRECT_SAVE'

export type ActivityActionFilter = 'all' | 'approvals' | 'rejections' | 'submissions' | 'direct_saves'
export type ActivityTimeRange = 'today' | 'week' | 'month' | 'all'

export interface ActivityLogDto {
  id: string
  action: AuditAction
  targetGroupName: string
  changeType: ChangeType
  criticalIndicator: boolean
  performedAt: string
  performedByRole: string
  completionReason?: string
  escalationReason?: string
}

export interface ActivityListResponse {
  items: ActivityLogDto[]
  totalCount: number
  page: number
  size: number
}
===ENDFILE
===FILE: ./src/types/index.ts
export interface AdminPermissions {
  canPreviewDashboards: boolean
  canViewRoleTemplates: boolean
  canViewAdGroups: boolean
  canViewPendingApprovals: boolean
  canApproveChanges: boolean
  canEditBusinessInfo: boolean
  canEditPermissions: boolean
  canEditApplications: boolean
  canEnableDisableGroups: boolean
  canDirectSave: boolean
  canViewNotices: boolean
  canCreateNotice: boolean
  canEditNotice: boolean
  canPublishNotice: boolean
  canArchiveNotice: boolean
  canSaveDraft: boolean
}

export interface ErrorInfo {
  code: string
  message: string
  context?: Record<string, unknown>
}

export interface AdminMFEProps {
  authToken: string
  permissions?: AdminPermissions
  currentRole?: string
  onNavigate?: (path: string) => void
  onError?: (error: ErrorInfo) => void
}

export type AdminView =
  | 'dashboard'
  | 'ad-groups'
  | 'pending-approvals'
  | 'system-notices'

export interface RoleTemplate {
  id: string
  name: string
  description: string
  permissions: string[]
  widgets: string[]
  createdAt: string
  updatedAt: string
  roleName?: string
  roleDisplayName?: string
}

export interface AdGroup {
  id: string
  name: string
  distinguishedName: string
  memberCount: number
  assignedLayouts: string[]
  isActive: boolean
  createdAt: string
  updatedAt: string
  logicalName?: string
  roleName?: string
  market?: string
  region?: string
  country?: string
  businessUnit?: string
  accessLevel?: 'VIEWER' | 'MAKER' | 'CHECKER' | 'SUPER_ADMIN'
}

export interface PendingApproval {
  id: string
  type: 'role-template' | 'ad-group' | 'system-notice'
  action: 'create' | 'update' | 'delete'
  entityId: string
  entityName: string
  requestedBy: string
  requestedAt: string
  changes: Record<string, unknown>
  status: 'pending' | 'approved' | 'rejected'
}

export interface SystemNotice {
  id: string
  title: string
  message: string
  type: 'info' | 'warning' | 'error' | 'success'
  isActive: boolean
  startDate: string
  endDate: string
  createdBy: string
  createdAt: string
}
===ENDFILE
===FILE: ./src/types/integration/embedded-apps.ts
/**
 * Function definition using API contract naming conventions.
 */
interface FunctionDefinition {
  displayName: string;
  description?: string;
  categoryText?: string;
  searchKeywordValues?: string[];
  requiresApprovalFlag?: boolean;
  mfeConfig?: Record<string, unknown>;
}

/**
 * AD Group access configuration following PAPI naming conventions.
 */
interface AdGroupAccess {
  functionValues: string[];
  lastModifiedByText?: string;
  marketCode?: string;
}

/**
 * Embedded app DTO following PAPI naming conventions.
 * Field mappings from SAPI EmbeddedAppDto:
 * - appIdentifier (internal: appKey)
 * - titleText (internal: title)
 * - descriptionText (internal: description)
 * - categoryName (internal: category)
 * - baseUrlAddress (internal: baseUrl)
 * - isActiveIndicator (internal: isActive)
 * - functionDefinitionsObject (internal: functionDefinitions)
 * - adGroupAccessObject (internal: adGroupAccess)
 * - appFunctionKeys (derived from functionDefinitions keys)
 */
export interface EmbeddedApp {
  appIdentifier: string;
  titleText: string;
  descriptionText: string;
  categoryName: string;
  baseUrlAddress?: string;
  loadingStrategyCode?: string;
  primaryKeywordsText?: string[];
  secondaryKeywordsText?: string[];
  mfeConfigObject?: Record<string, unknown>;
  regionalUrlsObject?: Record<string, unknown>;
  isActiveIndicator: boolean;
  functionDefinitionsObject: Record<string, FunctionDefinition>;
  adGroupAccessObject?: Record<string, AdGroupAccess>;
  appFunctionKeys?: string[];
}

/**
 * Extended app DTO with assignment status for UI display.
 * These fields are computed client-side, not from SAPI.
 */
export interface EmbeddedAppWithStatus extends EmbeddedApp {
  isAssignedIndicator: boolean;
  assignedFunctionKeys: string[];
  defaultFunctionKey?: string;
}
===ENDFILE
===FILE: ./src/types/system/layout-template.ts
/**
 * Shared layout template types for admin preview components
 */

export interface PermissionState {
  state: 'enabled' | 'disabled' | 'hidden' | 'inherited';
  [key: string]: unknown;
}

export interface RoleTemplate {
  roleName: string;
  displayName: string;
  columns: Record<string, PermissionState>;
  widgets: Record<string, PermissionState>;
  features: Record<string, PermissionState>;
  settingsTabs: Record<string, PermissionState>;
  settingsOptions: Record<string, PermissionState>;
  microFrontends: Record<string, PermissionState>;
  [key: string]: unknown;
}
===ENDFILE
===FILE: ./src/utils/admin/__tests__/notice-validators.test.ts
import { describe, expect, it } from 'vitest'
import { hasValue, isConfiguredGroup, isEndDateValid, validateNoticeForm } from '../notice-validators'

describe('hasValue', () => {
  it('returns true for non-empty strings', () => {
    expect(hasValue({ value: 'hello' })).toBe(true)
    expect(hasValue({ value: ' a ' })).toBe(true)
  })

  it('returns false for empty, whitespace-only, null, undefined', () => {
    expect(hasValue({ value: '' })).toBe(false)
    expect(hasValue({ value: '   ' })).toBe(false)
    expect(hasValue({ value: null })).toBe(false)
    expect(hasValue({ value: undefined })).toBe(false)
    expect(hasValue({})).toBe(false)
  })
})

describe('isConfiguredGroup', () => {
  it('returns true when both logicalName and roleName present', () => {
    expect(isConfiguredGroup({
      group: { logicalName: 'Test', roleName: 'voice_agent' } as never
    })).toBe(true)
  })

  it('returns false when logicalName missing', () => {
    expect(isConfiguredGroup({
      group: { roleName: 'voice_agent' } as never
    })).toBe(false)
  })

  it('returns false when roleName missing', () => {
    expect(isConfiguredGroup({
      group: { logicalName: 'Test' } as never
    })).toBe(false)
  })

  it('returns false when both missing', () => {
    expect(isConfiguredGroup({ group: {} as never })).toBe(false)
  })
})

describe('isEndDateValid', () => {
  it('returns true when no dates provided', () => {
    expect(isEndDateValid({})).toBe(true)
    expect(isEndDateValid({ startAt: undefined })).toBe(true)
    expect(isEndDateValid({ endAt: undefined })).toBe(true)
  })

  it('returns true when only startAt provided', () => {
    expect(isEndDateValid({ startAt: '2026-01-01' })).toBe(true)
  })

  it('returns true when end is after start', () => {
    expect(isEndDateValid({ startAt: '2026-01-01', endAt: '2026-02-01' })).toBe(true)
  })

  it('returns false when end is before start', () => {
    expect(isEndDateValid({ startAt: '2026-02-01', endAt: '2026-01-01' })).toBe(false)
  })

  it('returns false when end equals start', () => {
    expect(isEndDateValid({ startAt: '2026-01-01T00:00:00Z', endAt: '2026-01-01T00:00:00Z' })).toBe(false)
  })
})

describe('validateNoticeForm', () => {
  it('returns valid when both title and message present', () => {
    expect(validateNoticeForm({ title: 'T', message: 'M' })).toEqual({ valid: true })
  })

  it('returns invalid when title missing', () => {
    const result = validateNoticeForm({ message: 'M' })
    expect(result.valid).toBe(false)
    expect(result.error).toBe('titleMessageRequired')
  })

  it('returns invalid when message missing', () => {
    const result = validateNoticeForm({ title: 'T' })
    expect(result.valid).toBe(false)
    expect(result.error).toBe('titleMessageRequired')
  })

  it('returns invalid when both missing', () => {
    const result = validateNoticeForm({})
    expect(result.valid).toBe(false)
  })

  it('returns invalid for empty strings', () => {
    const result = validateNoticeForm({ title: '', message: '' })
    expect(result.valid).toBe(false)
  })
})
===ENDFILE
===FILE: ./src/utils/admin/__tests__/permission-hierarchy-sorter.test.ts
import { describe, expect, it, vi } from 'vitest'

vi.mock('../../../components/admin/business-relevant-toggles', () => ({
  businessRelevantToggles: {
    capabilities: {
      toggles: {
        'columns.kms': { businessName: 'Knowledge Base', section: 'Dashboard Access', linkedKeys: ['features.search.knowledgeBase'] },
        'columns.embeddedApps': { businessName: 'Banking Applications', section: 'Dashboard Access', linkedKeys: ['features.search.embeddedApps'] },
        'columns.spaceCopilot': { businessName: 'AI Assistant', section: 'Dashboard Access', linkedKeys: ['micro_frontends.spaceCopilot'] },
        'columns.chat': { businessName: 'Chat Interface', section: 'Dashboard Access' },
        'micro_frontends.mediaBar': { businessName: 'Media Controls', section: 'Platform Apps', linkedKeys: ['widgets.mediaBar.callControls'] }
      }
    },
    workspacePreferences: {
      toggles: {
        'settings_options.calls.autoAccept': { businessName: 'Auto-Accept Calls', section: 'Call Preferences' },
        'settings_options.calls.doNotDisturb.duration': { businessName: 'Do Not Disturb', section: 'Call Preferences' },
        'settings_options.interface.showTranscript': { businessName: 'Show Transcripts', section: 'Privacy & Display' },
        'settings_options.interface.autoCloseKnowledgeOnCallEnd': { businessName: 'Auto-Close Knowledge', section: 'Privacy & Display' },
        'settings_options.interface.spaceCopilotMode': { businessName: 'AI Assistant Mode', section: 'AI Preference' }
      }
    }
  }
}))

const { sortWithHierarchy } = await import('../permission-hierarchy-sorter')

describe('sortWithHierarchy', () => {
  it('sorts by section order for capabilities', () => {
    const keys = [
      'columns.kms',
      'micro_frontends.mediaBar',
      'columns.embeddedApps'
    ]

    const result = sortWithHierarchy({ keys, levelKey: 'capabilities' })

    const kmsIdx = result.indexOf('columns.kms')
    const mediaIdx = result.indexOf('micro_frontends.mediaBar')

    // Dashboard Access items come before Platform Apps
    expect(kmsIdx).toBeLessThan(mediaIdx)
  })

  it('sorts workspacePreferences by section', () => {
    const keys = [
      'settings_options.calls.autoAccept',
      'settings_options.interface.showTranscript',
      'settings_options.interface.spaceCopilotMode'
    ]

    const result = sortWithHierarchy({ keys, levelKey: 'workspacePreferences' })

    const autoAcceptIdx = result.indexOf('settings_options.calls.autoAccept')
    const transcriptIdx = result.indexOf('settings_options.interface.showTranscript')
    const copilotIdx = result.indexOf('settings_options.interface.spaceCopilotMode')

    // Call Preferences first, then Privacy & Display, then AI Preference
    expect(autoAcceptIdx).toBeLessThan(transcriptIdx)
    expect(transcriptIdx).toBeLessThan(copilotIdx)
  })

  it('handles empty keys array', () => {
    expect(sortWithHierarchy({ keys: [], levelKey: 'capabilities' })).toEqual([])
  })

  it('handles unknown level key', () => {
    const result = sortWithHierarchy({ keys: ['a', 'b'], levelKey: 'nonexistent' })
    expect(result).toHaveLength(2)
  })
})
===ENDFILE
===FILE: ./src/utils/admin/__tests__/permission-level-resolver.test.ts
import { describe, expect, it } from 'vitest'
import { resolvePermissionLevel, resolveLinkedKey, COMPOUND_LEVELS } from '../permission-level-resolver'

describe('resolvePermissionLevel', () => {
  it('passes through non-compound levels unchanged', () => {
    expect(resolvePermissionLevel({ level: 'columns', key: 'kms' })).toEqual({
      actualLevel: 'columns',
      actualKey: 'kms'
    })

    expect(resolvePermissionLevel({ level: 'features', key: 'search.global' })).toEqual({
      actualLevel: 'features',
      actualKey: 'search.global'
    })

    expect(resolvePermissionLevel({ level: 'widgets', key: 'customer.info' })).toEqual({
      actualLevel: 'widgets',
      actualKey: 'customer.info'
    })
  })

  it('resolves capabilities with columns prefix', () => {
    expect(resolvePermissionLevel({ level: 'capabilities', key: 'columns.spaceCopilot' })).toEqual({
      actualLevel: 'columns',
      actualKey: 'spaceCopilot'
    })

    expect(resolvePermissionLevel({ level: 'capabilities', key: 'columns.kms' })).toEqual({
      actualLevel: 'columns',
      actualKey: 'kms'
    })
  })

  it('resolves capabilities with features prefix', () => {
    expect(resolvePermissionLevel({ level: 'capabilities', key: 'features.search.knowledgeBase' })).toEqual({
      actualLevel: 'features',
      actualKey: 'search.knowledgeBase'
    })
  })

  it('resolves capabilities with micro_frontends prefix', () => {
    expect(resolvePermissionLevel({ level: 'capabilities', key: 'micro_frontends.mediaBar' })).toEqual({
      actualLevel: 'micro_frontends',
      actualKey: 'mediaBar'
    })

    expect(resolvePermissionLevel({ level: 'capabilities', key: 'micro_frontends.spaceCopilot' })).toEqual({
      actualLevel: 'micro_frontends',
      actualKey: 'spaceCopilot'
    })
  })

  it('resolves workspacePreferences with widgets prefix', () => {
    expect(resolvePermissionLevel({ level: 'workspacePreferences', key: 'widgets.customer.info' })).toEqual({
      actualLevel: 'widgets',
      actualKey: 'customer.info'
    })
  })

  it('resolves workspacePreferences with settings_tabs prefix', () => {
    expect(resolvePermissionLevel({ level: 'workspacePreferences', key: 'settings_tabs.help' })).toEqual({
      actualLevel: 'settings_tabs',
      actualKey: 'help'
    })
  })

  it('resolves workspacePreferences with settings_options prefix', () => {
    expect(resolvePermissionLevel({ level: 'workspacePreferences', key: 'settings_options.calls.autoAccept' })).toEqual({
      actualLevel: 'settings_options',
      actualKey: 'calls.autoAccept'
    })
  })

  it('handles capabilities key with no dots via fallback', () => {
    const result = resolvePermissionLevel({ level: 'capabilities', key: 'standalone' })
    expect(result.actualLevel).toBe('standalone')
    expect(result.actualKey).toBe('')
  })
})

describe('resolveLinkedKey', () => {
  it('resolves known section prefix (features)', () => {
    expect(resolveLinkedKey('features.search.knowledgeBase')).toEqual({
      actualLevel: 'features',
      actualKey: 'search.knowledgeBase'
    })
  })

  it('resolves known section prefix (micro_frontends)', () => {
    expect(resolveLinkedKey('micro_frontends.spaceCopilot')).toEqual({
      actualLevel: 'micro_frontends',
      actualKey: 'spaceCopilot'
    })
  })

  it('resolves known section prefix (widgets)', () => {
    expect(resolveLinkedKey('widgets.mediaBar.callControls')).toEqual({
      actualLevel: 'widgets',
      actualKey: 'mediaBar.callControls'
    })
  })

  it('falls back to splitting on first dot for unknown prefixes', () => {
    expect(resolveLinkedKey('unknown.section.key')).toEqual({
      actualLevel: 'unknown',
      actualKey: 'section.key'
    })
  })
})

describe('COMPOUND_LEVELS', () => {
  it('defines capabilities sections', () => {
    expect(COMPOUND_LEVELS.capabilities).toEqual(['columns', 'features', 'micro_frontends'])
  })

  it('defines workspacePreferences sections', () => {
    expect(COMPOUND_LEVELS.workspacePreferences).toEqual(['widgets', 'settings_tabs', 'settings_options'])
  })
})
===ENDFILE
===FILE: ./src/utils/admin/notice-validators.ts
import type { AdGroup } from '../../types/features/ad-group-config'

export function hasValue({ value }: { value?: string | null }): boolean {
  return Boolean(value && value.trim().length > 0)
}

export function isConfiguredGroup({ group }: { group: AdGroup }): boolean {
  return (
    hasValue({ value: group.logicalName }) &&
    hasValue({ value: group.roleName })
  )
}

export function isEndDateValid({ startAt, endAt }: { startAt?: string; endAt?: string }): boolean {
  if (!startAt || !endAt) {
    return true
  }
  const start = new Date(startAt)
  const end = new Date(endAt)
  return end > start
}

export function validateNoticeForm({ title, message }: { title?: string; message?: string }): { valid: boolean; error?: string } {
  if (!title || !message) {
    return {
      valid: false,
      error: 'titleMessageRequired'
    }
  }

  return { valid: true }
}
===ENDFILE
===FILE: ./src/utils/admin/permission-hierarchy-sorter.ts
import { businessRelevantToggles } from '../../components/admin/business-relevant-toggles'

export function sortWithHierarchy({ keys, levelKey }: { keys: string[]; levelKey: string }): string[] {
  const sorted: string[] = []
  const childrenMap: Record<string, string[]> = {}

  keys.forEach(key => {
    const config = businessRelevantToggles[levelKey]?.toggles[key]
    const parentKey = config?.parent
    if (parentKey) {
      if (!childrenMap[parentKey]) {
        childrenMap[parentKey] = []
      }
      childrenMap[parentKey].push(key)
    }
  })

  const topLevelKeys = keys.filter(key => {
    const config = businessRelevantToggles[levelKey]?.toggles[key]
    return !config?.parent
  })

  // Sort by section order (preserving first-appearance order of sections)
  const sectionOrder: string[] = []
  topLevelKeys.forEach(key => {
    const section = businessRelevantToggles[levelKey]?.toggles[key]?.section || ''
    if (!sectionOrder.includes(section)) {
      sectionOrder.push(section)
    }
  })

  topLevelKeys.sort((a, b) => {
    const sectionA = businessRelevantToggles[levelKey]?.toggles[a]?.section || ''
    const sectionB = businessRelevantToggles[levelKey]?.toggles[b]?.section || ''
    return sectionOrder.indexOf(sectionA) - sectionOrder.indexOf(sectionB)
  })

  topLevelKeys.forEach(key => {
    sorted.push(key)
    if (childrenMap[key]) {
      sorted.push(...childrenMap[key])
    }
  })

  return sorted
}
===ENDFILE
===FILE: ./src/utils/admin/permission-level-resolver.ts
/**
 * Permission Level Resolver - Shared utility for resolving actual permission levels
 * Handles compound UI levels (capabilities, workspacePreferences) that merge multiple template sections
 */

interface ResolvedPermissionLevel {
  actualLevel: string
  actualKey: string
}

/**
 * Compound levels map a single UI section to multiple template sections.
 * The key prefix in the permission key determines which template section it belongs to.
 */
const COMPOUND_LEVELS: Record<string, string[]> = {
  capabilities: ['columns', 'features', 'micro_frontends'],
  workspacePreferences: ['widgets', 'settings_tabs', 'settings_options']
}

/**
 * Resolve the actual permission level and key from display level and key.
 * For compound levels (capabilities, workspacePreferences), the key prefix determines the actual level.
 *
 * @example
 * resolvePermissionLevel({ level: 'capabilities', key: 'columns.spaceCopilot' })
 * // => { actualLevel: 'columns', actualKey: 'spaceCopilot' }
 *
 * resolvePermissionLevel({ level: 'capabilities', key: 'micro_frontends.mediaBar' })
 * // => { actualLevel: 'micro_frontends', actualKey: 'mediaBar' }
 *
 * resolvePermissionLevel({ level: 'workspacePreferences', key: 'settings_tabs.help' })
 * // => { actualLevel: 'settings_tabs', actualKey: 'help' }
 *
 * resolvePermissionLevel({ level: 'widgets', key: 'customer.info' })
 * // => { actualLevel: 'widgets', actualKey: 'customer.info' }
 */
export function resolvePermissionLevel({
  level,
  key
}: {
  level: string
  key: string
}): ResolvedPermissionLevel {
  const knownPrefixes = COMPOUND_LEVELS[level]
  if (!knownPrefixes) {
    return { actualLevel: level, actualKey: key }
  }

  for (const prefix of knownPrefixes) {
    if (key.startsWith(prefix + '.')) {
      return {
        actualLevel: prefix,
        actualKey: key.slice(prefix.length + 1)
      }
    }
  }

  // Fallback for unrecognized prefixes
  const [fallbackPrefix, ...rest] = key.split('.')
  return { actualLevel: fallbackPrefix, actualKey: rest.join('.') }
}

/**
 * Resolve a linked key string (e.g., 'micro_frontends.spaceCopilot') into its
 * actual template section and key. Uses COMPOUND_LEVELS to match known section
 * prefixes, falling back to splitting on the first dot.
 */
export function resolveLinkedKey(linkedKey: string): { actualLevel: string; actualKey: string } {
  const allSections = Object.values(COMPOUND_LEVELS).flat()
  for (const section of allSections) {
    if (linkedKey.startsWith(section + '.')) {
      return { actualLevel: section, actualKey: linkedKey.slice(section.length + 1) }
    }
  }
  const [level, ...rest] = linkedKey.split('.')
  return { actualLevel: level, actualKey: rest.join('.') }
}

export { COMPOUND_LEVELS }
===ENDFILE
===FILE: ./src/utils/api/__tests__/response-handler.test.ts
import { describe, expect, it, vi } from 'vitest'
import { handleApiResponse, handleApiResponseSafe, handleApiResponseWithTransform } from '../response-handler'

function makeResponse(body: unknown, status = 200, headers?: Record<string, string>): Response {
  const responseHeaders = new Headers(headers)
  if (!responseHeaders.has('content-type')) {
    responseHeaders.set('content-type', 'application/json')
  }
  return {
    ok: status >= 200 && status < 300,
    status,
    statusText: status === 200 ? 'OK' : 'Error',
    url: 'http://localhost/papi/v1/test',
    headers: responseHeaders,
    json: () => Promise.resolve(body),
    text: () => Promise.resolve(typeof body === 'string' ? body : JSON.stringify(body)),
    clone: function () { return { ...this, text: () => Promise.resolve(typeof body === 'string' ? body : JSON.stringify(body)) } as Response }
  } as unknown as Response
}

describe('handleApiResponse', () => {
  it('returns parsed JSON on success', async () => {
    const data = { data: { items: [] } }
    const result = await handleApiResponse<typeof data>({
      response: makeResponse(data),
      context: 'Test'
    })
    expect(result).toEqual(data)
  })

  it('throws on non-ok response', async () => {
    await expect(
      handleApiResponse({ response: makeResponse({}, 500), context: 'Test' })
    ).rejects.toThrow('HTTP 500')
  })

  it('detects HTML responses and throws proxy error', async () => {
    const htmlResponse = {
      ok: true,
      status: 200,
      url: 'http://localhost/papi/v1/test',
      headers: new Headers({ 'content-type': 'text/html' }),
      json: () => { throw new Error('not json') },
      clone: () => ({
        text: () => Promise.resolve('<!DOCTYPE html><html>')
      })
    } as unknown as Response

    await expect(
      handleApiResponse({ response: htmlResponse, context: 'TestContext' })
    ).rejects.toThrow('Expected JSON')
  })

  it('throws generic parse error for non-HTML parse failures', async () => {
    const badResponse = {
      ok: true,
      status: 200,
      url: 'http://localhost/papi/v1/test',
      headers: new Headers({ 'content-type': 'application/json' }),
      json: () => { throw new Error('bad json') },
      clone: () => ({
        text: () => Promise.resolve('not html just garbage')
      })
    } as unknown as Response

    await expect(
      handleApiResponse({ response: badResponse, context: 'ParseTest' })
    ).rejects.toThrow('Failed to parse ParseTest response')
  })
})

describe('handleApiResponseSafe', () => {
  it('returns parsed JSON on success', async () => {
    const data = { result: 'ok' }
    const result = await handleApiResponseSafe<typeof data, { error: string }>({
      response: makeResponse(data),
      errorTransform: (status) => ({ error: `Error ${status}` })
    })
    expect(result).toEqual(data)
  })

  it('returns error result on non-ok response', async () => {
    const result = await handleApiResponseSafe<unknown, { error: string; status: number }>({
      response: makeResponse({}, 404),
      errorTransform: (status, statusText) => ({ error: statusText, status })
    })
    expect(result).toEqual({ error: 'Error', status: 404 })
  })

  it('returns error for HTML response on parse failure', async () => {
    const htmlResponse = {
      ok: true,
      status: 200,
      url: 'http://localhost/test',
      headers: new Headers({ 'content-type': 'text/html' }),
      json: () => { throw new Error('not json') },
      clone: () => ({
        text: () => Promise.resolve('<html>')
      })
    } as unknown as Response

    const result = await handleApiResponseSafe<unknown, { status: number }>({
      response: htmlResponse,
      errorTransform: (status) => ({ status })
    })
    expect(result).toEqual({ status: 502 })
  })

  it('returns JSON_PARSE_ERROR for non-HTML parse failure', async () => {
    const badResponse = {
      ok: true,
      status: 200,
      url: 'http://localhost/test',
      headers: new Headers({ 'content-type': 'application/json' }),
      json: () => { throw new Error('bad') },
      clone: () => ({
        text: () => Promise.resolve('not html')
      })
    } as unknown as Response

    const result = await handleApiResponseSafe<unknown, { status: number }>({
      response: badResponse,
      errorTransform: (status) => ({ status })
    })
    expect(result).toEqual({ status: 500 })
  })
})

describe('handleApiResponseWithTransform', () => {
  it('returns parsed JSON without transform', async () => {
    const data = { items: [1, 2] }
    const result = await handleApiResponseWithTransform<typeof data>({
      response: makeResponse(data),
      errorMessage: 'Failed'
    })
    expect(result).toEqual(data)
  })

  it('applies transform function', async () => {
    const data = { items: [1, 2, 3] }
    const result = await handleApiResponseWithTransform<typeof data, number>({
      response: makeResponse(data),
      errorMessage: 'Failed',
      transform: (d) => d?.items.length ?? 0
    })
    expect(result).toBe(3)
  })

  it('throws with error text on non-ok response', async () => {
    const response = {
      ok: false,
      status: 400,
      text: () => Promise.resolve('Bad request body')
    } as unknown as Response

    await expect(
      handleApiResponseWithTransform({
        response,
        errorMessage: 'Failed to fetch'
      })
    ).rejects.toThrow('Failed to fetch (400): Bad request body')
  })

  it('handles null data with transform', async () => {
    const badJsonResponse = {
      ok: true,
      status: 200,
      json: () => { throw new Error('parse error') }
    } as unknown as Response

    const result = await handleApiResponseWithTransform<unknown, string>({
      response: badJsonResponse,
      errorMessage: 'Failed',
      transform: (d) => d === null ? 'fallback' : 'data'
    })
    expect(result).toBe('fallback')
  })
})
===ENDFILE
===FILE: ./src/utils/api/response-handler.ts
/**
 * API Response Handler - Shared utilities for handling API responses
 * Eliminates duplicate error handling and JSON parsing across services
 */

/* eslint-disable no-console */

/**
 * Parse JSON with fallback to null on error
 * @param response Fetch response object
 * @returns Parsed JSON or null on parse failure
 */
async function parseJsonSafe<T>(response: Response): Promise<T | null> {
  try {
    return await response.json() as T
  } catch {
    return null
  }
}

function isLikelyHtmlResponse(contentType: string, bodyPreview: string): boolean {
  const normalizedType = contentType.toLowerCase()
  const normalizedPreview = bodyPreview.trim().toLowerCase()

  return normalizedType.includes('text/html')
    || normalizedPreview.startsWith('<!doctype')
    || normalizedPreview.startsWith('<html')
}

function createNonJsonResponseError(context: string, response: Response): Error {
  return new Error(
    `[${context}] Expected JSON from ${response.url}, but received HTML. `
    + 'Check Vite /papi proxy configuration (VITE_PAPI_PROXY_TARGET).'
  )
}

/**
 * Handle API response with standard error checking and JSON parsing
 * @param response Fetch response object
 * @param context Context for error logging (e.g., 'AdminService.getAllAdGroups')
 * @returns Parsed JSON response
 * @throws Error if response not ok or JSON parsing fails
 */
export async function handleApiResponse<T>({
  response,
  context
}: {
  response: Response
  context: string
}): Promise<T> {
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
  }

  const responseCopy = typeof response.clone === 'function' ? response.clone() : null

  try {
    return await response.json() as T
  } catch (error) {
    const contentType = response.headers.get('content-type') ?? ''
    const bodyPreview = responseCopy
      ? (await responseCopy.text().catch(() => '')).slice(0, 120)
      : ''

    if (isLikelyHtmlResponse(contentType, bodyPreview)) {
      const proxyError = createNonJsonResponseError(context, response)
      console.error(proxyError.message, {
        status: response.status,
        contentType,
        bodyPreview
      })
      throw proxyError
    }

    console.error(`[${context}] Failed to parse response:`, error)
    throw new Error(`Failed to parse ${context} response`)
  }
}

/**
 * Handle API response with custom error result type (for methods that don't throw)
 * @param response Fetch response object
 * @param errorTransform Function to transform error into custom result type
 * @returns Parsed JSON response or transformed error
 */
export async function handleApiResponseSafe<T, E>({
  response,
  errorTransform
}: {
  response: Response
  errorTransform: (status: number, statusText: string, errorData?: Record<string, unknown>) => E
}): Promise<T | E> {
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}))
    return errorTransform(response.status, response.statusText, errorData)
  }

  const responseCopy = typeof response.clone === 'function' ? response.clone() : null

  try {
    return await response.json() as T
  } catch {
    const contentType = response.headers.get('content-type') ?? ''
    const bodyPreview = responseCopy
      ? (await responseCopy.text().catch(() => '')).slice(0, 120)
      : ''

    if (isLikelyHtmlResponse(contentType, bodyPreview)) {
      return errorTransform(502, 'NON_JSON_RESPONSE', {
        message: createNonJsonResponseError('handleApiResponseSafe', response).message,
        contentType,
        bodyPreview
      })
    }

    return errorTransform(500, 'JSON_PARSE_ERROR', {})
  }
}

/**
 * Handle API response with text-based error messages and optional transformation
 * Used for search/query endpoints that return text errors instead of JSON
 * @param response Fetch response object
 * @param errorMessage Error message prefix (e.g., 'Failed to get popular apps')
 * @param transform Optional transformation function to apply to parsed data
 * @returns Parsed and optionally transformed response
 * @throws Error with text-based error message if response not ok
 */
export async function handleApiResponseWithTransform<TInput, TOutput = TInput>({
  response,
  errorMessage,
  transform
}: {
  response: Response
  errorMessage: string
  transform?: (data: TInput | null) => TOutput
}): Promise<TOutput> {
  if (!response.ok) {
    const errorText = await response.text().catch(() => 'Unknown error')
    throw new Error(`${errorMessage} (${response.status}): ${errorText}`)
  }

  const data = await parseJsonSafe<TInput>(response)

  if (transform) {
    return transform(data)
  }

  return data as unknown as TOutput
}
===ENDFILE
===FILE: ./src/utils/auth/__tests__/auth-token-manager.test.ts
// @vitest-environment jsdom
import { beforeEach, describe, expect, it, vi } from 'vitest'

vi.mock('@/utils/core/debug', () => ({
  createLogger: () => ({
    trace: vi.fn(),
    debug: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn()
  })
}))

vi.mock('@/utils/core/error-tracking', () => ({
  logErrorToTracking: vi.fn()
}))

const {
  setAuthToken,
  getAuthToken,
  clearAuthToken,
  hydrateAuthTokenFromLegacyStorage,
  isSessionStorageAvailable
} = await import('../auth-token-manager')

describe('auth-token-manager', () => {
  beforeEach(() => {
    clearAuthToken()
    vi.clearAllMocks()
    window.sessionStorage.clear()
    window.localStorage.clear()
  })

  describe('setAuthToken / getAuthToken', () => {
    it('stores and retrieves token from memory', () => {
      setAuthToken('my-token')
      expect(getAuthToken()).toBe('my-token')
    })

    it('persists token to sessionStorage', () => {
      setAuthToken('persisted-token')
      expect(window.sessionStorage.getItem('ccaas-session-token')).toBe('persisted-token')
    })

    it('falls back to sessionStorage when in-memory token is absent', () => {
      // Directly set sessionStorage (bypassing setAuthToken so in-memory stays null)
      clearAuthToken()
      window.sessionStorage.setItem('ccaas-session-token', 'stored-token')

      const token = getAuthToken()
      expect(token).toBe('stored-token')
    })
  })

  describe('clearAuthToken', () => {
    it('removes token from memory and storage', () => {
      setAuthToken('to-clear')
      clearAuthToken()
      expect(getAuthToken()).toBeNull()
      expect(window.sessionStorage.getItem('ccaas-session-token')).toBeNull()
    })
  })

  describe('hydrateAuthTokenFromLegacyStorage', () => {
    it('migrates token from localStorage to sessionStorage', () => {
      window.localStorage.setItem('authToken', 'legacy-token')

      hydrateAuthTokenFromLegacyStorage()

      expect(getAuthToken()).toBe('legacy-token')
      expect(window.localStorage.getItem('authToken')).toBeNull()
    })

    it('does nothing when no legacy token exists', () => {
      hydrateAuthTokenFromLegacyStorage()
      expect(getAuthToken()).toBeNull()
    })
  })

  describe('isSessionStorageAvailable', () => {
    it('returns true in test environment', () => {
      expect(isSessionStorageAvailable()).toBe(true)
    })
  })
})
===ENDFILE
===FILE: ./src/utils/auth/auth-token-manager.ts
import { createLogger } from '@/utils/core/debug'
import { logErrorToTracking } from '@/utils/core/error-tracking'

const TOKEN_STORAGE_KEY = 'ccaas-session-token'

let inMemoryToken: string | null = null

const logger = createLogger('AUTH_TOKEN_MANAGER')

function isBrowserEnvironment(): boolean {
  return typeof window !== 'undefined'
}

function readFromSessionStorage(): string | null {
  if (!isBrowserEnvironment()) {
    return null
  }

  try {
    return window.sessionStorage.getItem(TOKEN_STORAGE_KEY)
  } catch (error) {
    logger.warn('SessionStorage read failed', {
      error,
      key: TOKEN_STORAGE_KEY
    })

    logErrorToTracking('SESSION_STORAGE_READ_FAILED', {
      error: error instanceof Error ? error.message : String(error),
      key: TOKEN_STORAGE_KEY
    })

    return null
  }
}

function writeToSessionStorage(token: string | null): void {
  if (!isBrowserEnvironment()) {
    return
  }

  try {
    if (token) {
      window.sessionStorage.setItem(TOKEN_STORAGE_KEY, token)
    } else {
      window.sessionStorage.removeItem(TOKEN_STORAGE_KEY)
    }
  } catch (error) {
    logger.warn('SessionStorage write failed', {
      error,
      hasToken: Boolean(token)
    })

    logErrorToTracking('SESSION_STORAGE_WRITE_FAILED', {
      error: error instanceof Error ? error.message : String(error),
      hasToken: Boolean(token)
    })
  }
}

export function setAuthToken(token: string): void {
  inMemoryToken = token
  writeToSessionStorage(token)
}

export function getAuthToken(): string | null {
  if (inMemoryToken) {
    return inMemoryToken
  }

  const stored = readFromSessionStorage()
  if (stored) {
    inMemoryToken = stored
  }

  return inMemoryToken
}

export function clearAuthToken(): void {
  inMemoryToken = null
  writeToSessionStorage(null)
}

export function hydrateAuthTokenFromLegacyStorage(): void {
  if (!isBrowserEnvironment()) {
    return
  }

  try {
    const legacyToken = window.localStorage.getItem('authToken')
    if (legacyToken) {
      setAuthToken(legacyToken)
      window.localStorage.removeItem('authToken')
    }
  } catch (error) {
    logger.warn('Legacy token migration failed', { error })
  }
}

export function isSessionStorageAvailable(): boolean {
  if (!isBrowserEnvironment()) {
    return false
  }

  try {
    const probeKey = '__session_probe__'
    window.sessionStorage.setItem(probeKey, 'ok')
    window.sessionStorage.removeItem(probeKey)
    return true
  } catch (error) {
    logger.warn('SessionStorage availability check failed', { error })
    return false
  }
}
===ENDFILE
===FILE: ./src/utils/core/__tests__/debug.test.ts
import { describe, expect, it, vi } from 'vitest'
import { createLogger } from '../debug'

describe('createLogger', () => {
  it('creates a logger with all log level methods', () => {
    const logger = createLogger('TestContext')
    expect(logger).toHaveProperty('trace')
    expect(logger).toHaveProperty('debug')
    expect(logger).toHaveProperty('info')
    expect(logger).toHaveProperty('warn')
    expect(logger).toHaveProperty('error')
  })

  it('logs messages with context prefix', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    const logger = createLogger('MyModule')

    logger.error('something went wrong')

    expect(spy).toHaveBeenCalledTimes(1)
    const loggedMessage = spy.mock.calls[0][0] as string
    expect(loggedMessage).toContain('MyModule')
    expect(loggedMessage).toContain('ERROR')
    expect(loggedMessage).toContain('something went wrong')

    spy.mockRestore()
  })

  it('logs messages with data when provided', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    const logger = createLogger('TestCtx')

    logger.error('err msg', { detail: 'extra' })

    expect(spy).toHaveBeenCalledTimes(1)
    expect(spy.mock.calls[0]).toHaveLength(2)
    expect(spy.mock.calls[0][1]).toEqual({ detail: 'extra' })

    spy.mockRestore()
  })

  it('uses default context when empty string provided', () => {
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {})
    const logger = createLogger('')

    logger.error('test')

    const loggedMessage = spy.mock.calls[0][0] as string
    expect(loggedMessage).toContain('agent-frontend')

    spy.mockRestore()
  })

  it('calls warn method on console.warn', () => {
    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {})
    const logger = createLogger('WarnTest')

    logger.warn('warning message')

    expect(spy).toHaveBeenCalledTimes(1)
    const loggedMessage = spy.mock.calls[0][0] as string
    expect(loggedMessage).toContain('WARN')

    spy.mockRestore()
  })

  it('calls info method on console.info', () => {
    const spy = vi.spyOn(console, 'info').mockImplementation(() => {})
    const logger = createLogger('InfoTest')

    logger.info('info message')

    expect(spy).toHaveBeenCalledTimes(1)
    const loggedMessage = spy.mock.calls[0][0] as string
    expect(loggedMessage).toContain('INFO')

    spy.mockRestore()
  })
})
===ENDFILE
===FILE: ./src/utils/core/__tests__/error-tracking.test.ts
// @vitest-environment jsdom
import { beforeEach, describe, expect, it, vi } from 'vitest'
import { logErrorToTracking } from '../error-tracking'

describe('logErrorToTracking', () => {
  const windowWithTracking = window as unknown as Record<string, unknown>

  beforeEach(() => {
    // Clean up any mock service
    delete windowWithTracking.errorTrackingService
  })

  it('calls service logError when available', () => {
    const logError = vi.fn()
    windowWithTracking.errorTrackingService = { logError }

    logErrorToTracking('TEST_ERROR', { key: 'value' })

    expect(logError).toHaveBeenCalledWith('TEST_ERROR', { key: 'value' })
  })

  it('does nothing when service is not available', () => {
    // No error tracking service on window
    expect(() => logErrorToTracking('TEST', {})).not.toThrow()
  })

  it('does nothing when logError method missing', () => {
    windowWithTracking.errorTrackingService = {}
    expect(() => logErrorToTracking('TEST', {})).not.toThrow()
  })
})
===ENDFILE
===FILE: ./src/utils/core/debug.ts
/* eslint-disable no-console */

// Log levels in ascending verbosity order
enum LogLevel {
  TRACE = 0,
  DEBUG = 1,
  INFO = 2,
  WARN = 3,
  ERROR = 4
}

const LEVEL_TO_CONSOLE: Record<LogLevel, keyof Console> = {
  [LogLevel.TRACE]: 'debug',
  [LogLevel.DEBUG]: 'debug',
  [LogLevel.INFO]: 'info',
  [LogLevel.WARN]: 'warn',
  [LogLevel.ERROR]: 'error'
}

const LEVEL_NAME: Record<LogLevel, string> = {
  [LogLevel.TRACE]: 'TRACE',
  [LogLevel.DEBUG]: 'DEBUG',
  [LogLevel.INFO]: 'INFO',
  [LogLevel.WARN]: 'WARN',
  [LogLevel.ERROR]: 'ERROR'
}

function parseLevel(rawLevel: unknown): LogLevel {
  if (!rawLevel || typeof rawLevel !== 'string') {
    return LogLevel.INFO
  }

  const normalised = rawLevel.toLowerCase()
  switch (normalised) {
    case 'trace':
      return LogLevel.TRACE
    case 'debug':
      return LogLevel.DEBUG
    case 'info':
      return LogLevel.INFO
    case 'warn':
    case 'warning':
      return LogLevel.WARN
    case 'error':
      return LogLevel.ERROR
    default:
      return LogLevel.INFO
  }
}

function resolveLogLevel(): LogLevel {
  try {
    const envLevel = import.meta.env?.VITE_LOG_LEVEL ?? import.meta.env?.VITE_AGENT_FRONTEND_LOG_LEVEL
    if (envLevel) {
      return parseLevel(envLevel)
    }

    const storedLevel = typeof window !== 'undefined' ? window.localStorage?.getItem('AGENT_FRONTEND_LOG_LEVEL') : undefined
    if (storedLevel) {
      return parseLevel(storedLevel)
    }

    if (import.meta.env?.MODE === 'development' || import.meta.env?.MODE === 'test') {
      return LogLevel.DEBUG
    }
  } catch {
    // Log level resolution failure handled silently
  }

  return LogLevel.INFO
}

const currentLevel = resolveLogLevel()

function shouldLog(level: LogLevel): boolean {
  return level >= currentLevel
}

function log(level: LogLevel, context: string, message: string, data?: unknown): void {
  if (!shouldLog(level)) {
    return
  }

  const methodName = LEVEL_TO_CONSOLE[level]

  const method = (...args: unknown[]) => {
    switch (methodName) {
      case 'debug':
        console.debug(...args)
        break
      case 'info':
        console.info(...args)
        break
      case 'warn':
        console.warn(...args)
        break
      case 'error':
        console.error(...args)
        break
      default:
        console.log(...args)
        break
    }
  }
  const timestamp = new Date().toISOString()

  if (typeof data === 'undefined') {
    method(`[${timestamp}] [${LEVEL_NAME[level]}] [${context}] ${message}`)
    return
  }

  method(`[${timestamp}] [${LEVEL_NAME[level]}] [${context}] ${message}`, data)
}

function traceLog(context: string, message: string, data?: unknown): void {
  log(LogLevel.TRACE, context, message, data)
}

function debugLog(context: string, message: string, data?: unknown): void {
  log(LogLevel.DEBUG, context, message, data)
}

function infoLog(context: string, message: string, data?: unknown): void {
  log(LogLevel.INFO, context, message, data)
}

function warnLog(context: string, message: string, data?: unknown): void {
  log(LogLevel.WARN, context, message, data)
}

function errorLog(context: string, message: string, data?: unknown): void {
  log(LogLevel.ERROR, context, message, data)
}

export function createLogger(context: string) {
  const scope = context || 'agent-frontend'

  return {
    trace: (message: string, data?: unknown) => traceLog(scope, message, data),
    debug: (message: string, data?: unknown) => debugLog(scope, message, data),
    info: (message: string, data?: unknown) => infoLog(scope, message, data),
    warn: (message: string, data?: unknown) => warnLog(scope, message, data),
    error: (message: string, data?: unknown) => errorLog(scope, message, data)
  }
}
===ENDFILE
===FILE: ./src/utils/core/error-tracking.ts
interface ErrorTrackingService {
  logError?: (eventId: string, context?: Record<string, unknown>) => void
}

export function logErrorToTracking(eventId: string, context: Record<string, unknown>): void {
  if (typeof window === 'undefined') {
    return
  }

  const service = (window as typeof window & { errorTrackingService?: ErrorTrackingService }).errorTrackingService
  service?.logError?.(eventId, context)
}
===ENDFILE
===FILE: ./src/utils/formatters/__tests__/layout-merger.test.ts
import { describe, expect, it, vi, beforeEach } from 'vitest'
import { computeAdGroupLayout } from '../layout-merger'

// Mock apiFetch
vi.mock('../../../services/core/api-client', () => ({
  apiFetch: vi.fn()
}))

import { apiFetch } from '../../../services/core/api-client'

const mockedApiFetch = vi.mocked(apiFetch)

function makeGroup(overrides: Record<string, unknown> = {}) {
  return {
    id: 'g1',
    groupIdentifier: 'CN=test-group',
    isActive: true,
    ...overrides
  }
}

function makeTemplate(overrides: Record<string, unknown> = {}) {
  return {
    roleName: 'voice_agent',
    displayName: 'Voice Agent',
    columns: {
      chat: { state: 'enabled' as const },
      kms: { state: 'enabled' as const },
      customer: { state: 'disabled' as const }
    },
    widgets: {},
    features: {},
    settingsTabs: {},
    settingsOptions: {},
    microFrontends: {},
    ...overrides
  }
}

describe('computeAdGroupLayout', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('returns the base template when group has no overrides', async () => {
    mockedApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: { roleName: 'voice_agent' } })
    } as Response)

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(makeGroup({ roleName: 'voice_agent' }), fetchTemplate)

    expect(result.roleName).toBe('voice_agent')
    expect(result.columns).toEqual(template.columns)
    expect(fetchTemplate).toHaveBeenCalledWith('voice_agent')
  })

  it('merges column assignment overrides with base template', async () => {
    mockedApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: {
          roleName: 'voice_agent',
          currentConfig: {
            permissionChanges: {
              columnPermissions: {
                customer: { enabledIndicator: true },
                chat: { enabledIndicator: false }
              }
            }
          }
        }
      })
    } as Response)

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(makeGroup({ roleName: 'voice_agent' }), fetchTemplate)

    // customer was disabled in template, overridden to enabled
    expect(result.columns.customer).toBeDefined()
    // chat was enabled in template, overridden to disabled
    expect(result.columns.chat).toBeUndefined()
    // kms not overridden, stays from template
    expect(result.columns.kms).toEqual({ state: 'enabled' })
  })

  it('falls back to group data when API lookup fails', async () => {
    mockedApiFetch.mockRejectedValue(new Error('Network error'))

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({
        roleName: 'voice_agent',
        columnAssignments: { kms: { state: 'disabled' } }
      }),
      fetchTemplate
    )

    expect(result.roleName).toBe('voice_agent')
    // kms should be removed since override state is 'disabled'
    expect(result.columns.kms).toBeUndefined()
  })

  it('falls back to group data when API returns non-ok response', async () => {
    mockedApiFetch.mockResolvedValue({
      ok: false,
      json: () => Promise.resolve({})
    } as Response)

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({ roleName: 'voice_agent' }),
      fetchTemplate
    )

    // Falls back to group (which has no assignments), so template columns are inherited
    expect(result.roleName).toBe('voice_agent')
    expect(fetchTemplate).toHaveBeenCalledWith('voice_agent')
  })

  it('uses default empty template when no fetchRoleTemplate is provided', async () => {
    mockedApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: { roleName: 'chat_agent' } })
    } as Response)

    const result = await computeAdGroupLayout(makeGroup({ roleName: 'chat_agent' }))

    expect(result.roleName).toBe('chat_agent')
    expect(result.columns).toEqual({})
  })

  it('handles inherit state by keeping base template value', async () => {
    mockedApiFetch.mockRejectedValue(new Error('skip'))

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({
        roleName: 'voice_agent',
        columnAssignments: { chat: { state: 'inherit' } }
      }),
      fetchTemplate
    )

    // inherit means keep the template value
    expect(result.columns.chat).toEqual({ state: 'enabled' })
  })

  it('handles enabled state by merging override properties', async () => {
    mockedApiFetch.mockRejectedValue(new Error('skip'))

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({
        roleName: 'voice_agent',
        columnAssignments: { customer: { state: 'enabled', customProp: true } }
      }),
      fetchTemplate
    )

    expect(result.columns.customer).toEqual({
      state: 'enabled',
      customProp: true
    })
  })

  it('uses logicalName as displayName when available', async () => {
    mockedApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({
        data: {
          roleName: 'voice_agent',
          logicalName: 'Custom Group Name'
        }
      })
    } as Response)

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({ roleName: 'voice_agent', logicalName: 'Custom Group Name' }),
      fetchTemplate
    )

    expect(result.displayName).toBe('Custom Group Name')
  })

  it('copies unprocessed template properties to merged layout', async () => {
    mockedApiFetch.mockRejectedValue(new Error('skip'))

    const template = makeTemplate({ customProp: 'value' })
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({ roleName: 'voice_agent' }),
      fetchTemplate
    )

    expect(result.customProp).toBe('value')
  })

  it('defaults to voice_agent when group has no roleName', async () => {
    mockedApiFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: {} })
    } as Response)

    const template = makeTemplate()
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    await computeAdGroupLayout(makeGroup(), fetchTemplate)

    expect(fetchTemplate).toHaveBeenCalledWith('voice_agent')
  })

  it('processes widget assignments alongside column assignments', async () => {
    mockedApiFetch.mockRejectedValue(new Error('skip'))

    const template = makeTemplate({
      widgets: { sentiment: { state: 'enabled' } }
    })
    const fetchTemplate = vi.fn().mockResolvedValue(template)

    const result = await computeAdGroupLayout(
      makeGroup({
        roleName: 'voice_agent',
        widgetAssignments: { sentiment: { state: 'disabled' } }
      }),
      fetchTemplate
    )

    expect(result.widgets.sentiment).toBeUndefined()
  })
})
===ENDFILE
===FILE: ./src/utils/formatters/layout-merger.ts
/**
 * Universal Layout Merger Utility
 * Automatically handles any layout structure without hardcoding specific properties
 * Zero maintenance required when new features are added
 */

import { apiFetch } from '../../services/core/api-client'

interface LayoutOverride {
  state?: 'enabled' | 'disabled' | 'inherit';
  [key: string]: unknown;
}

interface AdGroup {
  id: string;
  groupIdentifier: string;
  logicalName?: string;
  roleName?: string;
  market?: string;
  region?: string;
  businessUnit?: string;
  country?: string;
  isActive: boolean;
  columnAssignments?: Record<string, LayoutOverride>;
  widgetAssignments?: Record<string, LayoutOverride>;
  featureAssignments?: Record<string, LayoutOverride>;
  settingsTabAssignments?: Record<string, LayoutOverride>;
  settingsOptionAssignments?: Record<string, LayoutOverride>;
  microFrontendAssignments?: Record<string, LayoutOverride>;
  [key: string]: unknown; // Allow for future assignment types
}

interface PermissionItem {
  state: 'enabled' | 'disabled';
  [key: string]: unknown;
}

function toPermissionItem(override: LayoutOverride | undefined, fallback?: PermissionItem): PermissionItem | undefined {
  if (!override) {
    return fallback;
  }

  const base = fallback ? { ...fallback } : {};
  const state = override.state === 'disabled' ? 'disabled' : 'enabled';

  return {
    ...base,
    ...override,
    state
  };
}

function sanitizeOverrideRecord(overrides: unknown, baseTemplate: Record<string, PermissionItem> = {}): Record<string, PermissionItem> {
  if (typeof overrides !== 'object' || overrides === null || Array.isArray(overrides)) {
    return {};
  }

  return Object.entries(overrides as Record<string, LayoutOverride | undefined>).reduce<Record<string, PermissionItem>>((acc, [key, value]) => {
    const normalized = toPermissionItem(value, baseTemplate[key]);
    if (normalized) {
      acc[key] = normalized;
    }
    return acc;
  }, {});
}

function isPermissionMap(value: unknown): value is Record<string, PermissionItem> {
  if (typeof value !== 'object' || value === null || Array.isArray(value)) {
    return false;
  }

  return Object.values(value).every(item => {
    if (typeof item !== 'object' || item === null) {
      return false;
    }
    return 'state' in item && (item as PermissionItem).state !== undefined;
  });
}

function isLayoutOverrideRecord(value: unknown): value is Record<string, LayoutOverride> {
  if (typeof value !== 'object' || value === null || Array.isArray(value)) {
    return false;
  }

  return Object.values(value).every(entry => typeof entry === 'object' && entry !== null && !Array.isArray(entry));
}

interface RoleTemplate {
  roleName: string;
  displayName: string;
  columns: Record<string, PermissionItem>;
  widgets: Record<string, PermissionItem>;
  features: Record<string, PermissionItem>;
  settingsTabs: Record<string, PermissionItem>;
  settingsOptions: Record<string, PermissionItem>;
  microFrontends: Record<string, PermissionItem>;
  [key: string]: unknown; // Allow for future properties
}

/**
 * Merges base template properties with AD group overrides (internal use only)
 * Handles tri-state logic: enabled, disabled, inherit
 */
function mergeLayoutWithOverrides(
  baseTemplate: Record<string, PermissionItem>,
  overrides: Record<string, LayoutOverride> | undefined
): Record<string, PermissionItem> {
  if (!overrides || Object.keys(overrides).length === 0) {
    return baseTemplate;
  }

  const merged: Record<string, PermissionItem> = { ...baseTemplate };

  Object.entries(overrides).forEach(([key, override]) => {
    const current = override || {};
    switch (current.state) {
      case 'disabled': {
        delete merged[key];
        break;
      }
      case 'inherit': {
        merged[key] = baseTemplate[key];
        break;
      }
      case 'enabled':
      default: {
        const normalized = toPermissionItem(current, baseTemplate[key]);
        if (normalized) {
          merged[key] = normalized;
        }
      }
    }
  });

  return merged;
}

/**
 * Automatically maps AD group assignment properties to role template properties
 * Handles any property ending with "Assignments"
 */
function mapAssignmentKeyToTemplateKey(assignmentKey: string): string {
  // Remove "Assignments" suffix
  let templateKey = assignmentKey.replace(/Assignments$/, '');

  // Handle special cases for pluralization
  if (templateKey === 'column') templateKey = 'columns';
  else if (templateKey === 'widget') templateKey = 'widgets';
  else if (templateKey === 'feature') templateKey = 'features';
  else if (templateKey === 'settingsTab') templateKey = 'settingsTabs';
  else if (templateKey === 'settingsOption') templateKey = 'settingsOptions';
  else if (templateKey === 'microFrontend') templateKey = 'microFrontends';

  return templateKey;
}

function toOverrides(permissions: Record<string, unknown> | undefined): Record<string, LayoutOverride> | undefined {
  if (!permissions) return undefined;
  return Object.fromEntries(
    Object.entries(permissions).map(([key, value]) => {
      const enabled = Boolean((value as { enabledIndicator?: boolean })?.enabledIndicator);
      return [key, { state: enabled ? 'enabled' : 'disabled' as const }];
    })
  );
}

async function fetchCurrentGroupConfig(group: AdGroup): Promise<AdGroup> {
  try {
    const groupResponse = await apiFetch('/papi/v1/ad-groups/lookup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ data: { groupIdentifier: group.groupIdentifier } })
    });

    if (!groupResponse.ok) return group;

    const raw = await groupResponse.json() as { data?: Record<string, unknown> };
    const data = raw.data;
    if (!data) return group;

    const permissionChanges = (data.currentConfig as Record<string, unknown> | undefined)
      ?.permissionChanges as Record<string, unknown> | undefined;

    return {
      ...group,
      roleName: (data.roleName as string | undefined) ?? group.roleName,
      logicalName: (data.logicalName as string | undefined) ?? group.logicalName,
      columnAssignments: toOverrides(permissionChanges?.columnPermissions as Record<string, unknown> | undefined),
      widgetAssignments: toOverrides(permissionChanges?.widgetPermissions as Record<string, unknown> | undefined)
    };
  } catch {
    return group;
  }
}

function mergeAssignments(mergedLayout: RoleTemplate, baseTemplate: RoleTemplate, groupConfig: AdGroup): void {
  const assignmentKeys = Object.keys(groupConfig).filter(key => key.endsWith('Assignments'));

  for (const assignmentKey of assignmentKeys) {
    const templateKey = mapAssignmentKeyToTemplateKey(assignmentKey);
    const baseValue = baseTemplate[templateKey];
    const overrides = groupConfig[assignmentKey];

    const basePermissionMap = isPermissionMap(baseValue) ? baseValue : undefined;
    const overrideRecord = isLayoutOverrideRecord(overrides) ? overrides : undefined;

    if (basePermissionMap) {
      mergedLayout[templateKey] = mergeLayoutWithOverrides(basePermissionMap, overrideRecord);
    } else if (overrideRecord) {
      const sanitized = sanitizeOverrideRecord(overrideRecord);
      if (Object.keys(sanitized).length > 0) {
        mergedLayout[templateKey] = sanitized;
      }
    }
  }

  for (const key of Object.keys(baseTemplate)) {
    if (mergedLayout[key] === undefined) {
      mergedLayout[key] = baseTemplate[key];
    }
  }
}

const DEFAULT_TEMPLATE = (roleName: string): RoleTemplate => ({
  roleName,
  displayName: roleName,
  columns: {},
  widgets: {},
  features: {},
  settingsTabs: {},
  settingsOptions: {},
  microFrontends: {}
});

/**
 * Computes the final layout for an AD group by merging role template with overrides
 * Automatically discovers and processes all assignment properties
 */
export async function computeAdGroupLayout(
  group: AdGroup,
  fetchRoleTemplate?: (roleName: string) => Promise<RoleTemplate>
): Promise<RoleTemplate> {
  const currentGroupConfig = await fetchCurrentGroupConfig(group);
  const fetcher = fetchRoleTemplate || (async (roleName: string) => DEFAULT_TEMPLATE(roleName));
  const baseTemplate = await fetcher(currentGroupConfig.roleName || 'voice_agent');

  const mergedLayout: RoleTemplate = {
    ...DEFAULT_TEMPLATE(currentGroupConfig.roleName || baseTemplate.roleName),
    displayName: currentGroupConfig.logicalName || baseTemplate.displayName
  };

  mergeAssignments(mergedLayout, baseTemplate, currentGroupConfig);
  return mergedLayout;
}
===ENDFILE
===FILE: ./src/vite-env.d.ts
/// <reference types="vite/client" />
===ENDFILE
===FILE: ./tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  important: '.admin-mfe-root',
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px'
      }
    },
    fontFamily: {
      sans: ['Segoe UI', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Helvetica Neue', 'Arial', 'sans-serif'],
      mono: ['Segoe UI Mono', 'Consolas', 'monospace'],
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
===ENDFILE
===FILE: ./tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "jsx": "react-jsx",
    "moduleResolution": "Bundler",
    "strict": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "declaration": true,
    "emitDeclarationOnly": false,
    "outDir": "dist",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}
===ENDFILE
===FILE: ./tsconfig.sonar.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "jsx": "react-jsx",
    "moduleResolution": "node16",
    "strict": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "noEmit": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.tsx"]
}
===ENDFILE
===FILE: ./vite.config.ts
import { defineConfig, loadEnv } from 'vite'
import react from '@vitejs/plugin-react'
import federation from '@originjs/vite-plugin-federation'
import path from 'path'

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), '')
  const papiProxyTarget = env.VITE_PAPI_PROXY_TARGET || 'http://localhost:8095'

  return {
    plugins: [
      react(),
      federation({
        name: 'adminMfeRemote',
        filename: 'remoteEntry.js',
        exposes: {
          './AdminMFE': './src/AdminMFE.tsx',
        },
        shared: {
          react: { singleton: true, eager: true, requiredVersion: '^19.2.0' },
          'react-dom': { singleton: true, eager: true, requiredVersion: '^19.2.0' },
          'react/jsx-runtime': { singleton: true, eager: true, requiredVersion: '^19.2.0' }
        }
      })
    ],
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
      },
    },
    server: {
      port: 5185,
      cors: true,
      host: true,
      proxy: {
        '/papi': {
          target: papiProxyTarget,
          changeOrigin: true,
          secure: false
        }
      }
    },
    preview: {
      port: 5185,
      cors: true,
      host: true,
      proxy: {
        '/papi': {
          target: papiProxyTarget,
          changeOrigin: true,
          secure: false
        }
      }
    },
    test: {
      environment: 'jsdom',
      globals: true,
      setupFiles: ['./src/test-setup.ts'],
      coverage: {
        reporter: ['text', 'html', 'clover', 'lcov'],
      },
    },
    build: {
      outDir: 'dist',
      target: 'esnext',
      minify: false,
      cssCodeSplit: false,
      modulePreload: false,
      rollupOptions: {
        external: [],
      },
    },
  }
})
===ENDFILE
